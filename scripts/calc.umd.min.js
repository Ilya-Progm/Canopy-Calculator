(function (t, e) {
  "object" === typeof exports && "object" === typeof module
    ? (module.exports = e(require("vue")))
    : "function" === typeof define && define.amd
    ? define([], e)
    : "object" === typeof exports
    ? (exports["calc"] = e(require("vue")))
    : (t["calc"] = e(t["Vue"]));
})("undefined" !== typeof self ? self : this, function (t) {
  return (function (t) {
    var e = {};
    function n(i) {
      if (e[i]) return e[i].exports;
      var r = (e[i] = { i: i, l: !1, exports: {} });
      return t[i].call(r.exports, r, r.exports, n), (r.l = !0), r.exports;
    }
    return (
      (n.m = t),
      (n.c = e),
      (n.d = function (t, e, i) {
        n.o(t, e) || Object.defineProperty(t, e, { enumerable: !0, get: i });
      }),
      (n.r = function (t) {
        "undefined" !== typeof Symbol &&
          Symbol.toStringTag &&
          Object.defineProperty(t, Symbol.toStringTag, { value: "Module" }),
          Object.defineProperty(t, "__esModule", { value: !0 });
      }),
      (n.t = function (t, e) {
        if ((1 & e && (t = n(t)), 8 & e)) return t;
        if (4 & e && "object" === typeof t && t && t.__esModule) return t;
        var i = Object.create(null);
        if (
          (n.r(i),
          Object.defineProperty(i, "default", { enumerable: !0, value: t }),
          2 & e && "string" != typeof t)
        )
          for (var r in t)
            n.d(
              i,
              r,
              function (e) {
                return t[e];
              }.bind(null, r)
            );
        return i;
      }),
      (n.n = function (t) {
        var e =
          t && t.__esModule
            ? function () {
                return t["default"];
              }
            : function () {
                return t;
              };
        return n.d(e, "a", e), e;
      }),
      (n.o = function (t, e) {
        return Object.prototype.hasOwnProperty.call(t, e);
      }),
      (n.p = ""),
      n((n.s = "fb15"))
    );
  })({
    0: function (t, e) {},
    "00bb": function (t, e, n) {
      (function (e, i, r) {
        t.exports = i(n("21bf"), n("38ba"));
      })(0, function (t) {
        return (
          (t.mode.CFB = (function () {
            var e = t.lib.BlockCipherMode.extend();
            function n(t, e, n, i) {
              var r,
                a = this._iv;
              a
                ? ((r = a.slice(0)), (this._iv = void 0))
                : (r = this._prevBlock),
                i.encryptBlock(r, 0);
              for (var o = 0; o < n; o++) t[e + o] ^= r[o];
            }
            return (
              (e.Encryptor = e.extend({
                processBlock: function (t, e) {
                  var i = this._cipher,
                    r = i.blockSize;
                  n.call(this, t, e, r, i),
                    (this._prevBlock = t.slice(e, e + r));
                },
              })),
              (e.Decryptor = e.extend({
                processBlock: function (t, e) {
                  var i = this._cipher,
                    r = i.blockSize,
                    a = t.slice(e, e + r);
                  n.call(this, t, e, r, i), (this._prevBlock = a);
                },
              })),
              e
            );
          })()),
          t.mode.CFB
        );
      });
    },
    "00ee": function (t, e, n) {
      var i = n("b622"),
        r = i("toStringTag"),
        a = {};
      (a[r] = "z"), (t.exports = "[object z]" === String(a));
    },
    "04f8": function (t, e, n) {
      var i = n("2d00"),
        r = n("d039");
      t.exports =
        !!Object.getOwnPropertySymbols &&
        !r(function () {
          var t = Symbol();
          return (
            !String(t) ||
            !(Object(t) instanceof Symbol) ||
            (!Symbol.sham && i && i < 41)
          );
        });
    },
    "06cf": function (t, e, n) {
      var i = n("83ab"),
        r = n("c65b"),
        a = n("d1e7"),
        o = n("5c6c"),
        s = n("fc6a"),
        c = n("a04b"),
        l = n("1a2d"),
        h = n("0cfb"),
        u = Object.getOwnPropertyDescriptor;
      e.f = i
        ? u
        : function (t, e) {
            if (((t = s(t)), (e = c(e)), h))
              try {
                return u(t, e);
              } catch (n) {}
            if (l(t, e)) return o(!r(a.f, t, e), t[e]);
          };
    },
    "07fa": function (t, e, n) {
      var i = n("50c4");
      t.exports = function (t) {
        return i(t.length);
      };
    },
    "0a06": function (t, e, n) {
      "use strict";
      var i = n("c532"),
        r = n("30b5"),
        a = n("f6b4"),
        o = n("5270"),
        s = n("4a7b"),
        c = n("848b"),
        l = c.validators;
      function h(t) {
        (this.defaults = t),
          (this.interceptors = { request: new a(), response: new a() });
      }
      (h.prototype.request = function (t) {
        "string" === typeof t
          ? ((t = arguments[1] || {}), (t.url = arguments[0]))
          : (t = t || {}),
          (t = s(this.defaults, t)),
          t.method
            ? (t.method = t.method.toLowerCase())
            : this.defaults.method
            ? (t.method = this.defaults.method.toLowerCase())
            : (t.method = "get");
        var e = t.transitional;
        void 0 !== e &&
          c.assertOptions(
            e,
            {
              silentJSONParsing: l.transitional(l.boolean, "1.0.0"),
              forcedJSONParsing: l.transitional(l.boolean, "1.0.0"),
              clarifyTimeoutError: l.transitional(l.boolean, "1.0.0"),
            },
            !1
          );
        var n = [],
          i = !0;
        this.interceptors.request.forEach(function (e) {
          ("function" === typeof e.runWhen && !1 === e.runWhen(t)) ||
            ((i = i && e.synchronous), n.unshift(e.fulfilled, e.rejected));
        });
        var r,
          a = [];
        if (
          (this.interceptors.response.forEach(function (t) {
            a.push(t.fulfilled, t.rejected);
          }),
          !i)
        ) {
          var h = [o, void 0];
          Array.prototype.unshift.apply(h, n),
            (h = h.concat(a)),
            (r = Promise.resolve(t));
          while (h.length) r = r.then(h.shift(), h.shift());
          return r;
        }
        var u = t;
        while (n.length) {
          var d = n.shift(),
            p = n.shift();
          try {
            u = d(u);
          } catch (f) {
            p(f);
            break;
          }
        }
        try {
          r = o(u);
        } catch (f) {
          return Promise.reject(f);
        }
        while (a.length) r = r.then(a.shift(), a.shift());
        return r;
      }),
        (h.prototype.getUri = function (t) {
          return (
            (t = s(this.defaults, t)),
            r(t.url, t.params, t.paramsSerializer).replace(/^\?/, "")
          );
        }),
        i.forEach(["delete", "get", "head", "options"], function (t) {
          h.prototype[t] = function (e, n) {
            return this.request(
              s(n || {}, { method: t, url: e, data: (n || {}).data })
            );
          };
        }),
        i.forEach(["post", "put", "patch"], function (t) {
          h.prototype[t] = function (e, n, i) {
            return this.request(s(i || {}, { method: t, url: e, data: n }));
          };
        }),
        (t.exports = h);
    },
    "0cfb": function (t, e, n) {
      var i = n("83ab"),
        r = n("d039"),
        a = n("cc12");
      t.exports =
        !i &&
        !r(function () {
          return (
            7 !=
            Object.defineProperty(a("div"), "a", {
              get: function () {
                return 7;
              },
            }).a
          );
        });
    },
    "0d26": function (t, e, n) {
      var i = n("e330"),
        r = Error,
        a = i("".replace),
        o = (function (t) {
          return String(r(t).stack);
        })("zxcasd"),
        s = /\n\s*at [^:]*:[^\n]*/,
        c = s.test(o);
      t.exports = function (t, e) {
        if (c && "string" == typeof t && !r.prepareStackTrace)
          while (e--) t = a(t, s, "");
        return t;
      };
    },
    "0d51": function (t, e) {
      var n = String;
      t.exports = function (t) {
        try {
          return n(t);
        } catch (e) {
          return "Object";
        }
      };
    },
    "0df6": function (t, e, n) {
      "use strict";
      t.exports = function (t) {
        return function (e) {
          return t.apply(null, e);
        };
      };
    },
    "10b7": function (t, e, n) {
      (function (e, i) {
        t.exports = i(n("21bf"));
      })(0, function (t) {
        /** @preserve
	(c) 2012 by CÃ©dric Mesnil. All rights reserved.

	Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

	    - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
	    - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.

	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*/
        return (
          (function (e) {
            var n = t,
              i = n.lib,
              r = i.WordArray,
              a = i.Hasher,
              o = n.algo,
              s = r.create([
                0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13,
                1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15,
                8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13,
                3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8,
                11, 6, 15, 13,
              ]),
              c = r.create([
                5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3,
                7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14,
                6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5,
                12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13,
                14, 0, 3, 9, 11,
              ]),
              l = r.create([
                11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8,
                13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14,
                9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9,
                8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12,
                13, 14, 11, 8, 5, 6,
              ]),
              h = r.create([
                8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13,
                15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11,
                8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14,
                6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8,
                13, 6, 5, 15, 13, 11, 11,
              ]),
              u = r.create([0, 1518500249, 1859775393, 2400959708, 2840853838]),
              d = r.create([1352829926, 1548603684, 1836072691, 2053994217, 0]),
              p = (o.RIPEMD160 = a.extend({
                _doReset: function () {
                  this._hash = r.create([
                    1732584193, 4023233417, 2562383102, 271733878, 3285377520,
                  ]);
                },
                _doProcessBlock: function (t, e) {
                  for (var n = 0; n < 16; n++) {
                    var i = e + n,
                      r = t[i];
                    t[i] =
                      (16711935 & ((r << 8) | (r >>> 24))) |
                      (4278255360 & ((r << 24) | (r >>> 8)));
                  }
                  var a,
                    o,
                    p,
                    _,
                    b,
                    w,
                    M,
                    S,
                    E,
                    T,
                    A,
                    C = this._hash.words,
                    R = u.words,
                    L = d.words,
                    P = s.words,
                    D = c.words,
                    I = l.words,
                    O = h.words;
                  (w = a = C[0]),
                    (M = o = C[1]),
                    (S = p = C[2]),
                    (E = _ = C[3]),
                    (T = b = C[4]);
                  for (n = 0; n < 80; n += 1)
                    (A = (a + t[e + P[n]]) | 0),
                      (A +=
                        n < 16
                          ? f(o, p, _) + R[0]
                          : n < 32
                          ? m(o, p, _) + R[1]
                          : n < 48
                          ? g(o, p, _) + R[2]
                          : n < 64
                          ? v(o, p, _) + R[3]
                          : y(o, p, _) + R[4]),
                      (A |= 0),
                      (A = x(A, I[n])),
                      (A = (A + b) | 0),
                      (a = b),
                      (b = _),
                      (_ = x(p, 10)),
                      (p = o),
                      (o = A),
                      (A = (w + t[e + D[n]]) | 0),
                      (A +=
                        n < 16
                          ? y(M, S, E) + L[0]
                          : n < 32
                          ? v(M, S, E) + L[1]
                          : n < 48
                          ? g(M, S, E) + L[2]
                          : n < 64
                          ? m(M, S, E) + L[3]
                          : f(M, S, E) + L[4]),
                      (A |= 0),
                      (A = x(A, O[n])),
                      (A = (A + T) | 0),
                      (w = T),
                      (T = E),
                      (E = x(S, 10)),
                      (S = M),
                      (M = A);
                  (A = (C[1] + p + E) | 0),
                    (C[1] = (C[2] + _ + T) | 0),
                    (C[2] = (C[3] + b + w) | 0),
                    (C[3] = (C[4] + a + M) | 0),
                    (C[4] = (C[0] + o + S) | 0),
                    (C[0] = A);
                },
                _doFinalize: function () {
                  var t = this._data,
                    e = t.words,
                    n = 8 * this._nDataBytes,
                    i = 8 * t.sigBytes;
                  (e[i >>> 5] |= 128 << (24 - (i % 32))),
                    (e[14 + (((i + 64) >>> 9) << 4)] =
                      (16711935 & ((n << 8) | (n >>> 24))) |
                      (4278255360 & ((n << 24) | (n >>> 8)))),
                    (t.sigBytes = 4 * (e.length + 1)),
                    this._process();
                  for (var r = this._hash, a = r.words, o = 0; o < 5; o++) {
                    var s = a[o];
                    a[o] =
                      (16711935 & ((s << 8) | (s >>> 24))) |
                      (4278255360 & ((s << 24) | (s >>> 8)));
                  }
                  return r;
                },
                clone: function () {
                  var t = a.clone.call(this);
                  return (t._hash = this._hash.clone()), t;
                },
              }));
            function f(t, e, n) {
              return t ^ e ^ n;
            }
            function m(t, e, n) {
              return (t & e) | (~t & n);
            }
            function g(t, e, n) {
              return (t | ~e) ^ n;
            }
            function v(t, e, n) {
              return (t & n) | (e & ~n);
            }
            function y(t, e, n) {
              return t ^ (e | ~n);
            }
            function x(t, e) {
              return (t << e) | (t >>> (32 - e));
            }
            (n.RIPEMD160 = a._createHelper(p)),
              (n.HmacRIPEMD160 = a._createHmacHelper(p));
          })(Math),
          t.RIPEMD160
        );
      });
    },
    1132: function (t, e, n) {
      (function (e, i) {
        t.exports = i(n("21bf"));
      })(0, function (t) {
        return (
          (function () {
            var e = t,
              n = e.lib,
              i = n.WordArray,
              r = e.enc;
            r.Base64 = {
              stringify: function (t) {
                var e = t.words,
                  n = t.sigBytes,
                  i = this._map;
                t.clamp();
                for (var r = [], a = 0; a < n; a += 3)
                  for (
                    var o = (e[a >>> 2] >>> (24 - (a % 4) * 8)) & 255,
                      s = (e[(a + 1) >>> 2] >>> (24 - ((a + 1) % 4) * 8)) & 255,
                      c = (e[(a + 2) >>> 2] >>> (24 - ((a + 2) % 4) * 8)) & 255,
                      l = (o << 16) | (s << 8) | c,
                      h = 0;
                    h < 4 && a + 0.75 * h < n;
                    h++
                  )
                    r.push(i.charAt((l >>> (6 * (3 - h))) & 63));
                var u = i.charAt(64);
                if (u) while (r.length % 4) r.push(u);
                return r.join("");
              },
              parse: function (t) {
                var e = t.length,
                  n = this._map,
                  i = this._reverseMap;
                if (!i) {
                  i = this._reverseMap = [];
                  for (var r = 0; r < n.length; r++) i[n.charCodeAt(r)] = r;
                }
                var o = n.charAt(64);
                if (o) {
                  var s = t.indexOf(o);
                  -1 !== s && (e = s);
                }
                return a(t, e, i);
              },
              _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
            };
            function a(t, e, n) {
              for (var r = [], a = 0, o = 0; o < e; o++)
                if (o % 4) {
                  var s = n[t.charCodeAt(o - 1)] << ((o % 4) * 2),
                    c = n[t.charCodeAt(o)] >>> (6 - (o % 4) * 2),
                    l = s | c;
                  (r[a >>> 2] |= l << (24 - (a % 4) * 8)), a++;
                }
              return i.create(r, a);
            }
          })(),
          t.enc.Base64
        );
      });
    },
    1382: function (t, e, n) {
      (function (e, i, r) {
        t.exports = i(n("21bf"), n("1132"), n("72fe"), n("2b79"), n("38ba"));
      })(0, function (t) {
        return (
          (function () {
            var e = t,
              n = e.lib,
              i = n.StreamCipher,
              r = e.algo,
              a = [],
              o = [],
              s = [],
              c = (r.Rabbit = i.extend({
                _doReset: function () {
                  for (
                    var t = this._key.words, e = this.cfg.iv, n = 0;
                    n < 4;
                    n++
                  )
                    t[n] =
                      (16711935 & ((t[n] << 8) | (t[n] >>> 24))) |
                      (4278255360 & ((t[n] << 24) | (t[n] >>> 8)));
                  var i = (this._X = [
                      t[0],
                      (t[3] << 16) | (t[2] >>> 16),
                      t[1],
                      (t[0] << 16) | (t[3] >>> 16),
                      t[2],
                      (t[1] << 16) | (t[0] >>> 16),
                      t[3],
                      (t[2] << 16) | (t[1] >>> 16),
                    ]),
                    r = (this._C = [
                      (t[2] << 16) | (t[2] >>> 16),
                      (4294901760 & t[0]) | (65535 & t[1]),
                      (t[3] << 16) | (t[3] >>> 16),
                      (4294901760 & t[1]) | (65535 & t[2]),
                      (t[0] << 16) | (t[0] >>> 16),
                      (4294901760 & t[2]) | (65535 & t[3]),
                      (t[1] << 16) | (t[1] >>> 16),
                      (4294901760 & t[3]) | (65535 & t[0]),
                    ]);
                  this._b = 0;
                  for (n = 0; n < 4; n++) l.call(this);
                  for (n = 0; n < 8; n++) r[n] ^= i[(n + 4) & 7];
                  if (e) {
                    var a = e.words,
                      o = a[0],
                      s = a[1],
                      c =
                        (16711935 & ((o << 8) | (o >>> 24))) |
                        (4278255360 & ((o << 24) | (o >>> 8))),
                      h =
                        (16711935 & ((s << 8) | (s >>> 24))) |
                        (4278255360 & ((s << 24) | (s >>> 8))),
                      u = (c >>> 16) | (4294901760 & h),
                      d = (h << 16) | (65535 & c);
                    (r[0] ^= c),
                      (r[1] ^= u),
                      (r[2] ^= h),
                      (r[3] ^= d),
                      (r[4] ^= c),
                      (r[5] ^= u),
                      (r[6] ^= h),
                      (r[7] ^= d);
                    for (n = 0; n < 4; n++) l.call(this);
                  }
                },
                _doProcessBlock: function (t, e) {
                  var n = this._X;
                  l.call(this),
                    (a[0] = n[0] ^ (n[5] >>> 16) ^ (n[3] << 16)),
                    (a[1] = n[2] ^ (n[7] >>> 16) ^ (n[5] << 16)),
                    (a[2] = n[4] ^ (n[1] >>> 16) ^ (n[7] << 16)),
                    (a[3] = n[6] ^ (n[3] >>> 16) ^ (n[1] << 16));
                  for (var i = 0; i < 4; i++)
                    (a[i] =
                      (16711935 & ((a[i] << 8) | (a[i] >>> 24))) |
                      (4278255360 & ((a[i] << 24) | (a[i] >>> 8)))),
                      (t[e + i] ^= a[i]);
                },
                blockSize: 4,
                ivSize: 2,
              }));
            function l() {
              for (var t = this._X, e = this._C, n = 0; n < 8; n++) o[n] = e[n];
              (e[0] = (e[0] + 1295307597 + this._b) | 0),
                (e[1] =
                  (e[1] + 3545052371 + (e[0] >>> 0 < o[0] >>> 0 ? 1 : 0)) | 0),
                (e[2] =
                  (e[2] + 886263092 + (e[1] >>> 0 < o[1] >>> 0 ? 1 : 0)) | 0),
                (e[3] =
                  (e[3] + 1295307597 + (e[2] >>> 0 < o[2] >>> 0 ? 1 : 0)) | 0),
                (e[4] =
                  (e[4] + 3545052371 + (e[3] >>> 0 < o[3] >>> 0 ? 1 : 0)) | 0),
                (e[5] =
                  (e[5] + 886263092 + (e[4] >>> 0 < o[4] >>> 0 ? 1 : 0)) | 0),
                (e[6] =
                  (e[6] + 1295307597 + (e[5] >>> 0 < o[5] >>> 0 ? 1 : 0)) | 0),
                (e[7] =
                  (e[7] + 3545052371 + (e[6] >>> 0 < o[6] >>> 0 ? 1 : 0)) | 0),
                (this._b = e[7] >>> 0 < o[7] >>> 0 ? 1 : 0);
              for (n = 0; n < 8; n++) {
                var i = t[n] + e[n],
                  r = 65535 & i,
                  a = i >>> 16,
                  c = ((((r * r) >>> 17) + r * a) >>> 15) + a * a,
                  l = (((4294901760 & i) * i) | 0) + (((65535 & i) * i) | 0);
                s[n] = c ^ l;
              }
              (t[0] =
                (s[0] +
                  ((s[7] << 16) | (s[7] >>> 16)) +
                  ((s[6] << 16) | (s[6] >>> 16))) |
                0),
                (t[1] = (s[1] + ((s[0] << 8) | (s[0] >>> 24)) + s[7]) | 0),
                (t[2] =
                  (s[2] +
                    ((s[1] << 16) | (s[1] >>> 16)) +
                    ((s[0] << 16) | (s[0] >>> 16))) |
                  0),
                (t[3] = (s[3] + ((s[2] << 8) | (s[2] >>> 24)) + s[1]) | 0),
                (t[4] =
                  (s[4] +
                    ((s[3] << 16) | (s[3] >>> 16)) +
                    ((s[2] << 16) | (s[2] >>> 16))) |
                  0),
                (t[5] = (s[5] + ((s[4] << 8) | (s[4] >>> 24)) + s[3]) | 0),
                (t[6] =
                  (s[6] +
                    ((s[5] << 16) | (s[5] >>> 16)) +
                    ((s[4] << 16) | (s[4] >>> 16))) |
                  0),
                (t[7] = (s[7] + ((s[6] << 8) | (s[6] >>> 24)) + s[5]) | 0);
            }
            e.Rabbit = i._createHelper(c);
          })(),
          t.Rabbit
        );
      });
    },
    "13d2": function (t, e, n) {
      var i = n("e330"),
        r = n("d039"),
        a = n("1626"),
        o = n("1a2d"),
        s = n("83ab"),
        c = n("5e77").CONFIGURABLE,
        l = n("8925"),
        h = n("69f3"),
        u = h.enforce,
        d = h.get,
        p = String,
        f = Object.defineProperty,
        m = i("".slice),
        g = i("".replace),
        v = i([].join),
        y =
          s &&
          !r(function () {
            return 8 !== f(function () {}, "length", { value: 8 }).length;
          }),
        x = String(String).split("String"),
        _ = (t.exports = function (t, e, n) {
          "Symbol(" === m(p(e), 0, 7) &&
            (e = "[" + g(p(e), /^Symbol\(([^)]*)\)/, "$1") + "]"),
            n && n.getter && (e = "get " + e),
            n && n.setter && (e = "set " + e),
            (!o(t, "name") || (c && t.name !== e)) &&
              (s ? f(t, "name", { value: e, configurable: !0 }) : (t.name = e)),
            y &&
              n &&
              o(n, "arity") &&
              t.length !== n.arity &&
              f(t, "length", { value: n.arity });
          try {
            n && o(n, "constructor") && n.constructor
              ? s && f(t, "prototype", { writable: !1 })
              : t.prototype && (t.prototype = void 0);
          } catch (r) {}
          var i = u(t);
          return (
            o(i, "source") || (i.source = v(x, "string" == typeof e ? e : "")),
            t
          );
        });
      Function.prototype.toString = _(function () {
        return (a(this) && d(this).source) || l(this);
      }, "toString");
    },
    "14d9": function (t, e, n) {
      "use strict";
      var i = n("23e7"),
        r = n("7b0b"),
        a = n("07fa"),
        o = n("3a34"),
        s = n("3511"),
        c = n("d039"),
        l = c(function () {
          return 4294967297 !== [].push.call({ length: 4294967296 }, 1);
        }),
        h = function () {
          try {
            Object.defineProperty([], "length", { writable: !1 }).push();
          } catch (t) {
            return t instanceof TypeError;
          }
        },
        u = l || !h();
      i(
        { target: "Array", proto: !0, arity: 1, forced: u },
        {
          push: function (t) {
            var e = r(this),
              n = a(e),
              i = arguments.length;
            s(n + i);
            for (var c = 0; c < i; c++) (e[n] = arguments[c]), n++;
            return o(e, n), n;
          },
        }
      );
    },
    1626: function (t, e, n) {
      var i = n("8ea1"),
        r = i.all;
      t.exports = i.IS_HTMLDDA
        ? function (t) {
            return "function" == typeof t || t === r;
          }
        : function (t) {
            return "function" == typeof t;
          };
    },
    "17e1": function (t, e, n) {
      (function (e, i) {
        t.exports = i(n("21bf"));
      })(0, function (t) {
        return (
          (function () {
            if ("function" == typeof ArrayBuffer) {
              var e = t,
                n = e.lib,
                i = n.WordArray,
                r = i.init,
                a = (i.init = function (t) {
                  if (
                    (t instanceof ArrayBuffer && (t = new Uint8Array(t)),
                    (t instanceof Int8Array ||
                      ("undefined" !== typeof Uint8ClampedArray &&
                        t instanceof Uint8ClampedArray) ||
                      t instanceof Int16Array ||
                      t instanceof Uint16Array ||
                      t instanceof Int32Array ||
                      t instanceof Uint32Array ||
                      t instanceof Float32Array ||
                      t instanceof Float64Array) &&
                      (t = new Uint8Array(
                        t.buffer,
                        t.byteOffset,
                        t.byteLength
                      )),
                    t instanceof Uint8Array)
                  ) {
                    for (var e = t.byteLength, n = [], i = 0; i < e; i++)
                      n[i >>> 2] |= t[i] << (24 - (i % 4) * 8);
                    r.call(this, n, e);
                  } else r.apply(this, arguments);
                });
              a.prototype = i;
            }
          })(),
          t.lib.WordArray
        );
      });
    },
    "191b": function (t, e, n) {
      (function (e, i, r) {
        t.exports = i(n("21bf"), n("94f8"));
      })(0, function (t) {
        return (
          (function () {
            var e = t,
              n = e.lib,
              i = n.WordArray,
              r = e.algo,
              a = r.SHA256,
              o = (r.SHA224 = a.extend({
                _doReset: function () {
                  this._hash = new i.init([
                    3238371032, 914150663, 812702999, 4144912697, 4290775857,
                    1750603025, 1694076839, 3204075428,
                  ]);
                },
                _doFinalize: function () {
                  var t = a._doFinalize.call(this);
                  return (t.sigBytes -= 4), t;
                },
              }));
            (e.SHA224 = a._createHelper(o)),
              (e.HmacSHA224 = a._createHmacHelper(o));
          })(),
          t.SHA224
        );
      });
    },
    "1a2d": function (t, e, n) {
      var i = n("e330"),
        r = n("7b0b"),
        a = i({}.hasOwnProperty);
      t.exports =
        Object.hasOwn ||
        function (t, e) {
          return a(r(t), e);
        };
    },
    "1d2b": function (t, e, n) {
      "use strict";
      t.exports = function (t, e) {
        return function () {
          for (var n = new Array(arguments.length), i = 0; i < n.length; i++)
            n[i] = arguments[i];
          return t.apply(e, n);
        };
      };
    },
    "1d80": function (t, e, n) {
      var i = n("7234"),
        r = TypeError;
      t.exports = function (t) {
        if (i(t)) throw r("Can't call method on " + t);
        return t;
      };
    },
    "21bf": function (t, e, n) {
      (function (e) {
        (function (e, n) {
          t.exports = n();
        })(0, function () {
          var t =
            t ||
            (function (t, i) {
              var r;
              if (
                ("undefined" !== typeof window &&
                  window.crypto &&
                  (r = window.crypto),
                "undefined" !== typeof self && self.crypto && (r = self.crypto),
                "undefined" !== typeof globalThis &&
                  globalThis.crypto &&
                  (r = globalThis.crypto),
                !r &&
                  "undefined" !== typeof window &&
                  window.msCrypto &&
                  (r = window.msCrypto),
                !r && "undefined" !== typeof e && e.crypto && (r = e.crypto),
                !r)
              )
                try {
                  r = n(0);
                } catch (v) {}
              var a = function () {
                  if (r) {
                    if ("function" === typeof r.getRandomValues)
                      try {
                        return r.getRandomValues(new Uint32Array(1))[0];
                      } catch (v) {}
                    if ("function" === typeof r.randomBytes)
                      try {
                        return r.randomBytes(4).readInt32LE();
                      } catch (v) {}
                  }
                  throw new Error(
                    "Native crypto module could not be used to get secure random number."
                  );
                },
                o =
                  Object.create ||
                  (function () {
                    function t() {}
                    return function (e) {
                      var n;
                      return (
                        (t.prototype = e),
                        (n = new t()),
                        (t.prototype = null),
                        n
                      );
                    };
                  })(),
                s = {},
                c = (s.lib = {}),
                l = (c.Base = (function () {
                  return {
                    extend: function (t) {
                      var e = o(this);
                      return (
                        t && e.mixIn(t),
                        (e.hasOwnProperty("init") && this.init !== e.init) ||
                          (e.init = function () {
                            e.$super.init.apply(this, arguments);
                          }),
                        (e.init.prototype = e),
                        (e.$super = this),
                        e
                      );
                    },
                    create: function () {
                      var t = this.extend();
                      return t.init.apply(t, arguments), t;
                    },
                    init: function () {},
                    mixIn: function (t) {
                      for (var e in t) t.hasOwnProperty(e) && (this[e] = t[e]);
                      t.hasOwnProperty("toString") &&
                        (this.toString = t.toString);
                    },
                    clone: function () {
                      return this.init.prototype.extend(this);
                    },
                  };
                })()),
                h = (c.WordArray = l.extend({
                  init: function (t, e) {
                    (t = this.words = t || []),
                      (this.sigBytes = e != i ? e : 4 * t.length);
                  },
                  toString: function (t) {
                    return (t || d).stringify(this);
                  },
                  concat: function (t) {
                    var e = this.words,
                      n = t.words,
                      i = this.sigBytes,
                      r = t.sigBytes;
                    if ((this.clamp(), i % 4))
                      for (var a = 0; a < r; a++) {
                        var o = (n[a >>> 2] >>> (24 - (a % 4) * 8)) & 255;
                        e[(i + a) >>> 2] |= o << (24 - ((i + a) % 4) * 8);
                      }
                    else
                      for (var s = 0; s < r; s += 4)
                        e[(i + s) >>> 2] = n[s >>> 2];
                    return (this.sigBytes += r), this;
                  },
                  clamp: function () {
                    var e = this.words,
                      n = this.sigBytes;
                    (e[n >>> 2] &= 4294967295 << (32 - (n % 4) * 8)),
                      (e.length = t.ceil(n / 4));
                  },
                  clone: function () {
                    var t = l.clone.call(this);
                    return (t.words = this.words.slice(0)), t;
                  },
                  random: function (t) {
                    for (var e = [], n = 0; n < t; n += 4) e.push(a());
                    return new h.init(e, t);
                  },
                })),
                u = (s.enc = {}),
                d = (u.Hex = {
                  stringify: function (t) {
                    for (
                      var e = t.words, n = t.sigBytes, i = [], r = 0;
                      r < n;
                      r++
                    ) {
                      var a = (e[r >>> 2] >>> (24 - (r % 4) * 8)) & 255;
                      i.push((a >>> 4).toString(16)),
                        i.push((15 & a).toString(16));
                    }
                    return i.join("");
                  },
                  parse: function (t) {
                    for (var e = t.length, n = [], i = 0; i < e; i += 2)
                      n[i >>> 3] |=
                        parseInt(t.substr(i, 2), 16) << (24 - (i % 8) * 4);
                    return new h.init(n, e / 2);
                  },
                }),
                p = (u.Latin1 = {
                  stringify: function (t) {
                    for (
                      var e = t.words, n = t.sigBytes, i = [], r = 0;
                      r < n;
                      r++
                    ) {
                      var a = (e[r >>> 2] >>> (24 - (r % 4) * 8)) & 255;
                      i.push(String.fromCharCode(a));
                    }
                    return i.join("");
                  },
                  parse: function (t) {
                    for (var e = t.length, n = [], i = 0; i < e; i++)
                      n[i >>> 2] |=
                        (255 & t.charCodeAt(i)) << (24 - (i % 4) * 8);
                    return new h.init(n, e);
                  },
                }),
                f = (u.Utf8 = {
                  stringify: function (t) {
                    try {
                      return decodeURIComponent(escape(p.stringify(t)));
                    } catch (e) {
                      throw new Error("Malformed UTF-8 data");
                    }
                  },
                  parse: function (t) {
                    return p.parse(unescape(encodeURIComponent(t)));
                  },
                }),
                m = (c.BufferedBlockAlgorithm = l.extend({
                  reset: function () {
                    (this._data = new h.init()), (this._nDataBytes = 0);
                  },
                  _append: function (t) {
                    "string" == typeof t && (t = f.parse(t)),
                      this._data.concat(t),
                      (this._nDataBytes += t.sigBytes);
                  },
                  _process: function (e) {
                    var n,
                      i = this._data,
                      r = i.words,
                      a = i.sigBytes,
                      o = this.blockSize,
                      s = 4 * o,
                      c = a / s;
                    c = e ? t.ceil(c) : t.max((0 | c) - this._minBufferSize, 0);
                    var l = c * o,
                      u = t.min(4 * l, a);
                    if (l) {
                      for (var d = 0; d < l; d += o) this._doProcessBlock(r, d);
                      (n = r.splice(0, l)), (i.sigBytes -= u);
                    }
                    return new h.init(n, u);
                  },
                  clone: function () {
                    var t = l.clone.call(this);
                    return (t._data = this._data.clone()), t;
                  },
                  _minBufferSize: 0,
                })),
                g =
                  ((c.Hasher = m.extend({
                    cfg: l.extend(),
                    init: function (t) {
                      (this.cfg = this.cfg.extend(t)), this.reset();
                    },
                    reset: function () {
                      m.reset.call(this), this._doReset();
                    },
                    update: function (t) {
                      return this._append(t), this._process(), this;
                    },
                    finalize: function (t) {
                      t && this._append(t);
                      var e = this._doFinalize();
                      return e;
                    },
                    blockSize: 16,
                    _createHelper: function (t) {
                      return function (e, n) {
                        return new t.init(n).finalize(e);
                      };
                    },
                    _createHmacHelper: function (t) {
                      return function (e, n) {
                        return new g.HMAC.init(t, n).finalize(e);
                      };
                    },
                  })),
                  (s.algo = {}));
              return s;
            })(Math);
          return t;
        });
      }.call(this, n("c8ba")));
    },
    "23cb": function (t, e, n) {
      var i = n("5926"),
        r = Math.max,
        a = Math.min;
      t.exports = function (t, e) {
        var n = i(t);
        return n < 0 ? r(n + e, 0) : a(n, e);
      };
    },
    "23e7": function (t, e, n) {
      var i = n("da84"),
        r = n("06cf").f,
        a = n("9112"),
        o = n("cb2d"),
        s = n("6374"),
        c = n("e893"),
        l = n("94ca");
      t.exports = function (t, e) {
        var n,
          h,
          u,
          d,
          p,
          f,
          m = t.target,
          g = t.global,
          v = t.stat;
        if (((h = g ? i : v ? i[m] || s(m, {}) : (i[m] || {}).prototype), h))
          for (u in e) {
            if (
              ((p = e[u]),
              t.dontCallGetSet
                ? ((f = r(h, u)), (d = f && f.value))
                : (d = h[u]),
              (n = l(g ? u : m + (v ? "." : "#") + u, t.forced)),
              !n && void 0 !== d)
            ) {
              if (typeof p == typeof d) continue;
              c(p, d);
            }
            (t.sham || (d && d.sham)) && a(p, "sham", !0), o(h, u, p, t);
          }
      };
    },
    "241c": function (t, e, n) {
      var i = n("ca84"),
        r = n("7839"),
        a = r.concat("length", "prototype");
      e.f =
        Object.getOwnPropertyNames ||
        function (t) {
          return i(t, a);
        };
    },
    2444: function (t, e, n) {
      "use strict";
      (function (e) {
        var i = n("c532"),
          r = n("c8af"),
          a = n("387f"),
          o = { "Content-Type": "application/x-www-form-urlencoded" };
        function s(t, e) {
          !i.isUndefined(t) &&
            i.isUndefined(t["Content-Type"]) &&
            (t["Content-Type"] = e);
        }
        function c() {
          var t;
          return (
            ("undefined" !== typeof XMLHttpRequest ||
              ("undefined" !== typeof e &&
                "[object process]" === Object.prototype.toString.call(e))) &&
              (t = n("b50d")),
            t
          );
        }
        function l(t, e, n) {
          if (i.isString(t))
            try {
              return (e || JSON.parse)(t), i.trim(t);
            } catch (r) {
              if ("SyntaxError" !== r.name) throw r;
            }
          return (n || JSON.stringify)(t);
        }
        var h = {
          transitional: {
            silentJSONParsing: !0,
            forcedJSONParsing: !0,
            clarifyTimeoutError: !1,
          },
          adapter: c(),
          transformRequest: [
            function (t, e) {
              return (
                r(e, "Accept"),
                r(e, "Content-Type"),
                i.isFormData(t) ||
                i.isArrayBuffer(t) ||
                i.isBuffer(t) ||
                i.isStream(t) ||
                i.isFile(t) ||
                i.isBlob(t)
                  ? t
                  : i.isArrayBufferView(t)
                  ? t.buffer
                  : i.isURLSearchParams(t)
                  ? (s(e, "application/x-www-form-urlencoded;charset=utf-8"),
                    t.toString())
                  : i.isObject(t) ||
                    (e && "application/json" === e["Content-Type"])
                  ? (s(e, "application/json"), l(t))
                  : t
              );
            },
          ],
          transformResponse: [
            function (t) {
              var e = this.transitional,
                n = e && e.silentJSONParsing,
                r = e && e.forcedJSONParsing,
                o = !n && "json" === this.responseType;
              if (o || (r && i.isString(t) && t.length))
                try {
                  return JSON.parse(t);
                } catch (s) {
                  if (o) {
                    if ("SyntaxError" === s.name)
                      throw a(s, this, "E_JSON_PARSE");
                    throw s;
                  }
                }
              return t;
            },
          ],
          timeout: 0,
          xsrfCookieName: "XSRF-TOKEN",
          xsrfHeaderName: "X-XSRF-TOKEN",
          maxContentLength: -1,
          maxBodyLength: -1,
          validateStatus: function (t) {
            return t >= 200 && t < 300;
          },
          headers: { common: { Accept: "application/json, text/plain, */*" } },
        };
        i.forEach(["delete", "get", "head"], function (t) {
          h.headers[t] = {};
        }),
          i.forEach(["post", "put", "patch"], function (t) {
            h.headers[t] = i.merge(o);
          }),
          (t.exports = h);
      }.call(this, n("4362")));
    },
    "2a66": function (t, e, n) {
      (function (e, i, r) {
        t.exports = i(n("21bf"), n("38ba"));
      })(0, function (t) {
        return (
          (t.pad.ZeroPadding = {
            pad: function (t, e) {
              var n = 4 * e;
              t.clamp(), (t.sigBytes += n - (t.sigBytes % n || n));
            },
            unpad: function (t) {
              var e = t.words,
                n = t.sigBytes - 1;
              for (n = t.sigBytes - 1; n >= 0; n--)
                if ((e[n >>> 2] >>> (24 - (n % 4) * 8)) & 255) {
                  t.sigBytes = n + 1;
                  break;
                }
            },
          }),
          t.pad.ZeroPadding
        );
      });
    },
    "2b79": function (t, e, n) {
      (function (e, i, r) {
        t.exports = i(n("21bf"), n("df2f"), n("5980"));
      })(0, function (t) {
        return (
          (function () {
            var e = t,
              n = e.lib,
              i = n.Base,
              r = n.WordArray,
              a = e.algo,
              o = a.MD5,
              s = (a.EvpKDF = i.extend({
                cfg: i.extend({ keySize: 4, hasher: o, iterations: 1 }),
                init: function (t) {
                  this.cfg = this.cfg.extend(t);
                },
                compute: function (t, e) {
                  var n,
                    i = this.cfg,
                    a = i.hasher.create(),
                    o = r.create(),
                    s = o.words,
                    c = i.keySize,
                    l = i.iterations;
                  while (s.length < c) {
                    n && a.update(n), (n = a.update(t).finalize(e)), a.reset();
                    for (var h = 1; h < l; h++) (n = a.finalize(n)), a.reset();
                    o.concat(n);
                  }
                  return (o.sigBytes = 4 * c), o;
                },
              }));
            e.EvpKDF = function (t, e, n) {
              return s.create(n).compute(t, e);
            };
          })(),
          t.EvpKDF
        );
      });
    },
    "2ba4": function (t, e, n) {
      var i = n("40d5"),
        r = Function.prototype,
        a = r.apply,
        o = r.call;
      t.exports =
        ("object" == typeof Reflect && Reflect.apply) ||
        (i
          ? o.bind(a)
          : function () {
              return o.apply(a, arguments);
            });
    },
    "2d00": function (t, e, n) {
      var i,
        r,
        a = n("da84"),
        o = n("342f"),
        s = a.process,
        c = a.Deno,
        l = (s && s.versions) || (c && c.version),
        h = l && l.v8;
      h &&
        ((i = h.split(".")), (r = i[0] > 0 && i[0] < 4 ? 1 : +(i[0] + i[1]))),
        !r &&
          o &&
          ((i = o.match(/Edge\/(\d+)/)),
          (!i || i[1] >= 74) &&
            ((i = o.match(/Chrome\/(\d+)/)), i && (r = +i[1]))),
        (t.exports = r);
    },
    "2d83": function (t, e, n) {
      "use strict";
      var i = n("387f");
      t.exports = function (t, e, n, r, a) {
        var o = new Error(t);
        return i(o, e, n, r, a);
      };
    },
    "2e67": function (t, e, n) {
      "use strict";
      t.exports = function (t) {
        return !(!t || !t.__CANCEL__);
      };
    },
    "2ea7": function (t, e, n) {
      "use strict";
      function i() {}
      n.r(e),
        n.d(e, "WebGLRenderTargetCube", function () {
          return Xe;
        }),
        n.d(e, "WebGLRenderTarget", function () {
          return qe;
        }),
        n.d(e, "WebGLRenderer", function () {
          return zo;
        }),
        n.d(e, "ShaderLib", function () {
          return hr;
        }),
        n.d(e, "UniformsLib", function () {
          return lr;
        }),
        n.d(e, "UniformsUtils", function () {
          return or;
        }),
        n.d(e, "ShaderChunk", function () {
          return ar;
        }),
        n.d(e, "FogExp2", function () {
          return Uo;
        }),
        n.d(e, "Fog", function () {
          return Fo;
        }),
        n.d(e, "Scene", function () {
          return Ho;
        }),
        n.d(e, "Sprite", function () {
          return Go;
        }),
        n.d(e, "LOD", function () {
          return Vo;
        }),
        n.d(e, "SkinnedMesh", function () {
          return qo;
        }),
        n.d(e, "Skeleton", function () {
          return Wo;
        }),
        n.d(e, "Bone", function () {
          return jo;
        }),
        n.d(e, "Mesh", function () {
          return Xr;
        }),
        n.d(e, "LineSegments", function () {
          return Jo;
        }),
        n.d(e, "LineLoop", function () {
          return Zo;
        }),
        n.d(e, "Line", function () {
          return Yo;
        }),
        n.d(e, "Points", function () {
          return $o;
        }),
        n.d(e, "Group", function () {
          return Do;
        }),
        n.d(e, "VideoTexture", function () {
          return Qo;
        }),
        n.d(e, "DataTexture", function () {
          return Ye;
        }),
        n.d(e, "CompressedTexture", function () {
          return ts;
        }),
        n.d(e, "CubeTexture", function () {
          return aa;
        }),
        n.d(e, "CanvasTexture", function () {
          return Ao;
        }),
        n.d(e, "DepthTexture", function () {
          return es;
        }),
        n.d(e, "Texture", function () {
          return We;
        }),
        n.d(e, "CompressedTextureLoader", function () {
          return zc;
        }),
        n.d(e, "DataTextureLoader", function () {
          return Uc;
        }),
        n.d(e, "CubeTextureLoader", function () {
          return Hc;
        }),
        n.d(e, "TextureLoader", function () {
          return kc;
        }),
        n.d(e, "ObjectLoader", function () {
          return Yl;
        }),
        n.d(e, "MaterialLoader", function () {
          return Gl;
        }),
        n.d(e, "BufferGeometryLoader", function () {
          return Vl;
        }),
        n.d(e, "DefaultLoadingManager", function () {
          return Oc;
        }),
        n.d(e, "LoadingManager", function () {
          return Ic;
        }),
        n.d(e, "JSONLoader", function () {
          return Xl;
        }),
        n.d(e, "ImageLoader", function () {
          return Fc;
        }),
        n.d(e, "ImageBitmapLoader", function () {
          return Ql;
        }),
        n.d(e, "FontLoader", function () {
          return rh;
        }),
        n.d(e, "FileLoader", function () {
          return Bc;
        }),
        n.d(e, "Loader", function () {
          return jl;
        }),
        n.d(e, "LoaderUtils", function () {
          return ql;
        }),
        n.d(e, "Cache", function () {
          return Dc;
        }),
        n.d(e, "AudioLoader", function () {
          return oh;
        }),
        n.d(e, "SpotLightShadow", function () {
          return bl;
        }),
        n.d(e, "SpotLight", function () {
          return wl;
        }),
        n.d(e, "PointLight", function () {
          return Ml;
        }),
        n.d(e, "RectAreaLight", function () {
          return Al;
        }),
        n.d(e, "HemisphereLight", function () {
          return xl;
        }),
        n.d(e, "DirectionalLightShadow", function () {
          return Sl;
        }),
        n.d(e, "DirectionalLight", function () {
          return El;
        }),
        n.d(e, "AmbientLight", function () {
          return Tl;
        }),
        n.d(e, "LightShadow", function () {
          return _l;
        }),
        n.d(e, "Light", function () {
          return yl;
        }),
        n.d(e, "StereoCamera", function () {
          return sh;
        }),
        n.d(e, "PerspectiveCamera", function () {
          return Io;
        }),
        n.d(e, "OrthographicCamera", function () {
          return yr;
        }),
        n.d(e, "CubeCamera", function () {
          return ch;
        }),
        n.d(e, "ArrayCamera", function () {
          return Oo;
        }),
        n.d(e, "Camera", function () {
          return vr;
        }),
        n.d(e, "AudioListener", function () {
          return lh;
        }),
        n.d(e, "PositionalAudio", function () {
          return uh;
        }),
        n.d(e, "AudioContext", function () {
          return ah;
        }),
        n.d(e, "AudioAnalyser", function () {
          return dh;
        }),
        n.d(e, "Audio", function () {
          return hh;
        }),
        n.d(e, "VectorKeyframeTrack", function () {
          return Hl;
        }),
        n.d(e, "StringKeyframeTrack", function () {
          return Cl;
        }),
        n.d(e, "QuaternionKeyframeTrack", function () {
          return Dl;
        }),
        n.d(e, "NumberKeyframeTrack", function () {
          return Ol;
        }),
        n.d(e, "ColorKeyframeTrack", function () {
          return Il;
        }),
        n.d(e, "BooleanKeyframeTrack", function () {
          return Rl;
        }),
        n.d(e, "PropertyMixer", function () {
          return ph;
        }),
        n.d(e, "PropertyBinding", function () {
          return yh;
        }),
        n.d(e, "KeyframeTrack", function () {
          return Fl;
        }),
        n.d(e, "AnimationUtils", function () {
          return Ul;
        }),
        n.d(e, "AnimationObjectGroup", function () {
          return xh;
        }),
        n.d(e, "AnimationMixer", function () {
          return bh;
        }),
        n.d(e, "AnimationClip", function () {
          return kl;
        }),
        n.d(e, "Uniform", function () {
          return wh;
        }),
        n.d(e, "InstancedBufferGeometry", function () {
          return Mh;
        }),
        n.d(e, "BufferGeometry", function () {
          return Nr;
        }),
        n.d(e, "Geometry", function () {
          return br;
        }),
        n.d(e, "InterleavedBufferAttribute", function () {
          return Sh;
        }),
        n.d(e, "InstancedInterleavedBuffer", function () {
          return Th;
        }),
        n.d(e, "InterleavedBuffer", function () {
          return Eh;
        }),
        n.d(e, "InstancedBufferAttribute", function () {
          return Ah;
        }),
        n.d(e, "Face3", function () {
          return xr;
        }),
        n.d(e, "Object3D", function () {
          return gr;
        }),
        n.d(e, "Raycaster", function () {
          return Ch;
        }),
        n.d(e, "Layers", function () {
          return fr;
        }),
        n.d(e, "EventDispatcher", function () {
          return i;
        }),
        n.d(e, "Clock", function () {
          return Ph;
        }),
        n.d(e, "QuaternionLinearInterpolant", function () {
          return Pl;
        }),
        n.d(e, "LinearInterpolant", function () {
          return Bl;
        }),
        n.d(e, "DiscreteInterpolant", function () {
          return zl;
        }),
        n.d(e, "CubicInterpolant", function () {
          return Nl;
        }),
        n.d(e, "Interpolant", function () {
          return Ll;
        }),
        n.d(e, "Triangle", function () {
          return qr;
        }),
        n.d(e, "Math", function () {
          return ze;
        }),
        n.d(e, "Spherical", function () {
          return Dh;
        }),
        n.d(e, "Cylindrical", function () {
          return Ih;
        }),
        n.d(e, "Plane", function () {
          return Ke;
        }),
        n.d(e, "Frustum", function () {
          return $e;
        }),
        n.d(e, "Sphere", function () {
          return Ze;
        }),
        n.d(e, "Ray", function () {
          return Wr;
        }),
        n.d(e, "Matrix4", function () {
          return Fe;
        }),
        n.d(e, "Matrix3", function () {
          return Ge;
        }),
        n.d(e, "Box3", function () {
          return Je;
        }),
        n.d(e, "Box2", function () {
          return Oh;
        }),
        n.d(e, "Line3", function () {
          return jr;
        }),
        n.d(e, "Euler", function () {
          return pr;
        }),
        n.d(e, "Vector4", function () {
          return je;
        }),
        n.d(e, "Vector3", function () {
          return ke;
        }),
        n.d(e, "Vector2", function () {
          return Ue;
        }),
        n.d(e, "Quaternion", function () {
          return He;
        }),
        n.d(e, "Color", function () {
          return cr;
        }),
        n.d(e, "ImmediateRenderObject", function () {
          return Nh;
        }),
        n.d(e, "VertexNormalsHelper", function () {
          return Bh;
        }),
        n.d(e, "SpotLightHelper", function () {
          return zh;
        }),
        n.d(e, "SkeletonHelper", function () {
          return Fh;
        }),
        n.d(e, "PointLightHelper", function () {
          return Hh;
        }),
        n.d(e, "RectAreaLightHelper", function () {
          return kh;
        }),
        n.d(e, "HemisphereLightHelper", function () {
          return Gh;
        }),
        n.d(e, "GridHelper", function () {
          return Vh;
        }),
        n.d(e, "PolarGridHelper", function () {
          return Wh;
        }),
        n.d(e, "FaceNormalsHelper", function () {
          return jh;
        }),
        n.d(e, "DirectionalLightHelper", function () {
          return qh;
        }),
        n.d(e, "CameraHelper", function () {
          return Xh;
        }),
        n.d(e, "BoxHelper", function () {
          return Yh;
        }),
        n.d(e, "Box3Helper", function () {
          return Jh;
        }),
        n.d(e, "PlaneHelper", function () {
          return Zh;
        }),
        n.d(e, "ArrowHelper", function () {
          return Kh;
        }),
        n.d(e, "AxesHelper", function () {
          return $h;
        }),
        n.d(e, "Shape", function () {
          return vl;
        }),
        n.d(e, "Path", function () {
          return gl;
        }),
        n.d(e, "ShapePath", function () {
          return th;
        }),
        n.d(e, "Font", function () {
          return eh;
        }),
        n.d(e, "CurvePath", function () {
          return ml;
        }),
        n.d(e, "Curve", function () {
          return Gc;
        }),
        n.d(e, "ShapeUtils", function () {
          return Zs;
        }),
        n.d(e, "WebGLUtils", function () {
          return Po;
        }),
        n.d(e, "WireframeGeometry", function () {
          return ns;
        }),
        n.d(e, "ParametricGeometry", function () {
          return is;
        }),
        n.d(e, "ParametricBufferGeometry", function () {
          return rs;
        }),
        n.d(e, "TetrahedronGeometry", function () {
          return ss;
        }),
        n.d(e, "TetrahedronBufferGeometry", function () {
          return cs;
        }),
        n.d(e, "OctahedronGeometry", function () {
          return ls;
        }),
        n.d(e, "OctahedronBufferGeometry", function () {
          return hs;
        }),
        n.d(e, "IcosahedronGeometry", function () {
          return us;
        }),
        n.d(e, "IcosahedronBufferGeometry", function () {
          return ds;
        }),
        n.d(e, "DodecahedronGeometry", function () {
          return ps;
        }),
        n.d(e, "DodecahedronBufferGeometry", function () {
          return fs;
        }),
        n.d(e, "PolyhedronGeometry", function () {
          return as;
        }),
        n.d(e, "PolyhedronBufferGeometry", function () {
          return os;
        }),
        n.d(e, "TubeGeometry", function () {
          return ms;
        }),
        n.d(e, "TubeBufferGeometry", function () {
          return gs;
        }),
        n.d(e, "TorusKnotGeometry", function () {
          return vs;
        }),
        n.d(e, "TorusKnotBufferGeometry", function () {
          return ys;
        }),
        n.d(e, "TorusGeometry", function () {
          return xs;
        }),
        n.d(e, "TorusBufferGeometry", function () {
          return _s;
        }),
        n.d(e, "TextGeometry", function () {
          return ic;
        }),
        n.d(e, "TextBufferGeometry", function () {
          return rc;
        }),
        n.d(e, "SphereGeometry", function () {
          return ac;
        }),
        n.d(e, "SphereBufferGeometry", function () {
          return oc;
        }),
        n.d(e, "RingGeometry", function () {
          return sc;
        }),
        n.d(e, "RingBufferGeometry", function () {
          return cc;
        }),
        n.d(e, "PlaneGeometry", function () {
          return Ur;
        }),
        n.d(e, "PlaneBufferGeometry", function () {
          return Fr;
        }),
        n.d(e, "LatheGeometry", function () {
          return lc;
        }),
        n.d(e, "LatheBufferGeometry", function () {
          return hc;
        }),
        n.d(e, "ShapeGeometry", function () {
          return uc;
        }),
        n.d(e, "ShapeBufferGeometry", function () {
          return dc;
        }),
        n.d(e, "ExtrudeGeometry", function () {
          return Qs;
        }),
        n.d(e, "ExtrudeBufferGeometry", function () {
          return tc;
        }),
        n.d(e, "EdgesGeometry", function () {
          return fc;
        }),
        n.d(e, "ConeGeometry", function () {
          return vc;
        }),
        n.d(e, "ConeBufferGeometry", function () {
          return yc;
        }),
        n.d(e, "CylinderGeometry", function () {
          return mc;
        }),
        n.d(e, "CylinderBufferGeometry", function () {
          return gc;
        }),
        n.d(e, "CircleGeometry", function () {
          return xc;
        }),
        n.d(e, "CircleBufferGeometry", function () {
          return _c;
        }),
        n.d(e, "BoxGeometry", function () {
          return Br;
        }),
        n.d(e, "BoxBufferGeometry", function () {
          return zr;
        }),
        n.d(e, "ShadowMaterial", function () {
          return wc;
        }),
        n.d(e, "SpriteMaterial", function () {
          return ko;
        }),
        n.d(e, "RawShaderMaterial", function () {
          return Mc;
        }),
        n.d(e, "ShaderMaterial", function () {
          return Vr;
        }),
        n.d(e, "PointsMaterial", function () {
          return Ko;
        }),
        n.d(e, "MeshPhysicalMaterial", function () {
          return Ec;
        }),
        n.d(e, "MeshStandardMaterial", function () {
          return Sc;
        }),
        n.d(e, "MeshPhongMaterial", function () {
          return Tc;
        }),
        n.d(e, "MeshToonMaterial", function () {
          return Ac;
        }),
        n.d(e, "MeshNormalMaterial", function () {
          return Cc;
        }),
        n.d(e, "MeshLambertMaterial", function () {
          return Rc;
        }),
        n.d(e, "MeshDepthMaterial", function () {
          return So;
        }),
        n.d(e, "MeshDistanceMaterial", function () {
          return Eo;
        }),
        n.d(e, "MeshBasicMaterial", function () {
          return Gr;
        }),
        n.d(e, "LineDashedMaterial", function () {
          return Lc;
        }),
        n.d(e, "LineBasicMaterial", function () {
          return Xo;
        }),
        n.d(e, "Material", function () {
          return kr;
        }),
        n.d(e, "Float64BufferAttribute", function () {
          return Pr;
        }),
        n.d(e, "Float32BufferAttribute", function () {
          return Lr;
        }),
        n.d(e, "Uint32BufferAttribute", function () {
          return Rr;
        }),
        n.d(e, "Int32BufferAttribute", function () {
          return Cr;
        }),
        n.d(e, "Uint16BufferAttribute", function () {
          return Ar;
        }),
        n.d(e, "Int16BufferAttribute", function () {
          return Tr;
        }),
        n.d(e, "Uint8ClampedBufferAttribute", function () {
          return Er;
        }),
        n.d(e, "Uint8BufferAttribute", function () {
          return Sr;
        }),
        n.d(e, "Int8BufferAttribute", function () {
          return Mr;
        }),
        n.d(e, "BufferAttribute", function () {
          return wr;
        }),
        n.d(e, "ArcCurve", function () {
          return Wc;
        }),
        n.d(e, "CatmullRomCurve3", function () {
          return Zc;
        }),
        n.d(e, "CubicBezierCurve", function () {
          return sl;
        }),
        n.d(e, "CubicBezierCurve3", function () {
          return cl;
        }),
        n.d(e, "EllipseCurve", function () {
          return Vc;
        }),
        n.d(e, "LineCurve", function () {
          return ll;
        }),
        n.d(e, "LineCurve3", function () {
          return hl;
        }),
        n.d(e, "QuadraticBezierCurve", function () {
          return ul;
        }),
        n.d(e, "QuadraticBezierCurve3", function () {
          return dl;
        }),
        n.d(e, "SplineCurve", function () {
          return pl;
        }),
        n.d(e, "REVISION", function () {
          return r;
        }),
        n.d(e, "MOUSE", function () {
          return a;
        }),
        n.d(e, "CullFaceNone", function () {
          return o;
        }),
        n.d(e, "CullFaceBack", function () {
          return s;
        }),
        n.d(e, "CullFaceFront", function () {
          return c;
        }),
        n.d(e, "CullFaceFrontBack", function () {
          return l;
        }),
        n.d(e, "FrontFaceDirectionCW", function () {
          return h;
        }),
        n.d(e, "FrontFaceDirectionCCW", function () {
          return u;
        }),
        n.d(e, "BasicShadowMap", function () {
          return d;
        }),
        n.d(e, "PCFShadowMap", function () {
          return p;
        }),
        n.d(e, "PCFSoftShadowMap", function () {
          return f;
        }),
        n.d(e, "FrontSide", function () {
          return m;
        }),
        n.d(e, "BackSide", function () {
          return g;
        }),
        n.d(e, "DoubleSide", function () {
          return v;
        }),
        n.d(e, "FlatShading", function () {
          return y;
        }),
        n.d(e, "SmoothShading", function () {
          return x;
        }),
        n.d(e, "NoColors", function () {
          return _;
        }),
        n.d(e, "FaceColors", function () {
          return b;
        }),
        n.d(e, "VertexColors", function () {
          return w;
        }),
        n.d(e, "NoBlending", function () {
          return M;
        }),
        n.d(e, "NormalBlending", function () {
          return S;
        }),
        n.d(e, "AdditiveBlending", function () {
          return E;
        }),
        n.d(e, "SubtractiveBlending", function () {
          return T;
        }),
        n.d(e, "MultiplyBlending", function () {
          return A;
        }),
        n.d(e, "CustomBlending", function () {
          return C;
        }),
        n.d(e, "AddEquation", function () {
          return R;
        }),
        n.d(e, "SubtractEquation", function () {
          return L;
        }),
        n.d(e, "ReverseSubtractEquation", function () {
          return P;
        }),
        n.d(e, "MinEquation", function () {
          return D;
        }),
        n.d(e, "MaxEquation", function () {
          return I;
        }),
        n.d(e, "ZeroFactor", function () {
          return O;
        }),
        n.d(e, "OneFactor", function () {
          return N;
        }),
        n.d(e, "SrcColorFactor", function () {
          return B;
        }),
        n.d(e, "OneMinusSrcColorFactor", function () {
          return z;
        }),
        n.d(e, "SrcAlphaFactor", function () {
          return U;
        }),
        n.d(e, "OneMinusSrcAlphaFactor", function () {
          return F;
        }),
        n.d(e, "DstAlphaFactor", function () {
          return H;
        }),
        n.d(e, "OneMinusDstAlphaFactor", function () {
          return k;
        }),
        n.d(e, "DstColorFactor", function () {
          return G;
        }),
        n.d(e, "OneMinusDstColorFactor", function () {
          return V;
        }),
        n.d(e, "SrcAlphaSaturateFactor", function () {
          return W;
        }),
        n.d(e, "NeverDepth", function () {
          return j;
        }),
        n.d(e, "AlwaysDepth", function () {
          return q;
        }),
        n.d(e, "LessDepth", function () {
          return X;
        }),
        n.d(e, "LessEqualDepth", function () {
          return Y;
        }),
        n.d(e, "EqualDepth", function () {
          return J;
        }),
        n.d(e, "GreaterEqualDepth", function () {
          return Z;
        }),
        n.d(e, "GreaterDepth", function () {
          return K;
        }),
        n.d(e, "NotEqualDepth", function () {
          return $;
        }),
        n.d(e, "MultiplyOperation", function () {
          return Q;
        }),
        n.d(e, "MixOperation", function () {
          return tt;
        }),
        n.d(e, "AddOperation", function () {
          return et;
        }),
        n.d(e, "NoToneMapping", function () {
          return nt;
        }),
        n.d(e, "LinearToneMapping", function () {
          return it;
        }),
        n.d(e, "ReinhardToneMapping", function () {
          return rt;
        }),
        n.d(e, "Uncharted2ToneMapping", function () {
          return at;
        }),
        n.d(e, "CineonToneMapping", function () {
          return ot;
        }),
        n.d(e, "UVMapping", function () {
          return st;
        }),
        n.d(e, "CubeReflectionMapping", function () {
          return ct;
        }),
        n.d(e, "CubeRefractionMapping", function () {
          return lt;
        }),
        n.d(e, "EquirectangularReflectionMapping", function () {
          return ht;
        }),
        n.d(e, "EquirectangularRefractionMapping", function () {
          return ut;
        }),
        n.d(e, "SphericalReflectionMapping", function () {
          return dt;
        }),
        n.d(e, "CubeUVReflectionMapping", function () {
          return pt;
        }),
        n.d(e, "CubeUVRefractionMapping", function () {
          return ft;
        }),
        n.d(e, "RepeatWrapping", function () {
          return mt;
        }),
        n.d(e, "ClampToEdgeWrapping", function () {
          return gt;
        }),
        n.d(e, "MirroredRepeatWrapping", function () {
          return vt;
        }),
        n.d(e, "NearestFilter", function () {
          return yt;
        }),
        n.d(e, "NearestMipMapNearestFilter", function () {
          return xt;
        }),
        n.d(e, "NearestMipMapLinearFilter", function () {
          return _t;
        }),
        n.d(e, "LinearFilter", function () {
          return bt;
        }),
        n.d(e, "LinearMipMapNearestFilter", function () {
          return wt;
        }),
        n.d(e, "LinearMipMapLinearFilter", function () {
          return Mt;
        }),
        n.d(e, "UnsignedByteType", function () {
          return St;
        }),
        n.d(e, "ByteType", function () {
          return Et;
        }),
        n.d(e, "ShortType", function () {
          return Tt;
        }),
        n.d(e, "UnsignedShortType", function () {
          return At;
        }),
        n.d(e, "IntType", function () {
          return Ct;
        }),
        n.d(e, "UnsignedIntType", function () {
          return Rt;
        }),
        n.d(e, "FloatType", function () {
          return Lt;
        }),
        n.d(e, "HalfFloatType", function () {
          return Pt;
        }),
        n.d(e, "UnsignedShort4444Type", function () {
          return Dt;
        }),
        n.d(e, "UnsignedShort5551Type", function () {
          return It;
        }),
        n.d(e, "UnsignedShort565Type", function () {
          return Ot;
        }),
        n.d(e, "UnsignedInt248Type", function () {
          return Nt;
        }),
        n.d(e, "AlphaFormat", function () {
          return Bt;
        }),
        n.d(e, "RGBFormat", function () {
          return zt;
        }),
        n.d(e, "RGBAFormat", function () {
          return Ut;
        }),
        n.d(e, "LuminanceFormat", function () {
          return Ft;
        }),
        n.d(e, "LuminanceAlphaFormat", function () {
          return Ht;
        }),
        n.d(e, "RGBEFormat", function () {
          return kt;
        }),
        n.d(e, "DepthFormat", function () {
          return Gt;
        }),
        n.d(e, "DepthStencilFormat", function () {
          return Vt;
        }),
        n.d(e, "RGB_S3TC_DXT1_Format", function () {
          return Wt;
        }),
        n.d(e, "RGBA_S3TC_DXT1_Format", function () {
          return jt;
        }),
        n.d(e, "RGBA_S3TC_DXT3_Format", function () {
          return qt;
        }),
        n.d(e, "RGBA_S3TC_DXT5_Format", function () {
          return Xt;
        }),
        n.d(e, "RGB_PVRTC_4BPPV1_Format", function () {
          return Yt;
        }),
        n.d(e, "RGB_PVRTC_2BPPV1_Format", function () {
          return Jt;
        }),
        n.d(e, "RGBA_PVRTC_4BPPV1_Format", function () {
          return Zt;
        }),
        n.d(e, "RGBA_PVRTC_2BPPV1_Format", function () {
          return Kt;
        }),
        n.d(e, "RGB_ETC1_Format", function () {
          return $t;
        }),
        n.d(e, "RGBA_ASTC_4x4_Format", function () {
          return Qt;
        }),
        n.d(e, "RGBA_ASTC_5x4_Format", function () {
          return te;
        }),
        n.d(e, "RGBA_ASTC_5x5_Format", function () {
          return ee;
        }),
        n.d(e, "RGBA_ASTC_6x5_Format", function () {
          return ne;
        }),
        n.d(e, "RGBA_ASTC_6x6_Format", function () {
          return ie;
        }),
        n.d(e, "RGBA_ASTC_8x5_Format", function () {
          return re;
        }),
        n.d(e, "RGBA_ASTC_8x6_Format", function () {
          return ae;
        }),
        n.d(e, "RGBA_ASTC_8x8_Format", function () {
          return oe;
        }),
        n.d(e, "RGBA_ASTC_10x5_Format", function () {
          return se;
        }),
        n.d(e, "RGBA_ASTC_10x6_Format", function () {
          return ce;
        }),
        n.d(e, "RGBA_ASTC_10x8_Format", function () {
          return le;
        }),
        n.d(e, "RGBA_ASTC_10x10_Format", function () {
          return he;
        }),
        n.d(e, "RGBA_ASTC_12x10_Format", function () {
          return ue;
        }),
        n.d(e, "RGBA_ASTC_12x12_Format", function () {
          return de;
        }),
        n.d(e, "LoopOnce", function () {
          return pe;
        }),
        n.d(e, "LoopRepeat", function () {
          return fe;
        }),
        n.d(e, "LoopPingPong", function () {
          return me;
        }),
        n.d(e, "InterpolateDiscrete", function () {
          return ge;
        }),
        n.d(e, "InterpolateLinear", function () {
          return ve;
        }),
        n.d(e, "InterpolateSmooth", function () {
          return ye;
        }),
        n.d(e, "ZeroCurvatureEnding", function () {
          return xe;
        }),
        n.d(e, "ZeroSlopeEnding", function () {
          return _e;
        }),
        n.d(e, "WrapAroundEnding", function () {
          return be;
        }),
        n.d(e, "TrianglesDrawMode", function () {
          return we;
        }),
        n.d(e, "TriangleStripDrawMode", function () {
          return Me;
        }),
        n.d(e, "TriangleFanDrawMode", function () {
          return Se;
        }),
        n.d(e, "LinearEncoding", function () {
          return Ee;
        }),
        n.d(e, "sRGBEncoding", function () {
          return Te;
        }),
        n.d(e, "GammaEncoding", function () {
          return Ae;
        }),
        n.d(e, "RGBEEncoding", function () {
          return Ce;
        }),
        n.d(e, "LogLuvEncoding", function () {
          return Re;
        }),
        n.d(e, "RGBM7Encoding", function () {
          return Le;
        }),
        n.d(e, "RGBM16Encoding", function () {
          return Pe;
        }),
        n.d(e, "RGBDEncoding", function () {
          return De;
        }),
        n.d(e, "BasicDepthPacking", function () {
          return Ie;
        }),
        n.d(e, "RGBADepthPacking", function () {
          return Oe;
        }),
        n.d(e, "TangentSpaceNormalMap", function () {
          return Ne;
        }),
        n.d(e, "ObjectSpaceNormalMap", function () {
          return Be;
        }),
        n.d(e, "CubeGeometry", function () {
          return Br;
        }),
        n.d(e, "Face4", function () {
          return Qh;
        }),
        n.d(e, "LineStrip", function () {
          return tu;
        }),
        n.d(e, "LinePieces", function () {
          return eu;
        }),
        n.d(e, "MeshFaceMaterial", function () {
          return nu;
        }),
        n.d(e, "MultiMaterial", function () {
          return iu;
        }),
        n.d(e, "PointCloud", function () {
          return ru;
        }),
        n.d(e, "Particle", function () {
          return au;
        }),
        n.d(e, "ParticleSystem", function () {
          return ou;
        }),
        n.d(e, "PointCloudMaterial", function () {
          return su;
        }),
        n.d(e, "ParticleBasicMaterial", function () {
          return cu;
        }),
        n.d(e, "ParticleSystemMaterial", function () {
          return lu;
        }),
        n.d(e, "Vertex", function () {
          return hu;
        }),
        n.d(e, "DynamicBufferAttribute", function () {
          return uu;
        }),
        n.d(e, "Int8Attribute", function () {
          return du;
        }),
        n.d(e, "Uint8Attribute", function () {
          return pu;
        }),
        n.d(e, "Uint8ClampedAttribute", function () {
          return fu;
        }),
        n.d(e, "Int16Attribute", function () {
          return mu;
        }),
        n.d(e, "Uint16Attribute", function () {
          return gu;
        }),
        n.d(e, "Int32Attribute", function () {
          return vu;
        }),
        n.d(e, "Uint32Attribute", function () {
          return yu;
        }),
        n.d(e, "Float32Attribute", function () {
          return xu;
        }),
        n.d(e, "Float64Attribute", function () {
          return _u;
        }),
        n.d(e, "ClosedSplineCurve3", function () {
          return bu;
        }),
        n.d(e, "SplineCurve3", function () {
          return wu;
        }),
        n.d(e, "Spline", function () {
          return Mu;
        }),
        n.d(e, "AxisHelper", function () {
          return Su;
        }),
        n.d(e, "BoundingBoxHelper", function () {
          return Eu;
        }),
        n.d(e, "EdgesHelper", function () {
          return Tu;
        }),
        n.d(e, "WireframeHelper", function () {
          return Au;
        }),
        n.d(e, "XHRLoader", function () {
          return Cu;
        }),
        n.d(e, "BinaryTextureLoader", function () {
          return Ru;
        }),
        n.d(e, "GeometryUtils", function () {
          return Lu;
        }),
        n.d(e, "ImageUtils", function () {
          return Pu;
        }),
        n.d(e, "Projector", function () {
          return Du;
        }),
        n.d(e, "CanvasRenderer", function () {
          return Iu;
        }),
        n.d(e, "SceneUtils", function () {
          return Ou;
        }),
        n.d(e, "LensFlare", function () {
          return Nu;
        }),
        void 0 === Number.EPSILON && (Number.EPSILON = Math.pow(2, -52)),
        void 0 === Number.isInteger &&
          (Number.isInteger = function (t) {
            return "number" === typeof t && isFinite(t) && Math.floor(t) === t;
          }),
        void 0 === Math.sign &&
          (Math.sign = function (t) {
            return t < 0 ? -1 : t > 0 ? 1 : +t;
          }),
        "name" in Function.prototype === !1 &&
          Object.defineProperty(Function.prototype, "name", {
            get: function () {
              return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1];
            },
          }),
        void 0 === Object.assign &&
          (function () {
            Object.assign = function (t) {
              if (void 0 === t || null === t)
                throw new TypeError(
                  "Cannot convert undefined or null to object"
                );
              for (var e = Object(t), n = 1; n < arguments.length; n++) {
                var i = arguments[n];
                if (void 0 !== i && null !== i)
                  for (var r in i)
                    Object.prototype.hasOwnProperty.call(i, r) && (e[r] = i[r]);
              }
              return e;
            };
          })(),
        Object.assign(i.prototype, {
          addEventListener: function (t, e) {
            void 0 === this._listeners && (this._listeners = {});
            var n = this._listeners;
            void 0 === n[t] && (n[t] = []),
              -1 === n[t].indexOf(e) && n[t].push(e);
          },
          hasEventListener: function (t, e) {
            if (void 0 === this._listeners) return !1;
            var n = this._listeners;
            return void 0 !== n[t] && -1 !== n[t].indexOf(e);
          },
          removeEventListener: function (t, e) {
            if (void 0 !== this._listeners) {
              var n = this._listeners,
                i = n[t];
              if (void 0 !== i) {
                var r = i.indexOf(e);
                -1 !== r && i.splice(r, 1);
              }
            }
          },
          dispatchEvent: function (t) {
            if (void 0 !== this._listeners) {
              var e = this._listeners,
                n = e[t.type];
              if (void 0 !== n) {
                t.target = this;
                for (var i = n.slice(0), r = 0, a = i.length; r < a; r++)
                  i[r].call(this, t);
              }
            }
          },
        });
      var r = "94",
        a = { LEFT: 0, MIDDLE: 1, RIGHT: 2 },
        o = 0,
        s = 1,
        c = 2,
        l = 3,
        h = 0,
        u = 1,
        d = 0,
        p = 1,
        f = 2,
        m = 0,
        g = 1,
        v = 2,
        y = 1,
        x = 2,
        _ = 0,
        b = 1,
        w = 2,
        M = 0,
        S = 1,
        E = 2,
        T = 3,
        A = 4,
        C = 5,
        R = 100,
        L = 101,
        P = 102,
        D = 103,
        I = 104,
        O = 200,
        N = 201,
        B = 202,
        z = 203,
        U = 204,
        F = 205,
        H = 206,
        k = 207,
        G = 208,
        V = 209,
        W = 210,
        j = 0,
        q = 1,
        X = 2,
        Y = 3,
        J = 4,
        Z = 5,
        K = 6,
        $ = 7,
        Q = 0,
        tt = 1,
        et = 2,
        nt = 0,
        it = 1,
        rt = 2,
        at = 3,
        ot = 4,
        st = 300,
        ct = 301,
        lt = 302,
        ht = 303,
        ut = 304,
        dt = 305,
        pt = 306,
        ft = 307,
        mt = 1e3,
        gt = 1001,
        vt = 1002,
        yt = 1003,
        xt = 1004,
        _t = 1005,
        bt = 1006,
        wt = 1007,
        Mt = 1008,
        St = 1009,
        Et = 1010,
        Tt = 1011,
        At = 1012,
        Ct = 1013,
        Rt = 1014,
        Lt = 1015,
        Pt = 1016,
        Dt = 1017,
        It = 1018,
        Ot = 1019,
        Nt = 1020,
        Bt = 1021,
        zt = 1022,
        Ut = 1023,
        Ft = 1024,
        Ht = 1025,
        kt = Ut,
        Gt = 1026,
        Vt = 1027,
        Wt = 33776,
        jt = 33777,
        qt = 33778,
        Xt = 33779,
        Yt = 35840,
        Jt = 35841,
        Zt = 35842,
        Kt = 35843,
        $t = 36196,
        Qt = 37808,
        te = 37809,
        ee = 37810,
        ne = 37811,
        ie = 37812,
        re = 37813,
        ae = 37814,
        oe = 37815,
        se = 37816,
        ce = 37817,
        le = 37818,
        he = 37819,
        ue = 37820,
        de = 37821,
        pe = 2200,
        fe = 2201,
        me = 2202,
        ge = 2300,
        ve = 2301,
        ye = 2302,
        xe = 2400,
        _e = 2401,
        be = 2402,
        we = 0,
        Me = 1,
        Se = 2,
        Ee = 3e3,
        Te = 3001,
        Ae = 3007,
        Ce = 3002,
        Re = 3003,
        Le = 3004,
        Pe = 3005,
        De = 3006,
        Ie = 3200,
        Oe = 3201,
        Ne = 0,
        Be = 1,
        ze = {
          DEG2RAD: Math.PI / 180,
          RAD2DEG: 180 / Math.PI,
          generateUUID: (function () {
            for (var t = [], e = 0; e < 256; e++)
              t[e] = (e < 16 ? "0" : "") + e.toString(16);
            return function () {
              var e = (4294967295 * Math.random()) | 0,
                n = (4294967295 * Math.random()) | 0,
                i = (4294967295 * Math.random()) | 0,
                r = (4294967295 * Math.random()) | 0,
                a =
                  t[255 & e] +
                  t[(e >> 8) & 255] +
                  t[(e >> 16) & 255] +
                  t[(e >> 24) & 255] +
                  "-" +
                  t[255 & n] +
                  t[(n >> 8) & 255] +
                  "-" +
                  t[((n >> 16) & 15) | 64] +
                  t[(n >> 24) & 255] +
                  "-" +
                  t[(63 & i) | 128] +
                  t[(i >> 8) & 255] +
                  "-" +
                  t[(i >> 16) & 255] +
                  t[(i >> 24) & 255] +
                  t[255 & r] +
                  t[(r >> 8) & 255] +
                  t[(r >> 16) & 255] +
                  t[(r >> 24) & 255];
              return a.toUpperCase();
            };
          })(),
          clamp: function (t, e, n) {
            return Math.max(e, Math.min(n, t));
          },
          euclideanModulo: function (t, e) {
            return ((t % e) + e) % e;
          },
          mapLinear: function (t, e, n, i, r) {
            return i + ((t - e) * (r - i)) / (n - e);
          },
          lerp: function (t, e, n) {
            return (1 - n) * t + n * e;
          },
          smoothstep: function (t, e, n) {
            return t <= e
              ? 0
              : t >= n
              ? 1
              : ((t = (t - e) / (n - e)), t * t * (3 - 2 * t));
          },
          smootherstep: function (t, e, n) {
            return t <= e
              ? 0
              : t >= n
              ? 1
              : ((t = (t - e) / (n - e)), t * t * t * (t * (6 * t - 15) + 10));
          },
          randInt: function (t, e) {
            return t + Math.floor(Math.random() * (e - t + 1));
          },
          randFloat: function (t, e) {
            return t + Math.random() * (e - t);
          },
          randFloatSpread: function (t) {
            return t * (0.5 - Math.random());
          },
          degToRad: function (t) {
            return t * ze.DEG2RAD;
          },
          radToDeg: function (t) {
            return t * ze.RAD2DEG;
          },
          isPowerOfTwo: function (t) {
            return 0 === (t & (t - 1)) && 0 !== t;
          },
          ceilPowerOfTwo: function (t) {
            return Math.pow(2, Math.ceil(Math.log(t) / Math.LN2));
          },
          floorPowerOfTwo: function (t) {
            return Math.pow(2, Math.floor(Math.log(t) / Math.LN2));
          },
        };
      function Ue(t, e) {
        (this.x = t || 0), (this.y = e || 0);
      }
      function Fe() {
        (this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]),
          arguments.length > 0 &&
            console.error(
              "THREE.Matrix4: the constructor no longer reads arguments. use .set() instead."
            );
      }
      function He(t, e, n, i) {
        (this._x = t || 0),
          (this._y = e || 0),
          (this._z = n || 0),
          (this._w = void 0 !== i ? i : 1);
      }
      function ke(t, e, n) {
        (this.x = t || 0), (this.y = e || 0), (this.z = n || 0);
      }
      function Ge() {
        (this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
          arguments.length > 0 &&
            console.error(
              "THREE.Matrix3: the constructor no longer reads arguments. use .set() instead."
            );
      }
      Object.defineProperties(Ue.prototype, {
        width: {
          get: function () {
            return this.x;
          },
          set: function (t) {
            this.x = t;
          },
        },
        height: {
          get: function () {
            return this.y;
          },
          set: function (t) {
            this.y = t;
          },
        },
      }),
        Object.assign(Ue.prototype, {
          isVector2: !0,
          set: function (t, e) {
            return (this.x = t), (this.y = e), this;
          },
          setScalar: function (t) {
            return (this.x = t), (this.y = t), this;
          },
          setX: function (t) {
            return (this.x = t), this;
          },
          setY: function (t) {
            return (this.y = t), this;
          },
          setComponent: function (t, e) {
            switch (t) {
              case 0:
                this.x = e;
                break;
              case 1:
                this.y = e;
                break;
              default:
                throw new Error("index is out of range: " + t);
            }
            return this;
          },
          getComponent: function (t) {
            switch (t) {
              case 0:
                return this.x;
              case 1:
                return this.y;
              default:
                throw new Error("index is out of range: " + t);
            }
          },
          clone: function () {
            return new this.constructor(this.x, this.y);
          },
          copy: function (t) {
            return (this.x = t.x), (this.y = t.y), this;
          },
          add: function (t, e) {
            return void 0 !== e
              ? (console.warn(
                  "THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."
                ),
                this.addVectors(t, e))
              : ((this.x += t.x), (this.y += t.y), this);
          },
          addScalar: function (t) {
            return (this.x += t), (this.y += t), this;
          },
          addVectors: function (t, e) {
            return (this.x = t.x + e.x), (this.y = t.y + e.y), this;
          },
          addScaledVector: function (t, e) {
            return (this.x += t.x * e), (this.y += t.y * e), this;
          },
          sub: function (t, e) {
            return void 0 !== e
              ? (console.warn(
                  "THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."
                ),
                this.subVectors(t, e))
              : ((this.x -= t.x), (this.y -= t.y), this);
          },
          subScalar: function (t) {
            return (this.x -= t), (this.y -= t), this;
          },
          subVectors: function (t, e) {
            return (this.x = t.x - e.x), (this.y = t.y - e.y), this;
          },
          multiply: function (t) {
            return (this.x *= t.x), (this.y *= t.y), this;
          },
          multiplyScalar: function (t) {
            return (this.x *= t), (this.y *= t), this;
          },
          divide: function (t) {
            return (this.x /= t.x), (this.y /= t.y), this;
          },
          divideScalar: function (t) {
            return this.multiplyScalar(1 / t);
          },
          applyMatrix3: function (t) {
            var e = this.x,
              n = this.y,
              i = t.elements;
            return (
              (this.x = i[0] * e + i[3] * n + i[6]),
              (this.y = i[1] * e + i[4] * n + i[7]),
              this
            );
          },
          min: function (t) {
            return (
              (this.x = Math.min(this.x, t.x)),
              (this.y = Math.min(this.y, t.y)),
              this
            );
          },
          max: function (t) {
            return (
              (this.x = Math.max(this.x, t.x)),
              (this.y = Math.max(this.y, t.y)),
              this
            );
          },
          clamp: function (t, e) {
            return (
              (this.x = Math.max(t.x, Math.min(e.x, this.x))),
              (this.y = Math.max(t.y, Math.min(e.y, this.y))),
              this
            );
          },
          clampScalar: (function () {
            var t = new Ue(),
              e = new Ue();
            return function (n, i) {
              return t.set(n, n), e.set(i, i), this.clamp(t, e);
            };
          })(),
          clampLength: function (t, e) {
            var n = this.length();
            return this.divideScalar(n || 1).multiplyScalar(
              Math.max(t, Math.min(e, n))
            );
          },
          floor: function () {
            return (
              (this.x = Math.floor(this.x)), (this.y = Math.floor(this.y)), this
            );
          },
          ceil: function () {
            return (
              (this.x = Math.ceil(this.x)), (this.y = Math.ceil(this.y)), this
            );
          },
          round: function () {
            return (
              (this.x = Math.round(this.x)), (this.y = Math.round(this.y)), this
            );
          },
          roundToZero: function () {
            return (
              (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
              (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
              this
            );
          },
          negate: function () {
            return (this.x = -this.x), (this.y = -this.y), this;
          },
          dot: function (t) {
            return this.x * t.x + this.y * t.y;
          },
          lengthSq: function () {
            return this.x * this.x + this.y * this.y;
          },
          length: function () {
            return Math.sqrt(this.x * this.x + this.y * this.y);
          },
          manhattanLength: function () {
            return Math.abs(this.x) + Math.abs(this.y);
          },
          normalize: function () {
            return this.divideScalar(this.length() || 1);
          },
          angle: function () {
            var t = Math.atan2(this.y, this.x);
            return t < 0 && (t += 2 * Math.PI), t;
          },
          distanceTo: function (t) {
            return Math.sqrt(this.distanceToSquared(t));
          },
          distanceToSquared: function (t) {
            var e = this.x - t.x,
              n = this.y - t.y;
            return e * e + n * n;
          },
          manhattanDistanceTo: function (t) {
            return Math.abs(this.x - t.x) + Math.abs(this.y - t.y);
          },
          setLength: function (t) {
            return this.normalize().multiplyScalar(t);
          },
          lerp: function (t, e) {
            return (
              (this.x += (t.x - this.x) * e),
              (this.y += (t.y - this.y) * e),
              this
            );
          },
          lerpVectors: function (t, e, n) {
            return this.subVectors(e, t).multiplyScalar(n).add(t);
          },
          equals: function (t) {
            return t.x === this.x && t.y === this.y;
          },
          fromArray: function (t, e) {
            return (
              void 0 === e && (e = 0),
              (this.x = t[e]),
              (this.y = t[e + 1]),
              this
            );
          },
          toArray: function (t, e) {
            return (
              void 0 === t && (t = []),
              void 0 === e && (e = 0),
              (t[e] = this.x),
              (t[e + 1] = this.y),
              t
            );
          },
          fromBufferAttribute: function (t, e, n) {
            return (
              void 0 !== n &&
                console.warn(
                  "THREE.Vector2: offset has been removed from .fromBufferAttribute()."
                ),
              (this.x = t.getX(e)),
              (this.y = t.getY(e)),
              this
            );
          },
          rotateAround: function (t, e) {
            var n = Math.cos(e),
              i = Math.sin(e),
              r = this.x - t.x,
              a = this.y - t.y;
            return (
              (this.x = r * n - a * i + t.x),
              (this.y = r * i + a * n + t.y),
              this
            );
          },
        }),
        Object.assign(Fe.prototype, {
          isMatrix4: !0,
          set: function (t, e, n, i, r, a, o, s, c, l, h, u, d, p, f, m) {
            var g = this.elements;
            return (
              (g[0] = t),
              (g[4] = e),
              (g[8] = n),
              (g[12] = i),
              (g[1] = r),
              (g[5] = a),
              (g[9] = o),
              (g[13] = s),
              (g[2] = c),
              (g[6] = l),
              (g[10] = h),
              (g[14] = u),
              (g[3] = d),
              (g[7] = p),
              (g[11] = f),
              (g[15] = m),
              this
            );
          },
          identity: function () {
            return (
              this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
            );
          },
          clone: function () {
            return new Fe().fromArray(this.elements);
          },
          copy: function (t) {
            var e = this.elements,
              n = t.elements;
            return (
              (e[0] = n[0]),
              (e[1] = n[1]),
              (e[2] = n[2]),
              (e[3] = n[3]),
              (e[4] = n[4]),
              (e[5] = n[5]),
              (e[6] = n[6]),
              (e[7] = n[7]),
              (e[8] = n[8]),
              (e[9] = n[9]),
              (e[10] = n[10]),
              (e[11] = n[11]),
              (e[12] = n[12]),
              (e[13] = n[13]),
              (e[14] = n[14]),
              (e[15] = n[15]),
              this
            );
          },
          copyPosition: function (t) {
            var e = this.elements,
              n = t.elements;
            return (e[12] = n[12]), (e[13] = n[13]), (e[14] = n[14]), this;
          },
          extractBasis: function (t, e, n) {
            return (
              t.setFromMatrixColumn(this, 0),
              e.setFromMatrixColumn(this, 1),
              n.setFromMatrixColumn(this, 2),
              this
            );
          },
          makeBasis: function (t, e, n) {
            return (
              this.set(
                t.x,
                e.x,
                n.x,
                0,
                t.y,
                e.y,
                n.y,
                0,
                t.z,
                e.z,
                n.z,
                0,
                0,
                0,
                0,
                1
              ),
              this
            );
          },
          extractRotation: (function () {
            var t = new ke();
            return function (e) {
              var n = this.elements,
                i = e.elements,
                r = 1 / t.setFromMatrixColumn(e, 0).length(),
                a = 1 / t.setFromMatrixColumn(e, 1).length(),
                o = 1 / t.setFromMatrixColumn(e, 2).length();
              return (
                (n[0] = i[0] * r),
                (n[1] = i[1] * r),
                (n[2] = i[2] * r),
                (n[3] = 0),
                (n[4] = i[4] * a),
                (n[5] = i[5] * a),
                (n[6] = i[6] * a),
                (n[7] = 0),
                (n[8] = i[8] * o),
                (n[9] = i[9] * o),
                (n[10] = i[10] * o),
                (n[11] = 0),
                (n[12] = 0),
                (n[13] = 0),
                (n[14] = 0),
                (n[15] = 1),
                this
              );
            };
          })(),
          makeRotationFromEuler: function (t) {
            (t && t.isEuler) ||
              console.error(
                "THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order."
              );
            var e = this.elements,
              n = t.x,
              i = t.y,
              r = t.z,
              a = Math.cos(n),
              o = Math.sin(n),
              s = Math.cos(i),
              c = Math.sin(i),
              l = Math.cos(r),
              h = Math.sin(r);
            if ("XYZ" === t.order) {
              var u = a * l,
                d = a * h,
                p = o * l,
                f = o * h;
              (e[0] = s * l),
                (e[4] = -s * h),
                (e[8] = c),
                (e[1] = d + p * c),
                (e[5] = u - f * c),
                (e[9] = -o * s),
                (e[2] = f - u * c),
                (e[6] = p + d * c),
                (e[10] = a * s);
            } else if ("YXZ" === t.order) {
              var m = s * l,
                g = s * h,
                v = c * l,
                y = c * h;
              (e[0] = m + y * o),
                (e[4] = v * o - g),
                (e[8] = a * c),
                (e[1] = a * h),
                (e[5] = a * l),
                (e[9] = -o),
                (e[2] = g * o - v),
                (e[6] = y + m * o),
                (e[10] = a * s);
            } else if ("ZXY" === t.order) {
              (m = s * l), (g = s * h), (v = c * l), (y = c * h);
              (e[0] = m - y * o),
                (e[4] = -a * h),
                (e[8] = v + g * o),
                (e[1] = g + v * o),
                (e[5] = a * l),
                (e[9] = y - m * o),
                (e[2] = -a * c),
                (e[6] = o),
                (e[10] = a * s);
            } else if ("ZYX" === t.order) {
              (u = a * l), (d = a * h), (p = o * l), (f = o * h);
              (e[0] = s * l),
                (e[4] = p * c - d),
                (e[8] = u * c + f),
                (e[1] = s * h),
                (e[5] = f * c + u),
                (e[9] = d * c - p),
                (e[2] = -c),
                (e[6] = o * s),
                (e[10] = a * s);
            } else if ("YZX" === t.order) {
              var x = a * s,
                _ = a * c,
                b = o * s,
                w = o * c;
              (e[0] = s * l),
                (e[4] = w - x * h),
                (e[8] = b * h + _),
                (e[1] = h),
                (e[5] = a * l),
                (e[9] = -o * l),
                (e[2] = -c * l),
                (e[6] = _ * h + b),
                (e[10] = x - w * h);
            } else if ("XZY" === t.order) {
              (x = a * s), (_ = a * c), (b = o * s), (w = o * c);
              (e[0] = s * l),
                (e[4] = -h),
                (e[8] = c * l),
                (e[1] = x * h + w),
                (e[5] = a * l),
                (e[9] = _ * h - b),
                (e[2] = b * h - _),
                (e[6] = o * l),
                (e[10] = w * h + x);
            }
            return (
              (e[3] = 0),
              (e[7] = 0),
              (e[11] = 0),
              (e[12] = 0),
              (e[13] = 0),
              (e[14] = 0),
              (e[15] = 1),
              this
            );
          },
          makeRotationFromQuaternion: (function () {
            var t = new ke(0, 0, 0),
              e = new ke(1, 1, 1);
            return function (n) {
              return this.compose(t, n, e);
            };
          })(),
          lookAt: (function () {
            var t = new ke(),
              e = new ke(),
              n = new ke();
            return function (i, r, a) {
              var o = this.elements;
              return (
                n.subVectors(i, r),
                0 === n.lengthSq() && (n.z = 1),
                n.normalize(),
                t.crossVectors(a, n),
                0 === t.lengthSq() &&
                  (1 === Math.abs(a.z) ? (n.x += 1e-4) : (n.z += 1e-4),
                  n.normalize(),
                  t.crossVectors(a, n)),
                t.normalize(),
                e.crossVectors(n, t),
                (o[0] = t.x),
                (o[4] = e.x),
                (o[8] = n.x),
                (o[1] = t.y),
                (o[5] = e.y),
                (o[9] = n.y),
                (o[2] = t.z),
                (o[6] = e.z),
                (o[10] = n.z),
                this
              );
            };
          })(),
          multiply: function (t, e) {
            return void 0 !== e
              ? (console.warn(
                  "THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."
                ),
                this.multiplyMatrices(t, e))
              : this.multiplyMatrices(this, t);
          },
          premultiply: function (t) {
            return this.multiplyMatrices(t, this);
          },
          multiplyMatrices: function (t, e) {
            var n = t.elements,
              i = e.elements,
              r = this.elements,
              a = n[0],
              o = n[4],
              s = n[8],
              c = n[12],
              l = n[1],
              h = n[5],
              u = n[9],
              d = n[13],
              p = n[2],
              f = n[6],
              m = n[10],
              g = n[14],
              v = n[3],
              y = n[7],
              x = n[11],
              _ = n[15],
              b = i[0],
              w = i[4],
              M = i[8],
              S = i[12],
              E = i[1],
              T = i[5],
              A = i[9],
              C = i[13],
              R = i[2],
              L = i[6],
              P = i[10],
              D = i[14],
              I = i[3],
              O = i[7],
              N = i[11],
              B = i[15];
            return (
              (r[0] = a * b + o * E + s * R + c * I),
              (r[4] = a * w + o * T + s * L + c * O),
              (r[8] = a * M + o * A + s * P + c * N),
              (r[12] = a * S + o * C + s * D + c * B),
              (r[1] = l * b + h * E + u * R + d * I),
              (r[5] = l * w + h * T + u * L + d * O),
              (r[9] = l * M + h * A + u * P + d * N),
              (r[13] = l * S + h * C + u * D + d * B),
              (r[2] = p * b + f * E + m * R + g * I),
              (r[6] = p * w + f * T + m * L + g * O),
              (r[10] = p * M + f * A + m * P + g * N),
              (r[14] = p * S + f * C + m * D + g * B),
              (r[3] = v * b + y * E + x * R + _ * I),
              (r[7] = v * w + y * T + x * L + _ * O),
              (r[11] = v * M + y * A + x * P + _ * N),
              (r[15] = v * S + y * C + x * D + _ * B),
              this
            );
          },
          multiplyScalar: function (t) {
            var e = this.elements;
            return (
              (e[0] *= t),
              (e[4] *= t),
              (e[8] *= t),
              (e[12] *= t),
              (e[1] *= t),
              (e[5] *= t),
              (e[9] *= t),
              (e[13] *= t),
              (e[2] *= t),
              (e[6] *= t),
              (e[10] *= t),
              (e[14] *= t),
              (e[3] *= t),
              (e[7] *= t),
              (e[11] *= t),
              (e[15] *= t),
              this
            );
          },
          applyToBufferAttribute: (function () {
            var t = new ke();
            return function (e) {
              for (var n = 0, i = e.count; n < i; n++)
                (t.x = e.getX(n)),
                  (t.y = e.getY(n)),
                  (t.z = e.getZ(n)),
                  t.applyMatrix4(this),
                  e.setXYZ(n, t.x, t.y, t.z);
              return e;
            };
          })(),
          determinant: function () {
            var t = this.elements,
              e = t[0],
              n = t[4],
              i = t[8],
              r = t[12],
              a = t[1],
              o = t[5],
              s = t[9],
              c = t[13],
              l = t[2],
              h = t[6],
              u = t[10],
              d = t[14],
              p = t[3],
              f = t[7],
              m = t[11],
              g = t[15];
            return (
              p *
                (+r * s * h -
                  i * c * h -
                  r * o * u +
                  n * c * u +
                  i * o * d -
                  n * s * d) +
              f *
                (+e * s * d -
                  e * c * u +
                  r * a * u -
                  i * a * d +
                  i * c * l -
                  r * s * l) +
              m *
                (+e * c * h -
                  e * o * d -
                  r * a * h +
                  n * a * d +
                  r * o * l -
                  n * c * l) +
              g *
                (-i * o * l -
                  e * s * h +
                  e * o * u +
                  i * a * h -
                  n * a * u +
                  n * s * l)
            );
          },
          transpose: function () {
            var t,
              e = this.elements;
            return (
              (t = e[1]),
              (e[1] = e[4]),
              (e[4] = t),
              (t = e[2]),
              (e[2] = e[8]),
              (e[8] = t),
              (t = e[6]),
              (e[6] = e[9]),
              (e[9] = t),
              (t = e[3]),
              (e[3] = e[12]),
              (e[12] = t),
              (t = e[7]),
              (e[7] = e[13]),
              (e[13] = t),
              (t = e[11]),
              (e[11] = e[14]),
              (e[14] = t),
              this
            );
          },
          setPosition: function (t) {
            var e = this.elements;
            return (e[12] = t.x), (e[13] = t.y), (e[14] = t.z), this;
          },
          getInverse: function (t, e) {
            var n = this.elements,
              i = t.elements,
              r = i[0],
              a = i[1],
              o = i[2],
              s = i[3],
              c = i[4],
              l = i[5],
              h = i[6],
              u = i[7],
              d = i[8],
              p = i[9],
              f = i[10],
              m = i[11],
              g = i[12],
              v = i[13],
              y = i[14],
              x = i[15],
              _ =
                p * y * u -
                v * f * u +
                v * h * m -
                l * y * m -
                p * h * x +
                l * f * x,
              b =
                g * f * u -
                d * y * u -
                g * h * m +
                c * y * m +
                d * h * x -
                c * f * x,
              w =
                d * v * u -
                g * p * u +
                g * l * m -
                c * v * m -
                d * l * x +
                c * p * x,
              M =
                g * p * h -
                d * v * h -
                g * l * f +
                c * v * f +
                d * l * y -
                c * p * y,
              S = r * _ + a * b + o * w + s * M;
            if (0 === S) {
              var E =
                "THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0";
              if (!0 === e) throw new Error(E);
              return console.warn(E), this.identity();
            }
            var T = 1 / S;
            return (
              (n[0] = _ * T),
              (n[1] =
                (v * f * s -
                  p * y * s -
                  v * o * m +
                  a * y * m +
                  p * o * x -
                  a * f * x) *
                T),
              (n[2] =
                (l * y * s -
                  v * h * s +
                  v * o * u -
                  a * y * u -
                  l * o * x +
                  a * h * x) *
                T),
              (n[3] =
                (p * h * s -
                  l * f * s -
                  p * o * u +
                  a * f * u +
                  l * o * m -
                  a * h * m) *
                T),
              (n[4] = b * T),
              (n[5] =
                (d * y * s -
                  g * f * s +
                  g * o * m -
                  r * y * m -
                  d * o * x +
                  r * f * x) *
                T),
              (n[6] =
                (g * h * s -
                  c * y * s -
                  g * o * u +
                  r * y * u +
                  c * o * x -
                  r * h * x) *
                T),
              (n[7] =
                (c * f * s -
                  d * h * s +
                  d * o * u -
                  r * f * u -
                  c * o * m +
                  r * h * m) *
                T),
              (n[8] = w * T),
              (n[9] =
                (g * p * s -
                  d * v * s -
                  g * a * m +
                  r * v * m +
                  d * a * x -
                  r * p * x) *
                T),
              (n[10] =
                (c * v * s -
                  g * l * s +
                  g * a * u -
                  r * v * u -
                  c * a * x +
                  r * l * x) *
                T),
              (n[11] =
                (d * l * s -
                  c * p * s -
                  d * a * u +
                  r * p * u +
                  c * a * m -
                  r * l * m) *
                T),
              (n[12] = M * T),
              (n[13] =
                (d * v * o -
                  g * p * o +
                  g * a * f -
                  r * v * f -
                  d * a * y +
                  r * p * y) *
                T),
              (n[14] =
                (g * l * o -
                  c * v * o -
                  g * a * h +
                  r * v * h +
                  c * a * y -
                  r * l * y) *
                T),
              (n[15] =
                (c * p * o -
                  d * l * o +
                  d * a * h -
                  r * p * h -
                  c * a * f +
                  r * l * f) *
                T),
              this
            );
          },
          scale: function (t) {
            var e = this.elements,
              n = t.x,
              i = t.y,
              r = t.z;
            return (
              (e[0] *= n),
              (e[4] *= i),
              (e[8] *= r),
              (e[1] *= n),
              (e[5] *= i),
              (e[9] *= r),
              (e[2] *= n),
              (e[6] *= i),
              (e[10] *= r),
              (e[3] *= n),
              (e[7] *= i),
              (e[11] *= r),
              this
            );
          },
          getMaxScaleOnAxis: function () {
            var t = this.elements,
              e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2],
              n = t[4] * t[4] + t[5] * t[5] + t[6] * t[6],
              i = t[8] * t[8] + t[9] * t[9] + t[10] * t[10];
            return Math.sqrt(Math.max(e, n, i));
          },
          makeTranslation: function (t, e, n) {
            return (
              this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, n, 0, 0, 0, 1), this
            );
          },
          makeRotationX: function (t) {
            var e = Math.cos(t),
              n = Math.sin(t);
            return (
              this.set(1, 0, 0, 0, 0, e, -n, 0, 0, n, e, 0, 0, 0, 0, 1), this
            );
          },
          makeRotationY: function (t) {
            var e = Math.cos(t),
              n = Math.sin(t);
            return (
              this.set(e, 0, n, 0, 0, 1, 0, 0, -n, 0, e, 0, 0, 0, 0, 1), this
            );
          },
          makeRotationZ: function (t) {
            var e = Math.cos(t),
              n = Math.sin(t);
            return (
              this.set(e, -n, 0, 0, n, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
            );
          },
          makeRotationAxis: function (t, e) {
            var n = Math.cos(e),
              i = Math.sin(e),
              r = 1 - n,
              a = t.x,
              o = t.y,
              s = t.z,
              c = r * a,
              l = r * o;
            return (
              this.set(
                c * a + n,
                c * o - i * s,
                c * s + i * o,
                0,
                c * o + i * s,
                l * o + n,
                l * s - i * a,
                0,
                c * s - i * o,
                l * s + i * a,
                r * s * s + n,
                0,
                0,
                0,
                0,
                1
              ),
              this
            );
          },
          makeScale: function (t, e, n) {
            return (
              this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this
            );
          },
          makeShear: function (t, e, n) {
            return (
              this.set(1, e, n, 0, t, 1, n, 0, t, e, 1, 0, 0, 0, 0, 1), this
            );
          },
          compose: function (t, e, n) {
            var i = this.elements,
              r = e._x,
              a = e._y,
              o = e._z,
              s = e._w,
              c = r + r,
              l = a + a,
              h = o + o,
              u = r * c,
              d = r * l,
              p = r * h,
              f = a * l,
              m = a * h,
              g = o * h,
              v = s * c,
              y = s * l,
              x = s * h,
              _ = n.x,
              b = n.y,
              w = n.z;
            return (
              (i[0] = (1 - (f + g)) * _),
              (i[1] = (d + x) * _),
              (i[2] = (p - y) * _),
              (i[3] = 0),
              (i[4] = (d - x) * b),
              (i[5] = (1 - (u + g)) * b),
              (i[6] = (m + v) * b),
              (i[7] = 0),
              (i[8] = (p + y) * w),
              (i[9] = (m - v) * w),
              (i[10] = (1 - (u + f)) * w),
              (i[11] = 0),
              (i[12] = t.x),
              (i[13] = t.y),
              (i[14] = t.z),
              (i[15] = 1),
              this
            );
          },
          decompose: (function () {
            var t = new ke(),
              e = new Fe();
            return function (n, i, r) {
              var a = this.elements,
                o = t.set(a[0], a[1], a[2]).length(),
                s = t.set(a[4], a[5], a[6]).length(),
                c = t.set(a[8], a[9], a[10]).length(),
                l = this.determinant();
              l < 0 && (o = -o),
                (n.x = a[12]),
                (n.y = a[13]),
                (n.z = a[14]),
                e.copy(this);
              var h = 1 / o,
                u = 1 / s,
                d = 1 / c;
              return (
                (e.elements[0] *= h),
                (e.elements[1] *= h),
                (e.elements[2] *= h),
                (e.elements[4] *= u),
                (e.elements[5] *= u),
                (e.elements[6] *= u),
                (e.elements[8] *= d),
                (e.elements[9] *= d),
                (e.elements[10] *= d),
                i.setFromRotationMatrix(e),
                (r.x = o),
                (r.y = s),
                (r.z = c),
                this
              );
            };
          })(),
          makePerspective: function (t, e, n, i, r, a) {
            void 0 === a &&
              console.warn(
                "THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs."
              );
            var o = this.elements,
              s = (2 * r) / (e - t),
              c = (2 * r) / (n - i),
              l = (e + t) / (e - t),
              h = (n + i) / (n - i),
              u = -(a + r) / (a - r),
              d = (-2 * a * r) / (a - r);
            return (
              (o[0] = s),
              (o[4] = 0),
              (o[8] = l),
              (o[12] = 0),
              (o[1] = 0),
              (o[5] = c),
              (o[9] = h),
              (o[13] = 0),
              (o[2] = 0),
              (o[6] = 0),
              (o[10] = u),
              (o[14] = d),
              (o[3] = 0),
              (o[7] = 0),
              (o[11] = -1),
              (o[15] = 0),
              this
            );
          },
          makeOrthographic: function (t, e, n, i, r, a) {
            var o = this.elements,
              s = 1 / (e - t),
              c = 1 / (n - i),
              l = 1 / (a - r),
              h = (e + t) * s,
              u = (n + i) * c,
              d = (a + r) * l;
            return (
              (o[0] = 2 * s),
              (o[4] = 0),
              (o[8] = 0),
              (o[12] = -h),
              (o[1] = 0),
              (o[5] = 2 * c),
              (o[9] = 0),
              (o[13] = -u),
              (o[2] = 0),
              (o[6] = 0),
              (o[10] = -2 * l),
              (o[14] = -d),
              (o[3] = 0),
              (o[7] = 0),
              (o[11] = 0),
              (o[15] = 1),
              this
            );
          },
          equals: function (t) {
            for (var e = this.elements, n = t.elements, i = 0; i < 16; i++)
              if (e[i] !== n[i]) return !1;
            return !0;
          },
          fromArray: function (t, e) {
            void 0 === e && (e = 0);
            for (var n = 0; n < 16; n++) this.elements[n] = t[n + e];
            return this;
          },
          toArray: function (t, e) {
            void 0 === t && (t = []), void 0 === e && (e = 0);
            var n = this.elements;
            return (
              (t[e] = n[0]),
              (t[e + 1] = n[1]),
              (t[e + 2] = n[2]),
              (t[e + 3] = n[3]),
              (t[e + 4] = n[4]),
              (t[e + 5] = n[5]),
              (t[e + 6] = n[6]),
              (t[e + 7] = n[7]),
              (t[e + 8] = n[8]),
              (t[e + 9] = n[9]),
              (t[e + 10] = n[10]),
              (t[e + 11] = n[11]),
              (t[e + 12] = n[12]),
              (t[e + 13] = n[13]),
              (t[e + 14] = n[14]),
              (t[e + 15] = n[15]),
              t
            );
          },
        }),
        Object.assign(He, {
          slerp: function (t, e, n, i) {
            return n.copy(t).slerp(e, i);
          },
          slerpFlat: function (t, e, n, i, r, a, o) {
            var s = n[i + 0],
              c = n[i + 1],
              l = n[i + 2],
              h = n[i + 3],
              u = r[a + 0],
              d = r[a + 1],
              p = r[a + 2],
              f = r[a + 3];
            if (h !== f || s !== u || c !== d || l !== p) {
              var m = 1 - o,
                g = s * u + c * d + l * p + h * f,
                v = g >= 0 ? 1 : -1,
                y = 1 - g * g;
              if (y > Number.EPSILON) {
                var x = Math.sqrt(y),
                  _ = Math.atan2(x, g * v);
                (m = Math.sin(m * _) / x), (o = Math.sin(o * _) / x);
              }
              var b = o * v;
              if (
                ((s = s * m + u * b),
                (c = c * m + d * b),
                (l = l * m + p * b),
                (h = h * m + f * b),
                m === 1 - o)
              ) {
                var w = 1 / Math.sqrt(s * s + c * c + l * l + h * h);
                (s *= w), (c *= w), (l *= w), (h *= w);
              }
            }
            (t[e] = s), (t[e + 1] = c), (t[e + 2] = l), (t[e + 3] = h);
          },
        }),
        Object.defineProperties(He.prototype, {
          x: {
            get: function () {
              return this._x;
            },
            set: function (t) {
              (this._x = t), this.onChangeCallback();
            },
          },
          y: {
            get: function () {
              return this._y;
            },
            set: function (t) {
              (this._y = t), this.onChangeCallback();
            },
          },
          z: {
            get: function () {
              return this._z;
            },
            set: function (t) {
              (this._z = t), this.onChangeCallback();
            },
          },
          w: {
            get: function () {
              return this._w;
            },
            set: function (t) {
              (this._w = t), this.onChangeCallback();
            },
          },
        }),
        Object.assign(He.prototype, {
          set: function (t, e, n, i) {
            return (
              (this._x = t),
              (this._y = e),
              (this._z = n),
              (this._w = i),
              this.onChangeCallback(),
              this
            );
          },
          clone: function () {
            return new this.constructor(this._x, this._y, this._z, this._w);
          },
          copy: function (t) {
            return (
              (this._x = t.x),
              (this._y = t.y),
              (this._z = t.z),
              (this._w = t.w),
              this.onChangeCallback(),
              this
            );
          },
          setFromEuler: function (t, e) {
            if (!t || !t.isEuler)
              throw new Error(
                "THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order."
              );
            var n = t._x,
              i = t._y,
              r = t._z,
              a = t.order,
              o = Math.cos,
              s = Math.sin,
              c = o(n / 2),
              l = o(i / 2),
              h = o(r / 2),
              u = s(n / 2),
              d = s(i / 2),
              p = s(r / 2);
            return (
              "XYZ" === a
                ? ((this._x = u * l * h + c * d * p),
                  (this._y = c * d * h - u * l * p),
                  (this._z = c * l * p + u * d * h),
                  (this._w = c * l * h - u * d * p))
                : "YXZ" === a
                ? ((this._x = u * l * h + c * d * p),
                  (this._y = c * d * h - u * l * p),
                  (this._z = c * l * p - u * d * h),
                  (this._w = c * l * h + u * d * p))
                : "ZXY" === a
                ? ((this._x = u * l * h - c * d * p),
                  (this._y = c * d * h + u * l * p),
                  (this._z = c * l * p + u * d * h),
                  (this._w = c * l * h - u * d * p))
                : "ZYX" === a
                ? ((this._x = u * l * h - c * d * p),
                  (this._y = c * d * h + u * l * p),
                  (this._z = c * l * p - u * d * h),
                  (this._w = c * l * h + u * d * p))
                : "YZX" === a
                ? ((this._x = u * l * h + c * d * p),
                  (this._y = c * d * h + u * l * p),
                  (this._z = c * l * p - u * d * h),
                  (this._w = c * l * h - u * d * p))
                : "XZY" === a &&
                  ((this._x = u * l * h - c * d * p),
                  (this._y = c * d * h - u * l * p),
                  (this._z = c * l * p + u * d * h),
                  (this._w = c * l * h + u * d * p)),
              !1 !== e && this.onChangeCallback(),
              this
            );
          },
          setFromAxisAngle: function (t, e) {
            var n = e / 2,
              i = Math.sin(n);
            return (
              (this._x = t.x * i),
              (this._y = t.y * i),
              (this._z = t.z * i),
              (this._w = Math.cos(n)),
              this.onChangeCallback(),
              this
            );
          },
          setFromRotationMatrix: function (t) {
            var e,
              n = t.elements,
              i = n[0],
              r = n[4],
              a = n[8],
              o = n[1],
              s = n[5],
              c = n[9],
              l = n[2],
              h = n[6],
              u = n[10],
              d = i + s + u;
            return (
              d > 0
                ? ((e = 0.5 / Math.sqrt(d + 1)),
                  (this._w = 0.25 / e),
                  (this._x = (h - c) * e),
                  (this._y = (a - l) * e),
                  (this._z = (o - r) * e))
                : i > s && i > u
                ? ((e = 2 * Math.sqrt(1 + i - s - u)),
                  (this._w = (h - c) / e),
                  (this._x = 0.25 * e),
                  (this._y = (r + o) / e),
                  (this._z = (a + l) / e))
                : s > u
                ? ((e = 2 * Math.sqrt(1 + s - i - u)),
                  (this._w = (a - l) / e),
                  (this._x = (r + o) / e),
                  (this._y = 0.25 * e),
                  (this._z = (c + h) / e))
                : ((e = 2 * Math.sqrt(1 + u - i - s)),
                  (this._w = (o - r) / e),
                  (this._x = (a + l) / e),
                  (this._y = (c + h) / e),
                  (this._z = 0.25 * e)),
              this.onChangeCallback(),
              this
            );
          },
          setFromUnitVectors: (function () {
            var t,
              e = new ke(),
              n = 1e-6;
            return function (i, r) {
              return (
                void 0 === e && (e = new ke()),
                (t = i.dot(r) + 1),
                t < n
                  ? ((t = 0),
                    Math.abs(i.x) > Math.abs(i.z)
                      ? e.set(-i.y, i.x, 0)
                      : e.set(0, -i.z, i.y))
                  : e.crossVectors(i, r),
                (this._x = e.x),
                (this._y = e.y),
                (this._z = e.z),
                (this._w = t),
                this.normalize()
              );
            };
          })(),
          inverse: function () {
            return this.conjugate();
          },
          conjugate: function () {
            return (
              (this._x *= -1),
              (this._y *= -1),
              (this._z *= -1),
              this.onChangeCallback(),
              this
            );
          },
          dot: function (t) {
            return (
              this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w
            );
          },
          lengthSq: function () {
            return (
              this._x * this._x +
              this._y * this._y +
              this._z * this._z +
              this._w * this._w
            );
          },
          length: function () {
            return Math.sqrt(
              this._x * this._x +
                this._y * this._y +
                this._z * this._z +
                this._w * this._w
            );
          },
          normalize: function () {
            var t = this.length();
            return (
              0 === t
                ? ((this._x = 0), (this._y = 0), (this._z = 0), (this._w = 1))
                : ((t = 1 / t),
                  (this._x = this._x * t),
                  (this._y = this._y * t),
                  (this._z = this._z * t),
                  (this._w = this._w * t)),
              this.onChangeCallback(),
              this
            );
          },
          multiply: function (t, e) {
            return void 0 !== e
              ? (console.warn(
                  "THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."
                ),
                this.multiplyQuaternions(t, e))
              : this.multiplyQuaternions(this, t);
          },
          premultiply: function (t) {
            return this.multiplyQuaternions(t, this);
          },
          multiplyQuaternions: function (t, e) {
            var n = t._x,
              i = t._y,
              r = t._z,
              a = t._w,
              o = e._x,
              s = e._y,
              c = e._z,
              l = e._w;
            return (
              (this._x = n * l + a * o + i * c - r * s),
              (this._y = i * l + a * s + r * o - n * c),
              (this._z = r * l + a * c + n * s - i * o),
              (this._w = a * l - n * o - i * s - r * c),
              this.onChangeCallback(),
              this
            );
          },
          slerp: function (t, e) {
            if (0 === e) return this;
            if (1 === e) return this.copy(t);
            var n = this._x,
              i = this._y,
              r = this._z,
              a = this._w,
              o = a * t._w + n * t._x + i * t._y + r * t._z;
            if (
              (o < 0
                ? ((this._w = -t._w),
                  (this._x = -t._x),
                  (this._y = -t._y),
                  (this._z = -t._z),
                  (o = -o))
                : this.copy(t),
              o >= 1)
            )
              return (
                (this._w = a), (this._x = n), (this._y = i), (this._z = r), this
              );
            var s = 1 - o * o;
            if (s <= Number.EPSILON) {
              var c = 1 - e;
              return (
                (this._w = c * a + e * this._w),
                (this._x = c * n + e * this._x),
                (this._y = c * i + e * this._y),
                (this._z = c * r + e * this._z),
                this.normalize()
              );
            }
            var l = Math.sqrt(s),
              h = Math.atan2(l, o),
              u = Math.sin((1 - e) * h) / l,
              d = Math.sin(e * h) / l;
            return (
              (this._w = a * u + this._w * d),
              (this._x = n * u + this._x * d),
              (this._y = i * u + this._y * d),
              (this._z = r * u + this._z * d),
              this.onChangeCallback(),
              this
            );
          },
          equals: function (t) {
            return (
              t._x === this._x &&
              t._y === this._y &&
              t._z === this._z &&
              t._w === this._w
            );
          },
          fromArray: function (t, e) {
            return (
              void 0 === e && (e = 0),
              (this._x = t[e]),
              (this._y = t[e + 1]),
              (this._z = t[e + 2]),
              (this._w = t[e + 3]),
              this.onChangeCallback(),
              this
            );
          },
          toArray: function (t, e) {
            return (
              void 0 === t && (t = []),
              void 0 === e && (e = 0),
              (t[e] = this._x),
              (t[e + 1] = this._y),
              (t[e + 2] = this._z),
              (t[e + 3] = this._w),
              t
            );
          },
          onChange: function (t) {
            return (this.onChangeCallback = t), this;
          },
          onChangeCallback: function () {},
        }),
        Object.assign(ke.prototype, {
          isVector3: !0,
          set: function (t, e, n) {
            return (this.x = t), (this.y = e), (this.z = n), this;
          },
          setScalar: function (t) {
            return (this.x = t), (this.y = t), (this.z = t), this;
          },
          setX: function (t) {
            return (this.x = t), this;
          },
          setY: function (t) {
            return (this.y = t), this;
          },
          setZ: function (t) {
            return (this.z = t), this;
          },
          setComponent: function (t, e) {
            switch (t) {
              case 0:
                this.x = e;
                break;
              case 1:
                this.y = e;
                break;
              case 2:
                this.z = e;
                break;
              default:
                throw new Error("index is out of range: " + t);
            }
            return this;
          },
          getComponent: function (t) {
            switch (t) {
              case 0:
                return this.x;
              case 1:
                return this.y;
              case 2:
                return this.z;
              default:
                throw new Error("index is out of range: " + t);
            }
          },
          clone: function () {
            return new this.constructor(this.x, this.y, this.z);
          },
          copy: function (t) {
            return (this.x = t.x), (this.y = t.y), (this.z = t.z), this;
          },
          add: function (t, e) {
            return void 0 !== e
              ? (console.warn(
                  "THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."
                ),
                this.addVectors(t, e))
              : ((this.x += t.x), (this.y += t.y), (this.z += t.z), this);
          },
          addScalar: function (t) {
            return (this.x += t), (this.y += t), (this.z += t), this;
          },
          addVectors: function (t, e) {
            return (
              (this.x = t.x + e.x),
              (this.y = t.y + e.y),
              (this.z = t.z + e.z),
              this
            );
          },
          addScaledVector: function (t, e) {
            return (
              (this.x += t.x * e),
              (this.y += t.y * e),
              (this.z += t.z * e),
              this
            );
          },
          sub: function (t, e) {
            return void 0 !== e
              ? (console.warn(
                  "THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."
                ),
                this.subVectors(t, e))
              : ((this.x -= t.x), (this.y -= t.y), (this.z -= t.z), this);
          },
          subScalar: function (t) {
            return (this.x -= t), (this.y -= t), (this.z -= t), this;
          },
          subVectors: function (t, e) {
            return (
              (this.x = t.x - e.x),
              (this.y = t.y - e.y),
              (this.z = t.z - e.z),
              this
            );
          },
          multiply: function (t, e) {
            return void 0 !== e
              ? (console.warn(
                  "THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."
                ),
                this.multiplyVectors(t, e))
              : ((this.x *= t.x), (this.y *= t.y), (this.z *= t.z), this);
          },
          multiplyScalar: function (t) {
            return (this.x *= t), (this.y *= t), (this.z *= t), this;
          },
          multiplyVectors: function (t, e) {
            return (
              (this.x = t.x * e.x),
              (this.y = t.y * e.y),
              (this.z = t.z * e.z),
              this
            );
          },
          applyEuler: (function () {
            var t = new He();
            return function (e) {
              return (
                (e && e.isEuler) ||
                  console.error(
                    "THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."
                  ),
                this.applyQuaternion(t.setFromEuler(e))
              );
            };
          })(),
          applyAxisAngle: (function () {
            var t = new He();
            return function (e, n) {
              return this.applyQuaternion(t.setFromAxisAngle(e, n));
            };
          })(),
          applyMatrix3: function (t) {
            var e = this.x,
              n = this.y,
              i = this.z,
              r = t.elements;
            return (
              (this.x = r[0] * e + r[3] * n + r[6] * i),
              (this.y = r[1] * e + r[4] * n + r[7] * i),
              (this.z = r[2] * e + r[5] * n + r[8] * i),
              this
            );
          },
          applyMatrix4: function (t) {
            var e = this.x,
              n = this.y,
              i = this.z,
              r = t.elements,
              a = 1 / (r[3] * e + r[7] * n + r[11] * i + r[15]);
            return (
              (this.x = (r[0] * e + r[4] * n + r[8] * i + r[12]) * a),
              (this.y = (r[1] * e + r[5] * n + r[9] * i + r[13]) * a),
              (this.z = (r[2] * e + r[6] * n + r[10] * i + r[14]) * a),
              this
            );
          },
          applyQuaternion: function (t) {
            var e = this.x,
              n = this.y,
              i = this.z,
              r = t.x,
              a = t.y,
              o = t.z,
              s = t.w,
              c = s * e + a * i - o * n,
              l = s * n + o * e - r * i,
              h = s * i + r * n - a * e,
              u = -r * e - a * n - o * i;
            return (
              (this.x = c * s + u * -r + l * -o - h * -a),
              (this.y = l * s + u * -a + h * -r - c * -o),
              (this.z = h * s + u * -o + c * -a - l * -r),
              this
            );
          },
          project: (function () {
            var t = new Fe();
            return function (e) {
              return (
                t.multiplyMatrices(
                  e.projectionMatrix,
                  t.getInverse(e.matrixWorld)
                ),
                this.applyMatrix4(t)
              );
            };
          })(),
          unproject: (function () {
            var t = new Fe();
            return function (e) {
              return (
                t.multiplyMatrices(
                  e.matrixWorld,
                  t.getInverse(e.projectionMatrix)
                ),
                this.applyMatrix4(t)
              );
            };
          })(),
          transformDirection: function (t) {
            var e = this.x,
              n = this.y,
              i = this.z,
              r = t.elements;
            return (
              (this.x = r[0] * e + r[4] * n + r[8] * i),
              (this.y = r[1] * e + r[5] * n + r[9] * i),
              (this.z = r[2] * e + r[6] * n + r[10] * i),
              this.normalize()
            );
          },
          divide: function (t) {
            return (this.x /= t.x), (this.y /= t.y), (this.z /= t.z), this;
          },
          divideScalar: function (t) {
            return this.multiplyScalar(1 / t);
          },
          min: function (t) {
            return (
              (this.x = Math.min(this.x, t.x)),
              (this.y = Math.min(this.y, t.y)),
              (this.z = Math.min(this.z, t.z)),
              this
            );
          },
          max: function (t) {
            return (
              (this.x = Math.max(this.x, t.x)),
              (this.y = Math.max(this.y, t.y)),
              (this.z = Math.max(this.z, t.z)),
              this
            );
          },
          clamp: function (t, e) {
            return (
              (this.x = Math.max(t.x, Math.min(e.x, this.x))),
              (this.y = Math.max(t.y, Math.min(e.y, this.y))),
              (this.z = Math.max(t.z, Math.min(e.z, this.z))),
              this
            );
          },
          clampScalar: (function () {
            var t = new ke(),
              e = new ke();
            return function (n, i) {
              return t.set(n, n, n), e.set(i, i, i), this.clamp(t, e);
            };
          })(),
          clampLength: function (t, e) {
            var n = this.length();
            return this.divideScalar(n || 1).multiplyScalar(
              Math.max(t, Math.min(e, n))
            );
          },
          floor: function () {
            return (
              (this.x = Math.floor(this.x)),
              (this.y = Math.floor(this.y)),
              (this.z = Math.floor(this.z)),
              this
            );
          },
          ceil: function () {
            return (
              (this.x = Math.ceil(this.x)),
              (this.y = Math.ceil(this.y)),
              (this.z = Math.ceil(this.z)),
              this
            );
          },
          round: function () {
            return (
              (this.x = Math.round(this.x)),
              (this.y = Math.round(this.y)),
              (this.z = Math.round(this.z)),
              this
            );
          },
          roundToZero: function () {
            return (
              (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
              (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
              (this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)),
              this
            );
          },
          negate: function () {
            return (
              (this.x = -this.x), (this.y = -this.y), (this.z = -this.z), this
            );
          },
          dot: function (t) {
            return this.x * t.x + this.y * t.y + this.z * t.z;
          },
          lengthSq: function () {
            return this.x * this.x + this.y * this.y + this.z * this.z;
          },
          length: function () {
            return Math.sqrt(
              this.x * this.x + this.y * this.y + this.z * this.z
            );
          },
          manhattanLength: function () {
            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
          },
          normalize: function () {
            return this.divideScalar(this.length() || 1);
          },
          setLength: function (t) {
            return this.normalize().multiplyScalar(t);
          },
          lerp: function (t, e) {
            return (
              (this.x += (t.x - this.x) * e),
              (this.y += (t.y - this.y) * e),
              (this.z += (t.z - this.z) * e),
              this
            );
          },
          lerpVectors: function (t, e, n) {
            return this.subVectors(e, t).multiplyScalar(n).add(t);
          },
          cross: function (t, e) {
            return void 0 !== e
              ? (console.warn(
                  "THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."
                ),
                this.crossVectors(t, e))
              : this.crossVectors(this, t);
          },
          crossVectors: function (t, e) {
            var n = t.x,
              i = t.y,
              r = t.z,
              a = e.x,
              o = e.y,
              s = e.z;
            return (
              (this.x = i * s - r * o),
              (this.y = r * a - n * s),
              (this.z = n * o - i * a),
              this
            );
          },
          projectOnVector: function (t) {
            var e = t.dot(this) / t.lengthSq();
            return this.copy(t).multiplyScalar(e);
          },
          projectOnPlane: (function () {
            var t = new ke();
            return function (e) {
              return t.copy(this).projectOnVector(e), this.sub(t);
            };
          })(),
          reflect: (function () {
            var t = new ke();
            return function (e) {
              return this.sub(t.copy(e).multiplyScalar(2 * this.dot(e)));
            };
          })(),
          angleTo: function (t) {
            var e = this.dot(t) / Math.sqrt(this.lengthSq() * t.lengthSq());
            return Math.acos(ze.clamp(e, -1, 1));
          },
          distanceTo: function (t) {
            return Math.sqrt(this.distanceToSquared(t));
          },
          distanceToSquared: function (t) {
            var e = this.x - t.x,
              n = this.y - t.y,
              i = this.z - t.z;
            return e * e + n * n + i * i;
          },
          manhattanDistanceTo: function (t) {
            return (
              Math.abs(this.x - t.x) +
              Math.abs(this.y - t.y) +
              Math.abs(this.z - t.z)
            );
          },
          setFromSpherical: function (t) {
            var e = Math.sin(t.phi) * t.radius;
            return (
              (this.x = e * Math.sin(t.theta)),
              (this.y = Math.cos(t.phi) * t.radius),
              (this.z = e * Math.cos(t.theta)),
              this
            );
          },
          setFromCylindrical: function (t) {
            return (
              (this.x = t.radius * Math.sin(t.theta)),
              (this.y = t.y),
              (this.z = t.radius * Math.cos(t.theta)),
              this
            );
          },
          setFromMatrixPosition: function (t) {
            var e = t.elements;
            return (this.x = e[12]), (this.y = e[13]), (this.z = e[14]), this;
          },
          setFromMatrixScale: function (t) {
            var e = this.setFromMatrixColumn(t, 0).length(),
              n = this.setFromMatrixColumn(t, 1).length(),
              i = this.setFromMatrixColumn(t, 2).length();
            return (this.x = e), (this.y = n), (this.z = i), this;
          },
          setFromMatrixColumn: function (t, e) {
            return this.fromArray(t.elements, 4 * e);
          },
          equals: function (t) {
            return t.x === this.x && t.y === this.y && t.z === this.z;
          },
          fromArray: function (t, e) {
            return (
              void 0 === e && (e = 0),
              (this.x = t[e]),
              (this.y = t[e + 1]),
              (this.z = t[e + 2]),
              this
            );
          },
          toArray: function (t, e) {
            return (
              void 0 === t && (t = []),
              void 0 === e && (e = 0),
              (t[e] = this.x),
              (t[e + 1] = this.y),
              (t[e + 2] = this.z),
              t
            );
          },
          fromBufferAttribute: function (t, e, n) {
            return (
              void 0 !== n &&
                console.warn(
                  "THREE.Vector3: offset has been removed from .fromBufferAttribute()."
                ),
              (this.x = t.getX(e)),
              (this.y = t.getY(e)),
              (this.z = t.getZ(e)),
              this
            );
          },
        }),
        Object.assign(Ge.prototype, {
          isMatrix3: !0,
          set: function (t, e, n, i, r, a, o, s, c) {
            var l = this.elements;
            return (
              (l[0] = t),
              (l[1] = i),
              (l[2] = o),
              (l[3] = e),
              (l[4] = r),
              (l[5] = s),
              (l[6] = n),
              (l[7] = a),
              (l[8] = c),
              this
            );
          },
          identity: function () {
            return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
          },
          clone: function () {
            return new this.constructor().fromArray(this.elements);
          },
          copy: function (t) {
            var e = this.elements,
              n = t.elements;
            return (
              (e[0] = n[0]),
              (e[1] = n[1]),
              (e[2] = n[2]),
              (e[3] = n[3]),
              (e[4] = n[4]),
              (e[5] = n[5]),
              (e[6] = n[6]),
              (e[7] = n[7]),
              (e[8] = n[8]),
              this
            );
          },
          setFromMatrix4: function (t) {
            var e = t.elements;
            return (
              this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]),
              this
            );
          },
          applyToBufferAttribute: (function () {
            var t = new ke();
            return function (e) {
              for (var n = 0, i = e.count; n < i; n++)
                (t.x = e.getX(n)),
                  (t.y = e.getY(n)),
                  (t.z = e.getZ(n)),
                  t.applyMatrix3(this),
                  e.setXYZ(n, t.x, t.y, t.z);
              return e;
            };
          })(),
          multiply: function (t) {
            return this.multiplyMatrices(this, t);
          },
          premultiply: function (t) {
            return this.multiplyMatrices(t, this);
          },
          multiplyMatrices: function (t, e) {
            var n = t.elements,
              i = e.elements,
              r = this.elements,
              a = n[0],
              o = n[3],
              s = n[6],
              c = n[1],
              l = n[4],
              h = n[7],
              u = n[2],
              d = n[5],
              p = n[8],
              f = i[0],
              m = i[3],
              g = i[6],
              v = i[1],
              y = i[4],
              x = i[7],
              _ = i[2],
              b = i[5],
              w = i[8];
            return (
              (r[0] = a * f + o * v + s * _),
              (r[3] = a * m + o * y + s * b),
              (r[6] = a * g + o * x + s * w),
              (r[1] = c * f + l * v + h * _),
              (r[4] = c * m + l * y + h * b),
              (r[7] = c * g + l * x + h * w),
              (r[2] = u * f + d * v + p * _),
              (r[5] = u * m + d * y + p * b),
              (r[8] = u * g + d * x + p * w),
              this
            );
          },
          multiplyScalar: function (t) {
            var e = this.elements;
            return (
              (e[0] *= t),
              (e[3] *= t),
              (e[6] *= t),
              (e[1] *= t),
              (e[4] *= t),
              (e[7] *= t),
              (e[2] *= t),
              (e[5] *= t),
              (e[8] *= t),
              this
            );
          },
          determinant: function () {
            var t = this.elements,
              e = t[0],
              n = t[1],
              i = t[2],
              r = t[3],
              a = t[4],
              o = t[5],
              s = t[6],
              c = t[7],
              l = t[8];
            return (
              e * a * l -
              e * o * c -
              n * r * l +
              n * o * s +
              i * r * c -
              i * a * s
            );
          },
          getInverse: function (t, e) {
            t &&
              t.isMatrix4 &&
              console.error(
                "THREE.Matrix3: .getInverse() no longer takes a Matrix4 argument."
              );
            var n = t.elements,
              i = this.elements,
              r = n[0],
              a = n[1],
              o = n[2],
              s = n[3],
              c = n[4],
              l = n[5],
              h = n[6],
              u = n[7],
              d = n[8],
              p = d * c - l * u,
              f = l * h - d * s,
              m = u * s - c * h,
              g = r * p + a * f + o * m;
            if (0 === g) {
              var v =
                "THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0";
              if (!0 === e) throw new Error(v);
              return console.warn(v), this.identity();
            }
            var y = 1 / g;
            return (
              (i[0] = p * y),
              (i[1] = (o * u - d * a) * y),
              (i[2] = (l * a - o * c) * y),
              (i[3] = f * y),
              (i[4] = (d * r - o * h) * y),
              (i[5] = (o * s - l * r) * y),
              (i[6] = m * y),
              (i[7] = (a * h - u * r) * y),
              (i[8] = (c * r - a * s) * y),
              this
            );
          },
          transpose: function () {
            var t,
              e = this.elements;
            return (
              (t = e[1]),
              (e[1] = e[3]),
              (e[3] = t),
              (t = e[2]),
              (e[2] = e[6]),
              (e[6] = t),
              (t = e[5]),
              (e[5] = e[7]),
              (e[7] = t),
              this
            );
          },
          getNormalMatrix: function (t) {
            return this.setFromMatrix4(t).getInverse(this).transpose();
          },
          transposeIntoArray: function (t) {
            var e = this.elements;
            return (
              (t[0] = e[0]),
              (t[1] = e[3]),
              (t[2] = e[6]),
              (t[3] = e[1]),
              (t[4] = e[4]),
              (t[5] = e[7]),
              (t[6] = e[2]),
              (t[7] = e[5]),
              (t[8] = e[8]),
              this
            );
          },
          setUvTransform: function (t, e, n, i, r, a, o) {
            var s = Math.cos(r),
              c = Math.sin(r);
            this.set(
              n * s,
              n * c,
              -n * (s * a + c * o) + a + t,
              -i * c,
              i * s,
              -i * (-c * a + s * o) + o + e,
              0,
              0,
              1
            );
          },
          scale: function (t, e) {
            var n = this.elements;
            return (
              (n[0] *= t),
              (n[3] *= t),
              (n[6] *= t),
              (n[1] *= e),
              (n[4] *= e),
              (n[7] *= e),
              this
            );
          },
          rotate: function (t) {
            var e = Math.cos(t),
              n = Math.sin(t),
              i = this.elements,
              r = i[0],
              a = i[3],
              o = i[6],
              s = i[1],
              c = i[4],
              l = i[7];
            return (
              (i[0] = e * r + n * s),
              (i[3] = e * a + n * c),
              (i[6] = e * o + n * l),
              (i[1] = -n * r + e * s),
              (i[4] = -n * a + e * c),
              (i[7] = -n * o + e * l),
              this
            );
          },
          translate: function (t, e) {
            var n = this.elements;
            return (
              (n[0] += t * n[2]),
              (n[3] += t * n[5]),
              (n[6] += t * n[8]),
              (n[1] += e * n[2]),
              (n[4] += e * n[5]),
              (n[7] += e * n[8]),
              this
            );
          },
          equals: function (t) {
            for (var e = this.elements, n = t.elements, i = 0; i < 9; i++)
              if (e[i] !== n[i]) return !1;
            return !0;
          },
          fromArray: function (t, e) {
            void 0 === e && (e = 0);
            for (var n = 0; n < 9; n++) this.elements[n] = t[n + e];
            return this;
          },
          toArray: function (t, e) {
            void 0 === t && (t = []), void 0 === e && (e = 0);
            var n = this.elements;
            return (
              (t[e] = n[0]),
              (t[e + 1] = n[1]),
              (t[e + 2] = n[2]),
              (t[e + 3] = n[3]),
              (t[e + 4] = n[4]),
              (t[e + 5] = n[5]),
              (t[e + 6] = n[6]),
              (t[e + 7] = n[7]),
              (t[e + 8] = n[8]),
              t
            );
          },
        });
      var Ve = 0;
      function We(t, e, n, i, r, a, o, s, c, l) {
        Object.defineProperty(this, "id", { value: Ve++ }),
          (this.uuid = ze.generateUUID()),
          (this.name = ""),
          (this.image = void 0 !== t ? t : We.DEFAULT_IMAGE),
          (this.mipmaps = []),
          (this.mapping = void 0 !== e ? e : We.DEFAULT_MAPPING),
          (this.wrapS = void 0 !== n ? n : gt),
          (this.wrapT = void 0 !== i ? i : gt),
          (this.magFilter = void 0 !== r ? r : bt),
          (this.minFilter = void 0 !== a ? a : Mt),
          (this.anisotropy = void 0 !== c ? c : 1),
          (this.format = void 0 !== o ? o : Ut),
          (this.type = void 0 !== s ? s : St),
          (this.offset = new Ue(0, 0)),
          (this.repeat = new Ue(1, 1)),
          (this.center = new Ue(0, 0)),
          (this.rotation = 0),
          (this.matrixAutoUpdate = !0),
          (this.matrix = new Ge()),
          (this.generateMipmaps = !0),
          (this.premultiplyAlpha = !1),
          (this.flipY = !0),
          (this.unpackAlignment = 4),
          (this.encoding = void 0 !== l ? l : Ee),
          (this.version = 0),
          (this.onUpdate = null);
      }
      function je(t, e, n, i) {
        (this.x = t || 0),
          (this.y = e || 0),
          (this.z = n || 0),
          (this.w = void 0 !== i ? i : 1);
      }
      function qe(t, e, n) {
        (this.width = t),
          (this.height = e),
          (this.scissor = new je(0, 0, t, e)),
          (this.scissorTest = !1),
          (this.viewport = new je(0, 0, t, e)),
          (n = n || {}),
          void 0 === n.minFilter && (n.minFilter = bt),
          (this.texture = new We(
            void 0,
            void 0,
            n.wrapS,
            n.wrapT,
            n.magFilter,
            n.minFilter,
            n.format,
            n.type,
            n.anisotropy,
            n.encoding
          )),
          (this.texture.generateMipmaps =
            void 0 === n.generateMipmaps || n.generateMipmaps),
          (this.depthBuffer = void 0 === n.depthBuffer || n.depthBuffer),
          (this.stencilBuffer = void 0 === n.stencilBuffer || n.stencilBuffer),
          (this.depthTexture =
            void 0 !== n.depthTexture ? n.depthTexture : null);
      }
      function Xe(t, e, n) {
        qe.call(this, t, e, n),
          (this.activeCubeFace = 0),
          (this.activeMipMapLevel = 0);
      }
      function Ye(t, e, n, i, r, a, o, s, c, l, h, u) {
        We.call(this, null, a, o, s, c, l, i, r, h, u),
          (this.image = { data: t, width: e, height: n }),
          (this.magFilter = void 0 !== c ? c : yt),
          (this.minFilter = void 0 !== l ? l : yt),
          (this.generateMipmaps = !1),
          (this.flipY = !1),
          (this.unpackAlignment = 1);
      }
      function Je(t, e) {
        (this.min = void 0 !== t ? t : new ke(1 / 0, 1 / 0, 1 / 0)),
          (this.max = void 0 !== e ? e : new ke(-1 / 0, -1 / 0, -1 / 0));
      }
      function Ze(t, e) {
        (this.center = void 0 !== t ? t : new ke()),
          (this.radius = void 0 !== e ? e : 0);
      }
      function Ke(t, e) {
        (this.normal = void 0 !== t ? t : new ke(1, 0, 0)),
          (this.constant = void 0 !== e ? e : 0);
      }
      function $e(t, e, n, i, r, a) {
        this.planes = [
          void 0 !== t ? t : new Ke(),
          void 0 !== e ? e : new Ke(),
          void 0 !== n ? n : new Ke(),
          void 0 !== i ? i : new Ke(),
          void 0 !== r ? r : new Ke(),
          void 0 !== a ? a : new Ke(),
        ];
      }
      (We.DEFAULT_IMAGE = void 0),
        (We.DEFAULT_MAPPING = st),
        (We.prototype = Object.assign(Object.create(i.prototype), {
          constructor: We,
          isTexture: !0,
          updateMatrix: function () {
            this.matrix.setUvTransform(
              this.offset.x,
              this.offset.y,
              this.repeat.x,
              this.repeat.y,
              this.rotation,
              this.center.x,
              this.center.y
            );
          },
          clone: function () {
            return new this.constructor().copy(this);
          },
          copy: function (t) {
            return (
              (this.name = t.name),
              (this.image = t.image),
              (this.mipmaps = t.mipmaps.slice(0)),
              (this.mapping = t.mapping),
              (this.wrapS = t.wrapS),
              (this.wrapT = t.wrapT),
              (this.magFilter = t.magFilter),
              (this.minFilter = t.minFilter),
              (this.anisotropy = t.anisotropy),
              (this.format = t.format),
              (this.type = t.type),
              this.offset.copy(t.offset),
              this.repeat.copy(t.repeat),
              this.center.copy(t.center),
              (this.rotation = t.rotation),
              (this.matrixAutoUpdate = t.matrixAutoUpdate),
              this.matrix.copy(t.matrix),
              (this.generateMipmaps = t.generateMipmaps),
              (this.premultiplyAlpha = t.premultiplyAlpha),
              (this.flipY = t.flipY),
              (this.unpackAlignment = t.unpackAlignment),
              (this.encoding = t.encoding),
              this
            );
          },
          toJSON: function (t) {
            var e = void 0 === t || "string" === typeof t;
            if (!e && void 0 !== t.textures[this.uuid])
              return t.textures[this.uuid];
            function n(t) {
              var e;
              if (t instanceof HTMLCanvasElement) e = t;
              else {
                (e = document.createElementNS(
                  "http://www.w3.org/1999/xhtml",
                  "canvas"
                )),
                  (e.width = t.width),
                  (e.height = t.height);
                var n = e.getContext("2d");
                t instanceof ImageData
                  ? n.putImageData(t, 0, 0)
                  : n.drawImage(t, 0, 0, t.width, t.height);
              }
              return e.width > 2048 || e.height > 2048
                ? e.toDataURL("image/jpeg", 0.6)
                : e.toDataURL("image/png");
            }
            var i = {
              metadata: {
                version: 4.5,
                type: "Texture",
                generator: "Texture.toJSON",
              },
              uuid: this.uuid,
              name: this.name,
              mapping: this.mapping,
              repeat: [this.repeat.x, this.repeat.y],
              offset: [this.offset.x, this.offset.y],
              center: [this.center.x, this.center.y],
              rotation: this.rotation,
              wrap: [this.wrapS, this.wrapT],
              format: this.format,
              minFilter: this.minFilter,
              magFilter: this.magFilter,
              anisotropy: this.anisotropy,
              flipY: this.flipY,
            };
            if (void 0 !== this.image) {
              var r = this.image;
              if (
                (void 0 === r.uuid && (r.uuid = ze.generateUUID()),
                !e && void 0 === t.images[r.uuid])
              ) {
                var a;
                if (Array.isArray(r)) {
                  a = [];
                  for (var o = 0, s = r.length; o < s; o++) a.push(n(r[o]));
                } else a = n(r);
                t.images[r.uuid] = { uuid: r.uuid, url: a };
              }
              i.image = r.uuid;
            }
            return e || (t.textures[this.uuid] = i), i;
          },
          dispose: function () {
            this.dispatchEvent({ type: "dispose" });
          },
          transformUv: function (t) {
            if (this.mapping === st) {
              if ((t.applyMatrix3(this.matrix), t.x < 0 || t.x > 1))
                switch (this.wrapS) {
                  case mt:
                    t.x = t.x - Math.floor(t.x);
                    break;
                  case gt:
                    t.x = t.x < 0 ? 0 : 1;
                    break;
                  case vt:
                    1 === Math.abs(Math.floor(t.x) % 2)
                      ? (t.x = Math.ceil(t.x) - t.x)
                      : (t.x = t.x - Math.floor(t.x));
                    break;
                }
              if (t.y < 0 || t.y > 1)
                switch (this.wrapT) {
                  case mt:
                    t.y = t.y - Math.floor(t.y);
                    break;
                  case gt:
                    t.y = t.y < 0 ? 0 : 1;
                    break;
                  case vt:
                    1 === Math.abs(Math.floor(t.y) % 2)
                      ? (t.y = Math.ceil(t.y) - t.y)
                      : (t.y = t.y - Math.floor(t.y));
                    break;
                }
              this.flipY && (t.y = 1 - t.y);
            }
          },
        })),
        Object.defineProperty(We.prototype, "needsUpdate", {
          set: function (t) {
            !0 === t && this.version++;
          },
        }),
        Object.assign(je.prototype, {
          isVector4: !0,
          set: function (t, e, n, i) {
            return (this.x = t), (this.y = e), (this.z = n), (this.w = i), this;
          },
          setScalar: function (t) {
            return (this.x = t), (this.y = t), (this.z = t), (this.w = t), this;
          },
          setX: function (t) {
            return (this.x = t), this;
          },
          setY: function (t) {
            return (this.y = t), this;
          },
          setZ: function (t) {
            return (this.z = t), this;
          },
          setW: function (t) {
            return (this.w = t), this;
          },
          setComponent: function (t, e) {
            switch (t) {
              case 0:
                this.x = e;
                break;
              case 1:
                this.y = e;
                break;
              case 2:
                this.z = e;
                break;
              case 3:
                this.w = e;
                break;
              default:
                throw new Error("index is out of range: " + t);
            }
            return this;
          },
          getComponent: function (t) {
            switch (t) {
              case 0:
                return this.x;
              case 1:
                return this.y;
              case 2:
                return this.z;
              case 3:
                return this.w;
              default:
                throw new Error("index is out of range: " + t);
            }
          },
          clone: function () {
            return new this.constructor(this.x, this.y, this.z, this.w);
          },
          copy: function (t) {
            return (
              (this.x = t.x),
              (this.y = t.y),
              (this.z = t.z),
              (this.w = void 0 !== t.w ? t.w : 1),
              this
            );
          },
          add: function (t, e) {
            return void 0 !== e
              ? (console.warn(
                  "THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."
                ),
                this.addVectors(t, e))
              : ((this.x += t.x),
                (this.y += t.y),
                (this.z += t.z),
                (this.w += t.w),
                this);
          },
          addScalar: function (t) {
            return (
              (this.x += t), (this.y += t), (this.z += t), (this.w += t), this
            );
          },
          addVectors: function (t, e) {
            return (
              (this.x = t.x + e.x),
              (this.y = t.y + e.y),
              (this.z = t.z + e.z),
              (this.w = t.w + e.w),
              this
            );
          },
          addScaledVector: function (t, e) {
            return (
              (this.x += t.x * e),
              (this.y += t.y * e),
              (this.z += t.z * e),
              (this.w += t.w * e),
              this
            );
          },
          sub: function (t, e) {
            return void 0 !== e
              ? (console.warn(
                  "THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."
                ),
                this.subVectors(t, e))
              : ((this.x -= t.x),
                (this.y -= t.y),
                (this.z -= t.z),
                (this.w -= t.w),
                this);
          },
          subScalar: function (t) {
            return (
              (this.x -= t), (this.y -= t), (this.z -= t), (this.w -= t), this
            );
          },
          subVectors: function (t, e) {
            return (
              (this.x = t.x - e.x),
              (this.y = t.y - e.y),
              (this.z = t.z - e.z),
              (this.w = t.w - e.w),
              this
            );
          },
          multiplyScalar: function (t) {
            return (
              (this.x *= t), (this.y *= t), (this.z *= t), (this.w *= t), this
            );
          },
          applyMatrix4: function (t) {
            var e = this.x,
              n = this.y,
              i = this.z,
              r = this.w,
              a = t.elements;
            return (
              (this.x = a[0] * e + a[4] * n + a[8] * i + a[12] * r),
              (this.y = a[1] * e + a[5] * n + a[9] * i + a[13] * r),
              (this.z = a[2] * e + a[6] * n + a[10] * i + a[14] * r),
              (this.w = a[3] * e + a[7] * n + a[11] * i + a[15] * r),
              this
            );
          },
          divideScalar: function (t) {
            return this.multiplyScalar(1 / t);
          },
          setAxisAngleFromQuaternion: function (t) {
            this.w = 2 * Math.acos(t.w);
            var e = Math.sqrt(1 - t.w * t.w);
            return (
              e < 1e-4
                ? ((this.x = 1), (this.y = 0), (this.z = 0))
                : ((this.x = t.x / e), (this.y = t.y / e), (this.z = t.z / e)),
              this
            );
          },
          setAxisAngleFromRotationMatrix: function (t) {
            var e,
              n,
              i,
              r,
              a = 0.01,
              o = 0.1,
              s = t.elements,
              c = s[0],
              l = s[4],
              h = s[8],
              u = s[1],
              d = s[5],
              p = s[9],
              f = s[2],
              m = s[6],
              g = s[10];
            if (
              Math.abs(l - u) < a &&
              Math.abs(h - f) < a &&
              Math.abs(p - m) < a
            ) {
              if (
                Math.abs(l + u) < o &&
                Math.abs(h + f) < o &&
                Math.abs(p + m) < o &&
                Math.abs(c + d + g - 3) < o
              )
                return this.set(1, 0, 0, 0), this;
              e = Math.PI;
              var v = (c + 1) / 2,
                y = (d + 1) / 2,
                x = (g + 1) / 2,
                _ = (l + u) / 4,
                b = (h + f) / 4,
                w = (p + m) / 4;
              return (
                v > y && v > x
                  ? v < a
                    ? ((n = 0), (i = 0.707106781), (r = 0.707106781))
                    : ((n = Math.sqrt(v)), (i = _ / n), (r = b / n))
                  : y > x
                  ? y < a
                    ? ((n = 0.707106781), (i = 0), (r = 0.707106781))
                    : ((i = Math.sqrt(y)), (n = _ / i), (r = w / i))
                  : x < a
                  ? ((n = 0.707106781), (i = 0.707106781), (r = 0))
                  : ((r = Math.sqrt(x)), (n = b / r), (i = w / r)),
                this.set(n, i, r, e),
                this
              );
            }
            var M = Math.sqrt(
              (m - p) * (m - p) + (h - f) * (h - f) + (u - l) * (u - l)
            );
            return (
              Math.abs(M) < 0.001 && (M = 1),
              (this.x = (m - p) / M),
              (this.y = (h - f) / M),
              (this.z = (u - l) / M),
              (this.w = Math.acos((c + d + g - 1) / 2)),
              this
            );
          },
          min: function (t) {
            return (
              (this.x = Math.min(this.x, t.x)),
              (this.y = Math.min(this.y, t.y)),
              (this.z = Math.min(this.z, t.z)),
              (this.w = Math.min(this.w, t.w)),
              this
            );
          },
          max: function (t) {
            return (
              (this.x = Math.max(this.x, t.x)),
              (this.y = Math.max(this.y, t.y)),
              (this.z = Math.max(this.z, t.z)),
              (this.w = Math.max(this.w, t.w)),
              this
            );
          },
          clamp: function (t, e) {
            return (
              (this.x = Math.max(t.x, Math.min(e.x, this.x))),
              (this.y = Math.max(t.y, Math.min(e.y, this.y))),
              (this.z = Math.max(t.z, Math.min(e.z, this.z))),
              (this.w = Math.max(t.w, Math.min(e.w, this.w))),
              this
            );
          },
          clampScalar: (function () {
            var t, e;
            return function (n, i) {
              return (
                void 0 === t && ((t = new je()), (e = new je())),
                t.set(n, n, n, n),
                e.set(i, i, i, i),
                this.clamp(t, e)
              );
            };
          })(),
          clampLength: function (t, e) {
            var n = this.length();
            return this.divideScalar(n || 1).multiplyScalar(
              Math.max(t, Math.min(e, n))
            );
          },
          floor: function () {
            return (
              (this.x = Math.floor(this.x)),
              (this.y = Math.floor(this.y)),
              (this.z = Math.floor(this.z)),
              (this.w = Math.floor(this.w)),
              this
            );
          },
          ceil: function () {
            return (
              (this.x = Math.ceil(this.x)),
              (this.y = Math.ceil(this.y)),
              (this.z = Math.ceil(this.z)),
              (this.w = Math.ceil(this.w)),
              this
            );
          },
          round: function () {
            return (
              (this.x = Math.round(this.x)),
              (this.y = Math.round(this.y)),
              (this.z = Math.round(this.z)),
              (this.w = Math.round(this.w)),
              this
            );
          },
          roundToZero: function () {
            return (
              (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
              (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
              (this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)),
              (this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w)),
              this
            );
          },
          negate: function () {
            return (
              (this.x = -this.x),
              (this.y = -this.y),
              (this.z = -this.z),
              (this.w = -this.w),
              this
            );
          },
          dot: function (t) {
            return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w;
          },
          lengthSq: function () {
            return (
              this.x * this.x +
              this.y * this.y +
              this.z * this.z +
              this.w * this.w
            );
          },
          length: function () {
            return Math.sqrt(
              this.x * this.x +
                this.y * this.y +
                this.z * this.z +
                this.w * this.w
            );
          },
          manhattanLength: function () {
            return (
              Math.abs(this.x) +
              Math.abs(this.y) +
              Math.abs(this.z) +
              Math.abs(this.w)
            );
          },
          normalize: function () {
            return this.divideScalar(this.length() || 1);
          },
          setLength: function (t) {
            return this.normalize().multiplyScalar(t);
          },
          lerp: function (t, e) {
            return (
              (this.x += (t.x - this.x) * e),
              (this.y += (t.y - this.y) * e),
              (this.z += (t.z - this.z) * e),
              (this.w += (t.w - this.w) * e),
              this
            );
          },
          lerpVectors: function (t, e, n) {
            return this.subVectors(e, t).multiplyScalar(n).add(t);
          },
          equals: function (t) {
            return (
              t.x === this.x &&
              t.y === this.y &&
              t.z === this.z &&
              t.w === this.w
            );
          },
          fromArray: function (t, e) {
            return (
              void 0 === e && (e = 0),
              (this.x = t[e]),
              (this.y = t[e + 1]),
              (this.z = t[e + 2]),
              (this.w = t[e + 3]),
              this
            );
          },
          toArray: function (t, e) {
            return (
              void 0 === t && (t = []),
              void 0 === e && (e = 0),
              (t[e] = this.x),
              (t[e + 1] = this.y),
              (t[e + 2] = this.z),
              (t[e + 3] = this.w),
              t
            );
          },
          fromBufferAttribute: function (t, e, n) {
            return (
              void 0 !== n &&
                console.warn(
                  "THREE.Vector4: offset has been removed from .fromBufferAttribute()."
                ),
              (this.x = t.getX(e)),
              (this.y = t.getY(e)),
              (this.z = t.getZ(e)),
              (this.w = t.getW(e)),
              this
            );
          },
        }),
        (qe.prototype = Object.assign(Object.create(i.prototype), {
          constructor: qe,
          isWebGLRenderTarget: !0,
          setSize: function (t, e) {
            (this.width === t && this.height === e) ||
              ((this.width = t), (this.height = e), this.dispose()),
              this.viewport.set(0, 0, t, e),
              this.scissor.set(0, 0, t, e);
          },
          clone: function () {
            return new this.constructor().copy(this);
          },
          copy: function (t) {
            return (
              (this.width = t.width),
              (this.height = t.height),
              this.viewport.copy(t.viewport),
              (this.texture = t.texture.clone()),
              (this.depthBuffer = t.depthBuffer),
              (this.stencilBuffer = t.stencilBuffer),
              (this.depthTexture = t.depthTexture),
              this
            );
          },
          dispose: function () {
            this.dispatchEvent({ type: "dispose" });
          },
        })),
        (Xe.prototype = Object.create(qe.prototype)),
        (Xe.prototype.constructor = Xe),
        (Xe.prototype.isWebGLRenderTargetCube = !0),
        (Ye.prototype = Object.create(We.prototype)),
        (Ye.prototype.constructor = Ye),
        (Ye.prototype.isDataTexture = !0),
        Object.assign(Je.prototype, {
          isBox3: !0,
          set: function (t, e) {
            return this.min.copy(t), this.max.copy(e), this;
          },
          setFromArray: function (t) {
            for (
              var e = 1 / 0,
                n = 1 / 0,
                i = 1 / 0,
                r = -1 / 0,
                a = -1 / 0,
                o = -1 / 0,
                s = 0,
                c = t.length;
              s < c;
              s += 3
            ) {
              var l = t[s],
                h = t[s + 1],
                u = t[s + 2];
              l < e && (e = l),
                h < n && (n = h),
                u < i && (i = u),
                l > r && (r = l),
                h > a && (a = h),
                u > o && (o = u);
            }
            return this.min.set(e, n, i), this.max.set(r, a, o), this;
          },
          setFromBufferAttribute: function (t) {
            for (
              var e = 1 / 0,
                n = 1 / 0,
                i = 1 / 0,
                r = -1 / 0,
                a = -1 / 0,
                o = -1 / 0,
                s = 0,
                c = t.count;
              s < c;
              s++
            ) {
              var l = t.getX(s),
                h = t.getY(s),
                u = t.getZ(s);
              l < e && (e = l),
                h < n && (n = h),
                u < i && (i = u),
                l > r && (r = l),
                h > a && (a = h),
                u > o && (o = u);
            }
            return this.min.set(e, n, i), this.max.set(r, a, o), this;
          },
          setFromPoints: function (t) {
            this.makeEmpty();
            for (var e = 0, n = t.length; e < n; e++) this.expandByPoint(t[e]);
            return this;
          },
          setFromCenterAndSize: (function () {
            var t = new ke();
            return function (e, n) {
              var i = t.copy(n).multiplyScalar(0.5);
              return this.min.copy(e).sub(i), this.max.copy(e).add(i), this;
            };
          })(),
          setFromObject: function (t) {
            return this.makeEmpty(), this.expandByObject(t);
          },
          clone: function () {
            return new this.constructor().copy(this);
          },
          copy: function (t) {
            return this.min.copy(t.min), this.max.copy(t.max), this;
          },
          makeEmpty: function () {
            return (
              (this.min.x = this.min.y = this.min.z = 1 / 0),
              (this.max.x = this.max.y = this.max.z = -1 / 0),
              this
            );
          },
          isEmpty: function () {
            return (
              this.max.x < this.min.x ||
              this.max.y < this.min.y ||
              this.max.z < this.min.z
            );
          },
          getCenter: function (t) {
            return (
              void 0 === t &&
                (console.warn(
                  "THREE.Box3: .getCenter() target is now required"
                ),
                (t = new ke())),
              this.isEmpty()
                ? t.set(0, 0, 0)
                : t.addVectors(this.min, this.max).multiplyScalar(0.5)
            );
          },
          getSize: function (t) {
            return (
              void 0 === t &&
                (console.warn("THREE.Box3: .getSize() target is now required"),
                (t = new ke())),
              this.isEmpty() ? t.set(0, 0, 0) : t.subVectors(this.max, this.min)
            );
          },
          expandByPoint: function (t) {
            return this.min.min(t), this.max.max(t), this;
          },
          expandByVector: function (t) {
            return this.min.sub(t), this.max.add(t), this;
          },
          expandByScalar: function (t) {
            return this.min.addScalar(-t), this.max.addScalar(t), this;
          },
          expandByObject: (function () {
            var t,
              e,
              n,
              i = new ke();
            function r(r) {
              var a = r.geometry;
              if (void 0 !== a)
                if (a.isGeometry) {
                  var o = a.vertices;
                  for (e = 0, n = o.length; e < n; e++)
                    i.copy(o[e]),
                      i.applyMatrix4(r.matrixWorld),
                      t.expandByPoint(i);
                } else if (a.isBufferGeometry) {
                  var s = a.attributes.position;
                  if (void 0 !== s)
                    for (e = 0, n = s.count; e < n; e++)
                      i.fromBufferAttribute(s, e).applyMatrix4(r.matrixWorld),
                        t.expandByPoint(i);
                }
            }
            return function (e) {
              return (t = this), e.updateMatrixWorld(!0), e.traverse(r), this;
            };
          })(),
          containsPoint: function (t) {
            return !(
              t.x < this.min.x ||
              t.x > this.max.x ||
              t.y < this.min.y ||
              t.y > this.max.y ||
              t.z < this.min.z ||
              t.z > this.max.z
            );
          },
          containsBox: function (t) {
            return (
              this.min.x <= t.min.x &&
              t.max.x <= this.max.x &&
              this.min.y <= t.min.y &&
              t.max.y <= this.max.y &&
              this.min.z <= t.min.z &&
              t.max.z <= this.max.z
            );
          },
          getParameter: function (t, e) {
            return (
              void 0 === e &&
                (console.warn(
                  "THREE.Box3: .getParameter() target is now required"
                ),
                (e = new ke())),
              e.set(
                (t.x - this.min.x) / (this.max.x - this.min.x),
                (t.y - this.min.y) / (this.max.y - this.min.y),
                (t.z - this.min.z) / (this.max.z - this.min.z)
              )
            );
          },
          intersectsBox: function (t) {
            return !(
              t.max.x < this.min.x ||
              t.min.x > this.max.x ||
              t.max.y < this.min.y ||
              t.min.y > this.max.y ||
              t.max.z < this.min.z ||
              t.min.z > this.max.z
            );
          },
          intersectsSphere: (function () {
            var t = new ke();
            return function (e) {
              return (
                this.clampPoint(e.center, t),
                t.distanceToSquared(e.center) <= e.radius * e.radius
              );
            };
          })(),
          intersectsPlane: function (t) {
            var e, n;
            return (
              t.normal.x > 0
                ? ((e = t.normal.x * this.min.x), (n = t.normal.x * this.max.x))
                : ((e = t.normal.x * this.max.x),
                  (n = t.normal.x * this.min.x)),
              t.normal.y > 0
                ? ((e += t.normal.y * this.min.y),
                  (n += t.normal.y * this.max.y))
                : ((e += t.normal.y * this.max.y),
                  (n += t.normal.y * this.min.y)),
              t.normal.z > 0
                ? ((e += t.normal.z * this.min.z),
                  (n += t.normal.z * this.max.z))
                : ((e += t.normal.z * this.max.z),
                  (n += t.normal.z * this.min.z)),
              e <= t.constant && n >= t.constant
            );
          },
          intersectsTriangle: (function () {
            var t = new ke(),
              e = new ke(),
              n = new ke(),
              i = new ke(),
              r = new ke(),
              a = new ke(),
              o = new ke(),
              s = new ke(),
              c = new ke(),
              l = new ke();
            function h(i) {
              var r, a;
              for (r = 0, a = i.length - 3; r <= a; r += 3) {
                o.fromArray(i, r);
                var s =
                    c.x * Math.abs(o.x) +
                    c.y * Math.abs(o.y) +
                    c.z * Math.abs(o.z),
                  l = t.dot(o),
                  h = e.dot(o),
                  u = n.dot(o);
                if (Math.max(-Math.max(l, h, u), Math.min(l, h, u)) > s)
                  return !1;
              }
              return !0;
            }
            return function (o) {
              if (this.isEmpty()) return !1;
              this.getCenter(s),
                c.subVectors(this.max, s),
                t.subVectors(o.a, s),
                e.subVectors(o.b, s),
                n.subVectors(o.c, s),
                i.subVectors(e, t),
                r.subVectors(n, e),
                a.subVectors(t, n);
              var u = [
                0,
                -i.z,
                i.y,
                0,
                -r.z,
                r.y,
                0,
                -a.z,
                a.y,
                i.z,
                0,
                -i.x,
                r.z,
                0,
                -r.x,
                a.z,
                0,
                -a.x,
                -i.y,
                i.x,
                0,
                -r.y,
                r.x,
                0,
                -a.y,
                a.x,
                0,
              ];
              return (
                !!h(u) &&
                ((u = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
                !!h(u) && (l.crossVectors(i, r), (u = [l.x, l.y, l.z]), h(u)))
              );
            };
          })(),
          clampPoint: function (t, e) {
            return (
              void 0 === e &&
                (console.warn(
                  "THREE.Box3: .clampPoint() target is now required"
                ),
                (e = new ke())),
              e.copy(t).clamp(this.min, this.max)
            );
          },
          distanceToPoint: (function () {
            var t = new ke();
            return function (e) {
              var n = t.copy(e).clamp(this.min, this.max);
              return n.sub(e).length();
            };
          })(),
          getBoundingSphere: (function () {
            var t = new ke();
            return function (e) {
              return (
                void 0 === e &&
                  (console.warn(
                    "THREE.Box3: .getBoundingSphere() target is now required"
                  ),
                  (e = new Ze())),
                this.getCenter(e.center),
                (e.radius = 0.5 * this.getSize(t).length()),
                e
              );
            };
          })(),
          intersect: function (t) {
            return (
              this.min.max(t.min),
              this.max.min(t.max),
              this.isEmpty() && this.makeEmpty(),
              this
            );
          },
          union: function (t) {
            return this.min.min(t.min), this.max.max(t.max), this;
          },
          applyMatrix4: function (t) {
            if (this.isEmpty()) return this;
            var e = t.elements,
              n = e[0] * this.min.x,
              i = e[1] * this.min.x,
              r = e[2] * this.min.x,
              a = e[0] * this.max.x,
              o = e[1] * this.max.x,
              s = e[2] * this.max.x,
              c = e[4] * this.min.y,
              l = e[5] * this.min.y,
              h = e[6] * this.min.y,
              u = e[4] * this.max.y,
              d = e[5] * this.max.y,
              p = e[6] * this.max.y,
              f = e[8] * this.min.z,
              m = e[9] * this.min.z,
              g = e[10] * this.min.z,
              v = e[8] * this.max.z,
              y = e[9] * this.max.z,
              x = e[10] * this.max.z;
            return (
              (this.min.x =
                Math.min(n, a) + Math.min(c, u) + Math.min(f, v) + e[12]),
              (this.min.y =
                Math.min(i, o) + Math.min(l, d) + Math.min(m, y) + e[13]),
              (this.min.z =
                Math.min(r, s) + Math.min(h, p) + Math.min(g, x) + e[14]),
              (this.max.x =
                Math.max(n, a) + Math.max(c, u) + Math.max(f, v) + e[12]),
              (this.max.y =
                Math.max(i, o) + Math.max(l, d) + Math.max(m, y) + e[13]),
              (this.max.z =
                Math.max(r, s) + Math.max(h, p) + Math.max(g, x) + e[14]),
              this
            );
          },
          translate: function (t) {
            return this.min.add(t), this.max.add(t), this;
          },
          equals: function (t) {
            return t.min.equals(this.min) && t.max.equals(this.max);
          },
        }),
        Object.assign(Ze.prototype, {
          set: function (t, e) {
            return this.center.copy(t), (this.radius = e), this;
          },
          setFromPoints: (function () {
            var t = new Je();
            return function (e, n) {
              var i = this.center;
              void 0 !== n ? i.copy(n) : t.setFromPoints(e).getCenter(i);
              for (var r = 0, a = 0, o = e.length; a < o; a++)
                r = Math.max(r, i.distanceToSquared(e[a]));
              return (this.radius = Math.sqrt(r)), this;
            };
          })(),
          clone: function () {
            return new this.constructor().copy(this);
          },
          copy: function (t) {
            return this.center.copy(t.center), (this.radius = t.radius), this;
          },
          empty: function () {
            return this.radius <= 0;
          },
          containsPoint: function (t) {
            return (
              t.distanceToSquared(this.center) <= this.radius * this.radius
            );
          },
          distanceToPoint: function (t) {
            return t.distanceTo(this.center) - this.radius;
          },
          intersectsSphere: function (t) {
            var e = this.radius + t.radius;
            return t.center.distanceToSquared(this.center) <= e * e;
          },
          intersectsBox: function (t) {
            return t.intersectsSphere(this);
          },
          intersectsPlane: function (t) {
            return Math.abs(t.distanceToPoint(this.center)) <= this.radius;
          },
          clampPoint: function (t, e) {
            var n = this.center.distanceToSquared(t);
            return (
              void 0 === e &&
                (console.warn(
                  "THREE.Sphere: .clampPoint() target is now required"
                ),
                (e = new ke())),
              e.copy(t),
              n > this.radius * this.radius &&
                (e.sub(this.center).normalize(),
                e.multiplyScalar(this.radius).add(this.center)),
              e
            );
          },
          getBoundingBox: function (t) {
            return (
              void 0 === t &&
                (console.warn(
                  "THREE.Sphere: .getBoundingBox() target is now required"
                ),
                (t = new Je())),
              t.set(this.center, this.center),
              t.expandByScalar(this.radius),
              t
            );
          },
          applyMatrix4: function (t) {
            return (
              this.center.applyMatrix4(t),
              (this.radius = this.radius * t.getMaxScaleOnAxis()),
              this
            );
          },
          translate: function (t) {
            return this.center.add(t), this;
          },
          equals: function (t) {
            return t.center.equals(this.center) && t.radius === this.radius;
          },
        }),
        Object.assign(Ke.prototype, {
          set: function (t, e) {
            return this.normal.copy(t), (this.constant = e), this;
          },
          setComponents: function (t, e, n, i) {
            return this.normal.set(t, e, n), (this.constant = i), this;
          },
          setFromNormalAndCoplanarPoint: function (t, e) {
            return (
              this.normal.copy(t), (this.constant = -e.dot(this.normal)), this
            );
          },
          setFromCoplanarPoints: (function () {
            var t = new ke(),
              e = new ke();
            return function (n, i, r) {
              var a = t.subVectors(r, i).cross(e.subVectors(n, i)).normalize();
              return this.setFromNormalAndCoplanarPoint(a, n), this;
            };
          })(),
          clone: function () {
            return new this.constructor().copy(this);
          },
          copy: function (t) {
            return (
              this.normal.copy(t.normal), (this.constant = t.constant), this
            );
          },
          normalize: function () {
            var t = 1 / this.normal.length();
            return this.normal.multiplyScalar(t), (this.constant *= t), this;
          },
          negate: function () {
            return (this.constant *= -1), this.normal.negate(), this;
          },
          distanceToPoint: function (t) {
            return this.normal.dot(t) + this.constant;
          },
          distanceToSphere: function (t) {
            return this.distanceToPoint(t.center) - t.radius;
          },
          projectPoint: function (t, e) {
            return (
              void 0 === e &&
                (console.warn(
                  "THREE.Plane: .projectPoint() target is now required"
                ),
                (e = new ke())),
              e
                .copy(this.normal)
                .multiplyScalar(-this.distanceToPoint(t))
                .add(t)
            );
          },
          intersectLine: (function () {
            var t = new ke();
            return function (e, n) {
              void 0 === n &&
                (console.warn(
                  "THREE.Plane: .intersectLine() target is now required"
                ),
                (n = new ke()));
              var i = e.delta(t),
                r = this.normal.dot(i);
              if (0 === r)
                return 0 === this.distanceToPoint(e.start)
                  ? n.copy(e.start)
                  : void 0;
              var a = -(e.start.dot(this.normal) + this.constant) / r;
              return a < 0 || a > 1
                ? void 0
                : n.copy(i).multiplyScalar(a).add(e.start);
            };
          })(),
          intersectsLine: function (t) {
            var e = this.distanceToPoint(t.start),
              n = this.distanceToPoint(t.end);
            return (e < 0 && n > 0) || (n < 0 && e > 0);
          },
          intersectsBox: function (t) {
            return t.intersectsPlane(this);
          },
          intersectsSphere: function (t) {
            return t.intersectsPlane(this);
          },
          coplanarPoint: function (t) {
            return (
              void 0 === t &&
                (console.warn(
                  "THREE.Plane: .coplanarPoint() target is now required"
                ),
                (t = new ke())),
              t.copy(this.normal).multiplyScalar(-this.constant)
            );
          },
          applyMatrix4: (function () {
            var t = new ke(),
              e = new Ge();
            return function (n, i) {
              var r = i || e.getNormalMatrix(n),
                a = this.coplanarPoint(t).applyMatrix4(n),
                o = this.normal.applyMatrix3(r).normalize();
              return (this.constant = -a.dot(o)), this;
            };
          })(),
          translate: function (t) {
            return (this.constant -= t.dot(this.normal)), this;
          },
          equals: function (t) {
            return t.normal.equals(this.normal) && t.constant === this.constant;
          },
        }),
        Object.assign($e.prototype, {
          set: function (t, e, n, i, r, a) {
            var o = this.planes;
            return (
              o[0].copy(t),
              o[1].copy(e),
              o[2].copy(n),
              o[3].copy(i),
              o[4].copy(r),
              o[5].copy(a),
              this
            );
          },
          clone: function () {
            return new this.constructor().copy(this);
          },
          copy: function (t) {
            for (var e = this.planes, n = 0; n < 6; n++) e[n].copy(t.planes[n]);
            return this;
          },
          setFromMatrix: function (t) {
            var e = this.planes,
              n = t.elements,
              i = n[0],
              r = n[1],
              a = n[2],
              o = n[3],
              s = n[4],
              c = n[5],
              l = n[6],
              h = n[7],
              u = n[8],
              d = n[9],
              p = n[10],
              f = n[11],
              m = n[12],
              g = n[13],
              v = n[14],
              y = n[15];
            return (
              e[0].setComponents(o - i, h - s, f - u, y - m).normalize(),
              e[1].setComponents(o + i, h + s, f + u, y + m).normalize(),
              e[2].setComponents(o + r, h + c, f + d, y + g).normalize(),
              e[3].setComponents(o - r, h - c, f - d, y - g).normalize(),
              e[4].setComponents(o - a, h - l, f - p, y - v).normalize(),
              e[5].setComponents(o + a, h + l, f + p, y + v).normalize(),
              this
            );
          },
          intersectsObject: (function () {
            var t = new Ze();
            return function (e) {
              var n = e.geometry;
              return (
                null === n.boundingSphere && n.computeBoundingSphere(),
                t.copy(n.boundingSphere).applyMatrix4(e.matrixWorld),
                this.intersectsSphere(t)
              );
            };
          })(),
          intersectsSprite: (function () {
            var t = new Ze();
            return function (e) {
              return (
                t.center.set(0, 0, 0),
                (t.radius = 0.7071067811865476),
                t.applyMatrix4(e.matrixWorld),
                this.intersectsSphere(t)
              );
            };
          })(),
          intersectsSphere: function (t) {
            for (
              var e = this.planes, n = t.center, i = -t.radius, r = 0;
              r < 6;
              r++
            ) {
              var a = e[r].distanceToPoint(n);
              if (a < i) return !1;
            }
            return !0;
          },
          intersectsBox: (function () {
            var t = new ke(),
              e = new ke();
            return function (n) {
              for (var i = this.planes, r = 0; r < 6; r++) {
                var a = i[r];
                (t.x = a.normal.x > 0 ? n.min.x : n.max.x),
                  (e.x = a.normal.x > 0 ? n.max.x : n.min.x),
                  (t.y = a.normal.y > 0 ? n.min.y : n.max.y),
                  (e.y = a.normal.y > 0 ? n.max.y : n.min.y),
                  (t.z = a.normal.z > 0 ? n.min.z : n.max.z),
                  (e.z = a.normal.z > 0 ? n.max.z : n.min.z);
                var o = a.distanceToPoint(t),
                  s = a.distanceToPoint(e);
                if (o < 0 && s < 0) return !1;
              }
              return !0;
            };
          })(),
          containsPoint: function (t) {
            for (var e = this.planes, n = 0; n < 6; n++)
              if (e[n].distanceToPoint(t) < 0) return !1;
            return !0;
          },
        });
      var Qe =
          "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif\n",
        tn = "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif\n",
        en =
          "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif\n",
        nn =
          "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif\n",
        rn =
          "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
        an = "\nvec3 transformed = vec3( position );\n",
        on = "\nvec3 objectNormal = vec3( normal );\n",
        sn =
          "float punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\tif( decayExponent > 0.0 ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tfloat maxDistanceCutoffFactor = pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\treturn distanceFalloff * maxDistanceCutoffFactor;\n#else\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n#endif\n\t}\n\treturn 1.0;\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n\treturn specularColor * AB.x + AB.y;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n",
        cn =
          "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tfDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif\n",
        ln =
          "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\tif ( clipped ) discard;\n\t#endif\n#endif\n",
        hn =
          "#if NUM_CLIPPING_PLANES > 0\n\t#if ! defined( PHYSICAL ) && ! defined( PHONG )\n\t\tvarying vec3 vViewPosition;\n\t#endif\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif\n",
        un =
          "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\tvarying vec3 vViewPosition;\n#endif\n",
        dn =
          "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n",
        pn = "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif",
        fn = "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif\n",
        mn = "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif",
        gn = "#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif",
        vn =
          "#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\n",
        yn =
          "#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_textureSize (1024.0)\nint getFaceFromDirection(vec3 direction) {\n\tvec3 absDirection = abs(direction);\n\tint face = -1;\n\tif( absDirection.x > absDirection.z ) {\n\t\tif(absDirection.x > absDirection.y )\n\t\t\tface = direction.x > 0.0 ? 0 : 3;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\telse {\n\t\tif(absDirection.z > absDirection.y )\n\t\t\tface = direction.z > 0.0 ? 2 : 5;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\treturn face;\n}\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n\tfloat dxRoughness = dFdx(roughness);\n\tfloat dyRoughness = dFdy(roughness);\n\tvec3 dx = dFdx( vec * scale * dxRoughness );\n\tvec3 dy = dFdy( vec * scale * dyRoughness );\n\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\n\td = clamp(d, 1.0, cubeUV_rangeClamp);\n\tfloat mipLevel = 0.5 * log2(d);\n\treturn vec2(floor(mipLevel), fract(mipLevel));\n}\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n\tfloat a = 16.0 * cubeUV_rcpTextureSize;\n\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n\tfloat powScale = exp2_packed.x * exp2_packed.y;\n\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n\tbool bRes = mipLevel == 0.0;\n\tscale =  bRes && (scale < a) ? a : scale;\n\tvec3 r;\n\tvec2 offset;\n\tint face = getFaceFromDirection(direction);\n\tfloat rcpPowScale = 1.0 / powScale;\n\tif( face == 0) {\n\t\tr = vec3(direction.x, -direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 1) {\n\t\tr = vec3(direction.y, direction.x, direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 2) {\n\t\tr = vec3(direction.z, direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 3) {\n\t\tr = vec3(direction.x, direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse if( face == 4) {\n\t\tr = vec3(direction.y, direction.x, -direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse {\n\t\tr = vec3(direction.z, -direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\tr = normalize(r);\n\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\n\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n\tvec2 base = offset + vec2( texelOffset );\n\treturn base + s * ( scale - 2.0 * texelOffset );\n}\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\nvec4 textureCubeUV(vec3 reflectedDirection, float roughness ) {\n\tfloat roughnessVal = roughness* cubeUV_maxLods3;\n\tfloat r1 = floor(roughnessVal);\n\tfloat r2 = r1 + 1.0;\n\tfloat t = fract(roughnessVal);\n\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n\tfloat s = mipInfo.y;\n\tfloat level0 = mipInfo.x;\n\tfloat level1 = level0 + 1.0;\n\tlevel1 = level1 > 5.0 ? 5.0 : level1;\n\tlevel0 += min( floor( s + 0.5 ), 5.0 );\n\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n\tvec4 result = mix(color10, color20, t);\n\treturn vec4(result.rgb, 1.0);\n}\n#endif\n",
        xn =
          "vec3 transformedNormal = normalMatrix * objectNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n",
        _n =
          "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif\n",
        bn =
          "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n#endif\n",
        wn =
          "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif\n",
        Mn =
          "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif\n",
        Sn = "  gl_FragColor = linearToOutputTexel( gl_FragColor );\n",
        En =
          "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.xyz * value.w * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.x, max( value.g, value.b ) );\n\tfloat M      = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM            = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.x, max( value.g, value.b ) );\n\tfloat D      = max( maxRange / maxRGB, 1.0 );\n\tD            = min( floor( D ) / 255.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n\tvec3 Xp_Y_XYZp = value.rgb * cLogLuvM;\n\tXp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract(Le);\n\tvResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;\n\treturn vec4( max(vRGB, 0.0), 1.0 );\n}\n",
        Tn =
          "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\tvec2 sampleUV;\n\t\treflectVec = normalize( reflectVec );\n\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\treflectVec = normalize( reflectVec );\n\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\tenvColor = envMapTexelToLinear( envColor );\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif\n",
        An =
          "#if defined( USE_ENVMAP ) || defined( PHYSICAL )\n\tuniform float reflectivity;\n\tuniform float envMapIntensity;\n#endif\n#ifdef USE_ENVMAP\n\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\n\t\tvarying vec3 vWorldPosition;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif\n",
        Cn =
          "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif\n",
        Rn =
          "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif\n",
        Ln = "\n#ifdef USE_FOG\nfogDepth = -mvPosition.z;\n#endif",
        Pn = "#ifdef USE_FOG\n  varying float fogDepth;\n#endif\n",
        Dn =
          "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif\n",
        In =
          "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif\n",
        On =
          "#ifdef TOON\n\tuniform sampler2D gradientMap;\n\tvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\t\tfloat dotNL = dot( normal, lightDirection );\n\t\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t\t#ifdef USE_GRADIENTMAP\n\t\t\treturn texture2D( gradientMap, coord ).rgb;\n\t\t#else\n\t\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t\t#endif\n\t}\n#endif\n",
        Nn =
          "#ifdef USE_LIGHTMAP\n\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n#endif\n",
        Bn =
          "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
        zn =
          "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n#endif\n",
        Un =
          "uniform vec3 ambientLightColor;\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t\tfloat shadowCameraNear;\n\t\tfloat shadowCameraFar;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif\n",
        Fn =
          "#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( queryVec, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\tvec4 envMapColor = textureCubeUV(queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent));\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif\n",
        Hn =
          "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;\n",
        kn =
          "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifdef TOON\n\t\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#else\n\t\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\t\tvec3 irradiance = dotNL * directLight.color;\n\t#endif\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)\n",
        Gn =
          "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef STANDARD\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.clearCoat = saturate( clearCoat );\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\n#endif\n",
        Vn =
          "struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n\t#ifndef STANDARD\n\t\tfloat clearCoat;\n\t\tfloat clearCoatRoughness;\n\t#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos - halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos + halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos + halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos - halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifndef STANDARD\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n\treflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\t#ifndef STANDARD\n\t\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifndef STANDARD\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\tfloat dotNL = dotNV;\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.indirectSpecular += ( 1.0 - clearCoatDHR ) * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n\t#ifndef STANDARD\n\t\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}\n",
        Wn =
          "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearCoatRadiance = vec3( 0.0 );\n#endif\n",
        jn =
          "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tirradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), maxMipLevel );\n\t#ifndef STANDARD\n\t\tclearCoatRadiance += getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), maxMipLevel );\n\t#endif\n#endif\n",
        qn =
          "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, clearCoatRadiance, geometry, material, reflectedLight );\n#endif\n",
        Xn =
          "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
        Yn =
          "#ifdef USE_LOGDEPTHBUF\n\tuniform float logDepthBufFC;\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#endif\n#endif\n",
        Jn =
          "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#endif\n\tuniform float logDepthBufFC;\n#endif",
        Zn =
          "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t#else\n\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\tgl_Position.z *= gl_Position.w;\n\t#endif\n#endif\n",
        Kn =
          "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif\n",
        $n = "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n",
        Qn =
          "#ifdef USE_MAP\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n",
        ti =
          "#ifdef USE_MAP\n\tuniform mat3 uvTransform;\n\tuniform sampler2D map;\n#endif\n",
        ei =
          "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif\n",
        ni =
          "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
        ii =
          "#ifdef USE_MORPHNORMALS\n\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n#endif\n",
        ri =
          "#ifdef USE_MORPHTARGETS\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif",
        ai =
          "#ifdef USE_MORPHTARGETS\n\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\t#endif\n#endif\n",
        oi =
          "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n#endif\n",
        si =
          "#ifdef USE_NORMALMAP\n\t#ifdef OBJECTSPACE_NORMALMAP\n\t\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\t#ifdef FLIP_SIDED\n\t\t\tnormal = - normal;\n\t\t#endif\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t\tnormal = normalize( normalMatrix * normal );\n\t#else\n\t\tnormal = perturbNormal2Arb( -vViewPosition, normal );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif\n",
        ci =
          "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n\t#ifdef OBJECTSPACE_NORMALMAP\n\t\tuniform mat3 normalMatrix;\n\t#else\n\t\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\t\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\t\tvec2 st0 = dFdx( vUv.st );\n\t\t\tvec2 st1 = dFdy( vUv.st );\n\t\t\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s );\n\t\t\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n\t\t\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n\t\t\tvec3 N = normalize( surf_norm );\n\t\t\tmat3 tsn = mat3( S, T, N );\n\t\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\t\tmapN.xy *= normalScale;\n\t\t\tmapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t\treturn normalize( tsn * mapN );\n\t\t}\n\t#endif\n#endif\n",
        li =
          "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}\n",
        hi =
          "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif\n",
        ui =
          "vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\ngl_Position = projectionMatrix * mvPosition;\n",
        di =
          "#if defined( DITHERING )\n  gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif\n",
        pi =
          "#if defined( DITHERING )\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif\n",
        fi =
          "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif\n",
        mi =
          "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
        gi =
          "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\n\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n\t\tvec2 f = fract( uv * size + 0.5 );\n\t\tfloat a = mix( lb, lt, f.y );\n\t\tfloat b = mix( rb, rt, f.y );\n\t\tfloat c = mix( a, b, f.x );\n\t\treturn c;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif\n",
        vi =
          "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n#endif\n",
        yi =
          "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n#endif\n",
        xi =
          "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#endif\n\t#endif\n\treturn shadow;\n}\n",
        _i =
          "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
        bi =
          "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif\n",
        wi =
          "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif\n",
        Mi =
          "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n#endif\n",
        Si =
          "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
        Ei = "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
        Ti =
          "#if defined( TONE_MAPPING )\n  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif\n",
        Ai =
          "#ifndef saturate\n\t#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\n",
        Ci =
          "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n#endif",
        Ri =
          "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n#endif\n",
        Li =
          "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",
        Pi =
          "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",
        Di =
          "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n#endif",
        Ii =
          "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = uv2;\n#endif",
        Oi =
          "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n#endif\n",
        Ni =
          "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldPosition;\nvoid main() {\n\tgl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\n\tgl_FragColor.a *= opacity;\n}\n",
        Bi =
          "varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}\n",
        zi =
          "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - gl_FragCoord.z ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n\t#endif\n}\n",
        Ui =
          "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}\n",
        Fi =
          "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}\n",
        Hi =
          "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}\n",
        ki =
          "uniform sampler2D tEquirect;\nvarying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldPosition );\n\tvec2 sampleUV;\n\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n}\n",
        Gi =
          "varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}\n",
        Vi =
          "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n",
        Wi =
          "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\tvLineDistance = scale * lineDistance;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}\n",
        ji =
          "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\treflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n",
        qi =
          "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}\n",
        Xi =
          "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n",
        Yi =
          "#define LAMBERT\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n",
        Ji =
          "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n",
        Zi =
          "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n",
        Ki =
          "#define PHYSICAL\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifndef STANDARD\n\tuniform float clearCoat;\n\tuniform float clearCoatRoughness;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <lights_pars_begin>\n#include <lights_pars_maps>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n",
        $i =
          "#define PHYSICAL\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n",
        Qi =
          "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}\n",
        tr =
          "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}\n",
        er =
          "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n",
        nr =
          "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#ifdef USE_SIZEATTENUATION\n\t\tgl_PointSize = size * ( scale / - mvPosition.z );\n\t#else\n\t\tgl_PointSize = size;\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}\n",
        ir =
          "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <fog_fragment>\n}\n",
        rr =
          "#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n",
        ar = {
          alphamap_fragment: Qe,
          alphamap_pars_fragment: tn,
          alphatest_fragment: en,
          aomap_fragment: nn,
          aomap_pars_fragment: rn,
          begin_vertex: an,
          beginnormal_vertex: on,
          bsdfs: sn,
          bumpmap_pars_fragment: cn,
          clipping_planes_fragment: ln,
          clipping_planes_pars_fragment: hn,
          clipping_planes_pars_vertex: un,
          clipping_planes_vertex: dn,
          color_fragment: pn,
          color_pars_fragment: fn,
          color_pars_vertex: mn,
          color_vertex: gn,
          common: vn,
          cube_uv_reflection_fragment: yn,
          defaultnormal_vertex: xn,
          displacementmap_pars_vertex: _n,
          displacementmap_vertex: bn,
          emissivemap_fragment: wn,
          emissivemap_pars_fragment: Mn,
          encodings_fragment: Sn,
          encodings_pars_fragment: En,
          envmap_fragment: Tn,
          envmap_pars_fragment: An,
          envmap_pars_vertex: Cn,
          envmap_vertex: Rn,
          fog_vertex: Ln,
          fog_pars_vertex: Pn,
          fog_fragment: Dn,
          fog_pars_fragment: In,
          gradientmap_pars_fragment: On,
          lightmap_fragment: Nn,
          lightmap_pars_fragment: Bn,
          lights_lambert_vertex: zn,
          lights_pars_begin: Un,
          lights_pars_maps: Fn,
          lights_phong_fragment: Hn,
          lights_phong_pars_fragment: kn,
          lights_physical_fragment: Gn,
          lights_physical_pars_fragment: Vn,
          lights_fragment_begin: Wn,
          lights_fragment_maps: jn,
          lights_fragment_end: qn,
          logdepthbuf_fragment: Xn,
          logdepthbuf_pars_fragment: Yn,
          logdepthbuf_pars_vertex: Jn,
          logdepthbuf_vertex: Zn,
          map_fragment: Kn,
          map_pars_fragment: $n,
          map_particle_fragment: Qn,
          map_particle_pars_fragment: ti,
          metalnessmap_fragment: ei,
          metalnessmap_pars_fragment: ni,
          morphnormal_vertex: ii,
          morphtarget_pars_vertex: ri,
          morphtarget_vertex: ai,
          normal_fragment_begin: oi,
          normal_fragment_maps: si,
          normalmap_pars_fragment: ci,
          packing: li,
          premultiplied_alpha_fragment: hi,
          project_vertex: ui,
          dithering_fragment: di,
          dithering_pars_fragment: pi,
          roughnessmap_fragment: fi,
          roughnessmap_pars_fragment: mi,
          shadowmap_pars_fragment: gi,
          shadowmap_pars_vertex: vi,
          shadowmap_vertex: yi,
          shadowmask_pars_fragment: xi,
          skinbase_vertex: _i,
          skinning_pars_vertex: bi,
          skinning_vertex: wi,
          skinnormal_vertex: Mi,
          specularmap_fragment: Si,
          specularmap_pars_fragment: Ei,
          tonemapping_fragment: Ti,
          tonemapping_pars_fragment: Ai,
          uv_pars_fragment: Ci,
          uv_pars_vertex: Ri,
          uv_vertex: Li,
          uv2_pars_fragment: Pi,
          uv2_pars_vertex: Di,
          uv2_vertex: Ii,
          worldpos_vertex: Oi,
          cube_frag: Ni,
          cube_vert: Bi,
          depth_frag: zi,
          depth_vert: Ui,
          distanceRGBA_frag: Fi,
          distanceRGBA_vert: Hi,
          equirect_frag: ki,
          equirect_vert: Gi,
          linedashed_frag: Vi,
          linedashed_vert: Wi,
          meshbasic_frag: ji,
          meshbasic_vert: qi,
          meshlambert_frag: Xi,
          meshlambert_vert: Yi,
          meshphong_frag: Ji,
          meshphong_vert: Zi,
          meshphysical_frag: Ki,
          meshphysical_vert: $i,
          normal_frag: Qi,
          normal_vert: tr,
          points_frag: er,
          points_vert: nr,
          shadow_frag: ir,
          shadow_vert: rr,
        },
        or = {
          merge: function (t) {
            for (var e = {}, n = 0; n < t.length; n++) {
              var i = this.clone(t[n]);
              for (var r in i) e[r] = i[r];
            }
            return e;
          },
          clone: function (t) {
            var e = {};
            for (var n in t)
              for (var i in ((e[n] = {}), t[n])) {
                var r = t[n][i];
                r &&
                (r.isColor ||
                  r.isMatrix3 ||
                  r.isMatrix4 ||
                  r.isVector2 ||
                  r.isVector3 ||
                  r.isVector4 ||
                  r.isTexture)
                  ? (e[n][i] = r.clone())
                  : Array.isArray(r)
                  ? (e[n][i] = r.slice())
                  : (e[n][i] = r);
              }
            return e;
          },
        },
        sr = {
          aliceblue: 15792383,
          antiquewhite: 16444375,
          aqua: 65535,
          aquamarine: 8388564,
          azure: 15794175,
          beige: 16119260,
          bisque: 16770244,
          black: 0,
          blanchedalmond: 16772045,
          blue: 255,
          blueviolet: 9055202,
          brown: 10824234,
          burlywood: 14596231,
          cadetblue: 6266528,
          chartreuse: 8388352,
          chocolate: 13789470,
          coral: 16744272,
          cornflowerblue: 6591981,
          cornsilk: 16775388,
          crimson: 14423100,
          cyan: 65535,
          darkblue: 139,
          darkcyan: 35723,
          darkgoldenrod: 12092939,
          darkgray: 11119017,
          darkgreen: 25600,
          darkgrey: 11119017,
          darkkhaki: 12433259,
          darkmagenta: 9109643,
          darkolivegreen: 5597999,
          darkorange: 16747520,
          darkorchid: 10040012,
          darkred: 9109504,
          darksalmon: 15308410,
          darkseagreen: 9419919,
          darkslateblue: 4734347,
          darkslategray: 3100495,
          darkslategrey: 3100495,
          darkturquoise: 52945,
          darkviolet: 9699539,
          deeppink: 16716947,
          deepskyblue: 49151,
          dimgray: 6908265,
          dimgrey: 6908265,
          dodgerblue: 2003199,
          firebrick: 11674146,
          floralwhite: 16775920,
          forestgreen: 2263842,
          fuchsia: 16711935,
          gainsboro: 14474460,
          ghostwhite: 16316671,
          gold: 16766720,
          goldenrod: 14329120,
          gray: 8421504,
          green: 32768,
          greenyellow: 11403055,
          grey: 8421504,
          honeydew: 15794160,
          hotpink: 16738740,
          indianred: 13458524,
          indigo: 4915330,
          ivory: 16777200,
          khaki: 15787660,
          lavender: 15132410,
          lavenderblush: 16773365,
          lawngreen: 8190976,
          lemonchiffon: 16775885,
          lightblue: 11393254,
          lightcoral: 15761536,
          lightcyan: 14745599,
          lightgoldenrodyellow: 16448210,
          lightgray: 13882323,
          lightgreen: 9498256,
          lightgrey: 13882323,
          lightpink: 16758465,
          lightsalmon: 16752762,
          lightseagreen: 2142890,
          lightskyblue: 8900346,
          lightslategray: 7833753,
          lightslategrey: 7833753,
          lightsteelblue: 11584734,
          lightyellow: 16777184,
          lime: 65280,
          limegreen: 3329330,
          linen: 16445670,
          magenta: 16711935,
          maroon: 8388608,
          mediumaquamarine: 6737322,
          mediumblue: 205,
          mediumorchid: 12211667,
          mediumpurple: 9662683,
          mediumseagreen: 3978097,
          mediumslateblue: 8087790,
          mediumspringgreen: 64154,
          mediumturquoise: 4772300,
          mediumvioletred: 13047173,
          midnightblue: 1644912,
          mintcream: 16121850,
          mistyrose: 16770273,
          moccasin: 16770229,
          navajowhite: 16768685,
          navy: 128,
          oldlace: 16643558,
          olive: 8421376,
          olivedrab: 7048739,
          orange: 16753920,
          orangered: 16729344,
          orchid: 14315734,
          palegoldenrod: 15657130,
          palegreen: 10025880,
          paleturquoise: 11529966,
          palevioletred: 14381203,
          papayawhip: 16773077,
          peachpuff: 16767673,
          peru: 13468991,
          pink: 16761035,
          plum: 14524637,
          powderblue: 11591910,
          purple: 8388736,
          rebeccapurple: 6697881,
          red: 16711680,
          rosybrown: 12357519,
          royalblue: 4286945,
          saddlebrown: 9127187,
          salmon: 16416882,
          sandybrown: 16032864,
          seagreen: 3050327,
          seashell: 16774638,
          sienna: 10506797,
          silver: 12632256,
          skyblue: 8900331,
          slateblue: 6970061,
          slategray: 7372944,
          slategrey: 7372944,
          snow: 16775930,
          springgreen: 65407,
          steelblue: 4620980,
          tan: 13808780,
          teal: 32896,
          thistle: 14204888,
          tomato: 16737095,
          turquoise: 4251856,
          violet: 15631086,
          wheat: 16113331,
          white: 16777215,
          whitesmoke: 16119285,
          yellow: 16776960,
          yellowgreen: 10145074,
        };
      function cr(t, e, n) {
        return void 0 === e && void 0 === n
          ? this.set(t)
          : this.setRGB(t, e, n);
      }
      Object.assign(cr.prototype, {
        isColor: !0,
        r: 1,
        g: 1,
        b: 1,
        set: function (t) {
          return (
            t && t.isColor
              ? this.copy(t)
              : "number" === typeof t
              ? this.setHex(t)
              : "string" === typeof t && this.setStyle(t),
            this
          );
        },
        setScalar: function (t) {
          return (this.r = t), (this.g = t), (this.b = t), this;
        },
        setHex: function (t) {
          return (
            (t = Math.floor(t)),
            (this.r = ((t >> 16) & 255) / 255),
            (this.g = ((t >> 8) & 255) / 255),
            (this.b = (255 & t) / 255),
            this
          );
        },
        setRGB: function (t, e, n) {
          return (this.r = t), (this.g = e), (this.b = n), this;
        },
        setHSL: (function () {
          function t(t, e, n) {
            return (
              n < 0 && (n += 1),
              n > 1 && (n -= 1),
              n < 1 / 6
                ? t + 6 * (e - t) * n
                : n < 0.5
                ? e
                : n < 2 / 3
                ? t + 6 * (e - t) * (2 / 3 - n)
                : t
            );
          }
          return function (e, n, i) {
            if (
              ((e = ze.euclideanModulo(e, 1)),
              (n = ze.clamp(n, 0, 1)),
              (i = ze.clamp(i, 0, 1)),
              0 === n)
            )
              this.r = this.g = this.b = i;
            else {
              var r = i <= 0.5 ? i * (1 + n) : i + n - i * n,
                a = 2 * i - r;
              (this.r = t(a, r, e + 1 / 3)),
                (this.g = t(a, r, e)),
                (this.b = t(a, r, e - 1 / 3));
            }
            return this;
          };
        })(),
        setStyle: function (t) {
          function e(e) {
            void 0 !== e &&
              parseFloat(e) < 1 &&
              console.warn(
                "THREE.Color: Alpha component of " + t + " will be ignored."
              );
          }
          var n;
          if ((n = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(t))) {
            var i,
              r = n[1],
              a = n[2];
            switch (r) {
              case "rgb":
              case "rgba":
                if (
                  (i =
                    /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(
                      a
                    ))
                )
                  return (
                    (this.r = Math.min(255, parseInt(i[1], 10)) / 255),
                    (this.g = Math.min(255, parseInt(i[2], 10)) / 255),
                    (this.b = Math.min(255, parseInt(i[3], 10)) / 255),
                    e(i[5]),
                    this
                  );
                if (
                  (i =
                    /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(
                      a
                    ))
                )
                  return (
                    (this.r = Math.min(100, parseInt(i[1], 10)) / 100),
                    (this.g = Math.min(100, parseInt(i[2], 10)) / 100),
                    (this.b = Math.min(100, parseInt(i[3], 10)) / 100),
                    e(i[5]),
                    this
                  );
                break;
              case "hsl":
              case "hsla":
                if (
                  (i =
                    /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(
                      a
                    ))
                ) {
                  var o = parseFloat(i[1]) / 360,
                    s = parseInt(i[2], 10) / 100,
                    c = parseInt(i[3], 10) / 100;
                  return e(i[5]), this.setHSL(o, s, c);
                }
                break;
            }
          } else if ((n = /^\#([A-Fa-f0-9]+)$/.exec(t))) {
            var l = n[1],
              h = l.length;
            if (3 === h)
              return (
                (this.r = parseInt(l.charAt(0) + l.charAt(0), 16) / 255),
                (this.g = parseInt(l.charAt(1) + l.charAt(1), 16) / 255),
                (this.b = parseInt(l.charAt(2) + l.charAt(2), 16) / 255),
                this
              );
            if (6 === h)
              return (
                (this.r = parseInt(l.charAt(0) + l.charAt(1), 16) / 255),
                (this.g = parseInt(l.charAt(2) + l.charAt(3), 16) / 255),
                (this.b = parseInt(l.charAt(4) + l.charAt(5), 16) / 255),
                this
              );
          }
          if (t && t.length > 0) {
            l = sr[t];
            void 0 !== l
              ? this.setHex(l)
              : console.warn("THREE.Color: Unknown color " + t);
          }
          return this;
        },
        clone: function () {
          return new this.constructor(this.r, this.g, this.b);
        },
        copy: function (t) {
          return (this.r = t.r), (this.g = t.g), (this.b = t.b), this;
        },
        copyGammaToLinear: function (t, e) {
          return (
            void 0 === e && (e = 2),
            (this.r = Math.pow(t.r, e)),
            (this.g = Math.pow(t.g, e)),
            (this.b = Math.pow(t.b, e)),
            this
          );
        },
        copyLinearToGamma: function (t, e) {
          void 0 === e && (e = 2);
          var n = e > 0 ? 1 / e : 1;
          return (
            (this.r = Math.pow(t.r, n)),
            (this.g = Math.pow(t.g, n)),
            (this.b = Math.pow(t.b, n)),
            this
          );
        },
        convertGammaToLinear: function (t) {
          return this.copyGammaToLinear(this, t), this;
        },
        convertLinearToGamma: function (t) {
          return this.copyLinearToGamma(this, t), this;
        },
        copySRGBToLinear: (function () {
          function t(t) {
            return t < 0.04045
              ? 0.0773993808 * t
              : Math.pow(0.9478672986 * t + 0.0521327014, 2.4);
          }
          return function (e) {
            return (
              (this.r = t(e.r)), (this.g = t(e.g)), (this.b = t(e.b)), this
            );
          };
        })(),
        copyLinearToSRGB: (function () {
          function t(t) {
            return t < 0.0031308
              ? 12.92 * t
              : 1.055 * Math.pow(t, 0.41666) - 0.055;
          }
          return function (e) {
            return (
              (this.r = t(e.r)), (this.g = t(e.g)), (this.b = t(e.b)), this
            );
          };
        })(),
        convertSRGBToLinear: function () {
          return this.copySRGBToLinear(this), this;
        },
        convertLinearToSRGB: function () {
          return this.copyLinearToSRGB(this), this;
        },
        getHex: function () {
          return (
            ((255 * this.r) << 16) ^
            ((255 * this.g) << 8) ^
            ((255 * this.b) << 0)
          );
        },
        getHexString: function () {
          return ("000000" + this.getHex().toString(16)).slice(-6);
        },
        getHSL: function (t) {
          void 0 === t &&
            (console.warn("THREE.Color: .getHSL() target is now required"),
            (t = { h: 0, s: 0, l: 0 }));
          var e,
            n,
            i = this.r,
            r = this.g,
            a = this.b,
            o = Math.max(i, r, a),
            s = Math.min(i, r, a),
            c = (s + o) / 2;
          if (s === o) (e = 0), (n = 0);
          else {
            var l = o - s;
            switch (((n = c <= 0.5 ? l / (o + s) : l / (2 - o - s)), o)) {
              case i:
                e = (r - a) / l + (r < a ? 6 : 0);
                break;
              case r:
                e = (a - i) / l + 2;
                break;
              case a:
                e = (i - r) / l + 4;
                break;
            }
            e /= 6;
          }
          return (t.h = e), (t.s = n), (t.l = c), t;
        },
        getStyle: function () {
          return (
            "rgb(" +
            ((255 * this.r) | 0) +
            "," +
            ((255 * this.g) | 0) +
            "," +
            ((255 * this.b) | 0) +
            ")"
          );
        },
        offsetHSL: (function () {
          var t = {};
          return function (e, n, i) {
            return (
              this.getHSL(t),
              (t.h += e),
              (t.s += n),
              (t.l += i),
              this.setHSL(t.h, t.s, t.l),
              this
            );
          };
        })(),
        add: function (t) {
          return (this.r += t.r), (this.g += t.g), (this.b += t.b), this;
        },
        addColors: function (t, e) {
          return (
            (this.r = t.r + e.r),
            (this.g = t.g + e.g),
            (this.b = t.b + e.b),
            this
          );
        },
        addScalar: function (t) {
          return (this.r += t), (this.g += t), (this.b += t), this;
        },
        sub: function (t) {
          return (
            (this.r = Math.max(0, this.r - t.r)),
            (this.g = Math.max(0, this.g - t.g)),
            (this.b = Math.max(0, this.b - t.b)),
            this
          );
        },
        multiply: function (t) {
          return (this.r *= t.r), (this.g *= t.g), (this.b *= t.b), this;
        },
        multiplyScalar: function (t) {
          return (this.r *= t), (this.g *= t), (this.b *= t), this;
        },
        lerp: function (t, e) {
          return (
            (this.r += (t.r - this.r) * e),
            (this.g += (t.g - this.g) * e),
            (this.b += (t.b - this.b) * e),
            this
          );
        },
        equals: function (t) {
          return t.r === this.r && t.g === this.g && t.b === this.b;
        },
        fromArray: function (t, e) {
          return (
            void 0 === e && (e = 0),
            (this.r = t[e]),
            (this.g = t[e + 1]),
            (this.b = t[e + 2]),
            this
          );
        },
        toArray: function (t, e) {
          return (
            void 0 === t && (t = []),
            void 0 === e && (e = 0),
            (t[e] = this.r),
            (t[e + 1] = this.g),
            (t[e + 2] = this.b),
            t
          );
        },
        toJSON: function () {
          return this.getHex();
        },
      });
      var lr = {
          common: {
            diffuse: { value: new cr(15658734) },
            opacity: { value: 1 },
            map: { value: null },
            uvTransform: { value: new Ge() },
            alphaMap: { value: null },
          },
          specularmap: { specularMap: { value: null } },
          envmap: {
            envMap: { value: null },
            flipEnvMap: { value: -1 },
            reflectivity: { value: 1 },
            refractionRatio: { value: 0.98 },
            maxMipLevel: { value: 0 },
          },
          aomap: { aoMap: { value: null }, aoMapIntensity: { value: 1 } },
          lightmap: {
            lightMap: { value: null },
            lightMapIntensity: { value: 1 },
          },
          emissivemap: { emissiveMap: { value: null } },
          bumpmap: { bumpMap: { value: null }, bumpScale: { value: 1 } },
          normalmap: {
            normalMap: { value: null },
            normalScale: { value: new Ue(1, 1) },
          },
          displacementmap: {
            displacementMap: { value: null },
            displacementScale: { value: 1 },
            displacementBias: { value: 0 },
          },
          roughnessmap: { roughnessMap: { value: null } },
          metalnessmap: { metalnessMap: { value: null } },
          gradientmap: { gradientMap: { value: null } },
          fog: {
            fogDensity: { value: 25e-5 },
            fogNear: { value: 1 },
            fogFar: { value: 2e3 },
            fogColor: { value: new cr(16777215) },
          },
          lights: {
            ambientLightColor: { value: [] },
            directionalLights: {
              value: [],
              properties: {
                direction: {},
                color: {},
                shadow: {},
                shadowBias: {},
                shadowRadius: {},
                shadowMapSize: {},
              },
            },
            directionalShadowMap: { value: [] },
            directionalShadowMatrix: { value: [] },
            spotLights: {
              value: [],
              properties: {
                color: {},
                position: {},
                direction: {},
                distance: {},
                coneCos: {},
                penumbraCos: {},
                decay: {},
                shadow: {},
                shadowBias: {},
                shadowRadius: {},
                shadowMapSize: {},
              },
            },
            spotShadowMap: { value: [] },
            spotShadowMatrix: { value: [] },
            pointLights: {
              value: [],
              properties: {
                color: {},
                position: {},
                decay: {},
                distance: {},
                shadow: {},
                shadowBias: {},
                shadowRadius: {},
                shadowMapSize: {},
                shadowCameraNear: {},
                shadowCameraFar: {},
              },
            },
            pointShadowMap: { value: [] },
            pointShadowMatrix: { value: [] },
            hemisphereLights: {
              value: [],
              properties: { direction: {}, skyColor: {}, groundColor: {} },
            },
            rectAreaLights: {
              value: [],
              properties: { color: {}, position: {}, width: {}, height: {} },
            },
          },
          points: {
            diffuse: { value: new cr(15658734) },
            opacity: { value: 1 },
            size: { value: 1 },
            scale: { value: 1 },
            map: { value: null },
            uvTransform: { value: new Ge() },
          },
        },
        hr = {
          basic: {
            uniforms: or.merge([
              lr.common,
              lr.specularmap,
              lr.envmap,
              lr.aomap,
              lr.lightmap,
              lr.fog,
            ]),
            vertexShader: ar.meshbasic_vert,
            fragmentShader: ar.meshbasic_frag,
          },
          lambert: {
            uniforms: or.merge([
              lr.common,
              lr.specularmap,
              lr.envmap,
              lr.aomap,
              lr.lightmap,
              lr.emissivemap,
              lr.fog,
              lr.lights,
              { emissive: { value: new cr(0) } },
            ]),
            vertexShader: ar.meshlambert_vert,
            fragmentShader: ar.meshlambert_frag,
          },
          phong: {
            uniforms: or.merge([
              lr.common,
              lr.specularmap,
              lr.envmap,
              lr.aomap,
              lr.lightmap,
              lr.emissivemap,
              lr.bumpmap,
              lr.normalmap,
              lr.displacementmap,
              lr.gradientmap,
              lr.fog,
              lr.lights,
              {
                emissive: { value: new cr(0) },
                specular: { value: new cr(1118481) },
                shininess: { value: 30 },
              },
            ]),
            vertexShader: ar.meshphong_vert,
            fragmentShader: ar.meshphong_frag,
          },
          standard: {
            uniforms: or.merge([
              lr.common,
              lr.envmap,
              lr.aomap,
              lr.lightmap,
              lr.emissivemap,
              lr.bumpmap,
              lr.normalmap,
              lr.displacementmap,
              lr.roughnessmap,
              lr.metalnessmap,
              lr.fog,
              lr.lights,
              {
                emissive: { value: new cr(0) },
                roughness: { value: 0.5 },
                metalness: { value: 0.5 },
                envMapIntensity: { value: 1 },
              },
            ]),
            vertexShader: ar.meshphysical_vert,
            fragmentShader: ar.meshphysical_frag,
          },
          points: {
            uniforms: or.merge([lr.points, lr.fog]),
            vertexShader: ar.points_vert,
            fragmentShader: ar.points_frag,
          },
          dashed: {
            uniforms: or.merge([
              lr.common,
              lr.fog,
              {
                scale: { value: 1 },
                dashSize: { value: 1 },
                totalSize: { value: 2 },
              },
            ]),
            vertexShader: ar.linedashed_vert,
            fragmentShader: ar.linedashed_frag,
          },
          depth: {
            uniforms: or.merge([lr.common, lr.displacementmap]),
            vertexShader: ar.depth_vert,
            fragmentShader: ar.depth_frag,
          },
          normal: {
            uniforms: or.merge([
              lr.common,
              lr.bumpmap,
              lr.normalmap,
              lr.displacementmap,
              { opacity: { value: 1 } },
            ]),
            vertexShader: ar.normal_vert,
            fragmentShader: ar.normal_frag,
          },
          cube: {
            uniforms: {
              tCube: { value: null },
              tFlip: { value: -1 },
              opacity: { value: 1 },
            },
            vertexShader: ar.cube_vert,
            fragmentShader: ar.cube_frag,
          },
          equirect: {
            uniforms: { tEquirect: { value: null } },
            vertexShader: ar.equirect_vert,
            fragmentShader: ar.equirect_frag,
          },
          distanceRGBA: {
            uniforms: or.merge([
              lr.common,
              lr.displacementmap,
              {
                referencePosition: { value: new ke() },
                nearDistance: { value: 1 },
                farDistance: { value: 1e3 },
              },
            ]),
            vertexShader: ar.distanceRGBA_vert,
            fragmentShader: ar.distanceRGBA_frag,
          },
          shadow: {
            uniforms: or.merge([
              lr.lights,
              lr.fog,
              { color: { value: new cr(0) }, opacity: { value: 1 } },
            ]),
            vertexShader: ar.shadow_vert,
            fragmentShader: ar.shadow_frag,
          },
        };
      function ur() {
        var t = null,
          e = !1,
          n = null;
        function i(r, a) {
          !1 !== e && (n(r, a), t.requestAnimationFrame(i));
        }
        return {
          start: function () {
            !0 !== e && null !== n && (t.requestAnimationFrame(i), (e = !0));
          },
          stop: function () {
            e = !1;
          },
          setAnimationLoop: function (t) {
            n = t;
          },
          setContext: function (e) {
            t = e;
          },
        };
      }
      function dr(t) {
        var e = new WeakMap();
        function n(e, n) {
          var i = e.array,
            r = e.dynamic ? t.DYNAMIC_DRAW : t.STATIC_DRAW,
            a = t.createBuffer();
          t.bindBuffer(n, a), t.bufferData(n, i, r), e.onUploadCallback();
          var o = t.FLOAT;
          return (
            i instanceof Float32Array
              ? (o = t.FLOAT)
              : i instanceof Float64Array
              ? console.warn(
                  "THREE.WebGLAttributes: Unsupported data buffer format: Float64Array."
                )
              : i instanceof Uint16Array
              ? (o = t.UNSIGNED_SHORT)
              : i instanceof Int16Array
              ? (o = t.SHORT)
              : i instanceof Uint32Array
              ? (o = t.UNSIGNED_INT)
              : i instanceof Int32Array
              ? (o = t.INT)
              : i instanceof Int8Array
              ? (o = t.BYTE)
              : i instanceof Uint8Array && (o = t.UNSIGNED_BYTE),
            {
              buffer: a,
              type: o,
              bytesPerElement: i.BYTES_PER_ELEMENT,
              version: e.version,
            }
          );
        }
        function i(e, n, i) {
          var r = n.array,
            a = n.updateRange;
          t.bindBuffer(i, e),
            !1 === n.dynamic
              ? t.bufferData(i, r, t.STATIC_DRAW)
              : -1 === a.count
              ? t.bufferSubData(i, 0, r)
              : 0 === a.count
              ? console.error(
                  "THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually."
                )
              : (t.bufferSubData(
                  i,
                  a.offset * r.BYTES_PER_ELEMENT,
                  r.subarray(a.offset, a.offset + a.count)
                ),
                (a.count = -1));
        }
        function r(t) {
          return t.isInterleavedBufferAttribute && (t = t.data), e.get(t);
        }
        function a(n) {
          n.isInterleavedBufferAttribute && (n = n.data);
          var i = e.get(n);
          i && (t.deleteBuffer(i.buffer), e.delete(n));
        }
        function o(t, r) {
          t.isInterleavedBufferAttribute && (t = t.data);
          var a = e.get(t);
          void 0 === a
            ? e.set(t, n(t, r))
            : a.version < t.version &&
              (i(a.buffer, t, r), (a.version = t.version));
        }
        return { get: r, remove: a, update: o };
      }
      function pr(t, e, n, i) {
        (this._x = t || 0),
          (this._y = e || 0),
          (this._z = n || 0),
          (this._order = i || pr.DefaultOrder);
      }
      function fr() {
        this.mask = 1;
      }
      (hr.physical = {
        uniforms: or.merge([
          hr.standard.uniforms,
          { clearCoat: { value: 0 }, clearCoatRoughness: { value: 0 } },
        ]),
        vertexShader: ar.meshphysical_vert,
        fragmentShader: ar.meshphysical_frag,
      }),
        (pr.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"]),
        (pr.DefaultOrder = "XYZ"),
        Object.defineProperties(pr.prototype, {
          x: {
            get: function () {
              return this._x;
            },
            set: function (t) {
              (this._x = t), this.onChangeCallback();
            },
          },
          y: {
            get: function () {
              return this._y;
            },
            set: function (t) {
              (this._y = t), this.onChangeCallback();
            },
          },
          z: {
            get: function () {
              return this._z;
            },
            set: function (t) {
              (this._z = t), this.onChangeCallback();
            },
          },
          order: {
            get: function () {
              return this._order;
            },
            set: function (t) {
              (this._order = t), this.onChangeCallback();
            },
          },
        }),
        Object.assign(pr.prototype, {
          isEuler: !0,
          set: function (t, e, n, i) {
            return (
              (this._x = t),
              (this._y = e),
              (this._z = n),
              (this._order = i || this._order),
              this.onChangeCallback(),
              this
            );
          },
          clone: function () {
            return new this.constructor(this._x, this._y, this._z, this._order);
          },
          copy: function (t) {
            return (
              (this._x = t._x),
              (this._y = t._y),
              (this._z = t._z),
              (this._order = t._order),
              this.onChangeCallback(),
              this
            );
          },
          setFromRotationMatrix: function (t, e, n) {
            var i = ze.clamp,
              r = t.elements,
              a = r[0],
              o = r[4],
              s = r[8],
              c = r[1],
              l = r[5],
              h = r[9],
              u = r[2],
              d = r[6],
              p = r[10];
            return (
              (e = e || this._order),
              "XYZ" === e
                ? ((this._y = Math.asin(i(s, -1, 1))),
                  Math.abs(s) < 0.99999
                    ? ((this._x = Math.atan2(-h, p)),
                      (this._z = Math.atan2(-o, a)))
                    : ((this._x = Math.atan2(d, l)), (this._z = 0)))
                : "YXZ" === e
                ? ((this._x = Math.asin(-i(h, -1, 1))),
                  Math.abs(h) < 0.99999
                    ? ((this._y = Math.atan2(s, p)),
                      (this._z = Math.atan2(c, l)))
                    : ((this._y = Math.atan2(-u, a)), (this._z = 0)))
                : "ZXY" === e
                ? ((this._x = Math.asin(i(d, -1, 1))),
                  Math.abs(d) < 0.99999
                    ? ((this._y = Math.atan2(-u, p)),
                      (this._z = Math.atan2(-o, l)))
                    : ((this._y = 0), (this._z = Math.atan2(c, a))))
                : "ZYX" === e
                ? ((this._y = Math.asin(-i(u, -1, 1))),
                  Math.abs(u) < 0.99999
                    ? ((this._x = Math.atan2(d, p)),
                      (this._z = Math.atan2(c, a)))
                    : ((this._x = 0), (this._z = Math.atan2(-o, l))))
                : "YZX" === e
                ? ((this._z = Math.asin(i(c, -1, 1))),
                  Math.abs(c) < 0.99999
                    ? ((this._x = Math.atan2(-h, l)),
                      (this._y = Math.atan2(-u, a)))
                    : ((this._x = 0), (this._y = Math.atan2(s, p))))
                : "XZY" === e
                ? ((this._z = Math.asin(-i(o, -1, 1))),
                  Math.abs(o) < 0.99999
                    ? ((this._x = Math.atan2(d, l)),
                      (this._y = Math.atan2(s, a)))
                    : ((this._x = Math.atan2(-h, p)), (this._y = 0)))
                : console.warn(
                    "THREE.Euler: .setFromRotationMatrix() given unsupported order: " +
                      e
                  ),
              (this._order = e),
              !1 !== n && this.onChangeCallback(),
              this
            );
          },
          setFromQuaternion: (function () {
            var t = new Fe();
            return function (e, n, i) {
              return (
                t.makeRotationFromQuaternion(e),
                this.setFromRotationMatrix(t, n, i)
              );
            };
          })(),
          setFromVector3: function (t, e) {
            return this.set(t.x, t.y, t.z, e || this._order);
          },
          reorder: (function () {
            var t = new He();
            return function (e) {
              return t.setFromEuler(this), this.setFromQuaternion(t, e);
            };
          })(),
          equals: function (t) {
            return (
              t._x === this._x &&
              t._y === this._y &&
              t._z === this._z &&
              t._order === this._order
            );
          },
          fromArray: function (t) {
            return (
              (this._x = t[0]),
              (this._y = t[1]),
              (this._z = t[2]),
              void 0 !== t[3] && (this._order = t[3]),
              this.onChangeCallback(),
              this
            );
          },
          toArray: function (t, e) {
            return (
              void 0 === t && (t = []),
              void 0 === e && (e = 0),
              (t[e] = this._x),
              (t[e + 1] = this._y),
              (t[e + 2] = this._z),
              (t[e + 3] = this._order),
              t
            );
          },
          toVector3: function (t) {
            return t
              ? t.set(this._x, this._y, this._z)
              : new ke(this._x, this._y, this._z);
          },
          onChange: function (t) {
            return (this.onChangeCallback = t), this;
          },
          onChangeCallback: function () {},
        }),
        Object.assign(fr.prototype, {
          set: function (t) {
            this.mask = (1 << t) | 0;
          },
          enable: function (t) {
            this.mask |= (1 << t) | 0;
          },
          toggle: function (t) {
            this.mask ^= (1 << t) | 0;
          },
          disable: function (t) {
            this.mask &= ~((1 << t) | 0);
          },
          test: function (t) {
            return 0 !== (this.mask & t.mask);
          },
        });
      var mr = 0;
      function gr() {
        Object.defineProperty(this, "id", { value: mr++ }),
          (this.uuid = ze.generateUUID()),
          (this.name = ""),
          (this.type = "Object3D"),
          (this.parent = null),
          (this.children = []),
          (this.up = gr.DefaultUp.clone());
        var t = new ke(),
          e = new pr(),
          n = new He(),
          i = new ke(1, 1, 1);
        function r() {
          n.setFromEuler(e, !1);
        }
        function a() {
          e.setFromQuaternion(n, void 0, !1);
        }
        e.onChange(r),
          n.onChange(a),
          Object.defineProperties(this, {
            position: { enumerable: !0, value: t },
            rotation: { enumerable: !0, value: e },
            quaternion: { enumerable: !0, value: n },
            scale: { enumerable: !0, value: i },
            modelViewMatrix: { value: new Fe() },
            normalMatrix: { value: new Ge() },
          }),
          (this.matrix = new Fe()),
          (this.matrixWorld = new Fe()),
          (this.matrixAutoUpdate = gr.DefaultMatrixAutoUpdate),
          (this.matrixWorldNeedsUpdate = !1),
          (this.layers = new fr()),
          (this.visible = !0),
          (this.castShadow = !1),
          (this.receiveShadow = !1),
          (this.frustumCulled = !0),
          (this.renderOrder = 0),
          (this.userData = {});
      }
      function vr() {
        gr.call(this),
          (this.type = "Camera"),
          (this.matrixWorldInverse = new Fe()),
          (this.projectionMatrix = new Fe());
      }
      function yr(t, e, n, i, r, a) {
        vr.call(this),
          (this.type = "OrthographicCamera"),
          (this.zoom = 1),
          (this.view = null),
          (this.left = t),
          (this.right = e),
          (this.top = n),
          (this.bottom = i),
          (this.near = void 0 !== r ? r : 0.1),
          (this.far = void 0 !== a ? a : 2e3),
          this.updateProjectionMatrix();
      }
      function xr(t, e, n, i, r, a) {
        (this.a = t),
          (this.b = e),
          (this.c = n),
          (this.normal = i && i.isVector3 ? i : new ke()),
          (this.vertexNormals = Array.isArray(i) ? i : []),
          (this.color = r && r.isColor ? r : new cr()),
          (this.vertexColors = Array.isArray(r) ? r : []),
          (this.materialIndex = void 0 !== a ? a : 0);
      }
      (gr.DefaultUp = new ke(0, 1, 0)),
        (gr.DefaultMatrixAutoUpdate = !0),
        (gr.prototype = Object.assign(Object.create(i.prototype), {
          constructor: gr,
          isObject3D: !0,
          onBeforeRender: function () {},
          onAfterRender: function () {},
          applyMatrix: function (t) {
            this.matrix.multiplyMatrices(t, this.matrix),
              this.matrix.decompose(this.position, this.quaternion, this.scale);
          },
          applyQuaternion: function (t) {
            return this.quaternion.premultiply(t), this;
          },
          setRotationFromAxisAngle: function (t, e) {
            this.quaternion.setFromAxisAngle(t, e);
          },
          setRotationFromEuler: function (t) {
            this.quaternion.setFromEuler(t, !0);
          },
          setRotationFromMatrix: function (t) {
            this.quaternion.setFromRotationMatrix(t);
          },
          setRotationFromQuaternion: function (t) {
            this.quaternion.copy(t);
          },
          rotateOnAxis: (function () {
            var t = new He();
            return function (e, n) {
              return (
                t.setFromAxisAngle(e, n), this.quaternion.multiply(t), this
              );
            };
          })(),
          rotateOnWorldAxis: (function () {
            var t = new He();
            return function (e, n) {
              return (
                t.setFromAxisAngle(e, n), this.quaternion.premultiply(t), this
              );
            };
          })(),
          rotateX: (function () {
            var t = new ke(1, 0, 0);
            return function (e) {
              return this.rotateOnAxis(t, e);
            };
          })(),
          rotateY: (function () {
            var t = new ke(0, 1, 0);
            return function (e) {
              return this.rotateOnAxis(t, e);
            };
          })(),
          rotateZ: (function () {
            var t = new ke(0, 0, 1);
            return function (e) {
              return this.rotateOnAxis(t, e);
            };
          })(),
          translateOnAxis: (function () {
            var t = new ke();
            return function (e, n) {
              return (
                t.copy(e).applyQuaternion(this.quaternion),
                this.position.add(t.multiplyScalar(n)),
                this
              );
            };
          })(),
          translateX: (function () {
            var t = new ke(1, 0, 0);
            return function (e) {
              return this.translateOnAxis(t, e);
            };
          })(),
          translateY: (function () {
            var t = new ke(0, 1, 0);
            return function (e) {
              return this.translateOnAxis(t, e);
            };
          })(),
          translateZ: (function () {
            var t = new ke(0, 0, 1);
            return function (e) {
              return this.translateOnAxis(t, e);
            };
          })(),
          localToWorld: function (t) {
            return t.applyMatrix4(this.matrixWorld);
          },
          worldToLocal: (function () {
            var t = new Fe();
            return function (e) {
              return e.applyMatrix4(t.getInverse(this.matrixWorld));
            };
          })(),
          lookAt: (function () {
            var t = new Fe(),
              e = new ke();
            return function (n, i, r) {
              n.isVector3 ? e.copy(n) : e.set(n, i, r),
                this.isCamera
                  ? t.lookAt(this.position, e, this.up)
                  : t.lookAt(e, this.position, this.up),
                this.quaternion.setFromRotationMatrix(t);
            };
          })(),
          add: function (t) {
            if (arguments.length > 1) {
              for (var e = 0; e < arguments.length; e++) this.add(arguments[e]);
              return this;
            }
            return t === this
              ? (console.error(
                  "THREE.Object3D.add: object can't be added as a child of itself.",
                  t
                ),
                this)
              : (t && t.isObject3D
                  ? (null !== t.parent && t.parent.remove(t),
                    (t.parent = this),
                    t.dispatchEvent({ type: "added" }),
                    this.children.push(t))
                  : console.error(
                      "THREE.Object3D.add: object not an instance of THREE.Object3D.",
                      t
                    ),
                this);
          },
          remove: function (t) {
            if (arguments.length > 1) {
              for (var e = 0; e < arguments.length; e++)
                this.remove(arguments[e]);
              return this;
            }
            var n = this.children.indexOf(t);
            return (
              -1 !== n &&
                ((t.parent = null),
                t.dispatchEvent({ type: "removed" }),
                this.children.splice(n, 1)),
              this
            );
          },
          getObjectById: function (t) {
            return this.getObjectByProperty("id", t);
          },
          getObjectByName: function (t) {
            return this.getObjectByProperty("name", t);
          },
          getObjectByProperty: function (t, e) {
            if (this[t] === e) return this;
            for (var n = 0, i = this.children.length; n < i; n++) {
              var r = this.children[n],
                a = r.getObjectByProperty(t, e);
              if (void 0 !== a) return a;
            }
          },
          getWorldPosition: function (t) {
            return (
              void 0 === t &&
                (console.warn(
                  "THREE.Object3D: .getWorldPosition() target is now required"
                ),
                (t = new ke())),
              this.updateMatrixWorld(!0),
              t.setFromMatrixPosition(this.matrixWorld)
            );
          },
          getWorldQuaternion: (function () {
            var t = new ke(),
              e = new ke();
            return function (n) {
              return (
                void 0 === n &&
                  (console.warn(
                    "THREE.Object3D: .getWorldQuaternion() target is now required"
                  ),
                  (n = new He())),
                this.updateMatrixWorld(!0),
                this.matrixWorld.decompose(t, n, e),
                n
              );
            };
          })(),
          getWorldScale: (function () {
            var t = new ke(),
              e = new He();
            return function (n) {
              return (
                void 0 === n &&
                  (console.warn(
                    "THREE.Object3D: .getWorldScale() target is now required"
                  ),
                  (n = new ke())),
                this.updateMatrixWorld(!0),
                this.matrixWorld.decompose(t, e, n),
                n
              );
            };
          })(),
          getWorldDirection: (function () {
            var t = new He();
            return function (e) {
              return (
                void 0 === e &&
                  (console.warn(
                    "THREE.Object3D: .getWorldDirection() target is now required"
                  ),
                  (e = new ke())),
                this.getWorldQuaternion(t),
                e.set(0, 0, 1).applyQuaternion(t)
              );
            };
          })(),
          raycast: function () {},
          traverse: function (t) {
            t(this);
            for (var e = this.children, n = 0, i = e.length; n < i; n++)
              e[n].traverse(t);
          },
          traverseVisible: function (t) {
            if (!1 !== this.visible) {
              t(this);
              for (var e = this.children, n = 0, i = e.length; n < i; n++)
                e[n].traverseVisible(t);
            }
          },
          traverseAncestors: function (t) {
            var e = this.parent;
            null !== e && (t(e), e.traverseAncestors(t));
          },
          updateMatrix: function () {
            this.matrix.compose(this.position, this.quaternion, this.scale),
              (this.matrixWorldNeedsUpdate = !0);
          },
          updateMatrixWorld: function (t) {
            this.matrixAutoUpdate && this.updateMatrix(),
              (this.matrixWorldNeedsUpdate || t) &&
                (null === this.parent
                  ? this.matrixWorld.copy(this.matrix)
                  : this.matrixWorld.multiplyMatrices(
                      this.parent.matrixWorld,
                      this.matrix
                    ),
                (this.matrixWorldNeedsUpdate = !1),
                (t = !0));
            for (var e = this.children, n = 0, i = e.length; n < i; n++)
              e[n].updateMatrixWorld(t);
          },
          toJSON: function (t) {
            var e = void 0 === t || "string" === typeof t,
              n = {};
            e &&
              ((t = {
                geometries: {},
                materials: {},
                textures: {},
                images: {},
                shapes: {},
              }),
              (n.metadata = {
                version: 4.5,
                type: "Object",
                generator: "Object3D.toJSON",
              }));
            var i = {};
            function r(e, n) {
              return void 0 === e[n.uuid] && (e[n.uuid] = n.toJSON(t)), n.uuid;
            }
            if (
              ((i.uuid = this.uuid),
              (i.type = this.type),
              "" !== this.name && (i.name = this.name),
              !0 === this.castShadow && (i.castShadow = !0),
              !0 === this.receiveShadow && (i.receiveShadow = !0),
              !1 === this.visible && (i.visible = !1),
              !1 === this.frustumCulled && (i.frustumCulled = !1),
              0 !== this.renderOrder && (i.renderOrder = this.renderOrder),
              "{}" !== JSON.stringify(this.userData) &&
                (i.userData = this.userData),
              (i.layers = this.layers.mask),
              (i.matrix = this.matrix.toArray()),
              !1 === this.matrixAutoUpdate && (i.matrixAutoUpdate = !1),
              void 0 !== this.geometry)
            ) {
              i.geometry = r(t.geometries, this.geometry);
              var a = this.geometry.parameters;
              if (void 0 !== a && void 0 !== a.shapes) {
                var o = a.shapes;
                if (Array.isArray(o))
                  for (var s = 0, c = o.length; s < c; s++) {
                    var l = o[s];
                    r(t.shapes, l);
                  }
                else r(t.shapes, o);
              }
            }
            if (void 0 !== this.material)
              if (Array.isArray(this.material)) {
                var h = [];
                for (s = 0, c = this.material.length; s < c; s++)
                  h.push(r(t.materials, this.material[s]));
                i.material = h;
              } else i.material = r(t.materials, this.material);
            if (this.children.length > 0) {
              i.children = [];
              for (s = 0; s < this.children.length; s++)
                i.children.push(this.children[s].toJSON(t).object);
            }
            if (e) {
              var u = m(t.geometries),
                d = m(t.materials),
                p = m(t.textures),
                f = m(t.images);
              o = m(t.shapes);
              u.length > 0 && (n.geometries = u),
                d.length > 0 && (n.materials = d),
                p.length > 0 && (n.textures = p),
                f.length > 0 && (n.images = f),
                o.length > 0 && (n.shapes = o);
            }
            return (n.object = i), n;
            function m(t) {
              var e = [];
              for (var n in t) {
                var i = t[n];
                delete i.metadata, e.push(i);
              }
              return e;
            }
          },
          clone: function (t) {
            return new this.constructor().copy(this, t);
          },
          copy: function (t, e) {
            if (
              (void 0 === e && (e = !0),
              (this.name = t.name),
              this.up.copy(t.up),
              this.position.copy(t.position),
              this.quaternion.copy(t.quaternion),
              this.scale.copy(t.scale),
              this.matrix.copy(t.matrix),
              this.matrixWorld.copy(t.matrixWorld),
              (this.matrixAutoUpdate = t.matrixAutoUpdate),
              (this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate),
              (this.layers.mask = t.layers.mask),
              (this.visible = t.visible),
              (this.castShadow = t.castShadow),
              (this.receiveShadow = t.receiveShadow),
              (this.frustumCulled = t.frustumCulled),
              (this.renderOrder = t.renderOrder),
              (this.userData = JSON.parse(JSON.stringify(t.userData))),
              !0 === e)
            )
              for (var n = 0; n < t.children.length; n++) {
                var i = t.children[n];
                this.add(i.clone());
              }
            return this;
          },
        })),
        (vr.prototype = Object.assign(Object.create(gr.prototype), {
          constructor: vr,
          isCamera: !0,
          copy: function (t, e) {
            return (
              gr.prototype.copy.call(this, t, e),
              this.matrixWorldInverse.copy(t.matrixWorldInverse),
              this.projectionMatrix.copy(t.projectionMatrix),
              this
            );
          },
          getWorldDirection: (function () {
            var t = new He();
            return function (e) {
              return (
                void 0 === e &&
                  (console.warn(
                    "THREE.Camera: .getWorldDirection() target is now required"
                  ),
                  (e = new ke())),
                this.getWorldQuaternion(t),
                e.set(0, 0, -1).applyQuaternion(t)
              );
            };
          })(),
          updateMatrixWorld: function (t) {
            gr.prototype.updateMatrixWorld.call(this, t),
              this.matrixWorldInverse.getInverse(this.matrixWorld);
          },
          clone: function () {
            return new this.constructor().copy(this);
          },
        })),
        (yr.prototype = Object.assign(Object.create(vr.prototype), {
          constructor: yr,
          isOrthographicCamera: !0,
          copy: function (t, e) {
            return (
              vr.prototype.copy.call(this, t, e),
              (this.left = t.left),
              (this.right = t.right),
              (this.top = t.top),
              (this.bottom = t.bottom),
              (this.near = t.near),
              (this.far = t.far),
              (this.zoom = t.zoom),
              (this.view = null === t.view ? null : Object.assign({}, t.view)),
              this
            );
          },
          setViewOffset: function (t, e, n, i, r, a) {
            null === this.view &&
              (this.view = {
                enabled: !0,
                fullWidth: 1,
                fullHeight: 1,
                offsetX: 0,
                offsetY: 0,
                width: 1,
                height: 1,
              }),
              (this.view.enabled = !0),
              (this.view.fullWidth = t),
              (this.view.fullHeight = e),
              (this.view.offsetX = n),
              (this.view.offsetY = i),
              (this.view.width = r),
              (this.view.height = a),
              this.updateProjectionMatrix();
          },
          clearViewOffset: function () {
            null !== this.view && (this.view.enabled = !1),
              this.updateProjectionMatrix();
          },
          updateProjectionMatrix: function () {
            var t = (this.right - this.left) / (2 * this.zoom),
              e = (this.top - this.bottom) / (2 * this.zoom),
              n = (this.right + this.left) / 2,
              i = (this.top + this.bottom) / 2,
              r = n - t,
              a = n + t,
              o = i + e,
              s = i - e;
            if (null !== this.view && this.view.enabled) {
              var c = this.zoom / (this.view.width / this.view.fullWidth),
                l = this.zoom / (this.view.height / this.view.fullHeight),
                h = (this.right - this.left) / this.view.width,
                u = (this.top - this.bottom) / this.view.height;
              (r += h * (this.view.offsetX / c)),
                (a = r + h * (this.view.width / c)),
                (o -= u * (this.view.offsetY / l)),
                (s = o - u * (this.view.height / l));
            }
            this.projectionMatrix.makeOrthographic(
              r,
              a,
              o,
              s,
              this.near,
              this.far
            );
          },
          toJSON: function (t) {
            var e = gr.prototype.toJSON.call(this, t);
            return (
              (e.object.zoom = this.zoom),
              (e.object.left = this.left),
              (e.object.right = this.right),
              (e.object.top = this.top),
              (e.object.bottom = this.bottom),
              (e.object.near = this.near),
              (e.object.far = this.far),
              null !== this.view &&
                (e.object.view = Object.assign({}, this.view)),
              e
            );
          },
        })),
        Object.assign(xr.prototype, {
          clone: function () {
            return new this.constructor().copy(this);
          },
          copy: function (t) {
            (this.a = t.a),
              (this.b = t.b),
              (this.c = t.c),
              this.normal.copy(t.normal),
              this.color.copy(t.color),
              (this.materialIndex = t.materialIndex);
            for (var e = 0, n = t.vertexNormals.length; e < n; e++)
              this.vertexNormals[e] = t.vertexNormals[e].clone();
            for (e = 0, n = t.vertexColors.length; e < n; e++)
              this.vertexColors[e] = t.vertexColors[e].clone();
            return this;
          },
        });
      var _r = 0;
      function br() {
        Object.defineProperty(this, "id", { value: (_r += 2) }),
          (this.uuid = ze.generateUUID()),
          (this.name = ""),
          (this.type = "Geometry"),
          (this.vertices = []),
          (this.colors = []),
          (this.faces = []),
          (this.faceVertexUvs = [[]]),
          (this.morphTargets = []),
          (this.morphNormals = []),
          (this.skinWeights = []),
          (this.skinIndices = []),
          (this.lineDistances = []),
          (this.boundingBox = null),
          (this.boundingSphere = null),
          (this.elementsNeedUpdate = !1),
          (this.verticesNeedUpdate = !1),
          (this.uvsNeedUpdate = !1),
          (this.normalsNeedUpdate = !1),
          (this.colorsNeedUpdate = !1),
          (this.lineDistancesNeedUpdate = !1),
          (this.groupsNeedUpdate = !1);
      }
      function wr(t, e, n) {
        if (Array.isArray(t))
          throw new TypeError(
            "THREE.BufferAttribute: array should be a Typed Array."
          );
        (this.name = ""),
          (this.array = t),
          (this.itemSize = e),
          (this.count = void 0 !== t ? t.length / e : 0),
          (this.normalized = !0 === n),
          (this.dynamic = !1),
          (this.updateRange = { offset: 0, count: -1 }),
          (this.version = 0);
      }
      function Mr(t, e, n) {
        wr.call(this, new Int8Array(t), e, n);
      }
      function Sr(t, e, n) {
        wr.call(this, new Uint8Array(t), e, n);
      }
      function Er(t, e, n) {
        wr.call(this, new Uint8ClampedArray(t), e, n);
      }
      function Tr(t, e, n) {
        wr.call(this, new Int16Array(t), e, n);
      }
      function Ar(t, e, n) {
        wr.call(this, new Uint16Array(t), e, n);
      }
      function Cr(t, e, n) {
        wr.call(this, new Int32Array(t), e, n);
      }
      function Rr(t, e, n) {
        wr.call(this, new Uint32Array(t), e, n);
      }
      function Lr(t, e, n) {
        wr.call(this, new Float32Array(t), e, n);
      }
      function Pr(t, e, n) {
        wr.call(this, new Float64Array(t), e, n);
      }
      function Dr() {
        (this.vertices = []),
          (this.normals = []),
          (this.colors = []),
          (this.uvs = []),
          (this.uvs2 = []),
          (this.groups = []),
          (this.morphTargets = {}),
          (this.skinWeights = []),
          (this.skinIndices = []),
          (this.boundingBox = null),
          (this.boundingSphere = null),
          (this.verticesNeedUpdate = !1),
          (this.normalsNeedUpdate = !1),
          (this.colorsNeedUpdate = !1),
          (this.uvsNeedUpdate = !1),
          (this.groupsNeedUpdate = !1);
      }
      function Ir(t) {
        if (0 === t.length) return -1 / 0;
        for (var e = t[0], n = 1, i = t.length; n < i; ++n)
          t[n] > e && (e = t[n]);
        return e;
      }
      (br.prototype = Object.assign(Object.create(i.prototype), {
        constructor: br,
        isGeometry: !0,
        applyMatrix: function (t) {
          for (
            var e = new Ge().getNormalMatrix(t),
              n = 0,
              i = this.vertices.length;
            n < i;
            n++
          ) {
            var r = this.vertices[n];
            r.applyMatrix4(t);
          }
          for (n = 0, i = this.faces.length; n < i; n++) {
            var a = this.faces[n];
            a.normal.applyMatrix3(e).normalize();
            for (var o = 0, s = a.vertexNormals.length; o < s; o++)
              a.vertexNormals[o].applyMatrix3(e).normalize();
          }
          return (
            null !== this.boundingBox && this.computeBoundingBox(),
            null !== this.boundingSphere && this.computeBoundingSphere(),
            (this.verticesNeedUpdate = !0),
            (this.normalsNeedUpdate = !0),
            this
          );
        },
        rotateX: (function () {
          var t = new Fe();
          return function (e) {
            return t.makeRotationX(e), this.applyMatrix(t), this;
          };
        })(),
        rotateY: (function () {
          var t = new Fe();
          return function (e) {
            return t.makeRotationY(e), this.applyMatrix(t), this;
          };
        })(),
        rotateZ: (function () {
          var t = new Fe();
          return function (e) {
            return t.makeRotationZ(e), this.applyMatrix(t), this;
          };
        })(),
        translate: (function () {
          var t = new Fe();
          return function (e, n, i) {
            return t.makeTranslation(e, n, i), this.applyMatrix(t), this;
          };
        })(),
        scale: (function () {
          var t = new Fe();
          return function (e, n, i) {
            return t.makeScale(e, n, i), this.applyMatrix(t), this;
          };
        })(),
        lookAt: (function () {
          var t = new gr();
          return function (e) {
            t.lookAt(e), t.updateMatrix(), this.applyMatrix(t.matrix);
          };
        })(),
        fromBufferGeometry: function (t) {
          var e = this,
            n = null !== t.index ? t.index.array : void 0,
            i = t.attributes,
            r = i.position.array,
            a = void 0 !== i.normal ? i.normal.array : void 0,
            o = void 0 !== i.color ? i.color.array : void 0,
            s = void 0 !== i.uv ? i.uv.array : void 0,
            c = void 0 !== i.uv2 ? i.uv2.array : void 0;
          void 0 !== c && (this.faceVertexUvs[1] = []);
          for (
            var l = [], h = [], u = [], d = 0, p = 0;
            d < r.length;
            d += 3, p += 2
          )
            e.vertices.push(new ke(r[d], r[d + 1], r[d + 2])),
              void 0 !== a && l.push(new ke(a[d], a[d + 1], a[d + 2])),
              void 0 !== o && e.colors.push(new cr(o[d], o[d + 1], o[d + 2])),
              void 0 !== s && h.push(new Ue(s[p], s[p + 1])),
              void 0 !== c && u.push(new Ue(c[p], c[p + 1]));
          function f(t, n, i, r) {
            var d =
                void 0 !== a ? [l[t].clone(), l[n].clone(), l[i].clone()] : [],
              p =
                void 0 !== o
                  ? [
                      e.colors[t].clone(),
                      e.colors[n].clone(),
                      e.colors[i].clone(),
                    ]
                  : [],
              f = new xr(t, n, i, d, p, r);
            e.faces.push(f),
              void 0 !== s &&
                e.faceVertexUvs[0].push([
                  h[t].clone(),
                  h[n].clone(),
                  h[i].clone(),
                ]),
              void 0 !== c &&
                e.faceVertexUvs[1].push([
                  u[t].clone(),
                  u[n].clone(),
                  u[i].clone(),
                ]);
          }
          var m = t.groups;
          if (m.length > 0)
            for (d = 0; d < m.length; d++)
              for (
                var g = m[d], v = g.start, y = g.count, x = ((p = v), v + y);
                p < x;
                p += 3
              )
                void 0 !== n
                  ? f(n[p], n[p + 1], n[p + 2], g.materialIndex)
                  : f(p, p + 1, p + 2, g.materialIndex);
          else if (void 0 !== n)
            for (d = 0; d < n.length; d += 3) f(n[d], n[d + 1], n[d + 2]);
          else for (d = 0; d < r.length / 3; d += 3) f(d, d + 1, d + 2);
          return (
            this.computeFaceNormals(),
            null !== t.boundingBox &&
              (this.boundingBox = t.boundingBox.clone()),
            null !== t.boundingSphere &&
              (this.boundingSphere = t.boundingSphere.clone()),
            this
          );
        },
        center: (function () {
          var t = new ke();
          return function () {
            return (
              this.computeBoundingBox(),
              this.boundingBox.getCenter(t).negate(),
              this.translate(t.x, t.y, t.z),
              this
            );
          };
        })(),
        normalize: function () {
          this.computeBoundingSphere();
          var t = this.boundingSphere.center,
            e = this.boundingSphere.radius,
            n = 0 === e ? 1 : 1 / e,
            i = new Fe();
          return (
            i.set(
              n,
              0,
              0,
              -n * t.x,
              0,
              n,
              0,
              -n * t.y,
              0,
              0,
              n,
              -n * t.z,
              0,
              0,
              0,
              1
            ),
            this.applyMatrix(i),
            this
          );
        },
        computeFaceNormals: function () {
          for (
            var t = new ke(), e = new ke(), n = 0, i = this.faces.length;
            n < i;
            n++
          ) {
            var r = this.faces[n],
              a = this.vertices[r.a],
              o = this.vertices[r.b],
              s = this.vertices[r.c];
            t.subVectors(s, o),
              e.subVectors(a, o),
              t.cross(e),
              t.normalize(),
              r.normal.copy(t);
          }
        },
        computeVertexNormals: function (t) {
          var e, n, i, r, a, o;
          for (
            void 0 === t && (t = !0),
              o = new Array(this.vertices.length),
              e = 0,
              n = this.vertices.length;
            e < n;
            e++
          )
            o[e] = new ke();
          if (t) {
            var s,
              c,
              l,
              h = new ke(),
              u = new ke();
            for (i = 0, r = this.faces.length; i < r; i++)
              (a = this.faces[i]),
                (s = this.vertices[a.a]),
                (c = this.vertices[a.b]),
                (l = this.vertices[a.c]),
                h.subVectors(l, c),
                u.subVectors(s, c),
                h.cross(u),
                o[a.a].add(h),
                o[a.b].add(h),
                o[a.c].add(h);
          } else
            for (
              this.computeFaceNormals(), i = 0, r = this.faces.length;
              i < r;
              i++
            )
              (a = this.faces[i]),
                o[a.a].add(a.normal),
                o[a.b].add(a.normal),
                o[a.c].add(a.normal);
          for (e = 0, n = this.vertices.length; e < n; e++) o[e].normalize();
          for (i = 0, r = this.faces.length; i < r; i++) {
            a = this.faces[i];
            var d = a.vertexNormals;
            3 === d.length
              ? (d[0].copy(o[a.a]), d[1].copy(o[a.b]), d[2].copy(o[a.c]))
              : ((d[0] = o[a.a].clone()),
                (d[1] = o[a.b].clone()),
                (d[2] = o[a.c].clone()));
          }
          this.faces.length > 0 && (this.normalsNeedUpdate = !0);
        },
        computeFlatVertexNormals: function () {
          var t, e, n;
          for (
            this.computeFaceNormals(), t = 0, e = this.faces.length;
            t < e;
            t++
          ) {
            n = this.faces[t];
            var i = n.vertexNormals;
            3 === i.length
              ? (i[0].copy(n.normal), i[1].copy(n.normal), i[2].copy(n.normal))
              : ((i[0] = n.normal.clone()),
                (i[1] = n.normal.clone()),
                (i[2] = n.normal.clone()));
          }
          this.faces.length > 0 && (this.normalsNeedUpdate = !0);
        },
        computeMorphNormals: function () {
          var t, e, n, i, r;
          for (n = 0, i = this.faces.length; n < i; n++)
            for (
              r = this.faces[n],
                r.__originalFaceNormal
                  ? r.__originalFaceNormal.copy(r.normal)
                  : (r.__originalFaceNormal = r.normal.clone()),
                r.__originalVertexNormals || (r.__originalVertexNormals = []),
                t = 0,
                e = r.vertexNormals.length;
              t < e;
              t++
            )
              r.__originalVertexNormals[t]
                ? r.__originalVertexNormals[t].copy(r.vertexNormals[t])
                : (r.__originalVertexNormals[t] = r.vertexNormals[t].clone());
          var a = new br();
          for (
            a.faces = this.faces, t = 0, e = this.morphTargets.length;
            t < e;
            t++
          ) {
            if (!this.morphNormals[t]) {
              (this.morphNormals[t] = {}),
                (this.morphNormals[t].faceNormals = []),
                (this.morphNormals[t].vertexNormals = []);
              var o = this.morphNormals[t].faceNormals,
                s = this.morphNormals[t].vertexNormals;
              for (n = 0, i = this.faces.length; n < i; n++)
                (c = new ke()),
                  (l = { a: new ke(), b: new ke(), c: new ke() }),
                  o.push(c),
                  s.push(l);
            }
            var c,
              l,
              h = this.morphNormals[t];
            for (
              a.vertices = this.morphTargets[t].vertices,
                a.computeFaceNormals(),
                a.computeVertexNormals(),
                n = 0,
                i = this.faces.length;
              n < i;
              n++
            )
              (r = this.faces[n]),
                (c = h.faceNormals[n]),
                (l = h.vertexNormals[n]),
                c.copy(r.normal),
                l.a.copy(r.vertexNormals[0]),
                l.b.copy(r.vertexNormals[1]),
                l.c.copy(r.vertexNormals[2]);
          }
          for (n = 0, i = this.faces.length; n < i; n++)
            (r = this.faces[n]),
              (r.normal = r.__originalFaceNormal),
              (r.vertexNormals = r.__originalVertexNormals);
        },
        computeBoundingBox: function () {
          null === this.boundingBox && (this.boundingBox = new Je()),
            this.boundingBox.setFromPoints(this.vertices);
        },
        computeBoundingSphere: function () {
          null === this.boundingSphere && (this.boundingSphere = new Ze()),
            this.boundingSphere.setFromPoints(this.vertices);
        },
        merge: function (t, e, n) {
          if (t && t.isGeometry) {
            var i,
              r = this.vertices.length,
              a = this.vertices,
              o = t.vertices,
              s = this.faces,
              c = t.faces,
              l = this.faceVertexUvs[0],
              h = t.faceVertexUvs[0],
              u = this.colors,
              d = t.colors;
            void 0 === n && (n = 0),
              void 0 !== e && (i = new Ge().getNormalMatrix(e));
            for (var p = 0, f = o.length; p < f; p++) {
              var m = o[p],
                g = m.clone();
              void 0 !== e && g.applyMatrix4(e), a.push(g);
            }
            for (p = 0, f = d.length; p < f; p++) u.push(d[p].clone());
            for (p = 0, f = c.length; p < f; p++) {
              var v,
                y,
                x,
                _ = c[p],
                b = _.vertexNormals,
                w = _.vertexColors;
              (v = new xr(_.a + r, _.b + r, _.c + r)),
                v.normal.copy(_.normal),
                void 0 !== i && v.normal.applyMatrix3(i).normalize();
              for (var M = 0, S = b.length; M < S; M++)
                (y = b[M].clone()),
                  void 0 !== i && y.applyMatrix3(i).normalize(),
                  v.vertexNormals.push(y);
              v.color.copy(_.color);
              for (M = 0, S = w.length; M < S; M++)
                (x = w[M]), v.vertexColors.push(x.clone());
              (v.materialIndex = _.materialIndex + n), s.push(v);
            }
            for (p = 0, f = h.length; p < f; p++) {
              var E = h[p],
                T = [];
              if (void 0 !== E) {
                for (M = 0, S = E.length; M < S; M++) T.push(E[M].clone());
                l.push(T);
              }
            }
          } else
            console.error(
              "THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.",
              t
            );
        },
        mergeMesh: function (t) {
          t && t.isMesh
            ? (t.matrixAutoUpdate && t.updateMatrix(),
              this.merge(t.geometry, t.matrix))
            : console.error(
                "THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.",
                t
              );
        },
        mergeVertices: function () {
          var t,
            e,
            n,
            i,
            r,
            a,
            o,
            s,
            c = {},
            l = [],
            h = [],
            u = 4,
            d = Math.pow(10, u);
          for (n = 0, i = this.vertices.length; n < i; n++)
            (t = this.vertices[n]),
              (e =
                Math.round(t.x * d) +
                "_" +
                Math.round(t.y * d) +
                "_" +
                Math.round(t.z * d)),
              void 0 === c[e]
                ? ((c[e] = n), l.push(this.vertices[n]), (h[n] = l.length - 1))
                : (h[n] = h[c[e]]);
          var p = [];
          for (n = 0, i = this.faces.length; n < i; n++) {
            (r = this.faces[n]),
              (r.a = h[r.a]),
              (r.b = h[r.b]),
              (r.c = h[r.c]),
              (a = [r.a, r.b, r.c]);
            for (var f = 0; f < 3; f++)
              if (a[f] === a[(f + 1) % 3]) {
                p.push(n);
                break;
              }
          }
          for (n = p.length - 1; n >= 0; n--) {
            var m = p[n];
            for (
              this.faces.splice(m, 1), o = 0, s = this.faceVertexUvs.length;
              o < s;
              o++
            )
              this.faceVertexUvs[o].splice(m, 1);
          }
          var g = this.vertices.length - l.length;
          return (this.vertices = l), g;
        },
        setFromPoints: function (t) {
          this.vertices = [];
          for (var e = 0, n = t.length; e < n; e++) {
            var i = t[e];
            this.vertices.push(new ke(i.x, i.y, i.z || 0));
          }
          return this;
        },
        sortFacesByMaterialIndex: function () {
          for (var t = this.faces, e = t.length, n = 0; n < e; n++)
            t[n]._id = n;
          function i(t, e) {
            return t.materialIndex - e.materialIndex;
          }
          t.sort(i);
          var r,
            a,
            o = this.faceVertexUvs[0],
            s = this.faceVertexUvs[1];
          o && o.length === e && (r = []), s && s.length === e && (a = []);
          for (n = 0; n < e; n++) {
            var c = t[n]._id;
            r && r.push(o[c]), a && a.push(s[c]);
          }
          r && (this.faceVertexUvs[0] = r), a && (this.faceVertexUvs[1] = a);
        },
        toJSON: function () {
          var t = {
            metadata: {
              version: 4.5,
              type: "Geometry",
              generator: "Geometry.toJSON",
            },
          };
          if (
            ((t.uuid = this.uuid),
            (t.type = this.type),
            "" !== this.name && (t.name = this.name),
            void 0 !== this.parameters)
          ) {
            var e = this.parameters;
            for (var n in e) void 0 !== e[n] && (t[n] = e[n]);
            return t;
          }
          for (var i = [], r = 0; r < this.vertices.length; r++) {
            var a = this.vertices[r];
            i.push(a.x, a.y, a.z);
          }
          var o = [],
            s = [],
            c = {},
            l = [],
            h = {},
            u = [],
            d = {};
          for (r = 0; r < this.faces.length; r++) {
            var p = this.faces[r],
              f = !0,
              m = !1,
              g = void 0 !== this.faceVertexUvs[0][r],
              v = p.normal.length() > 0,
              y = p.vertexNormals.length > 0,
              x = 1 !== p.color.r || 1 !== p.color.g || 1 !== p.color.b,
              _ = p.vertexColors.length > 0,
              b = 0;
            if (
              ((b = E(b, 0, 0)),
              (b = E(b, 1, f)),
              (b = E(b, 2, m)),
              (b = E(b, 3, g)),
              (b = E(b, 4, v)),
              (b = E(b, 5, y)),
              (b = E(b, 6, x)),
              (b = E(b, 7, _)),
              o.push(b),
              o.push(p.a, p.b, p.c),
              o.push(p.materialIndex),
              g)
            ) {
              var w = this.faceVertexUvs[0][r];
              o.push(C(w[0]), C(w[1]), C(w[2]));
            }
            if ((v && o.push(T(p.normal)), y)) {
              var M = p.vertexNormals;
              o.push(T(M[0]), T(M[1]), T(M[2]));
            }
            if ((x && o.push(A(p.color)), _)) {
              var S = p.vertexColors;
              o.push(A(S[0]), A(S[1]), A(S[2]));
            }
          }
          function E(t, e, n) {
            return n ? t | (1 << e) : t & ~(1 << e);
          }
          function T(t) {
            var e = t.x.toString() + t.y.toString() + t.z.toString();
            return (
              void 0 !== c[e] || ((c[e] = s.length / 3), s.push(t.x, t.y, t.z)),
              c[e]
            );
          }
          function A(t) {
            var e = t.r.toString() + t.g.toString() + t.b.toString();
            return (
              void 0 !== h[e] || ((h[e] = l.length), l.push(t.getHex())), h[e]
            );
          }
          function C(t) {
            var e = t.x.toString() + t.y.toString();
            return (
              void 0 !== d[e] || ((d[e] = u.length / 2), u.push(t.x, t.y)), d[e]
            );
          }
          return (
            (t.data = {}),
            (t.data.vertices = i),
            (t.data.normals = s),
            l.length > 0 && (t.data.colors = l),
            u.length > 0 && (t.data.uvs = [u]),
            (t.data.faces = o),
            t
          );
        },
        clone: function () {
          return new br().copy(this);
        },
        copy: function (t) {
          var e, n, i, r, a, o;
          (this.vertices = []),
            (this.colors = []),
            (this.faces = []),
            (this.faceVertexUvs = [[]]),
            (this.morphTargets = []),
            (this.morphNormals = []),
            (this.skinWeights = []),
            (this.skinIndices = []),
            (this.lineDistances = []),
            (this.boundingBox = null),
            (this.boundingSphere = null),
            (this.name = t.name);
          var s = t.vertices;
          for (e = 0, n = s.length; e < n; e++)
            this.vertices.push(s[e].clone());
          var c = t.colors;
          for (e = 0, n = c.length; e < n; e++) this.colors.push(c[e].clone());
          var l = t.faces;
          for (e = 0, n = l.length; e < n; e++) this.faces.push(l[e].clone());
          for (e = 0, n = t.faceVertexUvs.length; e < n; e++) {
            var h = t.faceVertexUvs[e];
            for (
              void 0 === this.faceVertexUvs[e] && (this.faceVertexUvs[e] = []),
                i = 0,
                r = h.length;
              i < r;
              i++
            ) {
              var u = h[i],
                d = [];
              for (a = 0, o = u.length; a < o; a++) {
                var p = u[a];
                d.push(p.clone());
              }
              this.faceVertexUvs[e].push(d);
            }
          }
          var f = t.morphTargets;
          for (e = 0, n = f.length; e < n; e++) {
            var m = {};
            if (((m.name = f[e].name), void 0 !== f[e].vertices))
              for (m.vertices = [], i = 0, r = f[e].vertices.length; i < r; i++)
                m.vertices.push(f[e].vertices[i].clone());
            if (void 0 !== f[e].normals)
              for (m.normals = [], i = 0, r = f[e].normals.length; i < r; i++)
                m.normals.push(f[e].normals[i].clone());
            this.morphTargets.push(m);
          }
          var g = t.morphNormals;
          for (e = 0, n = g.length; e < n; e++) {
            var v = {};
            if (void 0 !== g[e].vertexNormals)
              for (
                v.vertexNormals = [], i = 0, r = g[e].vertexNormals.length;
                i < r;
                i++
              ) {
                var y = g[e].vertexNormals[i],
                  x = {};
                (x.a = y.a.clone()),
                  (x.b = y.b.clone()),
                  (x.c = y.c.clone()),
                  v.vertexNormals.push(x);
              }
            if (void 0 !== g[e].faceNormals)
              for (
                v.faceNormals = [], i = 0, r = g[e].faceNormals.length;
                i < r;
                i++
              )
                v.faceNormals.push(g[e].faceNormals[i].clone());
            this.morphNormals.push(v);
          }
          var _ = t.skinWeights;
          for (e = 0, n = _.length; e < n; e++)
            this.skinWeights.push(_[e].clone());
          var b = t.skinIndices;
          for (e = 0, n = b.length; e < n; e++)
            this.skinIndices.push(b[e].clone());
          var w = t.lineDistances;
          for (e = 0, n = w.length; e < n; e++) this.lineDistances.push(w[e]);
          var M = t.boundingBox;
          null !== M && (this.boundingBox = M.clone());
          var S = t.boundingSphere;
          return (
            null !== S && (this.boundingSphere = S.clone()),
            (this.elementsNeedUpdate = t.elementsNeedUpdate),
            (this.verticesNeedUpdate = t.verticesNeedUpdate),
            (this.uvsNeedUpdate = t.uvsNeedUpdate),
            (this.normalsNeedUpdate = t.normalsNeedUpdate),
            (this.colorsNeedUpdate = t.colorsNeedUpdate),
            (this.lineDistancesNeedUpdate = t.lineDistancesNeedUpdate),
            (this.groupsNeedUpdate = t.groupsNeedUpdate),
            this
          );
        },
        dispose: function () {
          this.dispatchEvent({ type: "dispose" });
        },
      })),
        Object.defineProperty(wr.prototype, "needsUpdate", {
          set: function (t) {
            !0 === t && this.version++;
          },
        }),
        Object.assign(wr.prototype, {
          isBufferAttribute: !0,
          onUploadCallback: function () {},
          setArray: function (t) {
            if (Array.isArray(t))
              throw new TypeError(
                "THREE.BufferAttribute: array should be a Typed Array."
              );
            return (
              (this.count = void 0 !== t ? t.length / this.itemSize : 0),
              (this.array = t),
              this
            );
          },
          setDynamic: function (t) {
            return (this.dynamic = t), this;
          },
          copy: function (t) {
            return (
              (this.name = t.name),
              (this.array = new t.array.constructor(t.array)),
              (this.itemSize = t.itemSize),
              (this.count = t.count),
              (this.normalized = t.normalized),
              (this.dynamic = t.dynamic),
              this
            );
          },
          copyAt: function (t, e, n) {
            (t *= this.itemSize), (n *= e.itemSize);
            for (var i = 0, r = this.itemSize; i < r; i++)
              this.array[t + i] = e.array[n + i];
            return this;
          },
          copyArray: function (t) {
            return this.array.set(t), this;
          },
          copyColorsArray: function (t) {
            for (var e = this.array, n = 0, i = 0, r = t.length; i < r; i++) {
              var a = t[i];
              void 0 === a &&
                (console.warn(
                  "THREE.BufferAttribute.copyColorsArray(): color is undefined",
                  i
                ),
                (a = new cr())),
                (e[n++] = a.r),
                (e[n++] = a.g),
                (e[n++] = a.b);
            }
            return this;
          },
          copyVector2sArray: function (t) {
            for (var e = this.array, n = 0, i = 0, r = t.length; i < r; i++) {
              var a = t[i];
              void 0 === a &&
                (console.warn(
                  "THREE.BufferAttribute.copyVector2sArray(): vector is undefined",
                  i
                ),
                (a = new Ue())),
                (e[n++] = a.x),
                (e[n++] = a.y);
            }
            return this;
          },
          copyVector3sArray: function (t) {
            for (var e = this.array, n = 0, i = 0, r = t.length; i < r; i++) {
              var a = t[i];
              void 0 === a &&
                (console.warn(
                  "THREE.BufferAttribute.copyVector3sArray(): vector is undefined",
                  i
                ),
                (a = new ke())),
                (e[n++] = a.x),
                (e[n++] = a.y),
                (e[n++] = a.z);
            }
            return this;
          },
          copyVector4sArray: function (t) {
            for (var e = this.array, n = 0, i = 0, r = t.length; i < r; i++) {
              var a = t[i];
              void 0 === a &&
                (console.warn(
                  "THREE.BufferAttribute.copyVector4sArray(): vector is undefined",
                  i
                ),
                (a = new je())),
                (e[n++] = a.x),
                (e[n++] = a.y),
                (e[n++] = a.z),
                (e[n++] = a.w);
            }
            return this;
          },
          set: function (t, e) {
            return void 0 === e && (e = 0), this.array.set(t, e), this;
          },
          getX: function (t) {
            return this.array[t * this.itemSize];
          },
          setX: function (t, e) {
            return (this.array[t * this.itemSize] = e), this;
          },
          getY: function (t) {
            return this.array[t * this.itemSize + 1];
          },
          setY: function (t, e) {
            return (this.array[t * this.itemSize + 1] = e), this;
          },
          getZ: function (t) {
            return this.array[t * this.itemSize + 2];
          },
          setZ: function (t, e) {
            return (this.array[t * this.itemSize + 2] = e), this;
          },
          getW: function (t) {
            return this.array[t * this.itemSize + 3];
          },
          setW: function (t, e) {
            return (this.array[t * this.itemSize + 3] = e), this;
          },
          setXY: function (t, e, n) {
            return (
              (t *= this.itemSize),
              (this.array[t + 0] = e),
              (this.array[t + 1] = n),
              this
            );
          },
          setXYZ: function (t, e, n, i) {
            return (
              (t *= this.itemSize),
              (this.array[t + 0] = e),
              (this.array[t + 1] = n),
              (this.array[t + 2] = i),
              this
            );
          },
          setXYZW: function (t, e, n, i, r) {
            return (
              (t *= this.itemSize),
              (this.array[t + 0] = e),
              (this.array[t + 1] = n),
              (this.array[t + 2] = i),
              (this.array[t + 3] = r),
              this
            );
          },
          onUpload: function (t) {
            return (this.onUploadCallback = t), this;
          },
          clone: function () {
            return new this.constructor(this.array, this.itemSize).copy(this);
          },
        }),
        (Mr.prototype = Object.create(wr.prototype)),
        (Mr.prototype.constructor = Mr),
        (Sr.prototype = Object.create(wr.prototype)),
        (Sr.prototype.constructor = Sr),
        (Er.prototype = Object.create(wr.prototype)),
        (Er.prototype.constructor = Er),
        (Tr.prototype = Object.create(wr.prototype)),
        (Tr.prototype.constructor = Tr),
        (Ar.prototype = Object.create(wr.prototype)),
        (Ar.prototype.constructor = Ar),
        (Cr.prototype = Object.create(wr.prototype)),
        (Cr.prototype.constructor = Cr),
        (Rr.prototype = Object.create(wr.prototype)),
        (Rr.prototype.constructor = Rr),
        (Lr.prototype = Object.create(wr.prototype)),
        (Lr.prototype.constructor = Lr),
        (Pr.prototype = Object.create(wr.prototype)),
        (Pr.prototype.constructor = Pr),
        Object.assign(Dr.prototype, {
          computeGroups: function (t) {
            for (
              var e, n = [], i = void 0, r = t.faces, a = 0;
              a < r.length;
              a++
            ) {
              var o = r[a];
              o.materialIndex !== i &&
                ((i = o.materialIndex),
                void 0 !== e && ((e.count = 3 * a - e.start), n.push(e)),
                (e = { start: 3 * a, materialIndex: i }));
            }
            void 0 !== e && ((e.count = 3 * a - e.start), n.push(e)),
              (this.groups = n);
          },
          fromGeometry: function (t) {
            var e,
              n = t.faces,
              i = t.vertices,
              r = t.faceVertexUvs,
              a = r[0] && r[0].length > 0,
              o = r[1] && r[1].length > 0,
              s = t.morphTargets,
              c = s.length;
            if (c > 0) {
              e = [];
              for (var l = 0; l < c; l++) e[l] = [];
              this.morphTargets.position = e;
            }
            var h,
              u = t.morphNormals,
              d = u.length;
            if (d > 0) {
              h = [];
              for (l = 0; l < d; l++) h[l] = [];
              this.morphTargets.normal = h;
            }
            var p = t.skinIndices,
              f = t.skinWeights,
              m = p.length === i.length,
              g = f.length === i.length;
            i.length > 0 &&
              0 === n.length &&
              console.error(
                "THREE.DirectGeometry: Faceless geometries are not supported."
              );
            for (l = 0; l < n.length; l++) {
              var v = n[l];
              this.vertices.push(i[v.a], i[v.b], i[v.c]);
              var y = v.vertexNormals;
              if (3 === y.length) this.normals.push(y[0], y[1], y[2]);
              else {
                var x = v.normal;
                this.normals.push(x, x, x);
              }
              var _ = v.vertexColors;
              if (3 === _.length) this.colors.push(_[0], _[1], _[2]);
              else {
                var b = v.color;
                this.colors.push(b, b, b);
              }
              if (!0 === a) {
                var w = r[0][l];
                void 0 !== w
                  ? this.uvs.push(w[0], w[1], w[2])
                  : (console.warn(
                      "THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ",
                      l
                    ),
                    this.uvs.push(new Ue(), new Ue(), new Ue()));
              }
              if (!0 === o) {
                w = r[1][l];
                void 0 !== w
                  ? this.uvs2.push(w[0], w[1], w[2])
                  : (console.warn(
                      "THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ",
                      l
                    ),
                    this.uvs2.push(new Ue(), new Ue(), new Ue()));
              }
              for (var M = 0; M < c; M++) {
                var S = s[M].vertices;
                e[M].push(S[v.a], S[v.b], S[v.c]);
              }
              for (M = 0; M < d; M++) {
                var E = u[M].vertexNormals[l];
                h[M].push(E.a, E.b, E.c);
              }
              m && this.skinIndices.push(p[v.a], p[v.b], p[v.c]),
                g && this.skinWeights.push(f[v.a], f[v.b], f[v.c]);
            }
            return (
              this.computeGroups(t),
              (this.verticesNeedUpdate = t.verticesNeedUpdate),
              (this.normalsNeedUpdate = t.normalsNeedUpdate),
              (this.colorsNeedUpdate = t.colorsNeedUpdate),
              (this.uvsNeedUpdate = t.uvsNeedUpdate),
              (this.groupsNeedUpdate = t.groupsNeedUpdate),
              this
            );
          },
        });
      var Or = 1;
      function Nr() {
        Object.defineProperty(this, "id", { value: (Or += 2) }),
          (this.uuid = ze.generateUUID()),
          (this.name = ""),
          (this.type = "BufferGeometry"),
          (this.index = null),
          (this.attributes = {}),
          (this.morphAttributes = {}),
          (this.groups = []),
          (this.boundingBox = null),
          (this.boundingSphere = null),
          (this.drawRange = { start: 0, count: 1 / 0 }),
          (this.userData = {});
      }
      function Br(t, e, n, i, r, a) {
        br.call(this),
          (this.type = "BoxGeometry"),
          (this.parameters = {
            width: t,
            height: e,
            depth: n,
            widthSegments: i,
            heightSegments: r,
            depthSegments: a,
          }),
          this.fromBufferGeometry(new zr(t, e, n, i, r, a)),
          this.mergeVertices();
      }
      function zr(t, e, n, i, r, a) {
        Nr.call(this),
          (this.type = "BoxBufferGeometry"),
          (this.parameters = {
            width: t,
            height: e,
            depth: n,
            widthSegments: i,
            heightSegments: r,
            depthSegments: a,
          });
        var o = this;
        (t = t || 1),
          (e = e || 1),
          (n = n || 1),
          (i = Math.floor(i) || 1),
          (r = Math.floor(r) || 1),
          (a = Math.floor(a) || 1);
        var s = [],
          c = [],
          l = [],
          h = [],
          u = 0,
          d = 0;
        function p(t, e, n, i, r, a, p, f, m, g, v) {
          var y,
            x,
            _ = a / m,
            b = p / g,
            w = a / 2,
            M = p / 2,
            S = f / 2,
            E = m + 1,
            T = g + 1,
            A = 0,
            C = 0,
            R = new ke();
          for (x = 0; x < T; x++) {
            var L = x * b - M;
            for (y = 0; y < E; y++) {
              var P = y * _ - w;
              (R[t] = P * i),
                (R[e] = L * r),
                (R[n] = S),
                c.push(R.x, R.y, R.z),
                (R[t] = 0),
                (R[e] = 0),
                (R[n] = f > 0 ? 1 : -1),
                l.push(R.x, R.y, R.z),
                h.push(y / m),
                h.push(1 - x / g),
                (A += 1);
            }
          }
          for (x = 0; x < g; x++)
            for (y = 0; y < m; y++) {
              var D = u + y + E * x,
                I = u + y + E * (x + 1),
                O = u + (y + 1) + E * (x + 1),
                N = u + (y + 1) + E * x;
              s.push(D, I, N), s.push(I, O, N), (C += 6);
            }
          o.addGroup(d, C, v), (d += C), (u += A);
        }
        p("z", "y", "x", -1, -1, n, e, t, a, r, 0),
          p("z", "y", "x", 1, -1, n, e, -t, a, r, 1),
          p("x", "z", "y", 1, 1, t, n, e, i, a, 2),
          p("x", "z", "y", 1, -1, t, n, -e, i, a, 3),
          p("x", "y", "z", 1, -1, t, e, n, i, r, 4),
          p("x", "y", "z", -1, -1, t, e, -n, i, r, 5),
          this.setIndex(s),
          this.addAttribute("position", new Lr(c, 3)),
          this.addAttribute("normal", new Lr(l, 3)),
          this.addAttribute("uv", new Lr(h, 2));
      }
      function Ur(t, e, n, i) {
        br.call(this),
          (this.type = "PlaneGeometry"),
          (this.parameters = {
            width: t,
            height: e,
            widthSegments: n,
            heightSegments: i,
          }),
          this.fromBufferGeometry(new Fr(t, e, n, i)),
          this.mergeVertices();
      }
      function Fr(t, e, n, i) {
        Nr.call(this),
          (this.type = "PlaneBufferGeometry"),
          (this.parameters = {
            width: t,
            height: e,
            widthSegments: n,
            heightSegments: i,
          }),
          (t = t || 1),
          (e = e || 1);
        var r,
          a,
          o = t / 2,
          s = e / 2,
          c = Math.floor(n) || 1,
          l = Math.floor(i) || 1,
          h = c + 1,
          u = l + 1,
          d = t / c,
          p = e / l,
          f = [],
          m = [],
          g = [],
          v = [];
        for (a = 0; a < u; a++) {
          var y = a * p - s;
          for (r = 0; r < h; r++) {
            var x = r * d - o;
            m.push(x, -y, 0), g.push(0, 0, 1), v.push(r / c), v.push(1 - a / l);
          }
        }
        for (a = 0; a < l; a++)
          for (r = 0; r < c; r++) {
            var _ = r + h * a,
              b = r + h * (a + 1),
              w = r + 1 + h * (a + 1),
              M = r + 1 + h * a;
            f.push(_, b, M), f.push(b, w, M);
          }
        this.setIndex(f),
          this.addAttribute("position", new Lr(m, 3)),
          this.addAttribute("normal", new Lr(g, 3)),
          this.addAttribute("uv", new Lr(v, 2));
      }
      (Nr.prototype = Object.assign(Object.create(i.prototype), {
        constructor: Nr,
        isBufferGeometry: !0,
        getIndex: function () {
          return this.index;
        },
        setIndex: function (t) {
          Array.isArray(t)
            ? (this.index = new (Ir(t) > 65535 ? Rr : Ar)(t, 1))
            : (this.index = t);
        },
        addAttribute: function (t, e) {
          return (e && e.isBufferAttribute) ||
            (e && e.isInterleavedBufferAttribute)
            ? "index" === t
              ? (console.warn(
                  "THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."
                ),
                this.setIndex(e),
                this)
              : ((this.attributes[t] = e), this)
            : (console.warn(
                "THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."
              ),
              this.addAttribute(t, new wr(arguments[1], arguments[2])));
        },
        getAttribute: function (t) {
          return this.attributes[t];
        },
        removeAttribute: function (t) {
          return delete this.attributes[t], this;
        },
        addGroup: function (t, e, n) {
          this.groups.push({
            start: t,
            count: e,
            materialIndex: void 0 !== n ? n : 0,
          });
        },
        clearGroups: function () {
          this.groups = [];
        },
        setDrawRange: function (t, e) {
          (this.drawRange.start = t), (this.drawRange.count = e);
        },
        applyMatrix: function (t) {
          var e = this.attributes.position;
          void 0 !== e && (t.applyToBufferAttribute(e), (e.needsUpdate = !0));
          var n = this.attributes.normal;
          if (void 0 !== n) {
            var i = new Ge().getNormalMatrix(t);
            i.applyToBufferAttribute(n), (n.needsUpdate = !0);
          }
          return (
            null !== this.boundingBox && this.computeBoundingBox(),
            null !== this.boundingSphere && this.computeBoundingSphere(),
            this
          );
        },
        rotateX: (function () {
          var t = new Fe();
          return function (e) {
            return t.makeRotationX(e), this.applyMatrix(t), this;
          };
        })(),
        rotateY: (function () {
          var t = new Fe();
          return function (e) {
            return t.makeRotationY(e), this.applyMatrix(t), this;
          };
        })(),
        rotateZ: (function () {
          var t = new Fe();
          return function (e) {
            return t.makeRotationZ(e), this.applyMatrix(t), this;
          };
        })(),
        translate: (function () {
          var t = new Fe();
          return function (e, n, i) {
            return t.makeTranslation(e, n, i), this.applyMatrix(t), this;
          };
        })(),
        scale: (function () {
          var t = new Fe();
          return function (e, n, i) {
            return t.makeScale(e, n, i), this.applyMatrix(t), this;
          };
        })(),
        lookAt: (function () {
          var t = new gr();
          return function (e) {
            t.lookAt(e), t.updateMatrix(), this.applyMatrix(t.matrix);
          };
        })(),
        center: (function () {
          var t = new ke();
          return function () {
            return (
              this.computeBoundingBox(),
              this.boundingBox.getCenter(t).negate(),
              this.translate(t.x, t.y, t.z),
              this
            );
          };
        })(),
        setFromObject: function (t) {
          var e = t.geometry;
          if (t.isPoints || t.isLine) {
            var n = new Lr(3 * e.vertices.length, 3),
              i = new Lr(3 * e.colors.length, 3);
            if (
              (this.addAttribute("position", n.copyVector3sArray(e.vertices)),
              this.addAttribute("color", i.copyColorsArray(e.colors)),
              e.lineDistances && e.lineDistances.length === e.vertices.length)
            ) {
              var r = new Lr(e.lineDistances.length, 1);
              this.addAttribute("lineDistance", r.copyArray(e.lineDistances));
            }
            null !== e.boundingSphere &&
              (this.boundingSphere = e.boundingSphere.clone()),
              null !== e.boundingBox &&
                (this.boundingBox = e.boundingBox.clone());
          } else t.isMesh && e && e.isGeometry && this.fromGeometry(e);
          return this;
        },
        setFromPoints: function (t) {
          for (var e = [], n = 0, i = t.length; n < i; n++) {
            var r = t[n];
            e.push(r.x, r.y, r.z || 0);
          }
          return this.addAttribute("position", new Lr(e, 3)), this;
        },
        updateFromObject: function (t) {
          var e,
            n = t.geometry;
          if (t.isMesh) {
            var i = n.__directGeometry;
            if (
              (!0 === n.elementsNeedUpdate &&
                ((i = void 0), (n.elementsNeedUpdate = !1)),
              void 0 === i)
            )
              return this.fromGeometry(n);
            (i.verticesNeedUpdate = n.verticesNeedUpdate),
              (i.normalsNeedUpdate = n.normalsNeedUpdate),
              (i.colorsNeedUpdate = n.colorsNeedUpdate),
              (i.uvsNeedUpdate = n.uvsNeedUpdate),
              (i.groupsNeedUpdate = n.groupsNeedUpdate),
              (n.verticesNeedUpdate = !1),
              (n.normalsNeedUpdate = !1),
              (n.colorsNeedUpdate = !1),
              (n.uvsNeedUpdate = !1),
              (n.groupsNeedUpdate = !1),
              (n = i);
          }
          return (
            !0 === n.verticesNeedUpdate &&
              ((e = this.attributes.position),
              void 0 !== e &&
                (e.copyVector3sArray(n.vertices), (e.needsUpdate = !0)),
              (n.verticesNeedUpdate = !1)),
            !0 === n.normalsNeedUpdate &&
              ((e = this.attributes.normal),
              void 0 !== e &&
                (e.copyVector3sArray(n.normals), (e.needsUpdate = !0)),
              (n.normalsNeedUpdate = !1)),
            !0 === n.colorsNeedUpdate &&
              ((e = this.attributes.color),
              void 0 !== e &&
                (e.copyColorsArray(n.colors), (e.needsUpdate = !0)),
              (n.colorsNeedUpdate = !1)),
            n.uvsNeedUpdate &&
              ((e = this.attributes.uv),
              void 0 !== e &&
                (e.copyVector2sArray(n.uvs), (e.needsUpdate = !0)),
              (n.uvsNeedUpdate = !1)),
            n.lineDistancesNeedUpdate &&
              ((e = this.attributes.lineDistance),
              void 0 !== e &&
                (e.copyArray(n.lineDistances), (e.needsUpdate = !0)),
              (n.lineDistancesNeedUpdate = !1)),
            n.groupsNeedUpdate &&
              (n.computeGroups(t.geometry),
              (this.groups = n.groups),
              (n.groupsNeedUpdate = !1)),
            this
          );
        },
        fromGeometry: function (t) {
          return (
            (t.__directGeometry = new Dr().fromGeometry(t)),
            this.fromDirectGeometry(t.__directGeometry)
          );
        },
        fromDirectGeometry: function (t) {
          var e = new Float32Array(3 * t.vertices.length);
          if (
            (this.addAttribute(
              "position",
              new wr(e, 3).copyVector3sArray(t.vertices)
            ),
            t.normals.length > 0)
          ) {
            var n = new Float32Array(3 * t.normals.length);
            this.addAttribute(
              "normal",
              new wr(n, 3).copyVector3sArray(t.normals)
            );
          }
          if (t.colors.length > 0) {
            var i = new Float32Array(3 * t.colors.length);
            this.addAttribute("color", new wr(i, 3).copyColorsArray(t.colors));
          }
          if (t.uvs.length > 0) {
            var r = new Float32Array(2 * t.uvs.length);
            this.addAttribute("uv", new wr(r, 2).copyVector2sArray(t.uvs));
          }
          if (t.uvs2.length > 0) {
            var a = new Float32Array(2 * t.uvs2.length);
            this.addAttribute("uv2", new wr(a, 2).copyVector2sArray(t.uvs2));
          }
          for (var o in ((this.groups = t.groups), t.morphTargets)) {
            for (
              var s = [], c = t.morphTargets[o], l = 0, h = c.length;
              l < h;
              l++
            ) {
              var u = c[l],
                d = new Lr(3 * u.length, 3);
              s.push(d.copyVector3sArray(u));
            }
            this.morphAttributes[o] = s;
          }
          if (t.skinIndices.length > 0) {
            var p = new Lr(4 * t.skinIndices.length, 4);
            this.addAttribute("skinIndex", p.copyVector4sArray(t.skinIndices));
          }
          if (t.skinWeights.length > 0) {
            var f = new Lr(4 * t.skinWeights.length, 4);
            this.addAttribute("skinWeight", f.copyVector4sArray(t.skinWeights));
          }
          return (
            null !== t.boundingSphere &&
              (this.boundingSphere = t.boundingSphere.clone()),
            null !== t.boundingBox &&
              (this.boundingBox = t.boundingBox.clone()),
            this
          );
        },
        computeBoundingBox: function () {
          null === this.boundingBox && (this.boundingBox = new Je());
          var t = this.attributes.position;
          void 0 !== t
            ? this.boundingBox.setFromBufferAttribute(t)
            : this.boundingBox.makeEmpty(),
            (isNaN(this.boundingBox.min.x) ||
              isNaN(this.boundingBox.min.y) ||
              isNaN(this.boundingBox.min.z)) &&
              console.error(
                'THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',
                this
              );
        },
        computeBoundingSphere: (function () {
          var t = new Je(),
            e = new ke();
          return function () {
            null === this.boundingSphere && (this.boundingSphere = new Ze());
            var n = this.attributes.position;
            if (n) {
              var i = this.boundingSphere.center;
              t.setFromBufferAttribute(n), t.getCenter(i);
              for (var r = 0, a = 0, o = n.count; a < o; a++)
                (e.x = n.getX(a)),
                  (e.y = n.getY(a)),
                  (e.z = n.getZ(a)),
                  (r = Math.max(r, i.distanceToSquared(e)));
              (this.boundingSphere.radius = Math.sqrt(r)),
                isNaN(this.boundingSphere.radius) &&
                  console.error(
                    'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
                    this
                  );
            }
          };
        })(),
        computeFaceNormals: function () {},
        computeVertexNormals: function () {
          var t = this.index,
            e = this.attributes,
            n = this.groups;
          if (e.position) {
            var i = e.position.array;
            if (void 0 === e.normal)
              this.addAttribute(
                "normal",
                new wr(new Float32Array(i.length), 3)
              );
            else
              for (var r = e.normal.array, a = 0, o = r.length; a < o; a++)
                r[a] = 0;
            var s,
              c,
              l,
              h = e.normal.array,
              u = new ke(),
              d = new ke(),
              p = new ke(),
              f = new ke(),
              m = new ke();
            if (t) {
              var g = t.array;
              0 === n.length && this.addGroup(0, g.length);
              for (var v = 0, y = n.length; v < y; ++v) {
                var x = n[v],
                  _ = x.start,
                  b = x.count;
                for (a = _, o = _ + b; a < o; a += 3)
                  (s = 3 * g[a + 0]),
                    (c = 3 * g[a + 1]),
                    (l = 3 * g[a + 2]),
                    u.fromArray(i, s),
                    d.fromArray(i, c),
                    p.fromArray(i, l),
                    f.subVectors(p, d),
                    m.subVectors(u, d),
                    f.cross(m),
                    (h[s] += f.x),
                    (h[s + 1] += f.y),
                    (h[s + 2] += f.z),
                    (h[c] += f.x),
                    (h[c + 1] += f.y),
                    (h[c + 2] += f.z),
                    (h[l] += f.x),
                    (h[l + 1] += f.y),
                    (h[l + 2] += f.z);
              }
            } else
              for (a = 0, o = i.length; a < o; a += 9)
                u.fromArray(i, a),
                  d.fromArray(i, a + 3),
                  p.fromArray(i, a + 6),
                  f.subVectors(p, d),
                  m.subVectors(u, d),
                  f.cross(m),
                  (h[a] = f.x),
                  (h[a + 1] = f.y),
                  (h[a + 2] = f.z),
                  (h[a + 3] = f.x),
                  (h[a + 4] = f.y),
                  (h[a + 5] = f.z),
                  (h[a + 6] = f.x),
                  (h[a + 7] = f.y),
                  (h[a + 8] = f.z);
            this.normalizeNormals(), (e.normal.needsUpdate = !0);
          }
        },
        merge: function (t, e) {
          if (t && t.isBufferGeometry) {
            void 0 === e &&
              ((e = 0),
              console.warn(
                "THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."
              ));
            var n = this.attributes;
            for (var i in n)
              if (void 0 !== t.attributes[i])
                for (
                  var r = n[i],
                    a = r.array,
                    o = t.attributes[i],
                    s = o.array,
                    c = o.itemSize,
                    l = 0,
                    h = c * e;
                  l < s.length;
                  l++, h++
                )
                  a[h] = s[l];
            return this;
          }
          console.error(
            "THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.",
            t
          );
        },
        normalizeNormals: (function () {
          var t = new ke();
          return function () {
            for (var e = this.attributes.normal, n = 0, i = e.count; n < i; n++)
              (t.x = e.getX(n)),
                (t.y = e.getY(n)),
                (t.z = e.getZ(n)),
                t.normalize(),
                e.setXYZ(n, t.x, t.y, t.z);
          };
        })(),
        toNonIndexed: function () {
          if (null === this.index)
            return (
              console.warn(
                "THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed."
              ),
              this
            );
          var t = new Nr(),
            e = this.index.array,
            n = this.attributes;
          for (var i in n) {
            for (
              var r = n[i],
                a = r.array,
                o = r.itemSize,
                s = new a.constructor(e.length * o),
                c = 0,
                l = 0,
                h = 0,
                u = e.length;
              h < u;
              h++
            ) {
              c = e[h] * o;
              for (var d = 0; d < o; d++) s[l++] = a[c++];
            }
            t.addAttribute(i, new wr(s, o));
          }
          var p = this.groups;
          for (h = 0, u = p.length; h < u; h++) {
            var f = p[h];
            t.addGroup(f.start, f.count, f.materialIndex);
          }
          return t;
        },
        toJSON: function () {
          var t = {
            metadata: {
              version: 4.5,
              type: "BufferGeometry",
              generator: "BufferGeometry.toJSON",
            },
          };
          if (
            ((t.uuid = this.uuid),
            (t.type = this.type),
            "" !== this.name && (t.name = this.name),
            Object.keys(this.userData).length > 0 &&
              (t.userData = this.userData),
            void 0 !== this.parameters)
          ) {
            var e = this.parameters;
            for (var n in e) void 0 !== e[n] && (t[n] = e[n]);
            return t;
          }
          t.data = { attributes: {} };
          var i = this.index;
          if (null !== i) {
            var r = Array.prototype.slice.call(i.array);
            t.data.index = { type: i.array.constructor.name, array: r };
          }
          var a = this.attributes;
          for (var n in a) {
            var o = a[n];
            r = Array.prototype.slice.call(o.array);
            t.data.attributes[n] = {
              itemSize: o.itemSize,
              type: o.array.constructor.name,
              array: r,
              normalized: o.normalized,
            };
          }
          var s = this.groups;
          s.length > 0 && (t.data.groups = JSON.parse(JSON.stringify(s)));
          var c = this.boundingSphere;
          return (
            null !== c &&
              (t.data.boundingSphere = {
                center: c.center.toArray(),
                radius: c.radius,
              }),
            t
          );
        },
        clone: function () {
          return new Nr().copy(this);
        },
        copy: function (t) {
          var e, n, i;
          (this.index = null),
            (this.attributes = {}),
            (this.morphAttributes = {}),
            (this.groups = []),
            (this.boundingBox = null),
            (this.boundingSphere = null),
            (this.name = t.name);
          var r = t.index;
          null !== r && this.setIndex(r.clone());
          var a = t.attributes;
          for (e in a) {
            var o = a[e];
            this.addAttribute(e, o.clone());
          }
          var s = t.morphAttributes;
          for (e in s) {
            var c = [],
              l = s[e];
            for (n = 0, i = l.length; n < i; n++) c.push(l[n].clone());
            this.morphAttributes[e] = c;
          }
          var h = t.groups;
          for (n = 0, i = h.length; n < i; n++) {
            var u = h[n];
            this.addGroup(u.start, u.count, u.materialIndex);
          }
          var d = t.boundingBox;
          null !== d && (this.boundingBox = d.clone());
          var p = t.boundingSphere;
          return (
            null !== p && (this.boundingSphere = p.clone()),
            (this.drawRange.start = t.drawRange.start),
            (this.drawRange.count = t.drawRange.count),
            (this.userData = t.userData),
            this
          );
        },
        dispose: function () {
          this.dispatchEvent({ type: "dispose" });
        },
      })),
        (Br.prototype = Object.create(br.prototype)),
        (Br.prototype.constructor = Br),
        (zr.prototype = Object.create(Nr.prototype)),
        (zr.prototype.constructor = zr),
        (Ur.prototype = Object.create(br.prototype)),
        (Ur.prototype.constructor = Ur),
        (Fr.prototype = Object.create(Nr.prototype)),
        (Fr.prototype.constructor = Fr);
      var Hr = 0;
      function kr() {
        Object.defineProperty(this, "id", { value: Hr++ }),
          (this.uuid = ze.generateUUID()),
          (this.name = ""),
          (this.type = "Material"),
          (this.fog = !0),
          (this.lights = !0),
          (this.blending = S),
          (this.side = m),
          (this.flatShading = !1),
          (this.vertexColors = _),
          (this.opacity = 1),
          (this.transparent = !1),
          (this.blendSrc = U),
          (this.blendDst = F),
          (this.blendEquation = R),
          (this.blendSrcAlpha = null),
          (this.blendDstAlpha = null),
          (this.blendEquationAlpha = null),
          (this.depthFunc = Y),
          (this.depthTest = !0),
          (this.depthWrite = !0),
          (this.clippingPlanes = null),
          (this.clipIntersection = !1),
          (this.clipShadows = !1),
          (this.shadowSide = null),
          (this.colorWrite = !0),
          (this.precision = null),
          (this.polygonOffset = !1),
          (this.polygonOffsetFactor = 0),
          (this.polygonOffsetUnits = 0),
          (this.dithering = !1),
          (this.alphaTest = 0),
          (this.premultipliedAlpha = !1),
          (this.overdraw = 0),
          (this.visible = !0),
          (this.userData = {}),
          (this.needsUpdate = !0);
      }
      function Gr(t) {
        kr.call(this),
          (this.type = "MeshBasicMaterial"),
          (this.color = new cr(16777215)),
          (this.map = null),
          (this.lightMap = null),
          (this.lightMapIntensity = 1),
          (this.aoMap = null),
          (this.aoMapIntensity = 1),
          (this.specularMap = null),
          (this.alphaMap = null),
          (this.envMap = null),
          (this.combine = Q),
          (this.reflectivity = 1),
          (this.refractionRatio = 0.98),
          (this.wireframe = !1),
          (this.wireframeLinewidth = 1),
          (this.wireframeLinecap = "round"),
          (this.wireframeLinejoin = "round"),
          (this.skinning = !1),
          (this.morphTargets = !1),
          (this.lights = !1),
          this.setValues(t);
      }
      function Vr(t) {
        kr.call(this),
          (this.type = "ShaderMaterial"),
          (this.defines = {}),
          (this.uniforms = {}),
          (this.vertexShader =
            "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}"),
          (this.fragmentShader =
            "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}"),
          (this.linewidth = 1),
          (this.wireframe = !1),
          (this.wireframeLinewidth = 1),
          (this.fog = !1),
          (this.lights = !1),
          (this.clipping = !1),
          (this.skinning = !1),
          (this.morphTargets = !1),
          (this.morphNormals = !1),
          (this.extensions = {
            derivatives: !1,
            fragDepth: !1,
            drawBuffers: !1,
            shaderTextureLOD: !1,
          }),
          (this.defaultAttributeValues = {
            color: [1, 1, 1],
            uv: [0, 0],
            uv2: [0, 0],
          }),
          (this.index0AttributeName = void 0),
          (this.uniformsNeedUpdate = !1),
          void 0 !== t &&
            (void 0 !== t.attributes &&
              console.error(
                "THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."
              ),
            this.setValues(t));
      }
      function Wr(t, e) {
        (this.origin = void 0 !== t ? t : new ke()),
          (this.direction = void 0 !== e ? e : new ke());
      }
      function jr(t, e) {
        (this.start = void 0 !== t ? t : new ke()),
          (this.end = void 0 !== e ? e : new ke());
      }
      function qr(t, e, n) {
        (this.a = void 0 !== t ? t : new ke()),
          (this.b = void 0 !== e ? e : new ke()),
          (this.c = void 0 !== n ? n : new ke());
      }
      function Xr(t, e) {
        gr.call(this),
          (this.type = "Mesh"),
          (this.geometry = void 0 !== t ? t : new Nr()),
          (this.material =
            void 0 !== e ? e : new Gr({ color: 16777215 * Math.random() })),
          (this.drawMode = we),
          this.updateMorphTargets();
      }
      function Yr(t, e, n, i) {
        var r,
          a,
          o,
          s = new cr(0),
          c = 0;
        function l(e, i, l, u) {
          var d = i.background;
          null === d ? h(s, c) : d && d.isColor && (h(d, 1), (u = !0)),
            (t.autoClear || u) &&
              t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil),
            d && d.isCubeTexture
              ? (void 0 === o &&
                  ((o = new Xr(
                    new zr(1, 1, 1),
                    new Vr({
                      uniforms: hr.cube.uniforms,
                      vertexShader: hr.cube.vertexShader,
                      fragmentShader: hr.cube.fragmentShader,
                      side: g,
                      depthTest: !0,
                      depthWrite: !1,
                      fog: !1,
                    })
                  )),
                  o.geometry.removeAttribute("normal"),
                  o.geometry.removeAttribute("uv"),
                  (o.onBeforeRender = function (t, e, n) {
                    this.matrixWorld.copyPosition(n.matrixWorld);
                  }),
                  n.update(o)),
                (o.material.uniforms.tCube.value = d),
                e.push(o, o.geometry, o.material, 0, null))
              : d &&
                d.isTexture &&
                (void 0 === r &&
                  ((r = new yr(-1, 1, 1, -1, 0, 1)),
                  (a = new Xr(
                    new Fr(2, 2),
                    new Gr({ depthTest: !1, depthWrite: !1, fog: !1 })
                  )),
                  n.update(a)),
                (a.material.map = d),
                t.renderBufferDirect(r, null, a.geometry, a.material, a, null));
        }
        function h(t, n) {
          e.buffers.color.setClear(t.r, t.g, t.b, n, i);
        }
        return {
          getClearColor: function () {
            return s;
          },
          setClearColor: function (t, e) {
            s.set(t), (c = void 0 !== e ? e : 1), h(s, c);
          },
          getClearAlpha: function () {
            return c;
          },
          setClearAlpha: function (t) {
            (c = t), h(s, c);
          },
          render: l,
        };
      }
      function Jr(t, e, n) {
        var i;
        function r(t) {
          i = t;
        }
        function a(e, r) {
          t.drawArrays(i, e, r), n.update(r, i);
        }
        function o(t, r, a) {
          var o = e.get("ANGLE_instanced_arrays");
          null !== o
            ? (o.drawArraysInstancedANGLE(i, r, a, t.maxInstancedCount),
              n.update(a, i, t.maxInstancedCount))
            : console.error(
                "THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
              );
        }
        (this.setMode = r), (this.render = a), (this.renderInstances = o);
      }
      function Zr(t, e, n) {
        var i;
        function r() {
          if (void 0 !== i) return i;
          var n = e.get("EXT_texture_filter_anisotropic");
          return (
            (i =
              null !== n
                ? t.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
                : 0),
            i
          );
        }
        function a(e) {
          if ("highp" === e) {
            if (
              t.getShaderPrecisionFormat(t.VERTEX_SHADER, t.HIGH_FLOAT)
                .precision > 0 &&
              t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.HIGH_FLOAT)
                .precision > 0
            )
              return "highp";
            e = "mediump";
          }
          return "mediump" === e &&
            t.getShaderPrecisionFormat(t.VERTEX_SHADER, t.MEDIUM_FLOAT)
              .precision > 0 &&
            t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.MEDIUM_FLOAT)
              .precision > 0
            ? "mediump"
            : "lowp";
        }
        var o = void 0 !== n.precision ? n.precision : "highp",
          s = a(o);
        s !== o &&
          (console.warn(
            "THREE.WebGLRenderer:",
            o,
            "not supported, using",
            s,
            "instead."
          ),
          (o = s));
        var c = !0 === n.logarithmicDepthBuffer,
          l = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS),
          h = t.getParameter(t.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
          u = t.getParameter(t.MAX_TEXTURE_SIZE),
          d = t.getParameter(t.MAX_CUBE_MAP_TEXTURE_SIZE),
          p = t.getParameter(t.MAX_VERTEX_ATTRIBS),
          f = t.getParameter(t.MAX_VERTEX_UNIFORM_VECTORS),
          m = t.getParameter(t.MAX_VARYING_VECTORS),
          g = t.getParameter(t.MAX_FRAGMENT_UNIFORM_VECTORS),
          v = h > 0,
          y = !!e.get("OES_texture_float"),
          x = v && y;
        return {
          getMaxAnisotropy: r,
          getMaxPrecision: a,
          precision: o,
          logarithmicDepthBuffer: c,
          maxTextures: l,
          maxVertexTextures: h,
          maxTextureSize: u,
          maxCubemapSize: d,
          maxAttributes: p,
          maxVertexUniforms: f,
          maxVaryings: m,
          maxFragmentUniforms: g,
          vertexTextures: v,
          floatFragmentTextures: y,
          floatVertexTextures: x,
        };
      }
      function Kr() {
        var t = this,
          e = null,
          n = 0,
          i = !1,
          r = !1,
          a = new Ke(),
          o = new Ge(),
          s = { value: null, needsUpdate: !1 };
        function c() {
          s.value !== e && ((s.value = e), (s.needsUpdate = n > 0)),
            (t.numPlanes = n),
            (t.numIntersection = 0);
        }
        function l(e, n, i, r) {
          var c = null !== e ? e.length : 0,
            l = null;
          if (0 !== c) {
            if (((l = s.value), !0 !== r || null === l)) {
              var h = i + 4 * c,
                u = n.matrixWorldInverse;
              o.getNormalMatrix(u),
                (null === l || l.length < h) && (l = new Float32Array(h));
              for (var d = 0, p = i; d !== c; ++d, p += 4)
                a.copy(e[d]).applyMatrix4(u, o),
                  a.normal.toArray(l, p),
                  (l[p + 3] = a.constant);
            }
            (s.value = l), (s.needsUpdate = !0);
          }
          return (t.numPlanes = c), l;
        }
        (this.uniform = s),
          (this.numPlanes = 0),
          (this.numIntersection = 0),
          (this.init = function (t, r, a) {
            var o = 0 !== t.length || r || 0 !== n || i;
            return (i = r), (e = l(t, a, 0)), (n = t.length), o;
          }),
          (this.beginShadows = function () {
            (r = !0), l(null);
          }),
          (this.endShadows = function () {
            (r = !1), c();
          }),
          (this.setState = function (t, a, o, h, u, d) {
            if (!i || null === t || 0 === t.length || (r && !o))
              r ? l(null) : c();
            else {
              var p = r ? 0 : n,
                f = 4 * p,
                m = u.clippingState || null;
              (s.value = m), (m = l(t, h, f, d));
              for (var g = 0; g !== f; ++g) m[g] = e[g];
              (u.clippingState = m),
                (this.numIntersection = a ? this.numPlanes : 0),
                (this.numPlanes += p);
            }
          });
      }
      function $r(t) {
        var e = {};
        return {
          get: function (n) {
            if (void 0 !== e[n]) return e[n];
            var i;
            switch (n) {
              case "WEBGL_depth_texture":
                i =
                  t.getExtension("WEBGL_depth_texture") ||
                  t.getExtension("MOZ_WEBGL_depth_texture") ||
                  t.getExtension("WEBKIT_WEBGL_depth_texture");
                break;
              case "EXT_texture_filter_anisotropic":
                i =
                  t.getExtension("EXT_texture_filter_anisotropic") ||
                  t.getExtension("MOZ_EXT_texture_filter_anisotropic") ||
                  t.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                break;
              case "WEBGL_compressed_texture_s3tc":
                i =
                  t.getExtension("WEBGL_compressed_texture_s3tc") ||
                  t.getExtension("MOZ_WEBGL_compressed_texture_s3tc") ||
                  t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                break;
              case "WEBGL_compressed_texture_pvrtc":
                i =
                  t.getExtension("WEBGL_compressed_texture_pvrtc") ||
                  t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                break;
              default:
                i = t.getExtension(n);
            }
            return (
              null === i &&
                console.warn(
                  "THREE.WebGLRenderer: " + n + " extension not supported."
                ),
              (e[n] = i),
              i
            );
          },
        };
      }
      function Qr(t, e, n) {
        var i = {},
          r = {};
        function a(t) {
          var o = t.target,
            s = i[o.id];
          for (var c in (null !== s.index && e.remove(s.index), s.attributes))
            e.remove(s.attributes[c]);
          o.removeEventListener("dispose", a), delete i[o.id];
          var l = r[o.id];
          l && (e.remove(l), delete r[o.id]),
            (l = r[s.id]),
            l && (e.remove(l), delete r[s.id]),
            n.memory.geometries--;
        }
        function o(t, e) {
          var r = i[e.id];
          return (
            r ||
            (e.addEventListener("dispose", a),
            e.isBufferGeometry
              ? (r = e)
              : e.isGeometry &&
                (void 0 === e._bufferGeometry &&
                  (e._bufferGeometry = new Nr().setFromObject(t)),
                (r = e._bufferGeometry)),
            (i[e.id] = r),
            n.memory.geometries++,
            r)
          );
        }
        function s(n) {
          var i = n.index,
            r = n.attributes;
          for (var a in (null !== i && e.update(i, t.ELEMENT_ARRAY_BUFFER), r))
            e.update(r[a], t.ARRAY_BUFFER);
          var o = n.morphAttributes;
          for (var a in o)
            for (var s = o[a], c = 0, l = s.length; c < l; c++)
              e.update(s[c], t.ARRAY_BUFFER);
        }
        function c(n) {
          var i = r[n.id];
          if (i) return i;
          var a = [],
            o = n.index,
            s = n.attributes;
          if (null !== o)
            for (var c = o.array, l = 0, h = c.length; l < h; l += 3) {
              var u = c[l + 0],
                d = c[l + 1],
                p = c[l + 2];
              a.push(u, d, d, p, p, u);
            }
          else
            for (
              c = s.position.array, l = 0, h = c.length / 3 - 1;
              l < h;
              l += 3
            ) {
              (u = l + 0), (d = l + 1), (p = l + 2);
              a.push(u, d, d, p, p, u);
            }
          return (
            (i = new (Ir(a) > 65535 ? Rr : Ar)(a, 1)),
            e.update(i, t.ELEMENT_ARRAY_BUFFER),
            (r[n.id] = i),
            i
          );
        }
        return { get: o, update: s, getWireframeAttribute: c };
      }
      function ta(t, e, n) {
        var i, r, a;
        function o(t) {
          i = t;
        }
        function s(t) {
          (r = t.type), (a = t.bytesPerElement);
        }
        function c(e, o) {
          t.drawElements(i, o, r, e * a), n.update(o, i);
        }
        function l(t, o, s) {
          var c = e.get("ANGLE_instanced_arrays");
          null !== c
            ? (c.drawElementsInstancedANGLE(
                i,
                s,
                r,
                o * a,
                t.maxInstancedCount
              ),
              n.update(s, i, t.maxInstancedCount))
            : console.error(
                "THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
              );
        }
        (this.setMode = o),
          (this.setIndex = s),
          (this.render = c),
          (this.renderInstances = l);
      }
      function ea(t) {
        var e = { geometries: 0, textures: 0 },
          n = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 };
        function i(e, i, r) {
          switch (((r = r || 1), n.calls++, i)) {
            case t.TRIANGLES:
              n.triangles += r * (e / 3);
              break;
            case t.TRIANGLE_STRIP:
            case t.TRIANGLE_FAN:
              n.triangles += r * (e - 2);
              break;
            case t.LINES:
              n.lines += r * (e / 2);
              break;
            case t.LINE_STRIP:
              n.lines += r * (e - 1);
              break;
            case t.LINE_LOOP:
              n.lines += r * e;
              break;
            case t.POINTS:
              n.points += r * e;
              break;
            default:
              console.error("THREE.WebGLInfo: Unknown draw mode:", i);
              break;
          }
        }
        function r() {
          n.frame++,
            (n.calls = 0),
            (n.triangles = 0),
            (n.points = 0),
            (n.lines = 0);
        }
        return {
          memory: e,
          render: n,
          programs: null,
          autoReset: !0,
          reset: r,
          update: i,
        };
      }
      function na(t, e) {
        return Math.abs(e[1]) - Math.abs(t[1]);
      }
      function ia(t) {
        var e = {},
          n = new Float32Array(8);
        function i(i, r, a, o) {
          var s = i.morphTargetInfluences,
            c = s.length,
            l = e[r.id];
          if (void 0 === l) {
            l = [];
            for (var h = 0; h < c; h++) l[h] = [h, 0];
            e[r.id] = l;
          }
          var u = a.morphTargets && r.morphAttributes.position,
            d = a.morphNormals && r.morphAttributes.normal;
          for (h = 0; h < c; h++) {
            var p = l[h];
            0 !== p[1] &&
              (u && r.removeAttribute("morphTarget" + h),
              d && r.removeAttribute("morphNormal" + h));
          }
          for (h = 0; h < c; h++) {
            p = l[h];
            (p[0] = h), (p[1] = s[h]);
          }
          l.sort(na);
          for (h = 0; h < 8; h++) {
            p = l[h];
            if (p) {
              var f = p[0],
                m = p[1];
              if (m) {
                u && r.addAttribute("morphTarget" + h, u[f]),
                  d && r.addAttribute("morphNormal" + h, d[f]),
                  (n[h] = m);
                continue;
              }
            }
            n[h] = 0;
          }
          o.getUniforms().setValue(t, "morphTargetInfluences", n);
        }
        return { update: i };
      }
      function ra(t, e) {
        var n = {};
        function i(i) {
          var r = e.render.frame,
            a = i.geometry,
            o = t.get(i, a);
          return (
            n[o.id] !== r &&
              (a.isGeometry && o.updateFromObject(i),
              t.update(o),
              (n[o.id] = r)),
            o
          );
        }
        function r() {
          n = {};
        }
        return { update: i, dispose: r };
      }
      function aa(t, e, n, i, r, a, o, s, c, l) {
        (t = void 0 !== t ? t : []),
          (e = void 0 !== e ? e : ct),
          We.call(this, t, e, n, i, r, a, o, s, c, l),
          (this.flipY = !1);
      }
      (kr.prototype = Object.assign(Object.create(i.prototype), {
        constructor: kr,
        isMaterial: !0,
        onBeforeCompile: function () {},
        setValues: function (t) {
          if (void 0 !== t)
            for (var e in t) {
              var n = t[e];
              if (void 0 !== n)
                if ("shading" !== e) {
                  var i = this[e];
                  void 0 !== i
                    ? i && i.isColor
                      ? i.set(n)
                      : i && i.isVector3 && n && n.isVector3
                      ? i.copy(n)
                      : (this[e] = "overdraw" === e ? Number(n) : n)
                    : console.warn(
                        "THREE." +
                          this.type +
                          ": '" +
                          e +
                          "' is not a property of this material."
                      );
                } else
                  console.warn(
                    "THREE." +
                      this.type +
                      ": .shading has been removed. Use the boolean .flatShading instead."
                  ),
                    (this.flatShading = n === y);
              else
                console.warn(
                  "THREE.Material: '" + e + "' parameter is undefined."
                );
            }
        },
        toJSON: function (t) {
          var e = void 0 === t || "string" === typeof t;
          e && (t = { textures: {}, images: {} });
          var n = {
            metadata: {
              version: 4.5,
              type: "Material",
              generator: "Material.toJSON",
            },
          };
          function i(t) {
            var e = [];
            for (var n in t) {
              var i = t[n];
              delete i.metadata, e.push(i);
            }
            return e;
          }
          if (
            ((n.uuid = this.uuid),
            (n.type = this.type),
            "" !== this.name && (n.name = this.name),
            this.color && this.color.isColor && (n.color = this.color.getHex()),
            void 0 !== this.roughness && (n.roughness = this.roughness),
            void 0 !== this.metalness && (n.metalness = this.metalness),
            this.emissive &&
              this.emissive.isColor &&
              (n.emissive = this.emissive.getHex()),
            1 !== this.emissiveIntensity &&
              (n.emissiveIntensity = this.emissiveIntensity),
            this.specular &&
              this.specular.isColor &&
              (n.specular = this.specular.getHex()),
            void 0 !== this.shininess && (n.shininess = this.shininess),
            void 0 !== this.clearCoat && (n.clearCoat = this.clearCoat),
            void 0 !== this.clearCoatRoughness &&
              (n.clearCoatRoughness = this.clearCoatRoughness),
            this.map && this.map.isTexture && (n.map = this.map.toJSON(t).uuid),
            this.alphaMap &&
              this.alphaMap.isTexture &&
              (n.alphaMap = this.alphaMap.toJSON(t).uuid),
            this.lightMap &&
              this.lightMap.isTexture &&
              (n.lightMap = this.lightMap.toJSON(t).uuid),
            this.aoMap &&
              this.aoMap.isTexture &&
              ((n.aoMap = this.aoMap.toJSON(t).uuid),
              (n.aoMapIntensity = this.aoMapIntensity)),
            this.bumpMap &&
              this.bumpMap.isTexture &&
              ((n.bumpMap = this.bumpMap.toJSON(t).uuid),
              (n.bumpScale = this.bumpScale)),
            this.normalMap &&
              this.normalMap.isTexture &&
              ((n.normalMap = this.normalMap.toJSON(t).uuid),
              (n.normalMapType = this.normalMapType),
              (n.normalScale = this.normalScale.toArray())),
            this.displacementMap &&
              this.displacementMap.isTexture &&
              ((n.displacementMap = this.displacementMap.toJSON(t).uuid),
              (n.displacementScale = this.displacementScale),
              (n.displacementBias = this.displacementBias)),
            this.roughnessMap &&
              this.roughnessMap.isTexture &&
              (n.roughnessMap = this.roughnessMap.toJSON(t).uuid),
            this.metalnessMap &&
              this.metalnessMap.isTexture &&
              (n.metalnessMap = this.metalnessMap.toJSON(t).uuid),
            this.emissiveMap &&
              this.emissiveMap.isTexture &&
              (n.emissiveMap = this.emissiveMap.toJSON(t).uuid),
            this.specularMap &&
              this.specularMap.isTexture &&
              (n.specularMap = this.specularMap.toJSON(t).uuid),
            this.envMap &&
              this.envMap.isTexture &&
              ((n.envMap = this.envMap.toJSON(t).uuid),
              (n.reflectivity = this.reflectivity)),
            this.gradientMap &&
              this.gradientMap.isTexture &&
              (n.gradientMap = this.gradientMap.toJSON(t).uuid),
            void 0 !== this.size && (n.size = this.size),
            void 0 !== this.sizeAttenuation &&
              (n.sizeAttenuation = this.sizeAttenuation),
            this.blending !== S && (n.blending = this.blending),
            !0 === this.flatShading && (n.flatShading = this.flatShading),
            this.side !== m && (n.side = this.side),
            this.vertexColors !== _ && (n.vertexColors = this.vertexColors),
            this.opacity < 1 && (n.opacity = this.opacity),
            !0 === this.transparent && (n.transparent = this.transparent),
            (n.depthFunc = this.depthFunc),
            (n.depthTest = this.depthTest),
            (n.depthWrite = this.depthWrite),
            0 !== this.rotation && (n.rotation = this.rotation),
            1 !== this.linewidth && (n.linewidth = this.linewidth),
            void 0 !== this.dashSize && (n.dashSize = this.dashSize),
            void 0 !== this.gapSize && (n.gapSize = this.gapSize),
            void 0 !== this.scale && (n.scale = this.scale),
            !0 === this.dithering && (n.dithering = !0),
            this.alphaTest > 0 && (n.alphaTest = this.alphaTest),
            !0 === this.premultipliedAlpha &&
              (n.premultipliedAlpha = this.premultipliedAlpha),
            !0 === this.wireframe && (n.wireframe = this.wireframe),
            this.wireframeLinewidth > 1 &&
              (n.wireframeLinewidth = this.wireframeLinewidth),
            "round" !== this.wireframeLinecap &&
              (n.wireframeLinecap = this.wireframeLinecap),
            "round" !== this.wireframeLinejoin &&
              (n.wireframeLinejoin = this.wireframeLinejoin),
            !0 === this.morphTargets && (n.morphTargets = !0),
            !0 === this.skinning && (n.skinning = !0),
            !1 === this.visible && (n.visible = !1),
            "{}" !== JSON.stringify(this.userData) &&
              (n.userData = this.userData),
            e)
          ) {
            var r = i(t.textures),
              a = i(t.images);
            r.length > 0 && (n.textures = r), a.length > 0 && (n.images = a);
          }
          return n;
        },
        clone: function () {
          return new this.constructor().copy(this);
        },
        copy: function (t) {
          (this.name = t.name),
            (this.fog = t.fog),
            (this.lights = t.lights),
            (this.blending = t.blending),
            (this.side = t.side),
            (this.flatShading = t.flatShading),
            (this.vertexColors = t.vertexColors),
            (this.opacity = t.opacity),
            (this.transparent = t.transparent),
            (this.blendSrc = t.blendSrc),
            (this.blendDst = t.blendDst),
            (this.blendEquation = t.blendEquation),
            (this.blendSrcAlpha = t.blendSrcAlpha),
            (this.blendDstAlpha = t.blendDstAlpha),
            (this.blendEquationAlpha = t.blendEquationAlpha),
            (this.depthFunc = t.depthFunc),
            (this.depthTest = t.depthTest),
            (this.depthWrite = t.depthWrite),
            (this.colorWrite = t.colorWrite),
            (this.precision = t.precision),
            (this.polygonOffset = t.polygonOffset),
            (this.polygonOffsetFactor = t.polygonOffsetFactor),
            (this.polygonOffsetUnits = t.polygonOffsetUnits),
            (this.dithering = t.dithering),
            (this.alphaTest = t.alphaTest),
            (this.premultipliedAlpha = t.premultipliedAlpha),
            (this.overdraw = t.overdraw),
            (this.visible = t.visible),
            (this.userData = JSON.parse(JSON.stringify(t.userData))),
            (this.clipShadows = t.clipShadows),
            (this.clipIntersection = t.clipIntersection);
          var e = t.clippingPlanes,
            n = null;
          if (null !== e) {
            var i = e.length;
            n = new Array(i);
            for (var r = 0; r !== i; ++r) n[r] = e[r].clone();
          }
          return (
            (this.clippingPlanes = n), (this.shadowSide = t.shadowSide), this
          );
        },
        dispose: function () {
          this.dispatchEvent({ type: "dispose" });
        },
      })),
        (Gr.prototype = Object.create(kr.prototype)),
        (Gr.prototype.constructor = Gr),
        (Gr.prototype.isMeshBasicMaterial = !0),
        (Gr.prototype.copy = function (t) {
          return (
            kr.prototype.copy.call(this, t),
            this.color.copy(t.color),
            (this.map = t.map),
            (this.lightMap = t.lightMap),
            (this.lightMapIntensity = t.lightMapIntensity),
            (this.aoMap = t.aoMap),
            (this.aoMapIntensity = t.aoMapIntensity),
            (this.specularMap = t.specularMap),
            (this.alphaMap = t.alphaMap),
            (this.envMap = t.envMap),
            (this.combine = t.combine),
            (this.reflectivity = t.reflectivity),
            (this.refractionRatio = t.refractionRatio),
            (this.wireframe = t.wireframe),
            (this.wireframeLinewidth = t.wireframeLinewidth),
            (this.wireframeLinecap = t.wireframeLinecap),
            (this.wireframeLinejoin = t.wireframeLinejoin),
            (this.skinning = t.skinning),
            (this.morphTargets = t.morphTargets),
            this
          );
        }),
        (Vr.prototype = Object.create(kr.prototype)),
        (Vr.prototype.constructor = Vr),
        (Vr.prototype.isShaderMaterial = !0),
        (Vr.prototype.copy = function (t) {
          return (
            kr.prototype.copy.call(this, t),
            (this.fragmentShader = t.fragmentShader),
            (this.vertexShader = t.vertexShader),
            (this.uniforms = or.clone(t.uniforms)),
            (this.defines = Object.assign({}, t.defines)),
            (this.wireframe = t.wireframe),
            (this.wireframeLinewidth = t.wireframeLinewidth),
            (this.lights = t.lights),
            (this.clipping = t.clipping),
            (this.skinning = t.skinning),
            (this.morphTargets = t.morphTargets),
            (this.morphNormals = t.morphNormals),
            (this.extensions = t.extensions),
            this
          );
        }),
        (Vr.prototype.toJSON = function (t) {
          var e = kr.prototype.toJSON.call(this, t);
          return (
            (e.uniforms = this.uniforms),
            (e.vertexShader = this.vertexShader),
            (e.fragmentShader = this.fragmentShader),
            e
          );
        }),
        Object.assign(Wr.prototype, {
          set: function (t, e) {
            return this.origin.copy(t), this.direction.copy(e), this;
          },
          clone: function () {
            return new this.constructor().copy(this);
          },
          copy: function (t) {
            return (
              this.origin.copy(t.origin), this.direction.copy(t.direction), this
            );
          },
          at: function (t, e) {
            return (
              void 0 === e &&
                (console.warn("THREE.Ray: .at() target is now required"),
                (e = new ke())),
              e.copy(this.direction).multiplyScalar(t).add(this.origin)
            );
          },
          lookAt: function (t) {
            return this.direction.copy(t).sub(this.origin).normalize(), this;
          },
          recast: (function () {
            var t = new ke();
            return function (e) {
              return this.origin.copy(this.at(e, t)), this;
            };
          })(),
          closestPointToPoint: function (t, e) {
            void 0 === e &&
              (console.warn(
                "THREE.Ray: .closestPointToPoint() target is now required"
              ),
              (e = new ke())),
              e.subVectors(t, this.origin);
            var n = e.dot(this.direction);
            return n < 0
              ? e.copy(this.origin)
              : e.copy(this.direction).multiplyScalar(n).add(this.origin);
          },
          distanceToPoint: function (t) {
            return Math.sqrt(this.distanceSqToPoint(t));
          },
          distanceSqToPoint: (function () {
            var t = new ke();
            return function (e) {
              var n = t.subVectors(e, this.origin).dot(this.direction);
              return n < 0
                ? this.origin.distanceToSquared(e)
                : (t.copy(this.direction).multiplyScalar(n).add(this.origin),
                  t.distanceToSquared(e));
            };
          })(),
          distanceSqToSegment: (function () {
            var t = new ke(),
              e = new ke(),
              n = new ke();
            return function (i, r, a, o) {
              t.copy(i).add(r).multiplyScalar(0.5),
                e.copy(r).sub(i).normalize(),
                n.copy(this.origin).sub(t);
              var s,
                c,
                l,
                h,
                u = 0.5 * i.distanceTo(r),
                d = -this.direction.dot(e),
                p = n.dot(this.direction),
                f = -n.dot(e),
                m = n.lengthSq(),
                g = Math.abs(1 - d * d);
              if (g > 0)
                if (((s = d * f - p), (c = d * p - f), (h = u * g), s >= 0))
                  if (c >= -h)
                    if (c <= h) {
                      var v = 1 / g;
                      (s *= v),
                        (c *= v),
                        (l =
                          s * (s + d * c + 2 * p) +
                          c * (d * s + c + 2 * f) +
                          m);
                    } else
                      (c = u),
                        (s = Math.max(0, -(d * c + p))),
                        (l = -s * s + c * (c + 2 * f) + m);
                  else
                    (c = -u),
                      (s = Math.max(0, -(d * c + p))),
                      (l = -s * s + c * (c + 2 * f) + m);
                else
                  c <= -h
                    ? ((s = Math.max(0, -(-d * u + p))),
                      (c = s > 0 ? -u : Math.min(Math.max(-u, -f), u)),
                      (l = -s * s + c * (c + 2 * f) + m))
                    : c <= h
                    ? ((s = 0),
                      (c = Math.min(Math.max(-u, -f), u)),
                      (l = c * (c + 2 * f) + m))
                    : ((s = Math.max(0, -(d * u + p))),
                      (c = s > 0 ? u : Math.min(Math.max(-u, -f), u)),
                      (l = -s * s + c * (c + 2 * f) + m));
              else
                (c = d > 0 ? -u : u),
                  (s = Math.max(0, -(d * c + p))),
                  (l = -s * s + c * (c + 2 * f) + m);
              return (
                a && a.copy(this.direction).multiplyScalar(s).add(this.origin),
                o && o.copy(e).multiplyScalar(c).add(t),
                l
              );
            };
          })(),
          intersectSphere: (function () {
            var t = new ke();
            return function (e, n) {
              t.subVectors(e.center, this.origin);
              var i = t.dot(this.direction),
                r = t.dot(t) - i * i,
                a = e.radius * e.radius;
              if (r > a) return null;
              var o = Math.sqrt(a - r),
                s = i - o,
                c = i + o;
              return s < 0 && c < 0
                ? null
                : s < 0
                ? this.at(c, n)
                : this.at(s, n);
            };
          })(),
          intersectsSphere: function (t) {
            return this.distanceToPoint(t.center) <= t.radius;
          },
          distanceToPlane: function (t) {
            var e = t.normal.dot(this.direction);
            if (0 === e) return 0 === t.distanceToPoint(this.origin) ? 0 : null;
            var n = -(this.origin.dot(t.normal) + t.constant) / e;
            return n >= 0 ? n : null;
          },
          intersectPlane: function (t, e) {
            var n = this.distanceToPlane(t);
            return null === n ? null : this.at(n, e);
          },
          intersectsPlane: function (t) {
            var e = t.distanceToPoint(this.origin);
            if (0 === e) return !0;
            var n = t.normal.dot(this.direction);
            return n * e < 0;
          },
          intersectBox: function (t, e) {
            var n,
              i,
              r,
              a,
              o,
              s,
              c = 1 / this.direction.x,
              l = 1 / this.direction.y,
              h = 1 / this.direction.z,
              u = this.origin;
            return (
              c >= 0
                ? ((n = (t.min.x - u.x) * c), (i = (t.max.x - u.x) * c))
                : ((n = (t.max.x - u.x) * c), (i = (t.min.x - u.x) * c)),
              l >= 0
                ? ((r = (t.min.y - u.y) * l), (a = (t.max.y - u.y) * l))
                : ((r = (t.max.y - u.y) * l), (a = (t.min.y - u.y) * l)),
              n > a || r > i
                ? null
                : ((r > n || n !== n) && (n = r),
                  (a < i || i !== i) && (i = a),
                  h >= 0
                    ? ((o = (t.min.z - u.z) * h), (s = (t.max.z - u.z) * h))
                    : ((o = (t.max.z - u.z) * h), (s = (t.min.z - u.z) * h)),
                  n > s || o > i
                    ? null
                    : ((o > n || n !== n) && (n = o),
                      (s < i || i !== i) && (i = s),
                      i < 0 ? null : this.at(n >= 0 ? n : i, e)))
            );
          },
          intersectsBox: (function () {
            var t = new ke();
            return function (e) {
              return null !== this.intersectBox(e, t);
            };
          })(),
          intersectTriangle: (function () {
            var t = new ke(),
              e = new ke(),
              n = new ke(),
              i = new ke();
            return function (r, a, o, s, c) {
              e.subVectors(a, r), n.subVectors(o, r), i.crossVectors(e, n);
              var l,
                h = this.direction.dot(i);
              if (h > 0) {
                if (s) return null;
                l = 1;
              } else {
                if (!(h < 0)) return null;
                (l = -1), (h = -h);
              }
              t.subVectors(this.origin, r);
              var u = l * this.direction.dot(n.crossVectors(t, n));
              if (u < 0) return null;
              var d = l * this.direction.dot(e.cross(t));
              if (d < 0) return null;
              if (u + d > h) return null;
              var p = -l * t.dot(i);
              return p < 0 ? null : this.at(p / h, c);
            };
          })(),
          applyMatrix4: function (t) {
            return (
              this.origin.applyMatrix4(t),
              this.direction.transformDirection(t),
              this
            );
          },
          equals: function (t) {
            return (
              t.origin.equals(this.origin) && t.direction.equals(this.direction)
            );
          },
        }),
        Object.assign(jr.prototype, {
          set: function (t, e) {
            return this.start.copy(t), this.end.copy(e), this;
          },
          clone: function () {
            return new this.constructor().copy(this);
          },
          copy: function (t) {
            return this.start.copy(t.start), this.end.copy(t.end), this;
          },
          getCenter: function (t) {
            return (
              void 0 === t &&
                (console.warn(
                  "THREE.Line3: .getCenter() target is now required"
                ),
                (t = new ke())),
              t.addVectors(this.start, this.end).multiplyScalar(0.5)
            );
          },
          delta: function (t) {
            return (
              void 0 === t &&
                (console.warn("THREE.Line3: .delta() target is now required"),
                (t = new ke())),
              t.subVectors(this.end, this.start)
            );
          },
          distanceSq: function () {
            return this.start.distanceToSquared(this.end);
          },
          distance: function () {
            return this.start.distanceTo(this.end);
          },
          at: function (t, e) {
            return (
              void 0 === e &&
                (console.warn("THREE.Line3: .at() target is now required"),
                (e = new ke())),
              this.delta(e).multiplyScalar(t).add(this.start)
            );
          },
          closestPointToPointParameter: (function () {
            var t = new ke(),
              e = new ke();
            return function (n, i) {
              t.subVectors(n, this.start), e.subVectors(this.end, this.start);
              var r = e.dot(e),
                a = e.dot(t),
                o = a / r;
              return i && (o = ze.clamp(o, 0, 1)), o;
            };
          })(),
          closestPointToPoint: function (t, e, n) {
            var i = this.closestPointToPointParameter(t, e);
            return (
              void 0 === n &&
                (console.warn(
                  "THREE.Line3: .closestPointToPoint() target is now required"
                ),
                (n = new ke())),
              this.delta(n).multiplyScalar(i).add(this.start)
            );
          },
          applyMatrix4: function (t) {
            return this.start.applyMatrix4(t), this.end.applyMatrix4(t), this;
          },
          equals: function (t) {
            return t.start.equals(this.start) && t.end.equals(this.end);
          },
        }),
        Object.assign(qr, {
          getNormal: (function () {
            var t = new ke();
            return function (e, n, i, r) {
              void 0 === r &&
                (console.warn(
                  "THREE.Triangle: .getNormal() target is now required"
                ),
                (r = new ke())),
                r.subVectors(i, n),
                t.subVectors(e, n),
                r.cross(t);
              var a = r.lengthSq();
              return a > 0
                ? r.multiplyScalar(1 / Math.sqrt(a))
                : r.set(0, 0, 0);
            };
          })(),
          getBarycoord: (function () {
            var t = new ke(),
              e = new ke(),
              n = new ke();
            return function (i, r, a, o, s) {
              t.subVectors(o, r), e.subVectors(a, r), n.subVectors(i, r);
              var c = t.dot(t),
                l = t.dot(e),
                h = t.dot(n),
                u = e.dot(e),
                d = e.dot(n),
                p = c * u - l * l;
              if (
                (void 0 === s &&
                  (console.warn(
                    "THREE.Triangle: .getBarycoord() target is now required"
                  ),
                  (s = new ke())),
                0 === p)
              )
                return s.set(-2, -1, -1);
              var f = 1 / p,
                m = (u * h - l * d) * f,
                g = (c * d - l * h) * f;
              return s.set(1 - m - g, g, m);
            };
          })(),
          containsPoint: (function () {
            var t = new ke();
            return function (e, n, i, r) {
              return (
                qr.getBarycoord(e, n, i, r, t),
                t.x >= 0 && t.y >= 0 && t.x + t.y <= 1
              );
            };
          })(),
        }),
        Object.assign(qr.prototype, {
          set: function (t, e, n) {
            return this.a.copy(t), this.b.copy(e), this.c.copy(n), this;
          },
          setFromPointsAndIndices: function (t, e, n, i) {
            return (
              this.a.copy(t[e]), this.b.copy(t[n]), this.c.copy(t[i]), this
            );
          },
          clone: function () {
            return new this.constructor().copy(this);
          },
          copy: function (t) {
            return this.a.copy(t.a), this.b.copy(t.b), this.c.copy(t.c), this;
          },
          getArea: (function () {
            var t = new ke(),
              e = new ke();
            return function () {
              return (
                t.subVectors(this.c, this.b),
                e.subVectors(this.a, this.b),
                0.5 * t.cross(e).length()
              );
            };
          })(),
          getMidpoint: function (t) {
            return (
              void 0 === t &&
                (console.warn(
                  "THREE.Triangle: .getMidpoint() target is now required"
                ),
                (t = new ke())),
              t
                .addVectors(this.a, this.b)
                .add(this.c)
                .multiplyScalar(1 / 3)
            );
          },
          getNormal: function (t) {
            return qr.getNormal(this.a, this.b, this.c, t);
          },
          getPlane: function (t) {
            return (
              void 0 === t &&
                (console.warn(
                  "THREE.Triangle: .getPlane() target is now required"
                ),
                (t = new ke())),
              t.setFromCoplanarPoints(this.a, this.b, this.c)
            );
          },
          getBarycoord: function (t, e) {
            return qr.getBarycoord(t, this.a, this.b, this.c, e);
          },
          containsPoint: function (t) {
            return qr.containsPoint(t, this.a, this.b, this.c);
          },
          intersectsBox: function (t) {
            return t.intersectsTriangle(this);
          },
          closestPointToPoint: (function () {
            var t = new Ke(),
              e = [new jr(), new jr(), new jr()],
              n = new ke(),
              i = new ke();
            return function (r, a) {
              void 0 === a &&
                (console.warn(
                  "THREE.Triangle: .closestPointToPoint() target is now required"
                ),
                (a = new ke()));
              var o = 1 / 0;
              if (
                (t.setFromCoplanarPoints(this.a, this.b, this.c),
                t.projectPoint(r, n),
                !0 === this.containsPoint(n))
              )
                a.copy(n);
              else {
                e[0].set(this.a, this.b),
                  e[1].set(this.b, this.c),
                  e[2].set(this.c, this.a);
                for (var s = 0; s < e.length; s++) {
                  e[s].closestPointToPoint(n, !0, i);
                  var c = n.distanceToSquared(i);
                  c < o && ((o = c), a.copy(i));
                }
              }
              return a;
            };
          })(),
          equals: function (t) {
            return (
              t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c)
            );
          },
        }),
        (Xr.prototype = Object.assign(Object.create(gr.prototype), {
          constructor: Xr,
          isMesh: !0,
          setDrawMode: function (t) {
            this.drawMode = t;
          },
          copy: function (t) {
            return (
              gr.prototype.copy.call(this, t),
              (this.drawMode = t.drawMode),
              void 0 !== t.morphTargetInfluences &&
                (this.morphTargetInfluences = t.morphTargetInfluences.slice()),
              void 0 !== t.morphTargetDictionary &&
                (this.morphTargetDictionary = Object.assign(
                  {},
                  t.morphTargetDictionary
                )),
              this
            );
          },
          updateMorphTargets: function () {
            var t,
              e,
              n,
              i = this.geometry;
            if (i.isBufferGeometry) {
              var r = i.morphAttributes,
                a = Object.keys(r);
              if (a.length > 0) {
                var o = r[a[0]];
                if (void 0 !== o)
                  for (
                    this.morphTargetInfluences = [],
                      this.morphTargetDictionary = {},
                      t = 0,
                      e = o.length;
                    t < e;
                    t++
                  )
                    (n = o[t].name || String(t)),
                      this.morphTargetInfluences.push(0),
                      (this.morphTargetDictionary[n] = t);
              }
            } else {
              var s = i.morphTargets;
              if (void 0 !== s && s.length > 0)
                for (
                  this.morphTargetInfluences = [],
                    this.morphTargetDictionary = {},
                    t = 0,
                    e = s.length;
                  t < e;
                  t++
                )
                  (n = s[t].name || String(t)),
                    this.morphTargetInfluences.push(0),
                    (this.morphTargetDictionary[n] = t);
            }
          },
          raycast: (function () {
            var t = new Fe(),
              e = new Wr(),
              n = new Ze(),
              i = new ke(),
              r = new ke(),
              a = new ke(),
              o = new ke(),
              s = new ke(),
              c = new ke(),
              l = new Ue(),
              h = new Ue(),
              u = new Ue(),
              d = new ke(),
              p = new ke(),
              f = new ke();
            function m(t, e, n, i, r, a, o) {
              return (
                qr.getBarycoord(t, e, n, i, d),
                r.multiplyScalar(d.x),
                a.multiplyScalar(d.y),
                o.multiplyScalar(d.z),
                r.add(a).add(o),
                r.clone()
              );
            }
            function y(t, e, n, i, r, a, o, s) {
              var c;
              if (
                ((c =
                  e.side === g
                    ? i.intersectTriangle(o, a, r, !0, s)
                    : i.intersectTriangle(r, a, o, e.side !== v, s)),
                null === c)
              )
                return null;
              f.copy(s), f.applyMatrix4(t.matrixWorld);
              var l = n.ray.origin.distanceTo(f);
              return l < n.near || l > n.far
                ? null
                : { distance: l, point: f.clone(), object: t };
            }
            function x(t, e, n, o, s, c, d, f, g) {
              i.fromBufferAttribute(s, d),
                r.fromBufferAttribute(s, f),
                a.fromBufferAttribute(s, g);
              var v = y(t, e, n, o, i, r, a, p);
              if (v) {
                c &&
                  (l.fromBufferAttribute(c, d),
                  h.fromBufferAttribute(c, f),
                  u.fromBufferAttribute(c, g),
                  (v.uv = m(p, i, r, a, l, h, u)));
                var x = new xr(d, f, g);
                qr.getNormal(i, r, a, x.normal), (v.face = x);
              }
              return v;
            }
            return function (d, f) {
              var g,
                v = this.geometry,
                _ = this.material,
                b = this.matrixWorld;
              if (
                void 0 !== _ &&
                (null === v.boundingSphere && v.computeBoundingSphere(),
                n.copy(v.boundingSphere),
                n.applyMatrix4(b),
                !1 !== d.ray.intersectsSphere(n) &&
                  (t.getInverse(b),
                  e.copy(d.ray).applyMatrix4(t),
                  null === v.boundingBox ||
                    !1 !== e.intersectsBox(v.boundingBox)))
              )
                if (v.isBufferGeometry) {
                  var w,
                    M,
                    S,
                    E,
                    T,
                    A,
                    C,
                    R,
                    L,
                    P,
                    D,
                    I = v.index,
                    O = v.attributes.position,
                    N = v.attributes.uv,
                    B = v.groups,
                    z = v.drawRange;
                  if (null !== I)
                    if (Array.isArray(_))
                      for (E = 0, A = B.length; E < A; E++)
                        for (
                          R = B[E],
                            L = _[R.materialIndex],
                            P = Math.max(R.start, z.start),
                            D = Math.min(R.start + R.count, z.start + z.count),
                            T = P,
                            C = D;
                          T < C;
                          T += 3
                        )
                          (w = I.getX(E)),
                            (M = I.getX(E + 1)),
                            (S = I.getX(E + 2)),
                            (g = x(this, L, d, e, O, N, w, M, S)),
                            g && ((g.faceIndex = Math.floor(E / 3)), f.push(g));
                    else
                      for (
                        P = Math.max(0, z.start),
                          D = Math.min(I.count, z.start + z.count),
                          E = P,
                          A = D;
                        E < A;
                        E += 3
                      )
                        (w = I.getX(E)),
                          (M = I.getX(E + 1)),
                          (S = I.getX(E + 2)),
                          (g = x(this, _, d, e, O, N, w, M, S)),
                          g && ((g.faceIndex = Math.floor(E / 3)), f.push(g));
                  else if (void 0 !== O)
                    if (Array.isArray(_))
                      for (E = 0, A = B.length; E < A; E++)
                        for (
                          R = B[E],
                            L = _[R.materialIndex],
                            P = Math.max(R.start, z.start),
                            D = Math.min(R.start + R.count, z.start + z.count),
                            T = P,
                            C = D;
                          T < C;
                          T += 3
                        )
                          (w = T),
                            (M = T + 1),
                            (S = T + 2),
                            (g = x(this, L, d, e, O, N, w, M, S)),
                            g && ((g.faceIndex = Math.floor(E / 3)), f.push(g));
                    else
                      for (
                        P = Math.max(0, z.start),
                          D = Math.min(O.count, z.start + z.count),
                          E = P,
                          A = D;
                        E < A;
                        E += 3
                      )
                        (w = E),
                          (M = E + 1),
                          (S = E + 2),
                          (g = x(this, _, d, e, O, N, w, M, S)),
                          g && ((g.faceIndex = Math.floor(E / 3)), f.push(g));
                } else if (v.isGeometry) {
                  var U,
                    F,
                    H,
                    k,
                    G = Array.isArray(_),
                    V = v.vertices,
                    W = v.faces,
                    j = v.faceVertexUvs[0];
                  j.length > 0 && (k = j);
                  for (var q = 0, X = W.length; q < X; q++) {
                    var Y = W[q],
                      J = G ? _[Y.materialIndex] : _;
                    if (void 0 !== J) {
                      if (
                        ((U = V[Y.a]),
                        (F = V[Y.b]),
                        (H = V[Y.c]),
                        !0 === J.morphTargets)
                      ) {
                        var Z = v.morphTargets,
                          K = this.morphTargetInfluences;
                        i.set(0, 0, 0), r.set(0, 0, 0), a.set(0, 0, 0);
                        for (var $ = 0, Q = Z.length; $ < Q; $++) {
                          var tt = K[$];
                          if (0 !== tt) {
                            var et = Z[$].vertices;
                            i.addScaledVector(o.subVectors(et[Y.a], U), tt),
                              r.addScaledVector(s.subVectors(et[Y.b], F), tt),
                              a.addScaledVector(c.subVectors(et[Y.c], H), tt);
                          }
                        }
                        i.add(U), r.add(F), a.add(H), (U = i), (F = r), (H = a);
                      }
                      if (((g = y(this, J, d, e, U, F, H, p)), g)) {
                        if (k && k[q]) {
                          var nt = k[q];
                          l.copy(nt[0]),
                            h.copy(nt[1]),
                            u.copy(nt[2]),
                            (g.uv = m(p, U, F, H, l, h, u));
                        }
                        (g.face = Y), (g.faceIndex = q), f.push(g);
                      }
                    }
                  }
                }
            };
          })(),
          clone: function () {
            return new this.constructor(this.geometry, this.material).copy(
              this
            );
          },
        })),
        (aa.prototype = Object.create(We.prototype)),
        (aa.prototype.constructor = aa),
        (aa.prototype.isCubeTexture = !0),
        Object.defineProperty(aa.prototype, "images", {
          get: function () {
            return this.image;
          },
          set: function (t) {
            this.image = t;
          },
        });
      var oa = new We(),
        sa = new aa();
      function ca() {
        (this.seq = []), (this.map = {});
      }
      var la = [],
        ha = [],
        ua = new Float32Array(16),
        da = new Float32Array(9),
        pa = new Float32Array(4);
      function fa(t, e, n) {
        var i = t[0];
        if (i <= 0 || i > 0) return t;
        var r = e * n,
          a = la[r];
        if (
          (void 0 === a && ((a = new Float32Array(r)), (la[r] = a)), 0 !== e)
        ) {
          i.toArray(a, 0);
          for (var o = 1, s = 0; o !== e; ++o) (s += n), t[o].toArray(a, s);
        }
        return a;
      }
      function ma(t, e) {
        if (t.length !== e.length) return !1;
        for (var n = 0, i = t.length; n < i; n++) if (t[n] !== e[n]) return !1;
        return !0;
      }
      function ga(t, e) {
        for (var n = 0, i = e.length; n < i; n++) t[n] = e[n];
      }
      function va(t, e) {
        var n = ha[e];
        void 0 === n && ((n = new Int32Array(e)), (ha[e] = n));
        for (var i = 0; i !== e; ++i) n[i] = t.allocTextureUnit();
        return n;
      }
      function ya(t, e) {
        var n = this.cache;
        n[0] !== e && (t.uniform1f(this.addr, e), (n[0] = e));
      }
      function xa(t, e) {
        var n = this.cache;
        n[0] !== e && (t.uniform1i(this.addr, e), (n[0] = e));
      }
      function _a(t, e) {
        var n = this.cache;
        if (void 0 !== e.x)
          (n[0] === e.x && n[1] === e.y) ||
            (t.uniform2f(this.addr, e.x, e.y), (n[0] = e.x), (n[1] = e.y));
        else {
          if (ma(n, e)) return;
          t.uniform2fv(this.addr, e), ga(n, e);
        }
      }
      function ba(t, e) {
        var n = this.cache;
        if (void 0 !== e.x)
          (n[0] === e.x && n[1] === e.y && n[2] === e.z) ||
            (t.uniform3f(this.addr, e.x, e.y, e.z),
            (n[0] = e.x),
            (n[1] = e.y),
            (n[2] = e.z));
        else if (void 0 !== e.r)
          (n[0] === e.r && n[1] === e.g && n[2] === e.b) ||
            (t.uniform3f(this.addr, e.r, e.g, e.b),
            (n[0] = e.r),
            (n[1] = e.g),
            (n[2] = e.b));
        else {
          if (ma(n, e)) return;
          t.uniform3fv(this.addr, e), ga(n, e);
        }
      }
      function wa(t, e) {
        var n = this.cache;
        if (void 0 !== e.x)
          (n[0] === e.x && n[1] === e.y && n[2] === e.z && n[3] === e.w) ||
            (t.uniform4f(this.addr, e.x, e.y, e.z, e.w),
            (n[0] = e.x),
            (n[1] = e.y),
            (n[2] = e.z),
            (n[3] = e.w));
        else {
          if (ma(n, e)) return;
          t.uniform4fv(this.addr, e), ga(n, e);
        }
      }
      function Ma(t, e) {
        var n = this.cache,
          i = e.elements;
        if (void 0 === i) {
          if (ma(n, e)) return;
          t.uniformMatrix2fv(this.addr, !1, e), ga(n, e);
        } else {
          if (ma(n, i)) return;
          pa.set(i), t.uniformMatrix2fv(this.addr, !1, pa), ga(n, i);
        }
      }
      function Sa(t, e) {
        var n = this.cache,
          i = e.elements;
        if (void 0 === i) {
          if (ma(n, e)) return;
          t.uniformMatrix3fv(this.addr, !1, e), ga(n, e);
        } else {
          if (ma(n, i)) return;
          da.set(i), t.uniformMatrix3fv(this.addr, !1, da), ga(n, i);
        }
      }
      function Ea(t, e) {
        var n = this.cache,
          i = e.elements;
        if (void 0 === i) {
          if (ma(n, e)) return;
          t.uniformMatrix4fv(this.addr, !1, e), ga(n, e);
        } else {
          if (ma(n, i)) return;
          ua.set(i), t.uniformMatrix4fv(this.addr, !1, ua), ga(n, i);
        }
      }
      function Ta(t, e, n) {
        var i = this.cache,
          r = n.allocTextureUnit();
        i[0] !== r && (t.uniform1i(this.addr, r), (i[0] = r)),
          n.setTexture2D(e || oa, r);
      }
      function Aa(t, e, n) {
        var i = this.cache,
          r = n.allocTextureUnit();
        i[0] !== r && (t.uniform1i(this.addr, r), (i[0] = r)),
          n.setTextureCube(e || sa, r);
      }
      function Ca(t, e) {
        var n = this.cache;
        ma(n, e) || (t.uniform2iv(this.addr, e), ga(n, e));
      }
      function Ra(t, e) {
        var n = this.cache;
        ma(n, e) || (t.uniform3iv(this.addr, e), ga(n, e));
      }
      function La(t, e) {
        var n = this.cache;
        ma(n, e) || (t.uniform4iv(this.addr, e), ga(n, e));
      }
      function Pa(t) {
        switch (t) {
          case 5126:
            return ya;
          case 35664:
            return _a;
          case 35665:
            return ba;
          case 35666:
            return wa;
          case 35674:
            return Ma;
          case 35675:
            return Sa;
          case 35676:
            return Ea;
          case 35678:
          case 36198:
            return Ta;
          case 35680:
            return Aa;
          case 5124:
          case 35670:
            return xa;
          case 35667:
          case 35671:
            return Ca;
          case 35668:
          case 35672:
            return Ra;
          case 35669:
          case 35673:
            return La;
        }
      }
      function Da(t, e) {
        var n = this.cache;
        ma(n, e) || (t.uniform1fv(this.addr, e), ga(n, e));
      }
      function Ia(t, e) {
        var n = this.cache;
        ma(n, e) || (t.uniform1iv(this.addr, e), ga(n, e));
      }
      function Oa(t, e) {
        var n = this.cache,
          i = fa(e, this.size, 2);
        ma(n, i) || (t.uniform2fv(this.addr, i), this.updateCache(i));
      }
      function Na(t, e) {
        var n = this.cache,
          i = fa(e, this.size, 3);
        ma(n, i) || (t.uniform3fv(this.addr, i), this.updateCache(i));
      }
      function Ba(t, e) {
        var n = this.cache,
          i = fa(e, this.size, 4);
        ma(n, i) || (t.uniform4fv(this.addr, i), this.updateCache(i));
      }
      function za(t, e) {
        var n = this.cache,
          i = fa(e, this.size, 4);
        ma(n, i) || (t.uniformMatrix2fv(this.addr, !1, i), this.updateCache(i));
      }
      function Ua(t, e) {
        var n = this.cache,
          i = fa(e, this.size, 9);
        ma(n, i) || (t.uniformMatrix3fv(this.addr, !1, i), this.updateCache(i));
      }
      function Fa(t, e) {
        var n = this.cache,
          i = fa(e, this.size, 16);
        ma(n, i) || (t.uniformMatrix4fv(this.addr, !1, i), this.updateCache(i));
      }
      function Ha(t, e, n) {
        var i = this.cache,
          r = e.length,
          a = va(n, r);
        !1 === ma(i, a) && (t.uniform1iv(this.addr, a), ga(i, a));
        for (var o = 0; o !== r; ++o) n.setTexture2D(e[o] || oa, a[o]);
      }
      function ka(t, e, n) {
        var i = this.cache,
          r = e.length,
          a = va(n, r);
        !1 === ma(i, a) && (t.uniform1iv(this.addr, a), ga(i, a));
        for (var o = 0; o !== r; ++o) n.setTextureCube(e[o] || sa, a[o]);
      }
      function Ga(t) {
        switch (t) {
          case 5126:
            return Da;
          case 35664:
            return Oa;
          case 35665:
            return Na;
          case 35666:
            return Ba;
          case 35674:
            return za;
          case 35675:
            return Ua;
          case 35676:
            return Fa;
          case 35678:
            return Ha;
          case 35680:
            return ka;
          case 5124:
          case 35670:
            return Ia;
          case 35667:
          case 35671:
            return Ca;
          case 35668:
          case 35672:
            return Ra;
          case 35669:
          case 35673:
            return La;
        }
      }
      function Va(t, e, n) {
        (this.id = t),
          (this.addr = n),
          (this.cache = []),
          (this.setValue = Pa(e.type));
      }
      function Wa(t, e, n) {
        (this.id = t),
          (this.addr = n),
          (this.cache = []),
          (this.size = e.size),
          (this.setValue = Ga(e.type));
      }
      function ja(t) {
        (this.id = t), ca.call(this);
      }
      (Wa.prototype.updateCache = function (t) {
        var e = this.cache;
        t instanceof Float32Array &&
          e.length !== t.length &&
          (this.cache = new Float32Array(t.length)),
          ga(e, t);
      }),
        (ja.prototype.setValue = function (t, e) {
          for (var n = this.seq, i = 0, r = n.length; i !== r; ++i) {
            var a = n[i];
            a.setValue(t, e[a.id]);
          }
        });
      var qa = /([\w\d_]+)(\])?(\[|\.)?/g;
      function Xa(t, e) {
        t.seq.push(e), (t.map[e.id] = e);
      }
      function Ya(t, e, n) {
        var i = t.name,
          r = i.length;
        qa.lastIndex = 0;
        while (1) {
          var a = qa.exec(i),
            o = qa.lastIndex,
            s = a[1],
            c = "]" === a[2],
            l = a[3];
          if ((c && (s |= 0), void 0 === l || ("[" === l && o + 2 === r))) {
            Xa(n, void 0 === l ? new Va(s, t, e) : new Wa(s, t, e));
            break;
          }
          var h = n.map,
            u = h[s];
          void 0 === u && ((u = new ja(s)), Xa(n, u)), (n = u);
        }
      }
      function Ja(t, e, n) {
        ca.call(this), (this.renderer = n);
        for (
          var i = t.getProgramParameter(e, t.ACTIVE_UNIFORMS), r = 0;
          r < i;
          ++r
        ) {
          var a = t.getActiveUniform(e, r),
            o = t.getUniformLocation(e, a.name);
          Ya(a, o, this);
        }
      }
      function Za(t) {
        for (var e = t.split("\n"), n = 0; n < e.length; n++)
          e[n] = n + 1 + ": " + e[n];
        return e.join("\n");
      }
      function Ka(t, e, n) {
        var i = t.createShader(e);
        return (
          t.shaderSource(i, n),
          t.compileShader(i),
          !1 === t.getShaderParameter(i, t.COMPILE_STATUS) &&
            console.error("THREE.WebGLShader: Shader couldn't compile."),
          "" !== t.getShaderInfoLog(i) &&
            console.warn(
              "THREE.WebGLShader: gl.getShaderInfoLog()",
              e === t.VERTEX_SHADER ? "vertex" : "fragment",
              t.getShaderInfoLog(i),
              Za(n)
            ),
          i
        );
      }
      (Ja.prototype.setValue = function (t, e, n) {
        var i = this.map[e];
        void 0 !== i && i.setValue(t, n, this.renderer);
      }),
        (Ja.prototype.setOptional = function (t, e, n) {
          var i = e[n];
          void 0 !== i && this.setValue(t, n, i);
        }),
        (Ja.upload = function (t, e, n, i) {
          for (var r = 0, a = e.length; r !== a; ++r) {
            var o = e[r],
              s = n[o.id];
            !1 !== s.needsUpdate && o.setValue(t, s.value, i);
          }
        }),
        (Ja.seqWithValue = function (t, e) {
          for (var n = [], i = 0, r = t.length; i !== r; ++i) {
            var a = t[i];
            a.id in e && n.push(a);
          }
          return n;
        });
      var $a = 0;
      function Qa(t) {
        switch (t) {
          case Ee:
            return ["Linear", "( value )"];
          case Te:
            return ["sRGB", "( value )"];
          case Ce:
            return ["RGBE", "( value )"];
          case Le:
            return ["RGBM", "( value, 7.0 )"];
          case Pe:
            return ["RGBM", "( value, 16.0 )"];
          case De:
            return ["RGBD", "( value, 256.0 )"];
          case Ae:
            return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
          default:
            throw new Error("unsupported encoding: " + t);
        }
      }
      function to(t, e) {
        var n = Qa(e);
        return (
          "vec4 " +
          t +
          "( vec4 value ) { return " +
          n[0] +
          "ToLinear" +
          n[1] +
          "; }"
        );
      }
      function eo(t, e) {
        var n = Qa(e);
        return (
          "vec4 " + t + "( vec4 value ) { return LinearTo" + n[0] + n[1] + "; }"
        );
      }
      function no(t, e) {
        var n;
        switch (e) {
          case it:
            n = "Linear";
            break;
          case rt:
            n = "Reinhard";
            break;
          case at:
            n = "Uncharted2";
            break;
          case ot:
            n = "OptimizedCineon";
            break;
          default:
            throw new Error("unsupported toneMapping: " + e);
        }
        return (
          "vec3 " +
          t +
          "( vec3 color ) { return " +
          n +
          "ToneMapping( color ); }"
        );
      }
      function io(t, e, n) {
        t = t || {};
        var i = [
          t.derivatives ||
          e.envMapCubeUV ||
          e.bumpMap ||
          (e.normalMap && !e.objectSpaceNormalMap) ||
          e.flatShading
            ? "#extension GL_OES_standard_derivatives : enable"
            : "",
          (t.fragDepth || e.logarithmicDepthBuffer) && n.get("EXT_frag_depth")
            ? "#extension GL_EXT_frag_depth : enable"
            : "",
          t.drawBuffers && n.get("WEBGL_draw_buffers")
            ? "#extension GL_EXT_draw_buffers : require"
            : "",
          (t.shaderTextureLOD || e.envMap) && n.get("EXT_shader_texture_lod")
            ? "#extension GL_EXT_shader_texture_lod : enable"
            : "",
        ];
        return i.filter(oo).join("\n");
      }
      function ro(t) {
        var e = [];
        for (var n in t) {
          var i = t[n];
          !1 !== i && e.push("#define " + n + " " + i);
        }
        return e.join("\n");
      }
      function ao(t, e) {
        for (
          var n = {}, i = t.getProgramParameter(e, t.ACTIVE_ATTRIBUTES), r = 0;
          r < i;
          r++
        ) {
          var a = t.getActiveAttrib(e, r),
            o = a.name;
          n[o] = t.getAttribLocation(e, o);
        }
        return n;
      }
      function oo(t) {
        return "" !== t;
      }
      function so(t, e) {
        return t
          .replace(/NUM_DIR_LIGHTS/g, e.numDirLights)
          .replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights)
          .replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights)
          .replace(/NUM_POINT_LIGHTS/g, e.numPointLights)
          .replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights);
      }
      function co(t, e) {
        return t
          .replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes)
          .replace(
            /UNION_CLIPPING_PLANES/g,
            e.numClippingPlanes - e.numClipIntersection
          );
      }
      function lo(t) {
        var e = /^[ \t]*#include +<([\w\d.]+)>/gm;
        function n(t, e) {
          var n = ar[e];
          if (void 0 === n)
            throw new Error("Can not resolve #include <" + e + ">");
          return lo(n);
        }
        return t.replace(e, n);
      }
      function ho(t) {
        var e =
          /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;
        function n(t, e, n, i) {
          for (var r = "", a = parseInt(e); a < parseInt(n); a++)
            r += i.replace(/\[ i \]/g, "[ " + a + " ]");
          return r;
        }
        return t.replace(e, n);
      }
      function uo(t, e, n, i, r, a) {
        var o = t.context,
          s = i.defines,
          c = r.vertexShader,
          l = r.fragmentShader,
          h = "SHADOWMAP_TYPE_BASIC";
        a.shadowMapType === p
          ? (h = "SHADOWMAP_TYPE_PCF")
          : a.shadowMapType === f && (h = "SHADOWMAP_TYPE_PCF_SOFT");
        var u = "ENVMAP_TYPE_CUBE",
          d = "ENVMAP_MODE_REFLECTION",
          m = "ENVMAP_BLENDING_MULTIPLY";
        if (a.envMap) {
          switch (i.envMap.mapping) {
            case ct:
            case lt:
              u = "ENVMAP_TYPE_CUBE";
              break;
            case pt:
            case ft:
              u = "ENVMAP_TYPE_CUBE_UV";
              break;
            case ht:
            case ut:
              u = "ENVMAP_TYPE_EQUIREC";
              break;
            case dt:
              u = "ENVMAP_TYPE_SPHERE";
              break;
          }
          switch (i.envMap.mapping) {
            case lt:
            case ut:
              d = "ENVMAP_MODE_REFRACTION";
              break;
          }
          switch (i.combine) {
            case Q:
              m = "ENVMAP_BLENDING_MULTIPLY";
              break;
            case tt:
              m = "ENVMAP_BLENDING_MIX";
              break;
            case et:
              m = "ENVMAP_BLENDING_ADD";
              break;
          }
        }
        var g,
          v,
          y = t.gammaFactor > 0 ? t.gammaFactor : 1,
          x = io(i.extensions, a, e),
          _ = ro(s),
          b = o.createProgram();
        i.isRawShaderMaterial
          ? ((g = [_].filter(oo).join("\n")),
            g.length > 0 && (g += "\n"),
            (v = [x, _].filter(oo).join("\n")),
            v.length > 0 && (v += "\n"))
          : ((g = [
              "precision " + a.precision + " float;",
              "precision " + a.precision + " int;",
              "#define SHADER_NAME " + r.name,
              _,
              a.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "",
              "#define GAMMA_FACTOR " + y,
              "#define MAX_BONES " + a.maxBones,
              a.useFog && a.fog ? "#define USE_FOG" : "",
              a.useFog && a.fogExp ? "#define FOG_EXP2" : "",
              a.map ? "#define USE_MAP" : "",
              a.envMap ? "#define USE_ENVMAP" : "",
              a.envMap ? "#define " + d : "",
              a.lightMap ? "#define USE_LIGHTMAP" : "",
              a.aoMap ? "#define USE_AOMAP" : "",
              a.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
              a.bumpMap ? "#define USE_BUMPMAP" : "",
              a.normalMap ? "#define USE_NORMALMAP" : "",
              a.normalMap && a.objectSpaceNormalMap
                ? "#define OBJECTSPACE_NORMALMAP"
                : "",
              a.displacementMap && a.supportsVertexTextures
                ? "#define USE_DISPLACEMENTMAP"
                : "",
              a.specularMap ? "#define USE_SPECULARMAP" : "",
              a.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
              a.metalnessMap ? "#define USE_METALNESSMAP" : "",
              a.alphaMap ? "#define USE_ALPHAMAP" : "",
              a.vertexColors ? "#define USE_COLOR" : "",
              a.flatShading ? "#define FLAT_SHADED" : "",
              a.skinning ? "#define USE_SKINNING" : "",
              a.useVertexTexture ? "#define BONE_TEXTURE" : "",
              a.morphTargets ? "#define USE_MORPHTARGETS" : "",
              a.morphNormals && !1 === a.flatShading
                ? "#define USE_MORPHNORMALS"
                : "",
              a.doubleSided ? "#define DOUBLE_SIDED" : "",
              a.flipSided ? "#define FLIP_SIDED" : "",
              a.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
              a.shadowMapEnabled ? "#define " + h : "",
              a.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
              a.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
              a.logarithmicDepthBuffer && e.get("EXT_frag_depth")
                ? "#define USE_LOGDEPTHBUF_EXT"
                : "",
              "uniform mat4 modelMatrix;",
              "uniform mat4 modelViewMatrix;",
              "uniform mat4 projectionMatrix;",
              "uniform mat4 viewMatrix;",
              "uniform mat3 normalMatrix;",
              "uniform vec3 cameraPosition;",
              "attribute vec3 position;",
              "attribute vec3 normal;",
              "attribute vec2 uv;",
              "#ifdef USE_COLOR",
              "\tattribute vec3 color;",
              "#endif",
              "#ifdef USE_MORPHTARGETS",
              "\tattribute vec3 morphTarget0;",
              "\tattribute vec3 morphTarget1;",
              "\tattribute vec3 morphTarget2;",
              "\tattribute vec3 morphTarget3;",
              "\t#ifdef USE_MORPHNORMALS",
              "\t\tattribute vec3 morphNormal0;",
              "\t\tattribute vec3 morphNormal1;",
              "\t\tattribute vec3 morphNormal2;",
              "\t\tattribute vec3 morphNormal3;",
              "\t#else",
              "\t\tattribute vec3 morphTarget4;",
              "\t\tattribute vec3 morphTarget5;",
              "\t\tattribute vec3 morphTarget6;",
              "\t\tattribute vec3 morphTarget7;",
              "\t#endif",
              "#endif",
              "#ifdef USE_SKINNING",
              "\tattribute vec4 skinIndex;",
              "\tattribute vec4 skinWeight;",
              "#endif",
              "\n",
            ]
              .filter(oo)
              .join("\n")),
            (v = [
              x,
              "precision " + a.precision + " float;",
              "precision " + a.precision + " int;",
              "#define SHADER_NAME " + r.name,
              _,
              a.alphaTest
                ? "#define ALPHATEST " +
                  a.alphaTest +
                  (a.alphaTest % 1 ? "" : ".0")
                : "",
              "#define GAMMA_FACTOR " + y,
              a.useFog && a.fog ? "#define USE_FOG" : "",
              a.useFog && a.fogExp ? "#define FOG_EXP2" : "",
              a.map ? "#define USE_MAP" : "",
              a.envMap ? "#define USE_ENVMAP" : "",
              a.envMap ? "#define " + u : "",
              a.envMap ? "#define " + d : "",
              a.envMap ? "#define " + m : "",
              a.lightMap ? "#define USE_LIGHTMAP" : "",
              a.aoMap ? "#define USE_AOMAP" : "",
              a.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
              a.bumpMap ? "#define USE_BUMPMAP" : "",
              a.normalMap ? "#define USE_NORMALMAP" : "",
              a.normalMap && a.objectSpaceNormalMap
                ? "#define OBJECTSPACE_NORMALMAP"
                : "",
              a.specularMap ? "#define USE_SPECULARMAP" : "",
              a.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
              a.metalnessMap ? "#define USE_METALNESSMAP" : "",
              a.alphaMap ? "#define USE_ALPHAMAP" : "",
              a.vertexColors ? "#define USE_COLOR" : "",
              a.gradientMap ? "#define USE_GRADIENTMAP" : "",
              a.flatShading ? "#define FLAT_SHADED" : "",
              a.doubleSided ? "#define DOUBLE_SIDED" : "",
              a.flipSided ? "#define FLIP_SIDED" : "",
              a.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
              a.shadowMapEnabled ? "#define " + h : "",
              a.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
              a.physicallyCorrectLights
                ? "#define PHYSICALLY_CORRECT_LIGHTS"
                : "",
              a.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
              a.logarithmicDepthBuffer && e.get("EXT_frag_depth")
                ? "#define USE_LOGDEPTHBUF_EXT"
                : "",
              a.envMap && e.get("EXT_shader_texture_lod")
                ? "#define TEXTURE_LOD_EXT"
                : "",
              "uniform mat4 viewMatrix;",
              "uniform vec3 cameraPosition;",
              a.toneMapping !== nt ? "#define TONE_MAPPING" : "",
              a.toneMapping !== nt ? ar["tonemapping_pars_fragment"] : "",
              a.toneMapping !== nt ? no("toneMapping", a.toneMapping) : "",
              a.dithering ? "#define DITHERING" : "",
              a.outputEncoding ||
              a.mapEncoding ||
              a.envMapEncoding ||
              a.emissiveMapEncoding
                ? ar["encodings_pars_fragment"]
                : "",
              a.mapEncoding ? to("mapTexelToLinear", a.mapEncoding) : "",
              a.envMapEncoding
                ? to("envMapTexelToLinear", a.envMapEncoding)
                : "",
              a.emissiveMapEncoding
                ? to("emissiveMapTexelToLinear", a.emissiveMapEncoding)
                : "",
              a.outputEncoding
                ? eo("linearToOutputTexel", a.outputEncoding)
                : "",
              a.depthPacking ? "#define DEPTH_PACKING " + i.depthPacking : "",
              "\n",
            ]
              .filter(oo)
              .join("\n"))),
          (c = lo(c)),
          (c = so(c, a)),
          (c = co(c, a)),
          (l = lo(l)),
          (l = so(l, a)),
          (l = co(l, a)),
          (c = ho(c)),
          (l = ho(l));
        var w = g + c,
          M = v + l,
          S = Ka(o, o.VERTEX_SHADER, w),
          E = Ka(o, o.FRAGMENT_SHADER, M);
        o.attachShader(b, S),
          o.attachShader(b, E),
          void 0 !== i.index0AttributeName
            ? o.bindAttribLocation(b, 0, i.index0AttributeName)
            : !0 === a.morphTargets && o.bindAttribLocation(b, 0, "position"),
          o.linkProgram(b);
        var T,
          A,
          C = o.getProgramInfoLog(b).trim(),
          R = o.getShaderInfoLog(S).trim(),
          L = o.getShaderInfoLog(E).trim(),
          P = !0,
          D = !0;
        return (
          !1 === o.getProgramParameter(b, o.LINK_STATUS)
            ? ((P = !1),
              console.error(
                "THREE.WebGLProgram: shader error: ",
                o.getError(),
                "gl.VALIDATE_STATUS",
                o.getProgramParameter(b, o.VALIDATE_STATUS),
                "gl.getProgramInfoLog",
                C,
                R,
                L
              ))
            : "" !== C
            ? console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", C)
            : ("" !== R && "" !== L) || (D = !1),
          D &&
            (this.diagnostics = {
              runnable: P,
              material: i,
              programLog: C,
              vertexShader: { log: R, prefix: g },
              fragmentShader: { log: L, prefix: v },
            }),
          o.deleteShader(S),
          o.deleteShader(E),
          (this.getUniforms = function () {
            return void 0 === T && (T = new Ja(o, b, t)), T;
          }),
          (this.getAttributes = function () {
            return void 0 === A && (A = ao(o, b)), A;
          }),
          (this.destroy = function () {
            o.deleteProgram(b), (this.program = void 0);
          }),
          Object.defineProperties(this, {
            uniforms: {
              get: function () {
                return (
                  console.warn(
                    "THREE.WebGLProgram: .uniforms is now .getUniforms()."
                  ),
                  this.getUniforms()
                );
              },
            },
            attributes: {
              get: function () {
                return (
                  console.warn(
                    "THREE.WebGLProgram: .attributes is now .getAttributes()."
                  ),
                  this.getAttributes()
                );
              },
            },
          }),
          (this.name = r.name),
          (this.id = $a++),
          (this.code = n),
          (this.usedTimes = 1),
          (this.program = b),
          (this.vertexShader = S),
          (this.fragmentShader = E),
          this
        );
      }
      function po(t, e, n) {
        var i = [],
          r = {
            MeshDepthMaterial: "depth",
            MeshDistanceMaterial: "distanceRGBA",
            MeshNormalMaterial: "normal",
            MeshBasicMaterial: "basic",
            MeshLambertMaterial: "lambert",
            MeshPhongMaterial: "phong",
            MeshToonMaterial: "phong",
            MeshStandardMaterial: "physical",
            MeshPhysicalMaterial: "physical",
            LineBasicMaterial: "basic",
            LineDashedMaterial: "dashed",
            PointsMaterial: "points",
            ShadowMaterial: "shadow",
          },
          a = [
            "precision",
            "supportsVertexTextures",
            "map",
            "mapEncoding",
            "envMap",
            "envMapMode",
            "envMapEncoding",
            "lightMap",
            "aoMap",
            "emissiveMap",
            "emissiveMapEncoding",
            "bumpMap",
            "normalMap",
            "objectSpaceNormalMap",
            "displacementMap",
            "specularMap",
            "roughnessMap",
            "metalnessMap",
            "gradientMap",
            "alphaMap",
            "combine",
            "vertexColors",
            "fog",
            "useFog",
            "fogExp",
            "flatShading",
            "sizeAttenuation",
            "logarithmicDepthBuffer",
            "skinning",
            "maxBones",
            "useVertexTexture",
            "morphTargets",
            "morphNormals",
            "maxMorphTargets",
            "maxMorphNormals",
            "premultipliedAlpha",
            "numDirLights",
            "numPointLights",
            "numSpotLights",
            "numHemiLights",
            "numRectAreaLights",
            "shadowMapEnabled",
            "shadowMapType",
            "toneMapping",
            "physicallyCorrectLights",
            "alphaTest",
            "doubleSided",
            "flipSided",
            "numClippingPlanes",
            "numClipIntersection",
            "depthPacking",
            "dithering",
          ];
        function o(t) {
          var e = t.skeleton,
            i = e.bones;
          if (n.floatVertexTextures) return 1024;
          var r = n.maxVertexUniforms,
            a = Math.floor((r - 20) / 4),
            o = Math.min(a, i.length);
          return o < i.length
            ? (console.warn(
                "THREE.WebGLRenderer: Skeleton has " +
                  i.length +
                  " bones. This GPU supports " +
                  o +
                  "."
              ),
              0)
            : o;
        }
        function s(t, e) {
          var n;
          return (
            t
              ? t.isTexture
                ? (n = t.encoding)
                : t.isWebGLRenderTarget &&
                  (console.warn(
                    "THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."
                  ),
                  (n = t.texture.encoding))
              : (n = Ee),
            n === Ee && e && (n = Ae),
            n
          );
        }
        (this.getParameters = function (e, i, a, c, l, h, u) {
          var d = r[e.type],
            p = u.isSkinnedMesh ? o(u) : 0,
            f = n.precision;
          null !== e.precision &&
            ((f = n.getMaxPrecision(e.precision)),
            f !== e.precision &&
              console.warn(
                "THREE.WebGLProgram.getParameters:",
                e.precision,
                "not supported, using",
                f,
                "instead."
              ));
          var m = t.getRenderTarget(),
            y = {
              shaderID: d,
              precision: f,
              supportsVertexTextures: n.vertexTextures,
              outputEncoding: s(m ? m.texture : null, t.gammaOutput),
              map: !!e.map,
              mapEncoding: s(e.map, t.gammaInput),
              envMap: !!e.envMap,
              envMapMode: e.envMap && e.envMap.mapping,
              envMapEncoding: s(e.envMap, t.gammaInput),
              envMapCubeUV:
                !!e.envMap &&
                (e.envMap.mapping === pt || e.envMap.mapping === ft),
              lightMap: !!e.lightMap,
              aoMap: !!e.aoMap,
              emissiveMap: !!e.emissiveMap,
              emissiveMapEncoding: s(e.emissiveMap, t.gammaInput),
              bumpMap: !!e.bumpMap,
              normalMap: !!e.normalMap,
              objectSpaceNormalMap: e.normalMapType === Be,
              displacementMap: !!e.displacementMap,
              roughnessMap: !!e.roughnessMap,
              metalnessMap: !!e.metalnessMap,
              specularMap: !!e.specularMap,
              alphaMap: !!e.alphaMap,
              gradientMap: !!e.gradientMap,
              combine: e.combine,
              vertexColors: e.vertexColors,
              fog: !!c,
              useFog: e.fog,
              fogExp: c && c.isFogExp2,
              flatShading: e.flatShading,
              sizeAttenuation: e.sizeAttenuation,
              logarithmicDepthBuffer: n.logarithmicDepthBuffer,
              skinning: e.skinning && p > 0,
              maxBones: p,
              useVertexTexture: n.floatVertexTextures,
              morphTargets: e.morphTargets,
              morphNormals: e.morphNormals,
              maxMorphTargets: t.maxMorphTargets,
              maxMorphNormals: t.maxMorphNormals,
              numDirLights: i.directional.length,
              numPointLights: i.point.length,
              numSpotLights: i.spot.length,
              numRectAreaLights: i.rectArea.length,
              numHemiLights: i.hemi.length,
              numClippingPlanes: l,
              numClipIntersection: h,
              dithering: e.dithering,
              shadowMapEnabled:
                t.shadowMap.enabled && u.receiveShadow && a.length > 0,
              shadowMapType: t.shadowMap.type,
              toneMapping: t.toneMapping,
              physicallyCorrectLights: t.physicallyCorrectLights,
              premultipliedAlpha: e.premultipliedAlpha,
              alphaTest: e.alphaTest,
              doubleSided: e.side === v,
              flipSided: e.side === g,
              depthPacking: void 0 !== e.depthPacking && e.depthPacking,
            };
          return y;
        }),
          (this.getProgramCode = function (e, n) {
            var i = [];
            if (
              (n.shaderID
                ? i.push(n.shaderID)
                : (i.push(e.fragmentShader), i.push(e.vertexShader)),
              void 0 !== e.defines)
            )
              for (var r in e.defines) i.push(r), i.push(e.defines[r]);
            for (var o = 0; o < a.length; o++) i.push(n[a[o]]);
            return (
              i.push(e.onBeforeCompile.toString()),
              i.push(t.gammaOutput),
              i.join()
            );
          }),
          (this.acquireProgram = function (n, r, a, o) {
            for (var s, c = 0, l = i.length; c < l; c++) {
              var h = i[c];
              if (h.code === o) {
                (s = h), ++s.usedTimes;
                break;
              }
            }
            return (
              void 0 === s && ((s = new uo(t, e, o, n, r, a)), i.push(s)), s
            );
          }),
          (this.releaseProgram = function (t) {
            if (0 === --t.usedTimes) {
              var e = i.indexOf(t);
              (i[e] = i[i.length - 1]), i.pop(), t.destroy();
            }
          }),
          (this.programs = i);
      }
      function fo() {
        var t = new WeakMap();
        function e(e) {
          var n = t.get(e);
          return void 0 === n && ((n = {}), t.set(e, n)), n;
        }
        function n(e) {
          t.delete(e);
        }
        function i(e, n, i) {
          t.get(e)[n] = i;
        }
        function r() {
          t = new WeakMap();
        }
        return { get: e, remove: n, update: i, dispose: r };
      }
      function mo(t, e) {
        return t.renderOrder !== e.renderOrder
          ? t.renderOrder - e.renderOrder
          : t.program && e.program && t.program !== e.program
          ? t.program.id - e.program.id
          : t.material.id !== e.material.id
          ? t.material.id - e.material.id
          : t.z !== e.z
          ? t.z - e.z
          : t.id - e.id;
      }
      function go(t, e) {
        return t.renderOrder !== e.renderOrder
          ? t.renderOrder - e.renderOrder
          : t.z !== e.z
          ? e.z - t.z
          : t.id - e.id;
      }
      function vo() {
        var t = [],
          e = 0,
          n = [],
          i = [];
        function r() {
          (e = 0), (n.length = 0), (i.length = 0);
        }
        function a(r, a, o, s, c) {
          var l = t[e];
          void 0 === l
            ? ((l = {
                id: r.id,
                object: r,
                geometry: a,
                material: o,
                program: o.program,
                renderOrder: r.renderOrder,
                z: s,
                group: c,
              }),
              (t[e] = l))
            : ((l.id = r.id),
              (l.object = r),
              (l.geometry = a),
              (l.material = o),
              (l.program = o.program),
              (l.renderOrder = r.renderOrder),
              (l.z = s),
              (l.group = c)),
            (!0 === o.transparent ? i : n).push(l),
            e++;
        }
        function o() {
          n.length > 1 && n.sort(mo), i.length > 1 && i.sort(go);
        }
        return { opaque: n, transparent: i, init: r, push: a, sort: o };
      }
      function yo() {
        var t = {};
        function e(e, n) {
          var i = e.id + "," + n.id,
            r = t[i];
          return void 0 === r && ((r = new vo()), (t[i] = r)), r;
        }
        function n() {
          t = {};
        }
        return { get: e, dispose: n };
      }
      function xo() {
        var t = {};
        return {
          get: function (e) {
            if (void 0 !== t[e.id]) return t[e.id];
            var n;
            switch (e.type) {
              case "DirectionalLight":
                n = {
                  direction: new ke(),
                  color: new cr(),
                  shadow: !1,
                  shadowBias: 0,
                  shadowRadius: 1,
                  shadowMapSize: new Ue(),
                };
                break;
              case "SpotLight":
                n = {
                  position: new ke(),
                  direction: new ke(),
                  color: new cr(),
                  distance: 0,
                  coneCos: 0,
                  penumbraCos: 0,
                  decay: 0,
                  shadow: !1,
                  shadowBias: 0,
                  shadowRadius: 1,
                  shadowMapSize: new Ue(),
                };
                break;
              case "PointLight":
                n = {
                  position: new ke(),
                  color: new cr(),
                  distance: 0,
                  decay: 0,
                  shadow: !1,
                  shadowBias: 0,
                  shadowRadius: 1,
                  shadowMapSize: new Ue(),
                  shadowCameraNear: 1,
                  shadowCameraFar: 1e3,
                };
                break;
              case "HemisphereLight":
                n = {
                  direction: new ke(),
                  skyColor: new cr(),
                  groundColor: new cr(),
                };
                break;
              case "RectAreaLight":
                n = {
                  color: new cr(),
                  position: new ke(),
                  halfWidth: new ke(),
                  halfHeight: new ke(),
                };
                break;
            }
            return (t[e.id] = n), n;
          },
        };
      }
      var _o = 0;
      function bo() {
        var t = new xo(),
          e = {
            id: _o++,
            hash: "",
            ambient: [0, 0, 0],
            directional: [],
            directionalShadowMap: [],
            directionalShadowMatrix: [],
            spot: [],
            spotShadowMap: [],
            spotShadowMatrix: [],
            rectArea: [],
            point: [],
            pointShadowMap: [],
            pointShadowMatrix: [],
            hemi: [],
          },
          n = new ke(),
          i = new Fe(),
          r = new Fe();
        function a(a, o, s) {
          for (
            var c = 0,
              l = 0,
              h = 0,
              u = 0,
              d = 0,
              p = 0,
              f = 0,
              m = 0,
              g = s.matrixWorldInverse,
              v = 0,
              y = a.length;
            v < y;
            v++
          ) {
            var x = a[v],
              _ = x.color,
              b = x.intensity,
              w = x.distance,
              M = x.shadow && x.shadow.map ? x.shadow.map.texture : null;
            if (x.isAmbientLight)
              (c += _.r * b), (l += _.g * b), (h += _.b * b);
            else if (x.isDirectionalLight) {
              var S = t.get(x);
              if (
                (S.color.copy(x.color).multiplyScalar(x.intensity),
                S.direction.setFromMatrixPosition(x.matrixWorld),
                n.setFromMatrixPosition(x.target.matrixWorld),
                S.direction.sub(n),
                S.direction.transformDirection(g),
                (S.shadow = x.castShadow),
                x.castShadow)
              ) {
                var E = x.shadow;
                (S.shadowBias = E.bias),
                  (S.shadowRadius = E.radius),
                  (S.shadowMapSize = E.mapSize);
              }
              (e.directionalShadowMap[u] = M),
                (e.directionalShadowMatrix[u] = x.shadow.matrix),
                (e.directional[u] = S),
                u++;
            } else if (x.isSpotLight) {
              S = t.get(x);
              if (
                (S.position.setFromMatrixPosition(x.matrixWorld),
                S.position.applyMatrix4(g),
                S.color.copy(_).multiplyScalar(b),
                (S.distance = w),
                S.direction.setFromMatrixPosition(x.matrixWorld),
                n.setFromMatrixPosition(x.target.matrixWorld),
                S.direction.sub(n),
                S.direction.transformDirection(g),
                (S.coneCos = Math.cos(x.angle)),
                (S.penumbraCos = Math.cos(x.angle * (1 - x.penumbra))),
                (S.decay = 0 === x.distance ? 0 : x.decay),
                (S.shadow = x.castShadow),
                x.castShadow)
              ) {
                E = x.shadow;
                (S.shadowBias = E.bias),
                  (S.shadowRadius = E.radius),
                  (S.shadowMapSize = E.mapSize);
              }
              (e.spotShadowMap[p] = M),
                (e.spotShadowMatrix[p] = x.shadow.matrix),
                (e.spot[p] = S),
                p++;
            } else if (x.isRectAreaLight) {
              S = t.get(x);
              S.color.copy(_).multiplyScalar(b),
                S.position.setFromMatrixPosition(x.matrixWorld),
                S.position.applyMatrix4(g),
                r.identity(),
                i.copy(x.matrixWorld),
                i.premultiply(g),
                r.extractRotation(i),
                S.halfWidth.set(0.5 * x.width, 0, 0),
                S.halfHeight.set(0, 0.5 * x.height, 0),
                S.halfWidth.applyMatrix4(r),
                S.halfHeight.applyMatrix4(r),
                (e.rectArea[f] = S),
                f++;
            } else if (x.isPointLight) {
              S = t.get(x);
              if (
                (S.position.setFromMatrixPosition(x.matrixWorld),
                S.position.applyMatrix4(g),
                S.color.copy(x.color).multiplyScalar(x.intensity),
                (S.distance = x.distance),
                (S.decay = 0 === x.distance ? 0 : x.decay),
                (S.shadow = x.castShadow),
                x.castShadow)
              ) {
                E = x.shadow;
                (S.shadowBias = E.bias),
                  (S.shadowRadius = E.radius),
                  (S.shadowMapSize = E.mapSize),
                  (S.shadowCameraNear = E.camera.near),
                  (S.shadowCameraFar = E.camera.far);
              }
              (e.pointShadowMap[d] = M),
                (e.pointShadowMatrix[d] = x.shadow.matrix),
                (e.point[d] = S),
                d++;
            } else if (x.isHemisphereLight) {
              S = t.get(x);
              S.direction.setFromMatrixPosition(x.matrixWorld),
                S.direction.transformDirection(g),
                S.direction.normalize(),
                S.skyColor.copy(x.color).multiplyScalar(b),
                S.groundColor.copy(x.groundColor).multiplyScalar(b),
                (e.hemi[m] = S),
                m++;
            }
          }
          (e.ambient[0] = c),
            (e.ambient[1] = l),
            (e.ambient[2] = h),
            (e.directional.length = u),
            (e.spot.length = p),
            (e.rectArea.length = f),
            (e.point.length = d),
            (e.hemi.length = m),
            (e.hash =
              e.id +
              "," +
              u +
              "," +
              d +
              "," +
              p +
              "," +
              f +
              "," +
              m +
              "," +
              o.length);
        }
        return { setup: a, state: e };
      }
      function wo() {
        var t = new bo(),
          e = [],
          n = [],
          i = [];
        function r() {
          (e.length = 0), (n.length = 0), (i.length = 0);
        }
        function a(t) {
          e.push(t);
        }
        function o(t) {
          n.push(t);
        }
        function s(t) {
          i.push(t);
        }
        function c(i) {
          t.setup(e, n, i);
        }
        var l = { lightsArray: e, shadowsArray: n, spritesArray: i, lights: t };
        return {
          init: r,
          state: l,
          setupLights: c,
          pushLight: a,
          pushShadow: o,
          pushSprite: s,
        };
      }
      function Mo() {
        var t = {};
        function e(e, n) {
          var i = e.id + "," + n.id,
            r = t[i];
          return void 0 === r && ((r = new wo()), (t[i] = r)), r;
        }
        function n() {
          t = {};
        }
        return { get: e, dispose: n };
      }
      function So(t) {
        kr.call(this),
          (this.type = "MeshDepthMaterial"),
          (this.depthPacking = Ie),
          (this.skinning = !1),
          (this.morphTargets = !1),
          (this.map = null),
          (this.alphaMap = null),
          (this.displacementMap = null),
          (this.displacementScale = 1),
          (this.displacementBias = 0),
          (this.wireframe = !1),
          (this.wireframeLinewidth = 1),
          (this.fog = !1),
          (this.lights = !1),
          this.setValues(t);
      }
      function Eo(t) {
        kr.call(this),
          (this.type = "MeshDistanceMaterial"),
          (this.referencePosition = new ke()),
          (this.nearDistance = 1),
          (this.farDistance = 1e3),
          (this.skinning = !1),
          (this.morphTargets = !1),
          (this.map = null),
          (this.alphaMap = null),
          (this.displacementMap = null),
          (this.displacementScale = 1),
          (this.displacementBias = 0),
          (this.fog = !1),
          (this.lights = !1),
          this.setValues(t);
      }
      function To(t, e, n) {
        for (
          var i = new $e(),
            r = new Fe(),
            a = new Ue(),
            o = new Ue(n, n),
            s = new ke(),
            c = new ke(),
            l = 1,
            h = 2,
            u = 1 + (l | h),
            d = new Array(u),
            f = new Array(u),
            y = {},
            x = { 0: g, 1: m, 2: v },
            _ = [
              new ke(1, 0, 0),
              new ke(-1, 0, 0),
              new ke(0, 0, 1),
              new ke(0, 0, -1),
              new ke(0, 1, 0),
              new ke(0, -1, 0),
            ],
            b = [
              new ke(0, 1, 0),
              new ke(0, 1, 0),
              new ke(0, 1, 0),
              new ke(0, 1, 0),
              new ke(0, 0, 1),
              new ke(0, 0, -1),
            ],
            w = [new je(), new je(), new je(), new je(), new je(), new je()],
            M = 0;
          M !== u;
          ++M
        ) {
          var S = 0 !== (M & l),
            E = 0 !== (M & h),
            T = new So({ depthPacking: Oe, morphTargets: S, skinning: E });
          d[M] = T;
          var A = new Eo({ morphTargets: S, skinning: E });
          f[M] = A;
        }
        var C = this;
        function R(e, n, i, r, a, o) {
          var s = e.geometry,
            c = null,
            u = d,
            p = e.customDepthMaterial;
          if ((i && ((u = f), (p = e.customDistanceMaterial)), p)) c = p;
          else {
            var m = !1;
            n.morphTargets &&
              (s && s.isBufferGeometry
                ? (m =
                    s.morphAttributes &&
                    s.morphAttributes.position &&
                    s.morphAttributes.position.length > 0)
                : s &&
                  s.isGeometry &&
                  (m = s.morphTargets && s.morphTargets.length > 0)),
              e.isSkinnedMesh &&
                !1 === n.skinning &&
                console.warn(
                  "THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:",
                  e
                );
            var g = e.isSkinnedMesh && n.skinning,
              v = 0;
            m && (v |= l), g && (v |= h), (c = u[v]);
          }
          if (
            t.localClippingEnabled &&
            !0 === n.clipShadows &&
            0 !== n.clippingPlanes.length
          ) {
            var _ = c.uuid,
              b = n.uuid,
              w = y[_];
            void 0 === w && ((w = {}), (y[_] = w));
            var M = w[b];
            void 0 === M && ((M = c.clone()), (w[b] = M)), (c = M);
          }
          return (
            (c.visible = n.visible),
            (c.wireframe = n.wireframe),
            (c.side = null != n.shadowSide ? n.shadowSide : x[n.side]),
            (c.clipShadows = n.clipShadows),
            (c.clippingPlanes = n.clippingPlanes),
            (c.clipIntersection = n.clipIntersection),
            (c.wireframeLinewidth = n.wireframeLinewidth),
            (c.linewidth = n.linewidth),
            i &&
              c.isMeshDistanceMaterial &&
              (c.referencePosition.copy(r),
              (c.nearDistance = a),
              (c.farDistance = o)),
            c
          );
        }
        function L(n, r, a, o) {
          if (!1 !== n.visible) {
            var s = n.layers.test(r.layers);
            if (
              s &&
              (n.isMesh || n.isLine || n.isPoints) &&
              n.castShadow &&
              (!n.frustumCulled || i.intersectsObject(n))
            ) {
              n.modelViewMatrix.multiplyMatrices(
                a.matrixWorldInverse,
                n.matrixWorld
              );
              var l = e.update(n),
                h = n.material;
              if (Array.isArray(h))
                for (var u = l.groups, d = 0, p = u.length; d < p; d++) {
                  var f = u[d],
                    m = h[f.materialIndex];
                  if (m && m.visible) {
                    var g = R(n, m, o, c, a.near, a.far);
                    t.renderBufferDirect(a, null, l, g, n, f);
                  }
                }
              else if (h.visible) {
                g = R(n, h, o, c, a.near, a.far);
                t.renderBufferDirect(a, null, l, g, n, null);
              }
            }
            for (var v = n.children, y = 0, x = v.length; y < x; y++)
              L(v[y], r, a, o);
          }
        }
        (this.enabled = !1),
          (this.autoUpdate = !0),
          (this.needsUpdate = !1),
          (this.type = p),
          (this.render = function (e, n, l) {
            if (
              !1 !== C.enabled &&
              (!1 !== C.autoUpdate || !1 !== C.needsUpdate) &&
              0 !== e.length
            ) {
              var h,
                u = t.context,
                d = t.state;
              d.disable(u.BLEND),
                d.buffers.color.setClear(1, 1, 1, 1),
                d.buffers.depth.setTest(!0),
                d.setScissorTest(!1);
              for (var p = 0, f = e.length; p < f; p++) {
                var m = e[p],
                  g = m.shadow,
                  v = m && m.isPointLight;
                if (void 0 !== g) {
                  var y = g.camera;
                  if ((a.copy(g.mapSize), a.min(o), v)) {
                    var x = a.x,
                      M = a.y;
                    w[0].set(2 * x, M, x, M),
                      w[1].set(0, M, x, M),
                      w[2].set(3 * x, M, x, M),
                      w[3].set(x, M, x, M),
                      w[4].set(3 * x, 0, x, M),
                      w[5].set(x, 0, x, M),
                      (a.x *= 4),
                      (a.y *= 2);
                  }
                  if (null === g.map) {
                    var S = { minFilter: yt, magFilter: yt, format: Ut };
                    (g.map = new qe(a.x, a.y, S)),
                      (g.map.texture.name = m.name + ".shadowMap"),
                      y.updateProjectionMatrix();
                  }
                  g.isSpotLightShadow && g.update(m);
                  var E = g.map,
                    T = g.matrix;
                  c.setFromMatrixPosition(m.matrixWorld),
                    y.position.copy(c),
                    v
                      ? ((h = 6), T.makeTranslation(-c.x, -c.y, -c.z))
                      : ((h = 1),
                        s.setFromMatrixPosition(m.target.matrixWorld),
                        y.lookAt(s),
                        y.updateMatrixWorld(),
                        T.set(
                          0.5,
                          0,
                          0,
                          0.5,
                          0,
                          0.5,
                          0,
                          0.5,
                          0,
                          0,
                          0.5,
                          0.5,
                          0,
                          0,
                          0,
                          1
                        ),
                        T.multiply(y.projectionMatrix),
                        T.multiply(y.matrixWorldInverse)),
                    t.setRenderTarget(E),
                    t.clear();
                  for (var A = 0; A < h; A++) {
                    if (v) {
                      s.copy(y.position),
                        s.add(_[A]),
                        y.up.copy(b[A]),
                        y.lookAt(s),
                        y.updateMatrixWorld();
                      var R = w[A];
                      d.viewport(R);
                    }
                    r.multiplyMatrices(
                      y.projectionMatrix,
                      y.matrixWorldInverse
                    ),
                      i.setFromMatrix(r),
                      L(n, l, y, v);
                  }
                } else
                  console.warn("THREE.WebGLShadowMap:", m, "has no shadow.");
              }
              C.needsUpdate = !1;
            }
          });
      }
      function Ao(t, e, n, i, r, a, o, s, c) {
        We.call(this, t, e, n, i, r, a, o, s, c), (this.needsUpdate = !0);
      }
      function Co(t, e, n, i, r) {
        var a,
          o,
          s,
          c,
          l,
          h,
          u = new ke(),
          d = new He(),
          p = new ke();
        function f() {
          var t = new Float32Array([
              -0.5, -0.5, 0, 0, 0.5, -0.5, 1, 0, 0.5, 0.5, 1, 1, -0.5, 0.5, 0,
              1,
            ]),
            n = new Uint16Array([0, 1, 2, 0, 2, 3]);
          (a = e.createBuffer()),
            (o = e.createBuffer()),
            e.bindBuffer(e.ARRAY_BUFFER, a),
            e.bufferData(e.ARRAY_BUFFER, t, e.STATIC_DRAW),
            e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, o),
            e.bufferData(e.ELEMENT_ARRAY_BUFFER, n, e.STATIC_DRAW),
            (s = m()),
            (c = {
              position: e.getAttribLocation(s, "position"),
              uv: e.getAttribLocation(s, "uv"),
            }),
            (l = {
              uvOffset: e.getUniformLocation(s, "uvOffset"),
              uvScale: e.getUniformLocation(s, "uvScale"),
              rotation: e.getUniformLocation(s, "rotation"),
              center: e.getUniformLocation(s, "center"),
              scale: e.getUniformLocation(s, "scale"),
              color: e.getUniformLocation(s, "color"),
              map: e.getUniformLocation(s, "map"),
              opacity: e.getUniformLocation(s, "opacity"),
              modelViewMatrix: e.getUniformLocation(s, "modelViewMatrix"),
              projectionMatrix: e.getUniformLocation(s, "projectionMatrix"),
              fogType: e.getUniformLocation(s, "fogType"),
              fogDensity: e.getUniformLocation(s, "fogDensity"),
              fogNear: e.getUniformLocation(s, "fogNear"),
              fogFar: e.getUniformLocation(s, "fogFar"),
              fogColor: e.getUniformLocation(s, "fogColor"),
              fogDepth: e.getUniformLocation(s, "fogDepth"),
              alphaTest: e.getUniformLocation(s, "alphaTest"),
            });
          var i = document.createElementNS(
            "http://www.w3.org/1999/xhtml",
            "canvas"
          );
          (i.width = 8), (i.height = 8);
          var r = i.getContext("2d");
          (r.fillStyle = "white"), r.fillRect(0, 0, 8, 8), (h = new Ao(i));
        }
        function m() {
          var t = e.createProgram(),
            n = e.createShader(e.VERTEX_SHADER),
            i = e.createShader(e.FRAGMENT_SHADER);
          return (
            e.shaderSource(
              n,
              [
                "precision " + r.precision + " float;",
                "#define SHADER_NAME SpriteMaterial",
                "uniform mat4 modelViewMatrix;",
                "uniform mat4 projectionMatrix;",
                "uniform float rotation;",
                "uniform vec2 center;",
                "uniform vec2 scale;",
                "uniform vec2 uvOffset;",
                "uniform vec2 uvScale;",
                "attribute vec2 position;",
                "attribute vec2 uv;",
                "varying vec2 vUV;",
                "varying float fogDepth;",
                "void main() {",
                "\tvUV = uvOffset + uv * uvScale;",
                "\tvec2 alignedPosition = ( position - center ) * scale;",
                "\tvec2 rotatedPosition;",
                "\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;",
                "\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;",
                "\tvec4 mvPosition;",
                "\tmvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );",
                "\tmvPosition.xy += rotatedPosition;",
                "\tgl_Position = projectionMatrix * mvPosition;",
                "\tfogDepth = - mvPosition.z;",
                "}",
              ].join("\n")
            ),
            e.shaderSource(
              i,
              [
                "precision " + r.precision + " float;",
                "#define SHADER_NAME SpriteMaterial",
                "uniform vec3 color;",
                "uniform sampler2D map;",
                "uniform float opacity;",
                "uniform int fogType;",
                "uniform vec3 fogColor;",
                "uniform float fogDensity;",
                "uniform float fogNear;",
                "uniform float fogFar;",
                "uniform float alphaTest;",
                "varying vec2 vUV;",
                "varying float fogDepth;",
                "void main() {",
                "\tvec4 texture = texture2D( map, vUV );",
                "\tgl_FragColor = vec4( color * texture.xyz, texture.a * opacity );",
                "\tif ( gl_FragColor.a < alphaTest ) discard;",
                "\tif ( fogType > 0 ) {",
                "\t\tfloat fogFactor = 0.0;",
                "\t\tif ( fogType == 1 ) {",
                "\t\t\tfogFactor = smoothstep( fogNear, fogFar, fogDepth );",
                "\t\t} else {",
                "\t\t\tconst float LOG2 = 1.442695;",
                "\t\t\tfogFactor = exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 );",
                "\t\t\tfogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );",
                "\t\t}",
                "\t\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );",
                "\t}",
                "}",
              ].join("\n")
            ),
            e.compileShader(n),
            e.compileShader(i),
            e.attachShader(t, n),
            e.attachShader(t, i),
            e.linkProgram(t),
            t
          );
        }
        function g(t, e) {
          return t.renderOrder !== e.renderOrder
            ? t.renderOrder - e.renderOrder
            : t.z !== e.z
            ? e.z - t.z
            : e.id - t.id;
        }
        this.render = function (r, m, v) {
          if (0 !== r.length) {
            void 0 === s && f(),
              n.useProgram(s),
              n.initAttributes(),
              n.enableAttribute(c.position),
              n.enableAttribute(c.uv),
              n.disableUnusedAttributes(),
              n.disable(e.CULL_FACE),
              n.enable(e.BLEND),
              e.bindBuffer(e.ARRAY_BUFFER, a),
              e.vertexAttribPointer(c.position, 2, e.FLOAT, !1, 16, 0),
              e.vertexAttribPointer(c.uv, 2, e.FLOAT, !1, 16, 8),
              e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, o),
              e.uniformMatrix4fv(
                l.projectionMatrix,
                !1,
                v.projectionMatrix.elements
              ),
              n.activeTexture(e.TEXTURE0),
              e.uniform1i(l.map, 0);
            var y = 0,
              x = 0,
              _ = m.fog;
            _
              ? (e.uniform3f(l.fogColor, _.color.r, _.color.g, _.color.b),
                _.isFog
                  ? (e.uniform1f(l.fogNear, _.near),
                    e.uniform1f(l.fogFar, _.far),
                    e.uniform1i(l.fogType, 1),
                    (y = 1),
                    (x = 1))
                  : _.isFogExp2 &&
                    (e.uniform1f(l.fogDensity, _.density),
                    e.uniform1i(l.fogType, 2),
                    (y = 2),
                    (x = 2)))
              : (e.uniform1i(l.fogType, 0), (y = 0), (x = 0));
            for (var b = 0, w = r.length; b < w; b++) {
              var M = r[b];
              M.modelViewMatrix.multiplyMatrices(
                v.matrixWorldInverse,
                M.matrixWorld
              ),
                (M.z = -M.modelViewMatrix.elements[14]);
            }
            r.sort(g);
            var S = [],
              E = [];
            for (b = 0, w = r.length; b < w; b++) {
              M = r[b];
              var T = M.material;
              if (!1 !== T.visible) {
                M.onBeforeRender(t, m, v, void 0, T, void 0),
                  e.uniform1f(l.alphaTest, T.alphaTest),
                  e.uniformMatrix4fv(
                    l.modelViewMatrix,
                    !1,
                    M.modelViewMatrix.elements
                  ),
                  M.matrixWorld.decompose(u, d, p),
                  (S[0] = p.x),
                  (S[1] = p.y),
                  (E[0] = M.center.x - 0.5),
                  (E[1] = M.center.y - 0.5);
                var A = 0;
                m.fog && T.fog && (A = x),
                  y !== A && (e.uniform1i(l.fogType, A), (y = A)),
                  null !== T.map
                    ? (e.uniform2f(l.uvOffset, T.map.offset.x, T.map.offset.y),
                      e.uniform2f(l.uvScale, T.map.repeat.x, T.map.repeat.y))
                    : (e.uniform2f(l.uvOffset, 0, 0),
                      e.uniform2f(l.uvScale, 1, 1)),
                  e.uniform1f(l.opacity, T.opacity),
                  e.uniform3f(l.color, T.color.r, T.color.g, T.color.b),
                  e.uniform1f(l.rotation, T.rotation),
                  e.uniform2fv(l.center, E),
                  e.uniform2fv(l.scale, S),
                  n.setBlending(
                    T.blending,
                    T.blendEquation,
                    T.blendSrc,
                    T.blendDst,
                    T.blendEquationAlpha,
                    T.blendSrcAlpha,
                    T.blendDstAlpha,
                    T.premultipliedAlpha
                  ),
                  n.buffers.depth.setTest(T.depthTest),
                  n.buffers.depth.setMask(T.depthWrite),
                  n.buffers.color.setMask(T.colorWrite),
                  i.setTexture2D(T.map || h, 0),
                  e.drawElements(e.TRIANGLES, 6, e.UNSIGNED_SHORT, 0),
                  M.onAfterRender(t, m, v, void 0, T, void 0);
              }
            }
            n.enable(e.CULL_FACE), n.reset();
          }
        };
      }
      function Ro(t, e, n) {
        function i() {
          var e = !1,
            n = new je(),
            i = null,
            r = new je(0, 0, 0, 0);
          return {
            setMask: function (n) {
              i === n || e || (t.colorMask(n, n, n, n), (i = n));
            },
            setLocked: function (t) {
              e = t;
            },
            setClear: function (e, i, a, o, s) {
              !0 === s && ((e *= o), (i *= o), (a *= o)),
                n.set(e, i, a, o),
                !1 === r.equals(n) && (t.clearColor(e, i, a, o), r.copy(n));
            },
            reset: function () {
              (e = !1), (i = null), r.set(-1, 0, 0, 0);
            },
          };
        }
        function r() {
          var e = !1,
            n = null,
            i = null,
            r = null;
          return {
            setTest: function (e) {
              e ? ct(t.DEPTH_TEST) : lt(t.DEPTH_TEST);
            },
            setMask: function (i) {
              n === i || e || (t.depthMask(i), (n = i));
            },
            setFunc: function (e) {
              if (i !== e) {
                if (e)
                  switch (e) {
                    case j:
                      t.depthFunc(t.NEVER);
                      break;
                    case q:
                      t.depthFunc(t.ALWAYS);
                      break;
                    case X:
                      t.depthFunc(t.LESS);
                      break;
                    case Y:
                      t.depthFunc(t.LEQUAL);
                      break;
                    case J:
                      t.depthFunc(t.EQUAL);
                      break;
                    case Z:
                      t.depthFunc(t.GEQUAL);
                      break;
                    case K:
                      t.depthFunc(t.GREATER);
                      break;
                    case $:
                      t.depthFunc(t.NOTEQUAL);
                      break;
                    default:
                      t.depthFunc(t.LEQUAL);
                  }
                else t.depthFunc(t.LEQUAL);
                i = e;
              }
            },
            setLocked: function (t) {
              e = t;
            },
            setClear: function (e) {
              r !== e && (t.clearDepth(e), (r = e));
            },
            reset: function () {
              (e = !1), (n = null), (i = null), (r = null);
            },
          };
        }
        function a() {
          var e = !1,
            n = null,
            i = null,
            r = null,
            a = null,
            o = null,
            s = null,
            c = null,
            l = null;
          return {
            setTest: function (e) {
              e ? ct(t.STENCIL_TEST) : lt(t.STENCIL_TEST);
            },
            setMask: function (i) {
              n === i || e || (t.stencilMask(i), (n = i));
            },
            setFunc: function (e, n, o) {
              (i === e && r === n && a === o) ||
                (t.stencilFunc(e, n, o), (i = e), (r = n), (a = o));
            },
            setOp: function (e, n, i) {
              (o === e && s === n && c === i) ||
                (t.stencilOp(e, n, i), (o = e), (s = n), (c = i));
            },
            setLocked: function (t) {
              e = t;
            },
            setClear: function (e) {
              l !== e && (t.clearStencil(e), (l = e));
            },
            reset: function () {
              (e = !1),
                (n = null),
                (i = null),
                (r = null),
                (a = null),
                (o = null),
                (s = null),
                (c = null),
                (l = null);
            },
          };
        }
        var l = new i(),
          h = new r(),
          u = new a(),
          d = t.getParameter(t.MAX_VERTEX_ATTRIBS),
          p = new Uint8Array(d),
          f = new Uint8Array(d),
          m = new Uint8Array(d),
          y = {},
          x = null,
          _ = null,
          b = null,
          w = null,
          R = null,
          L = null,
          P = null,
          D = null,
          I = null,
          O = !1,
          N = null,
          B = null,
          z = null,
          U = null,
          F = null,
          H = t.getParameter(t.MAX_COMBINED_TEXTURE_IMAGE_UNITS),
          k = !1,
          G = 0,
          V = t.getParameter(t.VERSION);
        -1 !== V.indexOf("WebGL")
          ? ((G = parseFloat(/^WebGL\ ([0-9])/.exec(V)[1])), (k = G >= 1))
          : -1 !== V.indexOf("OpenGL ES") &&
            ((G = parseFloat(/^OpenGL\ ES\ ([0-9])/.exec(V)[1])), (k = G >= 2));
        var W = null,
          Q = {},
          tt = new je(),
          et = new je();
        function nt(e, n, i) {
          var r = new Uint8Array(4),
            a = t.createTexture();
          t.bindTexture(e, a),
            t.texParameteri(e, t.TEXTURE_MIN_FILTER, t.NEAREST),
            t.texParameteri(e, t.TEXTURE_MAG_FILTER, t.NEAREST);
          for (var o = 0; o < i; o++)
            t.texImage2D(n + o, 0, t.RGBA, 1, 1, 0, t.RGBA, t.UNSIGNED_BYTE, r);
          return a;
        }
        var it = {};
        function rt() {
          for (var t = 0, e = p.length; t < e; t++) p[t] = 0;
        }
        function at(t) {
          ot(t, 0);
        }
        function ot(n, i) {
          if (
            ((p[n] = 1),
            0 === f[n] && (t.enableVertexAttribArray(n), (f[n] = 1)),
            m[n] !== i)
          ) {
            var r = e.get("ANGLE_instanced_arrays");
            r.vertexAttribDivisorANGLE(n, i), (m[n] = i);
          }
        }
        function st() {
          for (var e = 0, n = f.length; e !== n; ++e)
            f[e] !== p[e] && (t.disableVertexAttribArray(e), (f[e] = 0));
        }
        function ct(e) {
          !0 !== y[e] && (t.enable(e), (y[e] = !0));
        }
        function lt(e) {
          !1 !== y[e] && (t.disable(e), (y[e] = !1));
        }
        function ht() {
          if (
            null === x &&
            ((x = []),
            e.get("WEBGL_compressed_texture_pvrtc") ||
              e.get("WEBGL_compressed_texture_s3tc") ||
              e.get("WEBGL_compressed_texture_etc1") ||
              e.get("WEBGL_compressed_texture_astc"))
          )
            for (
              var n = t.getParameter(t.COMPRESSED_TEXTURE_FORMATS), i = 0;
              i < n.length;
              i++
            )
              x.push(n[i]);
          return x;
        }
        function ut(e) {
          return _ !== e && (t.useProgram(e), (_ = e), !0);
        }
        function dt(e, i, r, a, o, s, c, l) {
          if ((e !== M ? ct(t.BLEND) : lt(t.BLEND), e !== C)) {
            if (e !== b || l !== O)
              switch (e) {
                case E:
                  l
                    ? (t.blendEquationSeparate(t.FUNC_ADD, t.FUNC_ADD),
                      t.blendFuncSeparate(t.ONE, t.ONE, t.ONE, t.ONE))
                    : (t.blendEquation(t.FUNC_ADD),
                      t.blendFunc(t.SRC_ALPHA, t.ONE));
                  break;
                case T:
                  l
                    ? (t.blendEquationSeparate(t.FUNC_ADD, t.FUNC_ADD),
                      t.blendFuncSeparate(
                        t.ZERO,
                        t.ZERO,
                        t.ONE_MINUS_SRC_COLOR,
                        t.ONE_MINUS_SRC_ALPHA
                      ))
                    : (t.blendEquation(t.FUNC_ADD),
                      t.blendFunc(t.ZERO, t.ONE_MINUS_SRC_COLOR));
                  break;
                case A:
                  l
                    ? (t.blendEquationSeparate(t.FUNC_ADD, t.FUNC_ADD),
                      t.blendFuncSeparate(
                        t.ZERO,
                        t.SRC_COLOR,
                        t.ZERO,
                        t.SRC_ALPHA
                      ))
                    : (t.blendEquation(t.FUNC_ADD),
                      t.blendFunc(t.ZERO, t.SRC_COLOR));
                  break;
                default:
                  l
                    ? (t.blendEquationSeparate(t.FUNC_ADD, t.FUNC_ADD),
                      t.blendFuncSeparate(
                        t.ONE,
                        t.ONE_MINUS_SRC_ALPHA,
                        t.ONE,
                        t.ONE_MINUS_SRC_ALPHA
                      ))
                    : (t.blendEquationSeparate(t.FUNC_ADD, t.FUNC_ADD),
                      t.blendFuncSeparate(
                        t.SRC_ALPHA,
                        t.ONE_MINUS_SRC_ALPHA,
                        t.ONE,
                        t.ONE_MINUS_SRC_ALPHA
                      ));
              }
            (w = null),
              (R = null),
              (L = null),
              (P = null),
              (D = null),
              (I = null);
          } else
            (o = o || i),
              (s = s || r),
              (c = c || a),
              (i === w && o === P) ||
                (t.blendEquationSeparate(n.convert(i), n.convert(o)),
                (w = i),
                (P = o)),
              (r === R && a === L && s === D && c === I) ||
                (t.blendFuncSeparate(
                  n.convert(r),
                  n.convert(a),
                  n.convert(s),
                  n.convert(c)
                ),
                (R = r),
                (L = a),
                (D = s),
                (I = c));
          (b = e), (O = l);
        }
        function pt(e, n) {
          e.side === v ? lt(t.CULL_FACE) : ct(t.CULL_FACE);
          var i = e.side === g;
          n && (i = !i),
            ft(i),
            e.blending === S && !1 === e.transparent
              ? dt(M)
              : dt(
                  e.blending,
                  e.blendEquation,
                  e.blendSrc,
                  e.blendDst,
                  e.blendEquationAlpha,
                  e.blendSrcAlpha,
                  e.blendDstAlpha,
                  e.premultipliedAlpha
                ),
            h.setFunc(e.depthFunc),
            h.setTest(e.depthTest),
            h.setMask(e.depthWrite),
            l.setMask(e.colorWrite),
            vt(e.polygonOffset, e.polygonOffsetFactor, e.polygonOffsetUnits);
        }
        function ft(e) {
          N !== e && (e ? t.frontFace(t.CW) : t.frontFace(t.CCW), (N = e));
        }
        function mt(e) {
          e !== o
            ? (ct(t.CULL_FACE),
              e !== B &&
                (e === s
                  ? t.cullFace(t.BACK)
                  : e === c
                  ? t.cullFace(t.FRONT)
                  : t.cullFace(t.FRONT_AND_BACK)))
            : lt(t.CULL_FACE),
            (B = e);
        }
        function gt(e) {
          e !== z && (k && t.lineWidth(e), (z = e));
        }
        function vt(e, n, i) {
          e
            ? (ct(t.POLYGON_OFFSET_FILL),
              (U === n && F === i) || (t.polygonOffset(n, i), (U = n), (F = i)))
            : lt(t.POLYGON_OFFSET_FILL);
        }
        function yt(e) {
          e ? ct(t.SCISSOR_TEST) : lt(t.SCISSOR_TEST);
        }
        function xt(e) {
          void 0 === e && (e = t.TEXTURE0 + H - 1),
            W !== e && (t.activeTexture(e), (W = e));
        }
        function _t(e, n) {
          null === W && xt();
          var i = Q[W];
          void 0 === i && ((i = { type: void 0, texture: void 0 }), (Q[W] = i)),
            (i.type === e && i.texture === n) ||
              (t.bindTexture(e, n || it[e]), (i.type = e), (i.texture = n));
        }
        function bt() {
          try {
            t.compressedTexImage2D.apply(t, arguments);
          } catch (e) {
            console.error("THREE.WebGLState:", e);
          }
        }
        function wt() {
          try {
            t.texImage2D.apply(t, arguments);
          } catch (e) {
            console.error("THREE.WebGLState:", e);
          }
        }
        function Mt(e) {
          !1 === tt.equals(e) && (t.scissor(e.x, e.y, e.z, e.w), tt.copy(e));
        }
        function St(e) {
          !1 === et.equals(e) && (t.viewport(e.x, e.y, e.z, e.w), et.copy(e));
        }
        function Et() {
          for (var e = 0; e < f.length; e++)
            1 === f[e] && (t.disableVertexAttribArray(e), (f[e] = 0));
          (y = {}),
            (x = null),
            (W = null),
            (Q = {}),
            (_ = null),
            (b = null),
            (N = null),
            (B = null),
            l.reset(),
            h.reset(),
            u.reset();
        }
        return (
          (it[t.TEXTURE_2D] = nt(t.TEXTURE_2D, t.TEXTURE_2D, 1)),
          (it[t.TEXTURE_CUBE_MAP] = nt(
            t.TEXTURE_CUBE_MAP,
            t.TEXTURE_CUBE_MAP_POSITIVE_X,
            6
          )),
          l.setClear(0, 0, 0, 1),
          h.setClear(1),
          u.setClear(0),
          ct(t.DEPTH_TEST),
          h.setFunc(Y),
          ft(!1),
          mt(s),
          ct(t.CULL_FACE),
          ct(t.BLEND),
          dt(S),
          {
            buffers: { color: l, depth: h, stencil: u },
            initAttributes: rt,
            enableAttribute: at,
            enableAttributeAndDivisor: ot,
            disableUnusedAttributes: st,
            enable: ct,
            disable: lt,
            getCompressedTextureFormats: ht,
            useProgram: ut,
            setBlending: dt,
            setMaterial: pt,
            setFlipSided: ft,
            setCullFace: mt,
            setLineWidth: gt,
            setPolygonOffset: vt,
            setScissorTest: yt,
            activeTexture: xt,
            bindTexture: _t,
            compressedTexImage2D: bt,
            texImage2D: wt,
            scissor: Mt,
            viewport: St,
            reset: Et,
          }
        );
      }
      function Lo(t, e, n, i, r, a, o) {
        var s,
          c =
            "undefined" !== typeof WebGL2RenderingContext &&
            t instanceof WebGL2RenderingContext,
          l = {};
        function h(t, e) {
          if (t.width > e || t.height > e) {
            if ("data" in t)
              return void console.warn(
                "THREE.WebGLRenderer: image in DataTexture is too big (" +
                  t.width +
                  "x" +
                  t.height +
                  ")."
              );
            var n = e / Math.max(t.width, t.height),
              i = document.createElementNS(
                "http://www.w3.org/1999/xhtml",
                "canvas"
              );
            (i.width = Math.floor(t.width * n)),
              (i.height = Math.floor(t.height * n));
            var r = i.getContext("2d");
            return (
              r.drawImage(t, 0, 0, t.width, t.height, 0, 0, i.width, i.height),
              console.warn(
                "THREE.WebGLRenderer: image is too big (" +
                  t.width +
                  "x" +
                  t.height +
                  "). Resized to " +
                  i.width +
                  "x" +
                  i.height,
                t
              ),
              i
            );
          }
          return t;
        }
        function u(t) {
          return ze.isPowerOfTwo(t.width) && ze.isPowerOfTwo(t.height);
        }
        function d(t) {
          if (
            t instanceof HTMLImageElement ||
            t instanceof HTMLCanvasElement ||
            t instanceof ImageBitmap
          ) {
            void 0 === s &&
              (s = document.createElementNS(
                "http://www.w3.org/1999/xhtml",
                "canvas"
              )),
              (s.width = ze.floorPowerOfTwo(t.width)),
              (s.height = ze.floorPowerOfTwo(t.height));
            var e = s.getContext("2d");
            return (
              e.drawImage(t, 0, 0, s.width, s.height),
              console.warn(
                "THREE.WebGLRenderer: image is not power of two (" +
                  t.width +
                  "x" +
                  t.height +
                  "). Resized to " +
                  s.width +
                  "x" +
                  s.height,
                t
              ),
              s
            );
          }
          return t;
        }
        function p(t) {
          return (
            t.wrapS !== gt ||
            t.wrapT !== gt ||
            (t.minFilter !== yt && t.minFilter !== bt)
          );
        }
        function f(t, e) {
          return (
            t.generateMipmaps && e && t.minFilter !== yt && t.minFilter !== bt
          );
        }
        function m(e, n, r, a) {
          t.generateMipmap(e);
          var o = i.get(n);
          o.__maxMipLevel = Math.log(Math.max(r, a)) * Math.LOG2E;
        }
        function g(e) {
          return e === yt || e === xt || e === _t ? t.NEAREST : t.LINEAR;
        }
        function v(t) {
          var e = t.target;
          e.removeEventListener("dispose", v),
            x(e),
            e.isVideoTexture && delete l[e.id],
            o.memory.textures--;
        }
        function y(t) {
          var e = t.target;
          e.removeEventListener("dispose", y), _(e), o.memory.textures--;
        }
        function x(e) {
          var n = i.get(e);
          if (e.image && n.__image__webglTextureCube)
            t.deleteTexture(n.__image__webglTextureCube);
          else {
            if (void 0 === n.__webglInit) return;
            t.deleteTexture(n.__webglTexture);
          }
          i.remove(e);
        }
        function _(e) {
          var n = i.get(e),
            r = i.get(e.texture);
          if (e) {
            if (
              (void 0 !== r.__webglTexture && t.deleteTexture(r.__webglTexture),
              e.depthTexture && e.depthTexture.dispose(),
              e.isWebGLRenderTargetCube)
            )
              for (var a = 0; a < 6; a++)
                t.deleteFramebuffer(n.__webglFramebuffer[a]),
                  n.__webglDepthbuffer &&
                    t.deleteRenderbuffer(n.__webglDepthbuffer[a]);
            else
              t.deleteFramebuffer(n.__webglFramebuffer),
                n.__webglDepthbuffer &&
                  t.deleteRenderbuffer(n.__webglDepthbuffer);
            i.remove(e.texture), i.remove(e);
          }
        }
        function b(e, r) {
          var a = i.get(e);
          if (
            (e.isVideoTexture && D(e),
            e.version > 0 && a.__version !== e.version)
          ) {
            var o = e.image;
            if (void 0 === o)
              console.warn(
                "THREE.WebGLRenderer: Texture marked for update but image is undefined",
                e
              );
            else {
              if (!1 !== o.complete) return void E(a, e, r);
              console.warn(
                "THREE.WebGLRenderer: Texture marked for update but image is incomplete",
                e
              );
            }
          }
          n.activeTexture(t.TEXTURE0 + r),
            n.bindTexture(t.TEXTURE_2D, a.__webglTexture);
        }
        function w(e, s) {
          var c = i.get(e);
          if (6 === e.image.length)
            if (e.version > 0 && c.__version !== e.version) {
              c.__image__webglTextureCube ||
                (e.addEventListener("dispose", v),
                (c.__image__webglTextureCube = t.createTexture()),
                o.memory.textures++),
                n.activeTexture(t.TEXTURE0 + s),
                n.bindTexture(t.TEXTURE_CUBE_MAP, c.__image__webglTextureCube),
                t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL, e.flipY);
              for (
                var l = e && e.isCompressedTexture,
                  d = e.image[0] && e.image[0].isDataTexture,
                  p = [],
                  g = 0;
                g < 6;
                g++
              )
                p[g] =
                  l || d
                    ? d
                      ? e.image[g].image
                      : e.image[g]
                    : h(e.image[g], r.maxCubemapSize);
              var y = p[0],
                x = u(y),
                _ = a.convert(e.format),
                b = a.convert(e.type);
              S(t.TEXTURE_CUBE_MAP, e, x);
              for (g = 0; g < 6; g++)
                if (l)
                  for (var w, M = p[g].mipmaps, E = 0, T = M.length; E < T; E++)
                    (w = M[E]),
                      e.format !== Ut && e.format !== zt
                        ? n.getCompressedTextureFormats().indexOf(_) > -1
                          ? n.compressedTexImage2D(
                              t.TEXTURE_CUBE_MAP_POSITIVE_X + g,
                              E,
                              _,
                              w.width,
                              w.height,
                              0,
                              w.data
                            )
                          : console.warn(
                              "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"
                            )
                        : n.texImage2D(
                            t.TEXTURE_CUBE_MAP_POSITIVE_X + g,
                            E,
                            _,
                            w.width,
                            w.height,
                            0,
                            _,
                            b,
                            w.data
                          );
                else
                  d
                    ? n.texImage2D(
                        t.TEXTURE_CUBE_MAP_POSITIVE_X + g,
                        0,
                        _,
                        p[g].width,
                        p[g].height,
                        0,
                        _,
                        b,
                        p[g].data
                      )
                    : n.texImage2D(
                        t.TEXTURE_CUBE_MAP_POSITIVE_X + g,
                        0,
                        _,
                        _,
                        b,
                        p[g]
                      );
              (c.__maxMipLevel = l ? M.length - 1 : 0),
                f(e, x) && m(t.TEXTURE_CUBE_MAP, e, y.width, y.height),
                (c.__version = e.version),
                e.onUpdate && e.onUpdate(e);
            } else
              n.activeTexture(t.TEXTURE0 + s),
                n.bindTexture(t.TEXTURE_CUBE_MAP, c.__image__webglTextureCube);
        }
        function M(e, r) {
          n.activeTexture(t.TEXTURE0 + r),
            n.bindTexture(t.TEXTURE_CUBE_MAP, i.get(e).__webglTexture);
        }
        function S(n, o, s) {
          var c;
          if (
            (s
              ? (t.texParameteri(n, t.TEXTURE_WRAP_S, a.convert(o.wrapS)),
                t.texParameteri(n, t.TEXTURE_WRAP_T, a.convert(o.wrapT)),
                t.texParameteri(
                  n,
                  t.TEXTURE_MAG_FILTER,
                  a.convert(o.magFilter)
                ),
                t.texParameteri(
                  n,
                  t.TEXTURE_MIN_FILTER,
                  a.convert(o.minFilter)
                ))
              : (t.texParameteri(n, t.TEXTURE_WRAP_S, t.CLAMP_TO_EDGE),
                t.texParameteri(n, t.TEXTURE_WRAP_T, t.CLAMP_TO_EDGE),
                (o.wrapS === gt && o.wrapT === gt) ||
                  console.warn(
                    "THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.",
                    o
                  ),
                t.texParameteri(n, t.TEXTURE_MAG_FILTER, g(o.magFilter)),
                t.texParameteri(n, t.TEXTURE_MIN_FILTER, g(o.minFilter)),
                o.minFilter !== yt &&
                  o.minFilter !== bt &&
                  console.warn(
                    "THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.",
                    o
                  )),
            (c = e.get("EXT_texture_filter_anisotropic")),
            c)
          ) {
            if (o.type === Lt && null === e.get("OES_texture_float_linear"))
              return;
            if (
              o.type === Pt &&
              null === e.get("OES_texture_half_float_linear")
            )
              return;
            (o.anisotropy > 1 || i.get(o).__currentAnisotropy) &&
              (t.texParameterf(
                n,
                c.TEXTURE_MAX_ANISOTROPY_EXT,
                Math.min(o.anisotropy, r.getMaxAnisotropy())
              ),
              (i.get(o).__currentAnisotropy = o.anisotropy));
          }
        }
        function E(e, i, s) {
          void 0 === e.__webglInit &&
            ((e.__webglInit = !0),
            i.addEventListener("dispose", v),
            (e.__webglTexture = t.createTexture()),
            o.memory.textures++),
            n.activeTexture(t.TEXTURE0 + s),
            n.bindTexture(t.TEXTURE_2D, e.__webglTexture),
            t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL, i.flipY),
            t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL, i.premultiplyAlpha),
            t.pixelStorei(t.UNPACK_ALIGNMENT, i.unpackAlignment);
          var l = h(i.image, r.maxTextureSize);
          p(i) && !1 === u(l) && (l = d(l));
          var g = u(l),
            y = a.convert(i.format),
            x = a.convert(i.type);
          S(t.TEXTURE_2D, i, g);
          var _,
            b = i.mipmaps;
          if (i.isDepthTexture) {
            var w = t.DEPTH_COMPONENT;
            if (i.type === Lt) {
              if (!c)
                throw new Error(
                  "Float Depth Texture only supported in WebGL2.0"
                );
              w = t.DEPTH_COMPONENT32F;
            } else c && (w = t.DEPTH_COMPONENT16);
            i.format === Gt &&
              w === t.DEPTH_COMPONENT &&
              i.type !== At &&
              i.type !== Rt &&
              (console.warn(
                "THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."
              ),
              (i.type = At),
              (x = a.convert(i.type))),
              i.format === Vt &&
                ((w = t.DEPTH_STENCIL),
                i.type !== Nt &&
                  (console.warn(
                    "THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."
                  ),
                  (i.type = Nt),
                  (x = a.convert(i.type)))),
              n.texImage2D(
                t.TEXTURE_2D,
                0,
                w,
                l.width,
                l.height,
                0,
                y,
                x,
                null
              );
          } else if (i.isDataTexture)
            if (b.length > 0 && g) {
              for (var M = 0, E = b.length; M < E; M++)
                (_ = b[M]),
                  n.texImage2D(
                    t.TEXTURE_2D,
                    M,
                    y,
                    _.width,
                    _.height,
                    0,
                    y,
                    x,
                    _.data
                  );
              (i.generateMipmaps = !1), (e.__maxMipLevel = b.length - 1);
            } else
              n.texImage2D(
                t.TEXTURE_2D,
                0,
                y,
                l.width,
                l.height,
                0,
                y,
                x,
                l.data
              ),
                (e.__maxMipLevel = 0);
          else if (i.isCompressedTexture) {
            for (M = 0, E = b.length; M < E; M++)
              (_ = b[M]),
                i.format !== Ut && i.format !== zt
                  ? n.getCompressedTextureFormats().indexOf(y) > -1
                    ? n.compressedTexImage2D(
                        t.TEXTURE_2D,
                        M,
                        y,
                        _.width,
                        _.height,
                        0,
                        _.data
                      )
                    : console.warn(
                        "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"
                      )
                  : n.texImage2D(
                      t.TEXTURE_2D,
                      M,
                      y,
                      _.width,
                      _.height,
                      0,
                      y,
                      x,
                      _.data
                    );
            e.__maxMipLevel = b.length - 1;
          } else if (b.length > 0 && g) {
            for (M = 0, E = b.length; M < E; M++)
              (_ = b[M]), n.texImage2D(t.TEXTURE_2D, M, y, y, x, _);
            (i.generateMipmaps = !1), (e.__maxMipLevel = b.length - 1);
          } else
            n.texImage2D(t.TEXTURE_2D, 0, y, y, x, l), (e.__maxMipLevel = 0);
          f(i, g) && m(t.TEXTURE_2D, i, l.width, l.height),
            (e.__version = i.version),
            i.onUpdate && i.onUpdate(i);
        }
        function T(e, r, o, s) {
          var c = a.convert(r.texture.format),
            l = a.convert(r.texture.type);
          n.texImage2D(s, 0, c, r.width, r.height, 0, c, l, null),
            t.bindFramebuffer(t.FRAMEBUFFER, e),
            t.framebufferTexture2D(
              t.FRAMEBUFFER,
              o,
              s,
              i.get(r.texture).__webglTexture,
              0
            ),
            t.bindFramebuffer(t.FRAMEBUFFER, null);
        }
        function A(e, n) {
          t.bindRenderbuffer(t.RENDERBUFFER, e),
            n.depthBuffer && !n.stencilBuffer
              ? (t.renderbufferStorage(
                  t.RENDERBUFFER,
                  t.DEPTH_COMPONENT16,
                  n.width,
                  n.height
                ),
                t.framebufferRenderbuffer(
                  t.FRAMEBUFFER,
                  t.DEPTH_ATTACHMENT,
                  t.RENDERBUFFER,
                  e
                ))
              : n.depthBuffer && n.stencilBuffer
              ? (t.renderbufferStorage(
                  t.RENDERBUFFER,
                  t.DEPTH_STENCIL,
                  n.width,
                  n.height
                ),
                t.framebufferRenderbuffer(
                  t.FRAMEBUFFER,
                  t.DEPTH_STENCIL_ATTACHMENT,
                  t.RENDERBUFFER,
                  e
                ))
              : t.renderbufferStorage(
                  t.RENDERBUFFER,
                  t.RGBA4,
                  n.width,
                  n.height
                ),
            t.bindRenderbuffer(t.RENDERBUFFER, null);
        }
        function C(e, n) {
          var r = n && n.isWebGLRenderTargetCube;
          if (r)
            throw new Error(
              "Depth Texture with cube render targets is not supported"
            );
          if (
            (t.bindFramebuffer(t.FRAMEBUFFER, e),
            !n.depthTexture || !n.depthTexture.isDepthTexture)
          )
            throw new Error(
              "renderTarget.depthTexture must be an instance of THREE.DepthTexture"
            );
          (i.get(n.depthTexture).__webglTexture &&
            n.depthTexture.image.width === n.width &&
            n.depthTexture.image.height === n.height) ||
            ((n.depthTexture.image.width = n.width),
            (n.depthTexture.image.height = n.height),
            (n.depthTexture.needsUpdate = !0)),
            b(n.depthTexture, 0);
          var a = i.get(n.depthTexture).__webglTexture;
          if (n.depthTexture.format === Gt)
            t.framebufferTexture2D(
              t.FRAMEBUFFER,
              t.DEPTH_ATTACHMENT,
              t.TEXTURE_2D,
              a,
              0
            );
          else {
            if (n.depthTexture.format !== Vt)
              throw new Error("Unknown depthTexture format");
            t.framebufferTexture2D(
              t.FRAMEBUFFER,
              t.DEPTH_STENCIL_ATTACHMENT,
              t.TEXTURE_2D,
              a,
              0
            );
          }
        }
        function R(e) {
          var n = i.get(e),
            r = !0 === e.isWebGLRenderTargetCube;
          if (e.depthTexture) {
            if (r)
              throw new Error(
                "target.depthTexture not supported in Cube render targets"
              );
            C(n.__webglFramebuffer, e);
          } else if (r) {
            n.__webglDepthbuffer = [];
            for (var a = 0; a < 6; a++)
              t.bindFramebuffer(t.FRAMEBUFFER, n.__webglFramebuffer[a]),
                (n.__webglDepthbuffer[a] = t.createRenderbuffer()),
                A(n.__webglDepthbuffer[a], e);
          } else
            t.bindFramebuffer(t.FRAMEBUFFER, n.__webglFramebuffer),
              (n.__webglDepthbuffer = t.createRenderbuffer()),
              A(n.__webglDepthbuffer, e);
          t.bindFramebuffer(t.FRAMEBUFFER, null);
        }
        function L(e) {
          var r = i.get(e),
            a = i.get(e.texture);
          e.addEventListener("dispose", y),
            (a.__webglTexture = t.createTexture()),
            o.memory.textures++;
          var s = !0 === e.isWebGLRenderTargetCube,
            c = u(e);
          if (s) {
            r.__webglFramebuffer = [];
            for (var l = 0; l < 6; l++)
              r.__webglFramebuffer[l] = t.createFramebuffer();
          } else r.__webglFramebuffer = t.createFramebuffer();
          if (s) {
            n.bindTexture(t.TEXTURE_CUBE_MAP, a.__webglTexture),
              S(t.TEXTURE_CUBE_MAP, e.texture, c);
            for (l = 0; l < 6; l++)
              T(
                r.__webglFramebuffer[l],
                e,
                t.COLOR_ATTACHMENT0,
                t.TEXTURE_CUBE_MAP_POSITIVE_X + l
              );
            f(e.texture, c) &&
              m(t.TEXTURE_CUBE_MAP, e.texture, e.width, e.height),
              n.bindTexture(t.TEXTURE_CUBE_MAP, null);
          } else
            n.bindTexture(t.TEXTURE_2D, a.__webglTexture),
              S(t.TEXTURE_2D, e.texture, c),
              T(r.__webglFramebuffer, e, t.COLOR_ATTACHMENT0, t.TEXTURE_2D),
              f(e.texture, c) && m(t.TEXTURE_2D, e.texture, e.width, e.height),
              n.bindTexture(t.TEXTURE_2D, null);
          e.depthBuffer && R(e);
        }
        function P(e) {
          var r = e.texture,
            a = u(e);
          if (f(r, a)) {
            var o = e.isWebGLRenderTargetCube
                ? t.TEXTURE_CUBE_MAP
                : t.TEXTURE_2D,
              s = i.get(r).__webglTexture;
            n.bindTexture(o, s),
              m(o, r, e.width, e.height),
              n.bindTexture(o, null);
          }
        }
        function D(t) {
          var e = t.id,
            n = o.render.frame;
          l[e] !== n && ((l[e] = n), t.update());
        }
        (this.setTexture2D = b),
          (this.setTextureCube = w),
          (this.setTextureCubeDynamic = M),
          (this.setupRenderTarget = L),
          (this.updateRenderTargetMipmap = P);
      }
      function Po(t, e) {
        function n(n) {
          var i;
          if (n === mt) return t.REPEAT;
          if (n === gt) return t.CLAMP_TO_EDGE;
          if (n === vt) return t.MIRRORED_REPEAT;
          if (n === yt) return t.NEAREST;
          if (n === xt) return t.NEAREST_MIPMAP_NEAREST;
          if (n === _t) return t.NEAREST_MIPMAP_LINEAR;
          if (n === bt) return t.LINEAR;
          if (n === wt) return t.LINEAR_MIPMAP_NEAREST;
          if (n === Mt) return t.LINEAR_MIPMAP_LINEAR;
          if (n === St) return t.UNSIGNED_BYTE;
          if (n === Dt) return t.UNSIGNED_SHORT_4_4_4_4;
          if (n === It) return t.UNSIGNED_SHORT_5_5_5_1;
          if (n === Ot) return t.UNSIGNED_SHORT_5_6_5;
          if (n === Et) return t.BYTE;
          if (n === Tt) return t.SHORT;
          if (n === At) return t.UNSIGNED_SHORT;
          if (n === Ct) return t.INT;
          if (n === Rt) return t.UNSIGNED_INT;
          if (n === Lt) return t.FLOAT;
          if (n === Pt && ((i = e.get("OES_texture_half_float")), null !== i))
            return i.HALF_FLOAT_OES;
          if (n === Bt) return t.ALPHA;
          if (n === zt) return t.RGB;
          if (n === Ut) return t.RGBA;
          if (n === Ft) return t.LUMINANCE;
          if (n === Ht) return t.LUMINANCE_ALPHA;
          if (n === Gt) return t.DEPTH_COMPONENT;
          if (n === Vt) return t.DEPTH_STENCIL;
          if (n === R) return t.FUNC_ADD;
          if (n === L) return t.FUNC_SUBTRACT;
          if (n === P) return t.FUNC_REVERSE_SUBTRACT;
          if (n === O) return t.ZERO;
          if (n === N) return t.ONE;
          if (n === B) return t.SRC_COLOR;
          if (n === z) return t.ONE_MINUS_SRC_COLOR;
          if (n === U) return t.SRC_ALPHA;
          if (n === F) return t.ONE_MINUS_SRC_ALPHA;
          if (n === H) return t.DST_ALPHA;
          if (n === k) return t.ONE_MINUS_DST_ALPHA;
          if (n === G) return t.DST_COLOR;
          if (n === V) return t.ONE_MINUS_DST_COLOR;
          if (n === W) return t.SRC_ALPHA_SATURATE;
          if (
            (n === Wt || n === jt || n === qt || n === Xt) &&
            ((i = e.get("WEBGL_compressed_texture_s3tc")), null !== i)
          ) {
            if (n === Wt) return i.COMPRESSED_RGB_S3TC_DXT1_EXT;
            if (n === jt) return i.COMPRESSED_RGBA_S3TC_DXT1_EXT;
            if (n === qt) return i.COMPRESSED_RGBA_S3TC_DXT3_EXT;
            if (n === Xt) return i.COMPRESSED_RGBA_S3TC_DXT5_EXT;
          }
          if (
            (n === Yt || n === Jt || n === Zt || n === Kt) &&
            ((i = e.get("WEBGL_compressed_texture_pvrtc")), null !== i)
          ) {
            if (n === Yt) return i.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
            if (n === Jt) return i.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
            if (n === Zt) return i.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
            if (n === Kt) return i.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
          }
          if (
            n === $t &&
            ((i = e.get("WEBGL_compressed_texture_etc1")), null !== i)
          )
            return i.COMPRESSED_RGB_ETC1_WEBGL;
          if (
            (n === Qt ||
              n === te ||
              n === ee ||
              n === ne ||
              n === ie ||
              n === re ||
              n === ae ||
              n === oe ||
              n === se ||
              n === ce ||
              n === le ||
              n === he ||
              n === ue ||
              n === de) &&
            ((i = e.get("WEBGL_compressed_texture_astc")), null !== i)
          )
            return n;
          if (
            (n === D || n === I) &&
            ((i = e.get("EXT_blend_minmax")), null !== i)
          ) {
            if (n === D) return i.MIN_EXT;
            if (n === I) return i.MAX_EXT;
          }
          return n === Nt && ((i = e.get("WEBGL_depth_texture")), null !== i)
            ? i.UNSIGNED_INT_24_8_WEBGL
            : 0;
        }
        return { convert: n };
      }
      function Do() {
        gr.call(this), (this.type = "Group");
      }
      function Io(t, e, n, i) {
        vr.call(this),
          (this.type = "PerspectiveCamera"),
          (this.fov = void 0 !== t ? t : 50),
          (this.zoom = 1),
          (this.near = void 0 !== n ? n : 0.1),
          (this.far = void 0 !== i ? i : 2e3),
          (this.focus = 10),
          (this.aspect = void 0 !== e ? e : 1),
          (this.view = null),
          (this.filmGauge = 35),
          (this.filmOffset = 0),
          this.updateProjectionMatrix();
      }
      function Oo(t) {
        Io.call(this), (this.cameras = t || []);
      }
      function No(t) {
        var e = this,
          n = null,
          i = null,
          r = null,
          a = [],
          o = new Fe(),
          s = new Fe();
        "undefined" !== typeof window &&
          "VRFrameData" in window &&
          ((i = new window.VRFrameData()),
          window.addEventListener("vrdisplaypresentchange", v, !1));
        var c = new Fe(),
          l = new He(),
          h = new ke(),
          u = new Io();
        (u.bounds = new je(0, 0, 0.5, 1)), u.layers.enable(1);
        var d = new Io();
        (d.bounds = new je(0.5, 0, 0.5, 1)), d.layers.enable(2);
        var p,
          f,
          m = new Oo([u, d]);
        function g() {
          return null !== n && !0 === n.isPresenting;
        }
        function v() {
          if (g()) {
            var i = n.getEyeParameters("left"),
              r = i.renderWidth,
              a = i.renderHeight;
            (f = t.getPixelRatio()),
              (p = t.getSize()),
              t.setDrawingBufferSize(2 * r, a, 1),
              b.start();
          } else
            e.enabled &&
              (t.setDrawingBufferSize(p.width, p.height, f), b.stop());
        }
        m.layers.enable(1), m.layers.enable(2);
        var y = !1;
        function x(t) {
          for (
            var e = navigator.getGamepads && navigator.getGamepads(),
              n = 0,
              i = 0,
              r = e.length;
            n < r;
            n++
          ) {
            var a = e[n];
            if (
              a &&
              ("Daydream Controller" === a.id ||
                "Gear VR Controller" === a.id ||
                "Oculus Go Controller" === a.id ||
                "OpenVR Gamepad" === a.id ||
                a.id.startsWith("Oculus Touch") ||
                a.id.startsWith("Spatial Controller"))
            ) {
              if (i === t) return a;
              i++;
            }
          }
        }
        function _() {
          for (var t = 0; t < a.length; t++) {
            var e = a[t],
              n = x(t);
            if (void 0 !== n && void 0 !== n.pose) {
              if (null === n.pose) return;
              var i = n.pose;
              !1 === i.hasPosition && e.position.set(0.2, -0.6, -0.05),
                null !== i.position && e.position.fromArray(i.position),
                null !== i.orientation && e.quaternion.fromArray(i.orientation),
                e.matrix.compose(e.position, e.quaternion, e.scale),
                e.matrix.premultiply(o),
                e.matrix.decompose(e.position, e.quaternion, e.scale),
                (e.matrixWorldNeedsUpdate = !0),
                (e.visible = !0);
              var r = "Daydream Controller" === n.id ? 0 : 1;
              y !== n.buttons[r].pressed &&
                ((y = n.buttons[r].pressed),
                y
                  ? e.dispatchEvent({ type: "selectstart" })
                  : (e.dispatchEvent({ type: "selectend" }),
                    e.dispatchEvent({ type: "select" })));
            } else e.visible = !1;
          }
        }
        (this.enabled = !1),
          (this.userHeight = 1.6),
          (this.getController = function (t) {
            var e = a[t];
            return (
              void 0 === e &&
                ((e = new Do()),
                (e.matrixAutoUpdate = !1),
                (e.visible = !1),
                (a[t] = e)),
              e
            );
          }),
          (this.getDevice = function () {
            return n;
          }),
          (this.setDevice = function (t) {
            void 0 !== t && (n = t), b.setContext(t);
          }),
          (this.setPoseTarget = function (t) {
            void 0 !== t && (r = t);
          }),
          (this.getCamera = function (t) {
            if (null === n) return t.position.set(0, e.userHeight, 0), t;
            (n.depthNear = t.near), (n.depthFar = t.far), n.getFrameData(i);
            var a = n.stageParameters;
            a
              ? o.fromArray(a.sittingToStandingTransform)
              : o.makeTranslation(0, e.userHeight, 0);
            var p = i.pose,
              f = null !== r ? r : t;
            if (
              (f.matrix.copy(o),
              f.matrix.decompose(f.position, f.quaternion, f.scale),
              null !== p.orientation &&
                (l.fromArray(p.orientation), f.quaternion.multiply(l)),
              null !== p.position &&
                (l.setFromRotationMatrix(o),
                h.fromArray(p.position),
                h.applyQuaternion(l),
                f.position.add(h)),
              f.updateMatrixWorld(),
              !1 === n.isPresenting)
            )
              return t;
            (u.near = t.near),
              (d.near = t.near),
              (u.far = t.far),
              (d.far = t.far),
              m.matrixWorld.copy(t.matrixWorld),
              m.matrixWorldInverse.copy(t.matrixWorldInverse),
              u.matrixWorldInverse.fromArray(i.leftViewMatrix),
              d.matrixWorldInverse.fromArray(i.rightViewMatrix),
              s.getInverse(o),
              u.matrixWorldInverse.multiply(s),
              d.matrixWorldInverse.multiply(s);
            var g = f.parent;
            null !== g &&
              (c.getInverse(g.matrixWorld),
              u.matrixWorldInverse.multiply(c),
              d.matrixWorldInverse.multiply(c)),
              u.matrixWorld.getInverse(u.matrixWorldInverse),
              d.matrixWorld.getInverse(d.matrixWorldInverse),
              u.projectionMatrix.fromArray(i.leftProjectionMatrix),
              d.projectionMatrix.fromArray(i.rightProjectionMatrix),
              m.projectionMatrix.copy(u.projectionMatrix);
            var v = n.getLayers();
            if (v.length) {
              var y = v[0];
              null !== y.leftBounds &&
                4 === y.leftBounds.length &&
                u.bounds.fromArray(y.leftBounds),
                null !== y.rightBounds &&
                  4 === y.rightBounds.length &&
                  d.bounds.fromArray(y.rightBounds);
            }
            return _(), m;
          }),
          (this.getStandingMatrix = function () {
            return o;
          }),
          (this.isPresenting = g);
        var b = new ur();
        (this.setAnimationLoop = function (t) {
          b.setAnimationLoop(t);
        }),
          (this.submitFrame = function () {
            g() && n.submitFrame();
          }),
          (this.dispose = function () {
            "undefined" !== typeof window &&
              window.removeEventListener("vrdisplaypresentchange", v);
          });
      }
      function Bo(t) {
        var e = t.context,
          n = null,
          i = null,
          r = null,
          a = null,
          o = [],
          s = [];
        function c() {
          return null !== i && null !== r;
        }
        var l = new Io();
        l.layers.enable(1), (l.viewport = new je());
        var h = new Io();
        h.layers.enable(2), (h.viewport = new je());
        var u = new Oo([l, h]);
        function d(t) {
          var e = o[s.indexOf(t.inputSource)];
          e && e.dispatchEvent({ type: t.type });
        }
        function p() {
          t.setFramebuffer(null), v.stop();
        }
        function f(t, e) {
          null === e
            ? t.matrixWorld.copy(t.matrix)
            : t.matrixWorld.multiplyMatrices(e.matrixWorld, t.matrix),
            t.matrixWorldInverse.getInverse(t.matrixWorld);
        }
        u.layers.enable(1),
          u.layers.enable(2),
          (this.enabled = !1),
          (this.getController = function (t) {
            var e = o[t];
            return (
              void 0 === e &&
                ((e = new Do()),
                (e.matrixAutoUpdate = !1),
                (e.visible = !1),
                (o[t] = e)),
              e
            );
          }),
          (this.getDevice = function () {
            return n;
          }),
          (this.setDevice = function (t) {
            void 0 !== t && (n = t), e.setCompatibleXRDevice(t);
          }),
          (this.setSession = function (n, a) {
            (i = n),
              null !== i &&
                (i.addEventListener("select", d),
                i.addEventListener("selectstart", d),
                i.addEventListener("selectend", d),
                i.addEventListener("end", p),
                (i.baseLayer = new XRWebGLLayer(i, e)),
                i
                  .requestFrameOfReference(a.frameOfReferenceType)
                  .then(function (e) {
                    (r = e),
                      t.setFramebuffer(i.baseLayer.framebuffer),
                      v.setContext(i),
                      v.start();
                  }),
                (s = i.getInputSources()),
                i.addEventListener("inputsourceschange", function () {
                  (s = i.getInputSources()), console.log(s);
                }));
          }),
          (this.getCamera = function (t) {
            if (c()) {
              var e = t.parent,
                n = u.cameras;
              f(u, e);
              for (var i = 0; i < n.length; i++) f(n[i], e);
              t.matrixWorld.copy(u.matrixWorld);
              for (var r = t.children, a = ((i = 0), r.length); i < a; i++)
                r[i].updateMatrixWorld(!0);
              return u;
            }
            return t;
          }),
          (this.isPresenting = c);
        var m = null;
        function g(t, e) {
          if (((a = e.getDevicePose(r)), null !== a))
            for (var n = i.baseLayer, c = e.views, l = 0; l < c.length; l++) {
              var h = c[l],
                d = n.getViewport(h),
                p = a.getViewMatrix(h),
                f = u.cameras[l];
              f.matrix.fromArray(p).getInverse(f.matrix),
                f.projectionMatrix.fromArray(h.projectionMatrix),
                f.viewport.set(d.x, d.y, d.width, d.height),
                0 === l &&
                  (u.matrix.copy(f.matrix),
                  u.projectionMatrix.copy(f.projectionMatrix));
            }
          for (l = 0; l < o.length; l++) {
            var g = o[l],
              v = s[l];
            if (v) {
              var y = e.getInputPose(v, r);
              if (null !== y) {
                (g.matrix.elements = y.pointerMatrix),
                  g.matrix.decompose(g.position, g.rotation, g.scale),
                  (g.visible = !0);
                continue;
              }
            }
            g.visible = !1;
          }
          m && m(t);
        }
        var v = new ur();
        v.setAnimationLoop(g),
          (this.setAnimationLoop = function (t) {
            m = t;
          }),
          (this.dispose = function () {}),
          (this.getStandingMatrix = function () {
            return (
              console.warn(
                "THREE.WebXRManager: getStandingMatrix() is no longer needed."
              ),
              new THREE.Matrix4()
            );
          }),
          (this.submitFrame = function () {});
      }
      function zo(t) {
        console.log("THREE.WebGLRenderer", r), (t = t || {});
        var e =
            void 0 !== t.canvas
              ? t.canvas
              : document.createElementNS(
                  "http://www.w3.org/1999/xhtml",
                  "canvas"
                ),
          n = void 0 !== t.context ? t.context : null,
          i = void 0 !== t.alpha && t.alpha,
          a = void 0 === t.depth || t.depth,
          o = void 0 === t.stencil || t.stencil,
          s = void 0 !== t.antialias && t.antialias,
          c = void 0 === t.premultipliedAlpha || t.premultipliedAlpha,
          l = void 0 !== t.preserveDrawingBuffer && t.preserveDrawingBuffer,
          h = void 0 !== t.powerPreference ? t.powerPreference : "default",
          u = null,
          d = null;
        (this.domElement = e),
          (this.context = null),
          (this.autoClear = !0),
          (this.autoClearColor = !0),
          (this.autoClearDepth = !0),
          (this.autoClearStencil = !0),
          (this.sortObjects = !0),
          (this.clippingPlanes = []),
          (this.localClippingEnabled = !1),
          (this.gammaFactor = 2),
          (this.gammaInput = !1),
          (this.gammaOutput = !1),
          (this.physicallyCorrectLights = !1),
          (this.toneMapping = it),
          (this.toneMappingExposure = 1),
          (this.toneMappingWhitePoint = 1),
          (this.maxMorphTargets = 8),
          (this.maxMorphNormals = 4);
        var p,
          f,
          m,
          v,
          y,
          x,
          b,
          w,
          M,
          S,
          E,
          T,
          A,
          C,
          R,
          L,
          P,
          D,
          I,
          O = this,
          N = !1,
          B = null,
          z = null,
          U = null,
          F = -1,
          H = "",
          k = null,
          G = null,
          V = new je(),
          W = new je(),
          j = null,
          q = 0,
          X = e.width,
          Y = e.height,
          J = 1,
          Z = new je(0, 0, X, Y),
          K = new je(0, 0, X, Y),
          $ = !1,
          Q = new $e(),
          tt = new Kr(),
          et = !1,
          nt = !1,
          rt = new Fe(),
          at = new ke();
        function ot() {
          return null === z ? J : 1;
        }
        try {
          var st = {
            alpha: i,
            depth: a,
            stencil: o,
            antialias: s,
            premultipliedAlpha: c,
            preserveDrawingBuffer: l,
            powerPreference: h,
          };
          if (
            (e.addEventListener("webglcontextlost", ut, !1),
            e.addEventListener("webglcontextrestored", dt, !1),
            (p =
              n ||
              e.getContext("webgl", st) ||
              e.getContext("experimental-webgl", st)),
            null === p)
          )
            throw null !== e.getContext("webgl")
              ? new Error(
                  "Error creating WebGL context with your selected attributes."
                )
              : new Error("Error creating WebGL context.");
          void 0 === p.getShaderPrecisionFormat &&
            (p.getShaderPrecisionFormat = function () {
              return { rangeMin: 1, rangeMax: 1, precision: 1 };
            });
        } catch (jt) {
          console.error("THREE.WebGLRenderer: " + jt.message);
        }
        function ct() {
          (f = new $r(p)),
            f.get("WEBGL_depth_texture"),
            f.get("OES_texture_float"),
            f.get("OES_texture_float_linear"),
            f.get("OES_texture_half_float"),
            f.get("OES_texture_half_float_linear"),
            f.get("OES_standard_derivatives"),
            f.get("OES_element_index_uint"),
            f.get("ANGLE_instanced_arrays"),
            (I = new Po(p, f)),
            (m = new Zr(p, f, t)),
            (v = new Ro(p, f, I)),
            v.scissor(W.copy(K).multiplyScalar(J)),
            v.viewport(V.copy(Z).multiplyScalar(J)),
            (y = new ea(p)),
            (x = new fo()),
            (b = new Lo(p, f, v, x, m, I, y)),
            (w = new dr(p)),
            (M = new Qr(p, w, y)),
            (S = new ra(M, y)),
            (R = new ia(p)),
            (E = new po(O, f, m)),
            (T = new yo()),
            (A = new Mo()),
            (C = new Yr(O, v, S, c)),
            (L = new Jr(p, f, y)),
            (P = new ta(p, f, y)),
            (D = new Co(O, p, v, b, m)),
            (y.programs = E.programs),
            (O.context = p),
            (O.capabilities = m),
            (O.extensions = f),
            (O.properties = x),
            (O.renderLists = T),
            (O.state = v),
            (O.info = y);
        }
        ct();
        var lt = "xr" in navigator ? new Bo(O) : new No(O);
        this.vr = lt;
        var ht = new To(O, S, m.maxTextureSize);
        function ut(t) {
          t.preventDefault(),
            console.log("THREE.WebGLRenderer: Context Lost."),
            (N = !0);
        }
        function dt() {
          console.log("THREE.WebGLRenderer: Context Restored."), (N = !1), ct();
        }
        function pt(t) {
          var e = t.target;
          e.removeEventListener("dispose", pt), ft(e);
        }
        function ft(t) {
          mt(t), x.remove(t);
        }
        function mt(t) {
          var e = x.get(t).program;
          (t.program = void 0), void 0 !== e && E.releaseProgram(e);
        }
        function gt(t, e, n) {
          t.render(function (t) {
            O.renderBufferImmediate(t, e, n);
          });
        }
        function vt(t, e, n) {
          if (
            n &&
            n.isInstancedBufferGeometry &&
            null === f.get("ANGLE_instanced_arrays")
          )
            console.error(
              "THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
            );
          else {
            v.initAttributes();
            var i = n.attributes,
              r = e.getAttributes(),
              a = t.defaultAttributeValues;
            for (var o in r) {
              var s = r[o];
              if (s >= 0) {
                var c = i[o];
                if (void 0 !== c) {
                  var l = c.normalized,
                    h = c.itemSize,
                    u = w.get(c);
                  if (void 0 === u) continue;
                  var d = u.buffer,
                    m = u.type,
                    g = u.bytesPerElement;
                  if (c.isInterleavedBufferAttribute) {
                    var y = c.data,
                      x = y.stride,
                      _ = c.offset;
                    y && y.isInstancedInterleavedBuffer
                      ? (v.enableAttributeAndDivisor(s, y.meshPerAttribute),
                        void 0 === n.maxInstancedCount &&
                          (n.maxInstancedCount = y.meshPerAttribute * y.count))
                      : v.enableAttribute(s),
                      p.bindBuffer(p.ARRAY_BUFFER, d),
                      p.vertexAttribPointer(s, h, m, l, x * g, _ * g);
                  } else
                    c.isInstancedBufferAttribute
                      ? (v.enableAttributeAndDivisor(s, c.meshPerAttribute),
                        void 0 === n.maxInstancedCount &&
                          (n.maxInstancedCount = c.meshPerAttribute * c.count))
                      : v.enableAttribute(s),
                      p.bindBuffer(p.ARRAY_BUFFER, d),
                      p.vertexAttribPointer(s, h, m, l, 0, 0);
                } else if (void 0 !== a) {
                  var b = a[o];
                  if (void 0 !== b)
                    switch (b.length) {
                      case 2:
                        p.vertexAttrib2fv(s, b);
                        break;
                      case 3:
                        p.vertexAttrib3fv(s, b);
                        break;
                      case 4:
                        p.vertexAttrib4fv(s, b);
                        break;
                      default:
                        p.vertexAttrib1fv(s, b);
                    }
                }
              }
            }
            v.disableUnusedAttributes();
          }
        }
        (this.shadowMap = ht),
          (this.getContext = function () {
            return p;
          }),
          (this.getContextAttributes = function () {
            return p.getContextAttributes();
          }),
          (this.forceContextLoss = function () {
            var t = f.get("WEBGL_lose_context");
            t && t.loseContext();
          }),
          (this.forceContextRestore = function () {
            var t = f.get("WEBGL_lose_context");
            t && t.restoreContext();
          }),
          (this.getPixelRatio = function () {
            return J;
          }),
          (this.setPixelRatio = function (t) {
            void 0 !== t && ((J = t), this.setSize(X, Y, !1));
          }),
          (this.getSize = function () {
            return { width: X, height: Y };
          }),
          (this.setSize = function (t, n, i) {
            lt.isPresenting()
              ? console.warn(
                  "THREE.WebGLRenderer: Can't change size while VR device is presenting."
                )
              : ((X = t),
                (Y = n),
                (e.width = t * J),
                (e.height = n * J),
                !1 !== i &&
                  ((e.style.width = t + "px"), (e.style.height = n + "px")),
                this.setViewport(0, 0, t, n));
          }),
          (this.getDrawingBufferSize = function () {
            return { width: X * J, height: Y * J };
          }),
          (this.setDrawingBufferSize = function (t, n, i) {
            (X = t),
              (Y = n),
              (J = i),
              (e.width = t * i),
              (e.height = n * i),
              this.setViewport(0, 0, t, n);
          }),
          (this.getCurrentViewport = function () {
            return V;
          }),
          (this.setViewport = function (t, e, n, i) {
            Z.set(t, Y - e - i, n, i), v.viewport(V.copy(Z).multiplyScalar(J));
          }),
          (this.setScissor = function (t, e, n, i) {
            K.set(t, Y - e - i, n, i), v.scissor(W.copy(K).multiplyScalar(J));
          }),
          (this.setScissorTest = function (t) {
            v.setScissorTest(($ = t));
          }),
          (this.getClearColor = function () {
            return C.getClearColor();
          }),
          (this.setClearColor = function () {
            C.setClearColor.apply(C, arguments);
          }),
          (this.getClearAlpha = function () {
            return C.getClearAlpha();
          }),
          (this.setClearAlpha = function () {
            C.setClearAlpha.apply(C, arguments);
          }),
          (this.clear = function (t, e, n) {
            var i = 0;
            (void 0 === t || t) && (i |= p.COLOR_BUFFER_BIT),
              (void 0 === e || e) && (i |= p.DEPTH_BUFFER_BIT),
              (void 0 === n || n) && (i |= p.STENCIL_BUFFER_BIT),
              p.clear(i);
          }),
          (this.clearColor = function () {
            this.clear(!0, !1, !1);
          }),
          (this.clearDepth = function () {
            this.clear(!1, !0, !1);
          }),
          (this.clearStencil = function () {
            this.clear(!1, !1, !0);
          }),
          (this.clearTarget = function (t, e, n, i) {
            this.setRenderTarget(t), this.clear(e, n, i);
          }),
          (this.dispose = function () {
            e.removeEventListener("webglcontextlost", ut, !1),
              e.removeEventListener("webglcontextrestored", dt, !1),
              T.dispose(),
              A.dispose(),
              x.dispose(),
              S.dispose(),
              lt.dispose(),
              _t.stop();
          }),
          (this.renderBufferImmediate = function (t, e, n) {
            v.initAttributes();
            var i = x.get(t);
            t.hasPositions && !i.position && (i.position = p.createBuffer()),
              t.hasNormals && !i.normal && (i.normal = p.createBuffer()),
              t.hasUvs && !i.uv && (i.uv = p.createBuffer()),
              t.hasColors && !i.color && (i.color = p.createBuffer());
            var r = e.getAttributes();
            if (
              (t.hasPositions &&
                (p.bindBuffer(p.ARRAY_BUFFER, i.position),
                p.bufferData(p.ARRAY_BUFFER, t.positionArray, p.DYNAMIC_DRAW),
                v.enableAttribute(r.position),
                p.vertexAttribPointer(r.position, 3, p.FLOAT, !1, 0, 0)),
              t.hasNormals)
            ) {
              if (
                (p.bindBuffer(p.ARRAY_BUFFER, i.normal),
                !n.isMeshPhongMaterial &&
                  !n.isMeshStandardMaterial &&
                  !n.isMeshNormalMaterial &&
                  !0 === n.flatShading)
              )
                for (var a = 0, o = 3 * t.count; a < o; a += 9) {
                  var s = t.normalArray,
                    c = (s[a + 0] + s[a + 3] + s[a + 6]) / 3,
                    l = (s[a + 1] + s[a + 4] + s[a + 7]) / 3,
                    h = (s[a + 2] + s[a + 5] + s[a + 8]) / 3;
                  (s[a + 0] = c),
                    (s[a + 1] = l),
                    (s[a + 2] = h),
                    (s[a + 3] = c),
                    (s[a + 4] = l),
                    (s[a + 5] = h),
                    (s[a + 6] = c),
                    (s[a + 7] = l),
                    (s[a + 8] = h);
                }
              p.bufferData(p.ARRAY_BUFFER, t.normalArray, p.DYNAMIC_DRAW),
                v.enableAttribute(r.normal),
                p.vertexAttribPointer(r.normal, 3, p.FLOAT, !1, 0, 0);
            }
            t.hasUvs &&
              n.map &&
              (p.bindBuffer(p.ARRAY_BUFFER, i.uv),
              p.bufferData(p.ARRAY_BUFFER, t.uvArray, p.DYNAMIC_DRAW),
              v.enableAttribute(r.uv),
              p.vertexAttribPointer(r.uv, 2, p.FLOAT, !1, 0, 0)),
              t.hasColors &&
                n.vertexColors !== _ &&
                (p.bindBuffer(p.ARRAY_BUFFER, i.color),
                p.bufferData(p.ARRAY_BUFFER, t.colorArray, p.DYNAMIC_DRAW),
                v.enableAttribute(r.color),
                p.vertexAttribPointer(r.color, 3, p.FLOAT, !1, 0, 0)),
              v.disableUnusedAttributes(),
              p.drawArrays(p.TRIANGLES, 0, t.count),
              (t.count = 0);
          }),
          (this.renderBufferDirect = function (t, e, n, i, r, a) {
            var o = r.isMesh && r.matrixWorld.determinant() < 0;
            v.setMaterial(i, o);
            var s = Tt(t, e, i, r),
              c = n.id + "_" + s.id + "_" + (!0 === i.wireframe),
              l = !1;
            c !== H && ((H = c), (l = !0)),
              r.morphTargetInfluences && (R.update(r, n, i, s), (l = !0));
            var h,
              u = n.index,
              d = n.attributes.position,
              f = 1;
            !0 === i.wireframe && ((u = M.getWireframeAttribute(n)), (f = 2));
            var m = L;
            null !== u && ((h = w.get(u)), (m = P), m.setIndex(h)),
              l &&
                (vt(i, s, n),
                null !== u && p.bindBuffer(p.ELEMENT_ARRAY_BUFFER, h.buffer));
            var g = 1 / 0;
            null !== u ? (g = u.count) : void 0 !== d && (g = d.count);
            var y = n.drawRange.start * f,
              x = n.drawRange.count * f,
              _ = null !== a ? a.start * f : 0,
              b = null !== a ? a.count * f : 1 / 0,
              S = Math.max(y, _),
              E = Math.min(g, y + x, _ + b) - 1,
              T = Math.max(0, E - S + 1);
            if (0 !== T) {
              if (r.isMesh)
                if (!0 === i.wireframe)
                  v.setLineWidth(i.wireframeLinewidth * ot()),
                    m.setMode(p.LINES);
                else
                  switch (r.drawMode) {
                    case we:
                      m.setMode(p.TRIANGLES);
                      break;
                    case Me:
                      m.setMode(p.TRIANGLE_STRIP);
                      break;
                    case Se:
                      m.setMode(p.TRIANGLE_FAN);
                      break;
                  }
              else if (r.isLine) {
                var A = i.linewidth;
                void 0 === A && (A = 1),
                  v.setLineWidth(A * ot()),
                  r.isLineSegments
                    ? m.setMode(p.LINES)
                    : r.isLineLoop
                    ? m.setMode(p.LINE_LOOP)
                    : m.setMode(p.LINE_STRIP);
              } else r.isPoints && m.setMode(p.POINTS);
              n && n.isInstancedBufferGeometry
                ? n.maxInstancedCount > 0 && m.renderInstances(n, S, T)
                : m.render(S, T);
            }
          }),
          (this.compile = function (t, e) {
            (d = A.get(t, e)),
              d.init(),
              t.traverse(function (t) {
                t.isLight && (d.pushLight(t), t.castShadow && d.pushShadow(t));
              }),
              d.setupLights(e),
              t.traverse(function (e) {
                if (e.material)
                  if (Array.isArray(e.material))
                    for (var n = 0; n < e.material.length; n++)
                      Et(e.material[n], t.fog, e);
                  else Et(e.material, t.fog, e);
              });
          });
        var yt = null;
        function xt(t) {
          lt.isPresenting() || (yt && yt(t));
        }
        var _t = new ur();
        function bt(t, e, n) {
          if (!1 !== t.visible) {
            var i = t.layers.test(e.layers);
            if (i)
              if (t.isLight) d.pushLight(t), t.castShadow && d.pushShadow(t);
              else if (t.isSprite)
                (t.frustumCulled && !Q.intersectsSprite(t)) || d.pushSprite(t);
              else if (t.isImmediateRenderObject)
                n && at.setFromMatrixPosition(t.matrixWorld).applyMatrix4(rt),
                  u.push(t, null, t.material, at.z, null);
              else if (
                (t.isMesh || t.isLine || t.isPoints) &&
                (t.isSkinnedMesh && t.skeleton.update(),
                !t.frustumCulled || Q.intersectsObject(t))
              ) {
                n && at.setFromMatrixPosition(t.matrixWorld).applyMatrix4(rt);
                var r = S.update(t),
                  a = t.material;
                if (Array.isArray(a))
                  for (var o = r.groups, s = 0, c = o.length; s < c; s++) {
                    var l = o[s],
                      h = a[l.materialIndex];
                    h && h.visible && u.push(t, r, h, at.z, l);
                  }
                else a.visible && u.push(t, r, a, at.z, null);
              }
            var p = t.children;
            for (s = 0, c = p.length; s < c; s++) bt(p[s], e, n);
          }
        }
        function wt(t, e, n, i) {
          for (var r = 0, a = t.length; r < a; r++) {
            var o = t[r],
              s = o.object,
              c = o.geometry,
              l = void 0 === i ? o.material : i,
              h = o.group;
            if (n.isArrayCamera) {
              G = n;
              for (var u = n.cameras, d = 0, p = u.length; d < p; d++) {
                var f = u[d];
                if (s.layers.test(f.layers)) {
                  if ("viewport" in f) v.viewport(V.copy(f.viewport));
                  else {
                    var m = f.bounds,
                      g = m.x * X,
                      y = m.y * Y,
                      x = m.z * X,
                      _ = m.w * Y;
                    v.viewport(V.set(g, y, x, _).multiplyScalar(J));
                  }
                  Mt(s, e, f, c, l, h);
                }
              }
            } else (G = null), Mt(s, e, n, c, l, h);
          }
        }
        function Mt(t, e, n, i, r, a) {
          if (
            (t.onBeforeRender(O, e, n, i, r, a),
            (d = A.get(e, G || n)),
            t.modelViewMatrix.multiplyMatrices(
              n.matrixWorldInverse,
              t.matrixWorld
            ),
            t.normalMatrix.getNormalMatrix(t.modelViewMatrix),
            t.isImmediateRenderObject)
          ) {
            var o = t.isMesh && t.matrixWorld.determinant() < 0;
            v.setMaterial(r, o);
            var s = Tt(n, e.fog, r, t);
            (H = ""), gt(t, s, r);
          } else O.renderBufferDirect(n, e.fog, i, r, t, a);
          t.onAfterRender(O, e, n, i, r, a), (d = A.get(e, G || n));
        }
        function Et(t, e, n) {
          var i = x.get(t),
            r = d.state.lights,
            a = d.state.shadowsArray,
            o = E.getParameters(
              t,
              r.state,
              a,
              e,
              tt.numPlanes,
              tt.numIntersection,
              n
            ),
            s = E.getProgramCode(t, o),
            c = i.program,
            l = !0;
          if (void 0 === c) t.addEventListener("dispose", pt);
          else if (c.code !== s) mt(t);
          else if (i.lightsHash !== r.state.hash)
            x.update(t, "lightsHash", r.state.hash), (l = !1);
          else {
            if (void 0 !== o.shaderID) return;
            l = !1;
          }
          if (l) {
            if (o.shaderID) {
              var h = hr[o.shaderID];
              i.shader = {
                name: t.type,
                uniforms: or.clone(h.uniforms),
                vertexShader: h.vertexShader,
                fragmentShader: h.fragmentShader,
              };
            } else
              i.shader = {
                name: t.type,
                uniforms: t.uniforms,
                vertexShader: t.vertexShader,
                fragmentShader: t.fragmentShader,
              };
            t.onBeforeCompile(i.shader, O),
              (c = E.acquireProgram(t, i.shader, o, s)),
              (i.program = c),
              (t.program = c);
          }
          var u = c.getAttributes();
          if (t.morphTargets) {
            t.numSupportedMorphTargets = 0;
            for (var p = 0; p < O.maxMorphTargets; p++)
              u["morphTarget" + p] >= 0 && t.numSupportedMorphTargets++;
          }
          if (t.morphNormals) {
            t.numSupportedMorphNormals = 0;
            for (p = 0; p < O.maxMorphNormals; p++)
              u["morphNormal" + p] >= 0 && t.numSupportedMorphNormals++;
          }
          var f = i.shader.uniforms;
          ((t.isShaderMaterial || t.isRawShaderMaterial) &&
            !0 !== t.clipping) ||
            ((i.numClippingPlanes = tt.numPlanes),
            (i.numIntersection = tt.numIntersection),
            (f.clippingPlanes = tt.uniform)),
            (i.fog = e),
            (i.lightsHash = r.state.hash),
            t.lights &&
              ((f.ambientLightColor.value = r.state.ambient),
              (f.directionalLights.value = r.state.directional),
              (f.spotLights.value = r.state.spot),
              (f.rectAreaLights.value = r.state.rectArea),
              (f.pointLights.value = r.state.point),
              (f.hemisphereLights.value = r.state.hemi),
              (f.directionalShadowMap.value = r.state.directionalShadowMap),
              (f.directionalShadowMatrix.value =
                r.state.directionalShadowMatrix),
              (f.spotShadowMap.value = r.state.spotShadowMap),
              (f.spotShadowMatrix.value = r.state.spotShadowMatrix),
              (f.pointShadowMap.value = r.state.pointShadowMap),
              (f.pointShadowMatrix.value = r.state.pointShadowMatrix));
          var m = i.program.getUniforms(),
            g = Ja.seqWithValue(m.seq, f);
          i.uniformsList = g;
        }
        function Tt(t, e, n, i) {
          q = 0;
          var r = x.get(n),
            a = d.state.lights;
          if (et && (nt || t !== k)) {
            var o = t === k && n.id === F;
            tt.setState(
              n.clippingPlanes,
              n.clipIntersection,
              n.clipShadows,
              t,
              r,
              o
            );
          }
          !1 === n.needsUpdate &&
            (void 0 === r.program ||
            (n.fog && r.fog !== e) ||
            (n.lights && r.lightsHash !== a.state.hash)
              ? (n.needsUpdate = !0)
              : void 0 === r.numClippingPlanes ||
                (r.numClippingPlanes === tt.numPlanes &&
                  r.numIntersection === tt.numIntersection) ||
                (n.needsUpdate = !0)),
            n.needsUpdate && (Et(n, e, i), (n.needsUpdate = !1));
          var s = !1,
            c = !1,
            l = !1,
            h = r.program,
            u = h.getUniforms(),
            f = r.shader.uniforms;
          if (
            (v.useProgram(h.program) && ((s = !0), (c = !0), (l = !0)),
            n.id !== F && ((F = n.id), (c = !0)),
            s || t !== k)
          ) {
            if (
              (u.setValue(p, "projectionMatrix", t.projectionMatrix),
              m.logarithmicDepthBuffer &&
                u.setValue(
                  p,
                  "logDepthBufFC",
                  2 / (Math.log(t.far + 1) / Math.LN2)
                ),
              k !== (G || t) && ((k = G || t), (c = !0), (l = !0)),
              n.isShaderMaterial ||
                n.isMeshPhongMaterial ||
                n.isMeshStandardMaterial ||
                n.envMap)
            ) {
              var g = u.map.cameraPosition;
              void 0 !== g &&
                g.setValue(p, at.setFromMatrixPosition(t.matrixWorld));
            }
            (n.isMeshPhongMaterial ||
              n.isMeshLambertMaterial ||
              n.isMeshBasicMaterial ||
              n.isMeshStandardMaterial ||
              n.isShaderMaterial ||
              n.skinning) &&
              u.setValue(p, "viewMatrix", t.matrixWorldInverse);
          }
          if (n.skinning) {
            u.setOptional(p, i, "bindMatrix"),
              u.setOptional(p, i, "bindMatrixInverse");
            var y = i.skeleton;
            if (y) {
              var _ = y.bones;
              if (m.floatVertexTextures) {
                if (void 0 === y.boneTexture) {
                  var b = Math.sqrt(4 * _.length);
                  (b = ze.ceilPowerOfTwo(b)), (b = Math.max(b, 4));
                  var w = new Float32Array(b * b * 4);
                  w.set(y.boneMatrices);
                  var M = new Ye(w, b, b, Ut, Lt);
                  (M.needsUpdate = !0),
                    (y.boneMatrices = w),
                    (y.boneTexture = M),
                    (y.boneTextureSize = b);
                }
                u.setValue(p, "boneTexture", y.boneTexture),
                  u.setValue(p, "boneTextureSize", y.boneTextureSize);
              } else u.setOptional(p, y, "boneMatrices");
            }
          }
          return (
            c &&
              (u.setValue(p, "toneMappingExposure", O.toneMappingExposure),
              u.setValue(p, "toneMappingWhitePoint", O.toneMappingWhitePoint),
              n.lights && Vt(f, l),
              e && n.fog && It(f, e),
              n.isMeshBasicMaterial
                ? At(f, n)
                : n.isMeshLambertMaterial
                ? (At(f, n), Ot(f, n))
                : n.isMeshPhongMaterial
                ? (At(f, n), n.isMeshToonMaterial ? Bt(f, n) : Nt(f, n))
                : n.isMeshStandardMaterial
                ? (At(f, n), n.isMeshPhysicalMaterial ? Ft(f, n) : zt(f, n))
                : n.isMeshDepthMaterial
                ? (At(f, n), Ht(f, n))
                : n.isMeshDistanceMaterial
                ? (At(f, n), kt(f, n))
                : n.isMeshNormalMaterial
                ? (At(f, n), Gt(f, n))
                : n.isLineBasicMaterial
                ? (Ct(f, n), n.isLineDashedMaterial && Rt(f, n))
                : n.isPointsMaterial
                ? Dt(f, n)
                : n.isShadowMaterial &&
                  ((f.color.value = n.color), (f.opacity.value = n.opacity)),
              void 0 !== f.ltc_1 && (f.ltc_1.value = lr.LTC_1),
              void 0 !== f.ltc_2 && (f.ltc_2.value = lr.LTC_2),
              Ja.upload(p, r.uniformsList, f, O)),
            n.isShaderMaterial &&
              !0 === n.uniformsNeedUpdate &&
              (Ja.upload(p, r.uniformsList, f, O), (n.uniformsNeedUpdate = !1)),
            u.setValue(p, "modelViewMatrix", i.modelViewMatrix),
            u.setValue(p, "normalMatrix", i.normalMatrix),
            u.setValue(p, "modelMatrix", i.matrixWorld),
            h
          );
        }
        function At(t, e) {
          var n;
          (t.opacity.value = e.opacity),
            e.color && (t.diffuse.value = e.color),
            e.emissive &&
              t.emissive.value
                .copy(e.emissive)
                .multiplyScalar(e.emissiveIntensity),
            e.map && (t.map.value = e.map),
            e.alphaMap && (t.alphaMap.value = e.alphaMap),
            e.specularMap && (t.specularMap.value = e.specularMap),
            e.envMap &&
              ((t.envMap.value = e.envMap),
              (t.flipEnvMap.value =
                e.envMap && e.envMap.isCubeTexture ? -1 : 1),
              (t.reflectivity.value = e.reflectivity),
              (t.refractionRatio.value = e.refractionRatio),
              (t.maxMipLevel.value = x.get(e.envMap).__maxMipLevel)),
            e.lightMap &&
              ((t.lightMap.value = e.lightMap),
              (t.lightMapIntensity.value = e.lightMapIntensity)),
            e.aoMap &&
              ((t.aoMap.value = e.aoMap),
              (t.aoMapIntensity.value = e.aoMapIntensity)),
            e.map
              ? (n = e.map)
              : e.specularMap
              ? (n = e.specularMap)
              : e.displacementMap
              ? (n = e.displacementMap)
              : e.normalMap
              ? (n = e.normalMap)
              : e.bumpMap
              ? (n = e.bumpMap)
              : e.roughnessMap
              ? (n = e.roughnessMap)
              : e.metalnessMap
              ? (n = e.metalnessMap)
              : e.alphaMap
              ? (n = e.alphaMap)
              : e.emissiveMap && (n = e.emissiveMap),
            void 0 !== n &&
              (n.isWebGLRenderTarget && (n = n.texture),
              !0 === n.matrixAutoUpdate && n.updateMatrix(),
              t.uvTransform.value.copy(n.matrix));
        }
        function Ct(t, e) {
          (t.diffuse.value = e.color), (t.opacity.value = e.opacity);
        }
        function Rt(t, e) {
          (t.dashSize.value = e.dashSize),
            (t.totalSize.value = e.dashSize + e.gapSize),
            (t.scale.value = e.scale);
        }
        function Dt(t, e) {
          (t.diffuse.value = e.color),
            (t.opacity.value = e.opacity),
            (t.size.value = e.size * J),
            (t.scale.value = 0.5 * Y),
            (t.map.value = e.map),
            null !== e.map &&
              (!0 === e.map.matrixAutoUpdate && e.map.updateMatrix(),
              t.uvTransform.value.copy(e.map.matrix));
        }
        function It(t, e) {
          (t.fogColor.value = e.color),
            e.isFog
              ? ((t.fogNear.value = e.near), (t.fogFar.value = e.far))
              : e.isFogExp2 && (t.fogDensity.value = e.density);
        }
        function Ot(t, e) {
          e.emissiveMap && (t.emissiveMap.value = e.emissiveMap);
        }
        function Nt(t, e) {
          (t.specular.value = e.specular),
            (t.shininess.value = Math.max(e.shininess, 1e-4)),
            e.emissiveMap && (t.emissiveMap.value = e.emissiveMap),
            e.bumpMap &&
              ((t.bumpMap.value = e.bumpMap),
              (t.bumpScale.value = e.bumpScale),
              e.side === g && (t.bumpScale.value *= -1)),
            e.normalMap &&
              ((t.normalMap.value = e.normalMap),
              t.normalScale.value.copy(e.normalScale),
              e.side === g && t.normalScale.value.negate()),
            e.displacementMap &&
              ((t.displacementMap.value = e.displacementMap),
              (t.displacementScale.value = e.displacementScale),
              (t.displacementBias.value = e.displacementBias));
        }
        function Bt(t, e) {
          Nt(t, e), e.gradientMap && (t.gradientMap.value = e.gradientMap);
        }
        function zt(t, e) {
          (t.roughness.value = e.roughness),
            (t.metalness.value = e.metalness),
            e.roughnessMap && (t.roughnessMap.value = e.roughnessMap),
            e.metalnessMap && (t.metalnessMap.value = e.metalnessMap),
            e.emissiveMap && (t.emissiveMap.value = e.emissiveMap),
            e.bumpMap &&
              ((t.bumpMap.value = e.bumpMap),
              (t.bumpScale.value = e.bumpScale),
              e.side === g && (t.bumpScale.value *= -1)),
            e.normalMap &&
              ((t.normalMap.value = e.normalMap),
              t.normalScale.value.copy(e.normalScale),
              e.side === g && t.normalScale.value.negate()),
            e.displacementMap &&
              ((t.displacementMap.value = e.displacementMap),
              (t.displacementScale.value = e.displacementScale),
              (t.displacementBias.value = e.displacementBias)),
            e.envMap && (t.envMapIntensity.value = e.envMapIntensity);
        }
        function Ft(t, e) {
          zt(t, e),
            (t.reflectivity.value = e.reflectivity),
            (t.clearCoat.value = e.clearCoat),
            (t.clearCoatRoughness.value = e.clearCoatRoughness);
        }
        function Ht(t, e) {
          e.displacementMap &&
            ((t.displacementMap.value = e.displacementMap),
            (t.displacementScale.value = e.displacementScale),
            (t.displacementBias.value = e.displacementBias));
        }
        function kt(t, e) {
          e.displacementMap &&
            ((t.displacementMap.value = e.displacementMap),
            (t.displacementScale.value = e.displacementScale),
            (t.displacementBias.value = e.displacementBias)),
            t.referencePosition.value.copy(e.referencePosition),
            (t.nearDistance.value = e.nearDistance),
            (t.farDistance.value = e.farDistance);
        }
        function Gt(t, e) {
          e.bumpMap &&
            ((t.bumpMap.value = e.bumpMap),
            (t.bumpScale.value = e.bumpScale),
            e.side === g && (t.bumpScale.value *= -1)),
            e.normalMap &&
              ((t.normalMap.value = e.normalMap),
              t.normalScale.value.copy(e.normalScale),
              e.side === g && t.normalScale.value.negate()),
            e.displacementMap &&
              ((t.displacementMap.value = e.displacementMap),
              (t.displacementScale.value = e.displacementScale),
              (t.displacementBias.value = e.displacementBias));
        }
        function Vt(t, e) {
          (t.ambientLightColor.needsUpdate = e),
            (t.directionalLights.needsUpdate = e),
            (t.pointLights.needsUpdate = e),
            (t.spotLights.needsUpdate = e),
            (t.rectAreaLights.needsUpdate = e),
            (t.hemisphereLights.needsUpdate = e);
        }
        function Wt() {
          var t = q;
          return (
            t >= m.maxTextures &&
              console.warn(
                "THREE.WebGLRenderer: Trying to use " +
                  t +
                  " texture units while this GPU supports only " +
                  m.maxTextures
              ),
            (q += 1),
            t
          );
        }
        _t.setAnimationLoop(xt),
          "undefined" !== typeof window && _t.setContext(window),
          (this.setAnimationLoop = function (t) {
            (yt = t), lt.setAnimationLoop(t), _t.start();
          }),
          (this.render = function (t, e, n, i) {
            if (e && e.isCamera) {
              if (!N) {
                (H = ""),
                  (F = -1),
                  (k = null),
                  !0 === t.autoUpdate && t.updateMatrixWorld(),
                  null === e.parent && e.updateMatrixWorld(),
                  lt.enabled && (e = lt.getCamera(e)),
                  (d = A.get(t, e)),
                  d.init(),
                  t.onBeforeRender(O, t, e, n),
                  rt.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse),
                  Q.setFromMatrix(rt),
                  (nt = this.localClippingEnabled),
                  (et = tt.init(this.clippingPlanes, nt, e)),
                  (u = T.get(t, e)),
                  u.init(),
                  bt(t, e, O.sortObjects),
                  !0 === O.sortObjects && u.sort(),
                  et && tt.beginShadows();
                var r = d.state.shadowsArray;
                ht.render(r, t, e),
                  d.setupLights(e),
                  et && tt.endShadows(),
                  this.info.autoReset && this.info.reset(),
                  void 0 === n && (n = null),
                  this.setRenderTarget(n),
                  C.render(u, t, e, i);
                var a = u.opaque,
                  o = u.transparent;
                if (t.overrideMaterial) {
                  var s = t.overrideMaterial;
                  a.length && wt(a, t, e, s), o.length && wt(o, t, e, s);
                } else a.length && wt(a, t, e), o.length && wt(o, t, e);
                var c = d.state.spritesArray;
                D.render(c, t, e),
                  n && b.updateRenderTargetMipmap(n),
                  v.buffers.depth.setTest(!0),
                  v.buffers.depth.setMask(!0),
                  v.buffers.color.setMask(!0),
                  v.setPolygonOffset(!1),
                  t.onAfterRender(O, t, e),
                  lt.enabled && lt.submitFrame(),
                  (u = null),
                  (d = null);
              }
            } else
              console.error(
                "THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera."
              );
          }),
          (this.allocTextureUnit = Wt),
          (this.setTexture2D = (function () {
            var t = !1;
            return function (e, n) {
              e &&
                e.isWebGLRenderTarget &&
                (t ||
                  (console.warn(
                    "THREE.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead."
                  ),
                  (t = !0)),
                (e = e.texture)),
                b.setTexture2D(e, n);
            };
          })()),
          (this.setTexture = (function () {
            var t = !1;
            return function (e, n) {
              t ||
                (console.warn(
                  "THREE.WebGLRenderer: .setTexture is deprecated, use setTexture2D instead."
                ),
                (t = !0)),
                b.setTexture2D(e, n);
            };
          })()),
          (this.setTextureCube = (function () {
            var t = !1;
            return function (e, n) {
              e &&
                e.isWebGLRenderTargetCube &&
                (t ||
                  (console.warn(
                    "THREE.WebGLRenderer.setTextureCube: don't use cube render targets as textures. Use their .texture property instead."
                  ),
                  (t = !0)),
                (e = e.texture)),
                (e && e.isCubeTexture) ||
                (Array.isArray(e.image) && 6 === e.image.length)
                  ? b.setTextureCube(e, n)
                  : b.setTextureCubeDynamic(e, n);
            };
          })()),
          (this.setFramebuffer = function (t) {
            B = t;
          }),
          (this.getRenderTarget = function () {
            return z;
          }),
          (this.setRenderTarget = function (t) {
            (z = t),
              t &&
                void 0 === x.get(t).__webglFramebuffer &&
                b.setupRenderTarget(t);
            var e = B,
              n = !1;
            if (t) {
              var i = x.get(t).__webglFramebuffer;
              t.isWebGLRenderTargetCube
                ? ((e = i[t.activeCubeFace]), (n = !0))
                : (e = i),
                V.copy(t.viewport),
                W.copy(t.scissor),
                (j = t.scissorTest);
            } else
              V.copy(Z).multiplyScalar(J), W.copy(K).multiplyScalar(J), (j = $);
            if (
              (U !== e && (p.bindFramebuffer(p.FRAMEBUFFER, e), (U = e)),
              v.viewport(V),
              v.scissor(W),
              v.setScissorTest(j),
              n)
            ) {
              var r = x.get(t.texture);
              p.framebufferTexture2D(
                p.FRAMEBUFFER,
                p.COLOR_ATTACHMENT0,
                p.TEXTURE_CUBE_MAP_POSITIVE_X + t.activeCubeFace,
                r.__webglTexture,
                t.activeMipMapLevel
              );
            }
          }),
          (this.readRenderTargetPixels = function (t, e, n, i, r, a) {
            if (t && t.isWebGLRenderTarget) {
              var o = x.get(t).__webglFramebuffer;
              if (o) {
                var s = !1;
                o !== U && (p.bindFramebuffer(p.FRAMEBUFFER, o), (s = !0));
                try {
                  var c = t.texture,
                    l = c.format,
                    h = c.type;
                  if (
                    l !== Ut &&
                    I.convert(l) !==
                      p.getParameter(p.IMPLEMENTATION_COLOR_READ_FORMAT)
                  )
                    return void console.error(
                      "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format."
                    );
                  if (
                    h !== St &&
                    I.convert(h) !==
                      p.getParameter(p.IMPLEMENTATION_COLOR_READ_TYPE) &&
                    (h !== Lt ||
                      (!f.get("OES_texture_float") &&
                        !f.get("WEBGL_color_buffer_float"))) &&
                    (h !== Pt || !f.get("EXT_color_buffer_half_float"))
                  )
                    return void console.error(
                      "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type."
                    );
                  p.checkFramebufferStatus(p.FRAMEBUFFER) ===
                  p.FRAMEBUFFER_COMPLETE
                    ? e >= 0 &&
                      e <= t.width - i &&
                      n >= 0 &&
                      n <= t.height - r &&
                      p.readPixels(e, n, i, r, I.convert(l), I.convert(h), a)
                    : console.error(
                        "THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete."
                      );
                } finally {
                  s && p.bindFramebuffer(p.FRAMEBUFFER, U);
                }
              }
            } else
              console.error(
                "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget."
              );
          }),
          (this.copyFramebufferToTexture = function (t, e, n) {
            var i = e.image.width,
              r = e.image.height,
              a = I.convert(e.format);
            this.setTexture2D(e, 0),
              p.copyTexImage2D(p.TEXTURE_2D, n || 0, a, t.x, t.y, i, r, 0);
          }),
          (this.copyTextureToTexture = function (t, e, n, i) {
            var r = e.image.width,
              a = e.image.height,
              o = I.convert(n.format),
              s = I.convert(n.type);
            this.setTexture2D(n, 0),
              e.isDataTexture
                ? p.texSubImage2D(
                    p.TEXTURE_2D,
                    i || 0,
                    t.x,
                    t.y,
                    r,
                    a,
                    o,
                    s,
                    e.image.data
                  )
                : p.texSubImage2D(
                    p.TEXTURE_2D,
                    i || 0,
                    t.x,
                    t.y,
                    o,
                    s,
                    e.image
                  );
          });
      }
      function Uo(t, e) {
        (this.name = ""),
          (this.color = new cr(t)),
          (this.density = void 0 !== e ? e : 25e-5);
      }
      function Fo(t, e, n) {
        (this.name = ""),
          (this.color = new cr(t)),
          (this.near = void 0 !== e ? e : 1),
          (this.far = void 0 !== n ? n : 1e3);
      }
      function Ho() {
        gr.call(this),
          (this.type = "Scene"),
          (this.background = null),
          (this.fog = null),
          (this.overrideMaterial = null),
          (this.autoUpdate = !0);
      }
      function ko(t) {
        kr.call(this),
          (this.type = "SpriteMaterial"),
          (this.color = new cr(16777215)),
          (this.map = null),
          (this.rotation = 0),
          (this.fog = !1),
          (this.lights = !1),
          this.setValues(t);
      }
      function Go(t) {
        gr.call(this),
          (this.type = "Sprite"),
          (this.material = void 0 !== t ? t : new ko()),
          (this.center = new Ue(0.5, 0.5));
      }
      function Vo() {
        gr.call(this),
          (this.type = "LOD"),
          Object.defineProperties(this, {
            levels: { enumerable: !0, value: [] },
          });
      }
      function Wo(t, e) {
        if (
          ((t = t || []),
          (this.bones = t.slice(0)),
          (this.boneMatrices = new Float32Array(16 * this.bones.length)),
          void 0 === e)
        )
          this.calculateInverses();
        else if (this.bones.length === e.length) this.boneInverses = e.slice(0);
        else {
          console.warn("THREE.Skeleton boneInverses is the wrong length."),
            (this.boneInverses = []);
          for (var n = 0, i = this.bones.length; n < i; n++)
            this.boneInverses.push(new Fe());
        }
      }
      function jo() {
        gr.call(this), (this.type = "Bone");
      }
      function qo(t, e) {
        Xr.call(this, t, e),
          (this.type = "SkinnedMesh"),
          (this.bindMode = "attached"),
          (this.bindMatrix = new Fe()),
          (this.bindMatrixInverse = new Fe());
        var n = this.initBones(),
          i = new Wo(n);
        this.bind(i, this.matrixWorld), this.normalizeSkinWeights();
      }
      function Xo(t) {
        kr.call(this),
          (this.type = "LineBasicMaterial"),
          (this.color = new cr(16777215)),
          (this.linewidth = 1),
          (this.linecap = "round"),
          (this.linejoin = "round"),
          (this.lights = !1),
          this.setValues(t);
      }
      function Yo(t, e, n) {
        if (1 === n)
          return (
            console.warn(
              "THREE.Line: parameter THREE.LinePieces no longer supported. Created THREE.LineSegments instead."
            ),
            new Jo(t, e)
          );
        gr.call(this),
          (this.type = "Line"),
          (this.geometry = void 0 !== t ? t : new Nr()),
          (this.material =
            void 0 !== e ? e : new Xo({ color: 16777215 * Math.random() }));
      }
      function Jo(t, e) {
        Yo.call(this, t, e), (this.type = "LineSegments");
      }
      function Zo(t, e) {
        Yo.call(this, t, e), (this.type = "LineLoop");
      }
      function Ko(t) {
        kr.call(this),
          (this.type = "PointsMaterial"),
          (this.color = new cr(16777215)),
          (this.map = null),
          (this.size = 1),
          (this.sizeAttenuation = !0),
          (this.morphTargets = !1),
          (this.lights = !1),
          this.setValues(t);
      }
      function $o(t, e) {
        gr.call(this),
          (this.type = "Points"),
          (this.geometry = void 0 !== t ? t : new Nr()),
          (this.material =
            void 0 !== e ? e : new Ko({ color: 16777215 * Math.random() }));
      }
      function Qo(t, e, n, i, r, a, o, s, c) {
        We.call(this, t, e, n, i, r, a, o, s, c), (this.generateMipmaps = !1);
      }
      function ts(t, e, n, i, r, a, o, s, c, l, h, u) {
        We.call(this, null, a, o, s, c, l, i, r, h, u),
          (this.image = { width: e, height: n }),
          (this.mipmaps = t),
          (this.flipY = !1),
          (this.generateMipmaps = !1);
      }
      function es(t, e, n, i, r, a, o, s, c, l) {
        if (((l = void 0 !== l ? l : Gt), l !== Gt && l !== Vt))
          throw new Error(
            "DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat"
          );
        void 0 === n && l === Gt && (n = At),
          void 0 === n && l === Vt && (n = Nt),
          We.call(this, null, i, r, a, o, s, l, n, c),
          (this.image = { width: t, height: e }),
          (this.magFilter = void 0 !== o ? o : yt),
          (this.minFilter = void 0 !== s ? s : yt),
          (this.flipY = !1),
          (this.generateMipmaps = !1);
      }
      function ns(t) {
        Nr.call(this), (this.type = "WireframeGeometry");
        var e,
          n,
          i,
          r,
          a,
          o,
          s,
          c,
          l,
          h,
          u = [],
          d = [0, 0],
          p = {},
          f = ["a", "b", "c"];
        if (t && t.isGeometry) {
          var m = t.faces;
          for (e = 0, i = m.length; e < i; e++) {
            var g = m[e];
            for (n = 0; n < 3; n++)
              (s = g[f[n]]),
                (c = g[f[(n + 1) % 3]]),
                (d[0] = Math.min(s, c)),
                (d[1] = Math.max(s, c)),
                (l = d[0] + "," + d[1]),
                void 0 === p[l] && (p[l] = { index1: d[0], index2: d[1] });
          }
          for (l in p)
            (o = p[l]),
              (h = t.vertices[o.index1]),
              u.push(h.x, h.y, h.z),
              (h = t.vertices[o.index2]),
              u.push(h.x, h.y, h.z);
        } else if (t && t.isBufferGeometry) {
          var v, y, x, _, b, w, M, S;
          if (((h = new ke()), null !== t.index)) {
            for (
              v = t.attributes.position,
                y = t.index,
                x = t.groups,
                0 === x.length &&
                  (x = [{ start: 0, count: y.count, materialIndex: 0 }]),
                r = 0,
                a = x.length;
              r < a;
              ++r
            )
              for (
                _ = x[r], b = _.start, w = _.count, e = b, i = b + w;
                e < i;
                e += 3
              )
                for (n = 0; n < 3; n++)
                  (s = y.getX(e + n)),
                    (c = y.getX(e + ((n + 1) % 3))),
                    (d[0] = Math.min(s, c)),
                    (d[1] = Math.max(s, c)),
                    (l = d[0] + "," + d[1]),
                    void 0 === p[l] && (p[l] = { index1: d[0], index2: d[1] });
            for (l in p)
              (o = p[l]),
                h.fromBufferAttribute(v, o.index1),
                u.push(h.x, h.y, h.z),
                h.fromBufferAttribute(v, o.index2),
                u.push(h.x, h.y, h.z);
          } else
            for (v = t.attributes.position, e = 0, i = v.count / 3; e < i; e++)
              for (n = 0; n < 3; n++)
                (M = 3 * e + n),
                  h.fromBufferAttribute(v, M),
                  u.push(h.x, h.y, h.z),
                  (S = 3 * e + ((n + 1) % 3)),
                  h.fromBufferAttribute(v, S),
                  u.push(h.x, h.y, h.z);
        }
        this.addAttribute("position", new Lr(u, 3));
      }
      function is(t, e, n) {
        br.call(this),
          (this.type = "ParametricGeometry"),
          (this.parameters = { func: t, slices: e, stacks: n }),
          this.fromBufferGeometry(new rs(t, e, n)),
          this.mergeVertices();
      }
      function rs(t, e, n) {
        Nr.call(this),
          (this.type = "ParametricBufferGeometry"),
          (this.parameters = { func: t, slices: e, stacks: n });
        var i,
          r,
          a = [],
          o = [],
          s = [],
          c = [],
          l = 1e-5,
          h = new ke(),
          u = new ke(),
          d = new ke(),
          p = new ke(),
          f = new ke();
        t.length < 3 &&
          console.error(
            "THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter."
          );
        var m = e + 1;
        for (i = 0; i <= n; i++) {
          var g = i / n;
          for (r = 0; r <= e; r++) {
            var v = r / e;
            t(v, g, u),
              o.push(u.x, u.y, u.z),
              v - l >= 0
                ? (t(v - l, g, d), p.subVectors(u, d))
                : (t(v + l, g, d), p.subVectors(d, u)),
              g - l >= 0
                ? (t(v, g - l, d), f.subVectors(u, d))
                : (t(v, g + l, d), f.subVectors(d, u)),
              h.crossVectors(p, f).normalize(),
              s.push(h.x, h.y, h.z),
              c.push(v, g);
          }
        }
        for (i = 0; i < n; i++)
          for (r = 0; r < e; r++) {
            var y = i * m + r,
              x = i * m + r + 1,
              _ = (i + 1) * m + r + 1,
              b = (i + 1) * m + r;
            a.push(y, x, b), a.push(x, _, b);
          }
        this.setIndex(a),
          this.addAttribute("position", new Lr(o, 3)),
          this.addAttribute("normal", new Lr(s, 3)),
          this.addAttribute("uv", new Lr(c, 2));
      }
      function as(t, e, n, i) {
        br.call(this),
          (this.type = "PolyhedronGeometry"),
          (this.parameters = { vertices: t, indices: e, radius: n, detail: i }),
          this.fromBufferGeometry(new os(t, e, n, i)),
          this.mergeVertices();
      }
      function os(t, e, n, i) {
        Nr.call(this),
          (this.type = "PolyhedronBufferGeometry"),
          (this.parameters = { vertices: t, indices: e, radius: n, detail: i }),
          (n = n || 1),
          (i = i || 0);
        var r = [],
          a = [];
        function o(t) {
          for (
            var n = new ke(), i = new ke(), r = new ke(), a = 0;
            a < e.length;
            a += 3
          )
            d(e[a + 0], n), d(e[a + 1], i), d(e[a + 2], r), s(n, i, r, t);
        }
        function s(t, e, n, i) {
          var r,
            a,
            o = Math.pow(2, i),
            s = [];
          for (r = 0; r <= o; r++) {
            s[r] = [];
            var c = t.clone().lerp(n, r / o),
              l = e.clone().lerp(n, r / o),
              h = o - r;
            for (a = 0; a <= h; a++)
              s[r][a] = 0 === a && r === o ? c : c.clone().lerp(l, a / h);
          }
          for (r = 0; r < o; r++)
            for (a = 0; a < 2 * (o - r) - 1; a++) {
              var d = Math.floor(a / 2);
              a % 2 === 0
                ? (u(s[r][d + 1]), u(s[r + 1][d]), u(s[r][d]))
                : (u(s[r][d + 1]), u(s[r + 1][d + 1]), u(s[r + 1][d]));
            }
        }
        function c(t) {
          for (var e = new ke(), n = 0; n < r.length; n += 3)
            (e.x = r[n + 0]),
              (e.y = r[n + 1]),
              (e.z = r[n + 2]),
              e.normalize().multiplyScalar(t),
              (r[n + 0] = e.x),
              (r[n + 1] = e.y),
              (r[n + 2] = e.z);
        }
        function l() {
          for (var t = new ke(), e = 0; e < r.length; e += 3) {
            (t.x = r[e + 0]), (t.y = r[e + 1]), (t.z = r[e + 2]);
            var n = m(t) / 2 / Math.PI + 0.5,
              i = g(t) / Math.PI + 0.5;
            a.push(n, 1 - i);
          }
          p(), h();
        }
        function h() {
          for (var t = 0; t < a.length; t += 6) {
            var e = a[t + 0],
              n = a[t + 2],
              i = a[t + 4],
              r = Math.max(e, n, i),
              o = Math.min(e, n, i);
            r > 0.9 &&
              o < 0.1 &&
              (e < 0.2 && (a[t + 0] += 1),
              n < 0.2 && (a[t + 2] += 1),
              i < 0.2 && (a[t + 4] += 1));
          }
        }
        function u(t) {
          r.push(t.x, t.y, t.z);
        }
        function d(e, n) {
          var i = 3 * e;
          (n.x = t[i + 0]), (n.y = t[i + 1]), (n.z = t[i + 2]);
        }
        function p() {
          for (
            var t = new ke(),
              e = new ke(),
              n = new ke(),
              i = new ke(),
              o = new Ue(),
              s = new Ue(),
              c = new Ue(),
              l = 0,
              h = 0;
            l < r.length;
            l += 9, h += 6
          ) {
            t.set(r[l + 0], r[l + 1], r[l + 2]),
              e.set(r[l + 3], r[l + 4], r[l + 5]),
              n.set(r[l + 6], r[l + 7], r[l + 8]),
              o.set(a[h + 0], a[h + 1]),
              s.set(a[h + 2], a[h + 3]),
              c.set(a[h + 4], a[h + 5]),
              i.copy(t).add(e).add(n).divideScalar(3);
            var u = m(i);
            f(o, h + 0, t, u), f(s, h + 2, e, u), f(c, h + 4, n, u);
          }
        }
        function f(t, e, n, i) {
          i < 0 && 1 === t.x && (a[e] = t.x - 1),
            0 === n.x && 0 === n.z && (a[e] = i / 2 / Math.PI + 0.5);
        }
        function m(t) {
          return Math.atan2(t.z, -t.x);
        }
        function g(t) {
          return Math.atan2(-t.y, Math.sqrt(t.x * t.x + t.z * t.z));
        }
        o(i),
          c(n),
          l(),
          this.addAttribute("position", new Lr(r, 3)),
          this.addAttribute("normal", new Lr(r.slice(), 3)),
          this.addAttribute("uv", new Lr(a, 2)),
          0 === i ? this.computeVertexNormals() : this.normalizeNormals();
      }
      function ss(t, e) {
        br.call(this),
          (this.type = "TetrahedronGeometry"),
          (this.parameters = { radius: t, detail: e }),
          this.fromBufferGeometry(new cs(t, e)),
          this.mergeVertices();
      }
      function cs(t, e) {
        var n = [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1],
          i = [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1];
        os.call(this, n, i, t, e),
          (this.type = "TetrahedronBufferGeometry"),
          (this.parameters = { radius: t, detail: e });
      }
      function ls(t, e) {
        br.call(this),
          (this.type = "OctahedronGeometry"),
          (this.parameters = { radius: t, detail: e }),
          this.fromBufferGeometry(new hs(t, e)),
          this.mergeVertices();
      }
      function hs(t, e) {
        var n = [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1],
          i = [
            0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4,
            2,
          ];
        os.call(this, n, i, t, e),
          (this.type = "OctahedronBufferGeometry"),
          (this.parameters = { radius: t, detail: e });
      }
      function us(t, e) {
        br.call(this),
          (this.type = "IcosahedronGeometry"),
          (this.parameters = { radius: t, detail: e }),
          this.fromBufferGeometry(new ds(t, e)),
          this.mergeVertices();
      }
      function ds(t, e) {
        var n = (1 + Math.sqrt(5)) / 2,
          i = [
            -1,
            n,
            0,
            1,
            n,
            0,
            -1,
            -n,
            0,
            1,
            -n,
            0,
            0,
            -1,
            n,
            0,
            1,
            n,
            0,
            -1,
            -n,
            0,
            1,
            -n,
            n,
            0,
            -1,
            n,
            0,
            1,
            -n,
            0,
            -1,
            -n,
            0,
            1,
          ],
          r = [
            0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4,
            11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3,
            8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1,
          ];
        os.call(this, i, r, t, e),
          (this.type = "IcosahedronBufferGeometry"),
          (this.parameters = { radius: t, detail: e });
      }
      function ps(t, e) {
        br.call(this),
          (this.type = "DodecahedronGeometry"),
          (this.parameters = { radius: t, detail: e }),
          this.fromBufferGeometry(new fs(t, e)),
          this.mergeVertices();
      }
      function fs(t, e) {
        var n = (1 + Math.sqrt(5)) / 2,
          i = 1 / n,
          r = [
            -1,
            -1,
            -1,
            -1,
            -1,
            1,
            -1,
            1,
            -1,
            -1,
            1,
            1,
            1,
            -1,
            -1,
            1,
            -1,
            1,
            1,
            1,
            -1,
            1,
            1,
            1,
            0,
            -i,
            -n,
            0,
            -i,
            n,
            0,
            i,
            -n,
            0,
            i,
            n,
            -i,
            -n,
            0,
            -i,
            n,
            0,
            i,
            -n,
            0,
            i,
            n,
            0,
            -n,
            0,
            -i,
            n,
            0,
            -i,
            -n,
            0,
            i,
            n,
            0,
            i,
          ],
          a = [
            3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4,
            8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0,
            1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18,
            3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4,
            0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4,
            17, 1, 12, 14, 1, 14, 5, 1, 5, 9,
          ];
        os.call(this, r, a, t, e),
          (this.type = "DodecahedronBufferGeometry"),
          (this.parameters = { radius: t, detail: e });
      }
      function ms(t, e, n, i, r, a) {
        br.call(this),
          (this.type = "TubeGeometry"),
          (this.parameters = {
            path: t,
            tubularSegments: e,
            radius: n,
            radialSegments: i,
            closed: r,
          }),
          void 0 !== a &&
            console.warn("THREE.TubeGeometry: taper has been removed.");
        var o = new gs(t, e, n, i, r);
        (this.tangents = o.tangents),
          (this.normals = o.normals),
          (this.binormals = o.binormals),
          this.fromBufferGeometry(o),
          this.mergeVertices();
      }
      function gs(t, e, n, i, r) {
        Nr.call(this),
          (this.type = "TubeBufferGeometry"),
          (this.parameters = {
            path: t,
            tubularSegments: e,
            radius: n,
            radialSegments: i,
            closed: r,
          }),
          (e = e || 64),
          (n = n || 1),
          (i = i || 8),
          (r = r || !1);
        var a = t.computeFrenetFrames(e, r);
        (this.tangents = a.tangents),
          (this.normals = a.normals),
          (this.binormals = a.binormals);
        var o,
          s,
          c = new ke(),
          l = new ke(),
          h = new Ue(),
          u = new ke(),
          d = [],
          p = [],
          f = [],
          m = [];
        function g() {
          for (o = 0; o < e; o++) v(o);
          v(!1 === r ? e : 0), x(), y();
        }
        function v(r) {
          u = t.getPointAt(r / e, u);
          var o = a.normals[r],
            h = a.binormals[r];
          for (s = 0; s <= i; s++) {
            var f = (s / i) * Math.PI * 2,
              m = Math.sin(f),
              g = -Math.cos(f);
            (l.x = g * o.x + m * h.x),
              (l.y = g * o.y + m * h.y),
              (l.z = g * o.z + m * h.z),
              l.normalize(),
              p.push(l.x, l.y, l.z),
              (c.x = u.x + n * l.x),
              (c.y = u.y + n * l.y),
              (c.z = u.z + n * l.z),
              d.push(c.x, c.y, c.z);
          }
        }
        function y() {
          for (s = 1; s <= e; s++)
            for (o = 1; o <= i; o++) {
              var t = (i + 1) * (s - 1) + (o - 1),
                n = (i + 1) * s + (o - 1),
                r = (i + 1) * s + o,
                a = (i + 1) * (s - 1) + o;
              m.push(t, n, a), m.push(n, r, a);
            }
        }
        function x() {
          for (o = 0; o <= e; o++)
            for (s = 0; s <= i; s++)
              (h.x = o / e), (h.y = s / i), f.push(h.x, h.y);
        }
        g(),
          this.setIndex(m),
          this.addAttribute("position", new Lr(d, 3)),
          this.addAttribute("normal", new Lr(p, 3)),
          this.addAttribute("uv", new Lr(f, 2));
      }
      function vs(t, e, n, i, r, a, o) {
        br.call(this),
          (this.type = "TorusKnotGeometry"),
          (this.parameters = {
            radius: t,
            tube: e,
            tubularSegments: n,
            radialSegments: i,
            p: r,
            q: a,
          }),
          void 0 !== o &&
            console.warn(
              "THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead."
            ),
          this.fromBufferGeometry(new ys(t, e, n, i, r, a)),
          this.mergeVertices();
      }
      function ys(t, e, n, i, r, a) {
        Nr.call(this),
          (this.type = "TorusKnotBufferGeometry"),
          (this.parameters = {
            radius: t,
            tube: e,
            tubularSegments: n,
            radialSegments: i,
            p: r,
            q: a,
          }),
          (t = t || 1),
          (e = e || 0.4),
          (n = Math.floor(n) || 64),
          (i = Math.floor(i) || 8),
          (r = r || 2),
          (a = a || 3);
        var o,
          s,
          c = [],
          l = [],
          h = [],
          u = [],
          d = new ke(),
          p = new ke(),
          f = new ke(),
          m = new ke(),
          g = new ke(),
          v = new ke(),
          y = new ke();
        for (o = 0; o <= n; ++o) {
          var x = (o / n) * r * Math.PI * 2;
          for (
            A(x, r, a, t, f),
              A(x + 0.01, r, a, t, m),
              v.subVectors(m, f),
              y.addVectors(m, f),
              g.crossVectors(v, y),
              y.crossVectors(g, v),
              g.normalize(),
              y.normalize(),
              s = 0;
            s <= i;
            ++s
          ) {
            var _ = (s / i) * Math.PI * 2,
              b = -e * Math.cos(_),
              w = e * Math.sin(_);
            (d.x = f.x + (b * y.x + w * g.x)),
              (d.y = f.y + (b * y.y + w * g.y)),
              (d.z = f.z + (b * y.z + w * g.z)),
              l.push(d.x, d.y, d.z),
              p.subVectors(d, f).normalize(),
              h.push(p.x, p.y, p.z),
              u.push(o / n),
              u.push(s / i);
          }
        }
        for (s = 1; s <= n; s++)
          for (o = 1; o <= i; o++) {
            var M = (i + 1) * (s - 1) + (o - 1),
              S = (i + 1) * s + (o - 1),
              E = (i + 1) * s + o,
              T = (i + 1) * (s - 1) + o;
            c.push(M, S, T), c.push(S, E, T);
          }
        function A(t, e, n, i, r) {
          var a = Math.cos(t),
            o = Math.sin(t),
            s = (n / e) * t,
            c = Math.cos(s);
          (r.x = i * (2 + c) * 0.5 * a),
            (r.y = i * (2 + c) * o * 0.5),
            (r.z = i * Math.sin(s) * 0.5);
        }
        this.setIndex(c),
          this.addAttribute("position", new Lr(l, 3)),
          this.addAttribute("normal", new Lr(h, 3)),
          this.addAttribute("uv", new Lr(u, 2));
      }
      function xs(t, e, n, i, r) {
        br.call(this),
          (this.type = "TorusGeometry"),
          (this.parameters = {
            radius: t,
            tube: e,
            radialSegments: n,
            tubularSegments: i,
            arc: r,
          }),
          this.fromBufferGeometry(new _s(t, e, n, i, r)),
          this.mergeVertices();
      }
      function _s(t, e, n, i, r) {
        Nr.call(this),
          (this.type = "TorusBufferGeometry"),
          (this.parameters = {
            radius: t,
            tube: e,
            radialSegments: n,
            tubularSegments: i,
            arc: r,
          }),
          (t = t || 1),
          (e = e || 0.4),
          (n = Math.floor(n) || 8),
          (i = Math.floor(i) || 6),
          (r = r || 2 * Math.PI);
        var a,
          o,
          s = [],
          c = [],
          l = [],
          h = [],
          u = new ke(),
          d = new ke(),
          p = new ke();
        for (a = 0; a <= n; a++)
          for (o = 0; o <= i; o++) {
            var f = (o / i) * r,
              m = (a / n) * Math.PI * 2;
            (d.x = (t + e * Math.cos(m)) * Math.cos(f)),
              (d.y = (t + e * Math.cos(m)) * Math.sin(f)),
              (d.z = e * Math.sin(m)),
              c.push(d.x, d.y, d.z),
              (u.x = t * Math.cos(f)),
              (u.y = t * Math.sin(f)),
              p.subVectors(d, u).normalize(),
              l.push(p.x, p.y, p.z),
              h.push(o / i),
              h.push(a / n);
          }
        for (a = 1; a <= n; a++)
          for (o = 1; o <= i; o++) {
            var g = (i + 1) * a + o - 1,
              v = (i + 1) * (a - 1) + o - 1,
              y = (i + 1) * (a - 1) + o,
              x = (i + 1) * a + o;
            s.push(g, v, x), s.push(v, y, x);
          }
        this.setIndex(s),
          this.addAttribute("position", new Lr(c, 3)),
          this.addAttribute("normal", new Lr(l, 3)),
          this.addAttribute("uv", new Lr(h, 2));
      }
      (So.prototype = Object.create(kr.prototype)),
        (So.prototype.constructor = So),
        (So.prototype.isMeshDepthMaterial = !0),
        (So.prototype.copy = function (t) {
          return (
            kr.prototype.copy.call(this, t),
            (this.depthPacking = t.depthPacking),
            (this.skinning = t.skinning),
            (this.morphTargets = t.morphTargets),
            (this.map = t.map),
            (this.alphaMap = t.alphaMap),
            (this.displacementMap = t.displacementMap),
            (this.displacementScale = t.displacementScale),
            (this.displacementBias = t.displacementBias),
            (this.wireframe = t.wireframe),
            (this.wireframeLinewidth = t.wireframeLinewidth),
            this
          );
        }),
        (Eo.prototype = Object.create(kr.prototype)),
        (Eo.prototype.constructor = Eo),
        (Eo.prototype.isMeshDistanceMaterial = !0),
        (Eo.prototype.copy = function (t) {
          return (
            kr.prototype.copy.call(this, t),
            this.referencePosition.copy(t.referencePosition),
            (this.nearDistance = t.nearDistance),
            (this.farDistance = t.farDistance),
            (this.skinning = t.skinning),
            (this.morphTargets = t.morphTargets),
            (this.map = t.map),
            (this.alphaMap = t.alphaMap),
            (this.displacementMap = t.displacementMap),
            (this.displacementScale = t.displacementScale),
            (this.displacementBias = t.displacementBias),
            this
          );
        }),
        (Ao.prototype = Object.create(We.prototype)),
        (Ao.prototype.constructor = Ao),
        (Ao.prototype.isCanvasTexture = !0),
        (Do.prototype = Object.assign(Object.create(gr.prototype), {
          constructor: Do,
          isGroup: !0,
        })),
        (Io.prototype = Object.assign(Object.create(vr.prototype), {
          constructor: Io,
          isPerspectiveCamera: !0,
          copy: function (t, e) {
            return (
              vr.prototype.copy.call(this, t, e),
              (this.fov = t.fov),
              (this.zoom = t.zoom),
              (this.near = t.near),
              (this.far = t.far),
              (this.focus = t.focus),
              (this.aspect = t.aspect),
              (this.view = null === t.view ? null : Object.assign({}, t.view)),
              (this.filmGauge = t.filmGauge),
              (this.filmOffset = t.filmOffset),
              this
            );
          },
          setFocalLength: function (t) {
            var e = (0.5 * this.getFilmHeight()) / t;
            (this.fov = 2 * ze.RAD2DEG * Math.atan(e)),
              this.updateProjectionMatrix();
          },
          getFocalLength: function () {
            var t = Math.tan(0.5 * ze.DEG2RAD * this.fov);
            return (0.5 * this.getFilmHeight()) / t;
          },
          getEffectiveFOV: function () {
            return (
              2 *
              ze.RAD2DEG *
              Math.atan(Math.tan(0.5 * ze.DEG2RAD * this.fov) / this.zoom)
            );
          },
          getFilmWidth: function () {
            return this.filmGauge * Math.min(this.aspect, 1);
          },
          getFilmHeight: function () {
            return this.filmGauge / Math.max(this.aspect, 1);
          },
          setViewOffset: function (t, e, n, i, r, a) {
            (this.aspect = t / e),
              null === this.view &&
                (this.view = {
                  enabled: !0,
                  fullWidth: 1,
                  fullHeight: 1,
                  offsetX: 0,
                  offsetY: 0,
                  width: 1,
                  height: 1,
                }),
              (this.view.enabled = !0),
              (this.view.fullWidth = t),
              (this.view.fullHeight = e),
              (this.view.offsetX = n),
              (this.view.offsetY = i),
              (this.view.width = r),
              (this.view.height = a),
              this.updateProjectionMatrix();
          },
          clearViewOffset: function () {
            null !== this.view && (this.view.enabled = !1),
              this.updateProjectionMatrix();
          },
          updateProjectionMatrix: function () {
            var t = this.near,
              e = (t * Math.tan(0.5 * ze.DEG2RAD * this.fov)) / this.zoom,
              n = 2 * e,
              i = this.aspect * n,
              r = -0.5 * i,
              a = this.view;
            if (null !== this.view && this.view.enabled) {
              var o = a.fullWidth,
                s = a.fullHeight;
              (r += (a.offsetX * i) / o),
                (e -= (a.offsetY * n) / s),
                (i *= a.width / o),
                (n *= a.height / s);
            }
            var c = this.filmOffset;
            0 !== c && (r += (t * c) / this.getFilmWidth()),
              this.projectionMatrix.makePerspective(
                r,
                r + i,
                e,
                e - n,
                t,
                this.far
              );
          },
          toJSON: function (t) {
            var e = gr.prototype.toJSON.call(this, t);
            return (
              (e.object.fov = this.fov),
              (e.object.zoom = this.zoom),
              (e.object.near = this.near),
              (e.object.far = this.far),
              (e.object.focus = this.focus),
              (e.object.aspect = this.aspect),
              null !== this.view &&
                (e.object.view = Object.assign({}, this.view)),
              (e.object.filmGauge = this.filmGauge),
              (e.object.filmOffset = this.filmOffset),
              e
            );
          },
        })),
        (Oo.prototype = Object.assign(Object.create(Io.prototype), {
          constructor: Oo,
          isArrayCamera: !0,
        })),
        (Uo.prototype.isFogExp2 = !0),
        (Uo.prototype.clone = function () {
          return new Uo(this.color, this.density);
        }),
        (Uo.prototype.toJSON = function () {
          return {
            type: "FogExp2",
            color: this.color.getHex(),
            density: this.density,
          };
        }),
        (Fo.prototype.isFog = !0),
        (Fo.prototype.clone = function () {
          return new Fo(this.color, this.near, this.far);
        }),
        (Fo.prototype.toJSON = function () {
          return {
            type: "Fog",
            color: this.color.getHex(),
            near: this.near,
            far: this.far,
          };
        }),
        (Ho.prototype = Object.assign(Object.create(gr.prototype), {
          constructor: Ho,
          copy: function (t, e) {
            return (
              gr.prototype.copy.call(this, t, e),
              null !== t.background && (this.background = t.background.clone()),
              null !== t.fog && (this.fog = t.fog.clone()),
              null !== t.overrideMaterial &&
                (this.overrideMaterial = t.overrideMaterial.clone()),
              (this.autoUpdate = t.autoUpdate),
              (this.matrixAutoUpdate = t.matrixAutoUpdate),
              this
            );
          },
          toJSON: function (t) {
            var e = gr.prototype.toJSON.call(this, t);
            return (
              null !== this.background &&
                (e.object.background = this.background.toJSON(t)),
              null !== this.fog && (e.object.fog = this.fog.toJSON()),
              e
            );
          },
        })),
        (ko.prototype = Object.create(kr.prototype)),
        (ko.prototype.constructor = ko),
        (ko.prototype.isSpriteMaterial = !0),
        (ko.prototype.copy = function (t) {
          return (
            kr.prototype.copy.call(this, t),
            this.color.copy(t.color),
            (this.map = t.map),
            (this.rotation = t.rotation),
            this
          );
        }),
        (Go.prototype = Object.assign(Object.create(gr.prototype), {
          constructor: Go,
          isSprite: !0,
          raycast: (function () {
            var t = new ke(),
              e = new ke(),
              n = new ke(),
              i = new Ue(),
              r = new Ue(),
              a = new Fe(),
              o = new ke(),
              s = new ke(),
              c = new ke();
            function l(t, e, n, o, s, c) {
              i.subVectors(t, n).addScalar(0.5).multiply(o),
                void 0 !== s
                  ? ((r.x = c * i.x - s * i.y), (r.y = s * i.x + c * i.y))
                  : r.copy(i),
                t.copy(e),
                (t.x += r.x),
                (t.y += r.y),
                t.applyMatrix4(a);
            }
            return function (i, r) {
              e.setFromMatrixScale(this.matrixWorld),
                a
                  .getInverse(this.modelViewMatrix)
                  .premultiply(this.matrixWorld),
                n.setFromMatrixPosition(this.modelViewMatrix);
              var h,
                u,
                d = this.material.rotation;
              0 !== d && ((u = Math.cos(d)), (h = Math.sin(d)));
              var p = this.center;
              l(o.set(-0.5, -0.5, 0), n, p, e, h, u),
                l(s.set(0.5, -0.5, 0), n, p, e, h, u),
                l(c.set(0.5, 0.5, 0), n, p, e, h, u);
              var f = i.ray.intersectTriangle(o, s, c, !1, t);
              if (
                null !== f ||
                (l(s.set(-0.5, 0.5, 0), n, p, e, h, u),
                (f = i.ray.intersectTriangle(o, c, s, !1, t)),
                null !== f)
              ) {
                var m = i.ray.origin.distanceTo(t);
                m < i.near ||
                  m > i.far ||
                  r.push({
                    distance: m,
                    point: t.clone(),
                    face: null,
                    object: this,
                  });
              }
            };
          })(),
          clone: function () {
            return new this.constructor(this.material).copy(this);
          },
          copy: function (t) {
            return (
              gr.prototype.copy.call(this, t),
              void 0 !== t.center && this.center.copy(t.center),
              this
            );
          },
        })),
        (Vo.prototype = Object.assign(Object.create(gr.prototype), {
          constructor: Vo,
          copy: function (t) {
            gr.prototype.copy.call(this, t, !1);
            for (var e = t.levels, n = 0, i = e.length; n < i; n++) {
              var r = e[n];
              this.addLevel(r.object.clone(), r.distance);
            }
            return this;
          },
          addLevel: function (t, e) {
            void 0 === e && (e = 0), (e = Math.abs(e));
            for (var n = this.levels, i = 0; i < n.length; i++)
              if (e < n[i].distance) break;
            n.splice(i, 0, { distance: e, object: t }), this.add(t);
          },
          getObjectForDistance: function (t) {
            for (var e = this.levels, n = 1, i = e.length; n < i; n++)
              if (t < e[n].distance) break;
            return e[n - 1].object;
          },
          raycast: (function () {
            var t = new ke();
            return function (e, n) {
              t.setFromMatrixPosition(this.matrixWorld);
              var i = e.ray.origin.distanceTo(t);
              this.getObjectForDistance(i).raycast(e, n);
            };
          })(),
          update: (function () {
            var t = new ke(),
              e = new ke();
            return function (n) {
              var i = this.levels;
              if (i.length > 1) {
                t.setFromMatrixPosition(n.matrixWorld),
                  e.setFromMatrixPosition(this.matrixWorld);
                var r = t.distanceTo(e);
                i[0].object.visible = !0;
                for (var a = 1, o = i.length; a < o; a++) {
                  if (!(r >= i[a].distance)) break;
                  (i[a - 1].object.visible = !1), (i[a].object.visible = !0);
                }
                for (; a < o; a++) i[a].object.visible = !1;
              }
            };
          })(),
          toJSON: function (t) {
            var e = gr.prototype.toJSON.call(this, t);
            e.object.levels = [];
            for (var n = this.levels, i = 0, r = n.length; i < r; i++) {
              var a = n[i];
              e.object.levels.push({
                object: a.object.uuid,
                distance: a.distance,
              });
            }
            return e;
          },
        })),
        Object.assign(Wo.prototype, {
          calculateInverses: function () {
            this.boneInverses = [];
            for (var t = 0, e = this.bones.length; t < e; t++) {
              var n = new Fe();
              this.bones[t] && n.getInverse(this.bones[t].matrixWorld),
                this.boneInverses.push(n);
            }
          },
          pose: function () {
            var t, e, n;
            for (e = 0, n = this.bones.length; e < n; e++)
              (t = this.bones[e]),
                t && t.matrixWorld.getInverse(this.boneInverses[e]);
            for (e = 0, n = this.bones.length; e < n; e++)
              (t = this.bones[e]),
                t &&
                  (t.parent && t.parent.isBone
                    ? (t.matrix.getInverse(t.parent.matrixWorld),
                      t.matrix.multiply(t.matrixWorld))
                    : t.matrix.copy(t.matrixWorld),
                  t.matrix.decompose(t.position, t.quaternion, t.scale));
          },
          update: (function () {
            var t = new Fe(),
              e = new Fe();
            return function () {
              for (
                var n = this.bones,
                  i = this.boneInverses,
                  r = this.boneMatrices,
                  a = this.boneTexture,
                  o = 0,
                  s = n.length;
                o < s;
                o++
              ) {
                var c = n[o] ? n[o].matrixWorld : e;
                t.multiplyMatrices(c, i[o]), t.toArray(r, 16 * o);
              }
              void 0 !== a && (a.needsUpdate = !0);
            };
          })(),
          clone: function () {
            return new Wo(this.bones, this.boneInverses);
          },
          getBoneByName: function (t) {
            for (var e = 0, n = this.bones.length; e < n; e++) {
              var i = this.bones[e];
              if (i.name === t) return i;
            }
          },
        }),
        (jo.prototype = Object.assign(Object.create(gr.prototype), {
          constructor: jo,
          isBone: !0,
        })),
        (qo.prototype = Object.assign(Object.create(Xr.prototype), {
          constructor: qo,
          isSkinnedMesh: !0,
          initBones: function () {
            var t,
              e,
              n,
              i,
              r = [];
            if (this.geometry && void 0 !== this.geometry.bones) {
              for (n = 0, i = this.geometry.bones.length; n < i; n++)
                (e = this.geometry.bones[n]),
                  (t = new jo()),
                  r.push(t),
                  (t.name = e.name),
                  t.position.fromArray(e.pos),
                  t.quaternion.fromArray(e.rotq),
                  void 0 !== e.scl && t.scale.fromArray(e.scl);
              for (n = 0, i = this.geometry.bones.length; n < i; n++)
                (e = this.geometry.bones[n]),
                  -1 !== e.parent && null !== e.parent && void 0 !== r[e.parent]
                    ? r[e.parent].add(r[n])
                    : this.add(r[n]);
            }
            return this.updateMatrixWorld(!0), r;
          },
          bind: function (t, e) {
            (this.skeleton = t),
              void 0 === e &&
                (this.updateMatrixWorld(!0),
                this.skeleton.calculateInverses(),
                (e = this.matrixWorld)),
              this.bindMatrix.copy(e),
              this.bindMatrixInverse.getInverse(e);
          },
          pose: function () {
            this.skeleton.pose();
          },
          normalizeSkinWeights: function () {
            var t, e;
            if (this.geometry && this.geometry.isGeometry)
              for (e = 0; e < this.geometry.skinWeights.length; e++) {
                var n = this.geometry.skinWeights[e];
                (t = 1 / n.manhattanLength()),
                  t !== 1 / 0 ? n.multiplyScalar(t) : n.set(1, 0, 0, 0);
              }
            else if (this.geometry && this.geometry.isBufferGeometry) {
              var i = new je(),
                r = this.geometry.attributes.skinWeight;
              for (e = 0; e < r.count; e++)
                (i.x = r.getX(e)),
                  (i.y = r.getY(e)),
                  (i.z = r.getZ(e)),
                  (i.w = r.getW(e)),
                  (t = 1 / i.manhattanLength()),
                  t !== 1 / 0 ? i.multiplyScalar(t) : i.set(1, 0, 0, 0),
                  r.setXYZW(e, i.x, i.y, i.z, i.w);
            }
          },
          updateMatrixWorld: function (t) {
            Xr.prototype.updateMatrixWorld.call(this, t),
              "attached" === this.bindMode
                ? this.bindMatrixInverse.getInverse(this.matrixWorld)
                : "detached" === this.bindMode
                ? this.bindMatrixInverse.getInverse(this.bindMatrix)
                : console.warn(
                    "THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode
                  );
          },
          clone: function () {
            return new this.constructor(this.geometry, this.material).copy(
              this
            );
          },
        })),
        (Xo.prototype = Object.create(kr.prototype)),
        (Xo.prototype.constructor = Xo),
        (Xo.prototype.isLineBasicMaterial = !0),
        (Xo.prototype.copy = function (t) {
          return (
            kr.prototype.copy.call(this, t),
            this.color.copy(t.color),
            (this.linewidth = t.linewidth),
            (this.linecap = t.linecap),
            (this.linejoin = t.linejoin),
            this
          );
        }),
        (Yo.prototype = Object.assign(Object.create(gr.prototype), {
          constructor: Yo,
          isLine: !0,
          computeLineDistances: (function () {
            var t = new ke(),
              e = new ke();
            return function () {
              var n = this.geometry;
              if (n.isBufferGeometry)
                if (null === n.index) {
                  for (
                    var i = n.attributes.position, r = [0], a = 1, o = i.count;
                    a < o;
                    a++
                  )
                    t.fromBufferAttribute(i, a - 1),
                      e.fromBufferAttribute(i, a),
                      (r[a] = r[a - 1]),
                      (r[a] += t.distanceTo(e));
                  n.addAttribute("lineDistance", new Lr(r, 1));
                } else
                  console.warn(
                    "THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
                  );
              else if (n.isGeometry) {
                var s = n.vertices;
                r = n.lineDistances;
                r[0] = 0;
                for (a = 1, o = s.length; a < o; a++)
                  (r[a] = r[a - 1]), (r[a] += s[a - 1].distanceTo(s[a]));
              }
              return this;
            };
          })(),
          raycast: (function () {
            var t = new Fe(),
              e = new Wr(),
              n = new Ze();
            return function (i, r) {
              var a = i.linePrecision,
                o = a * a,
                s = this.geometry,
                c = this.matrixWorld;
              if (
                (null === s.boundingSphere && s.computeBoundingSphere(),
                n.copy(s.boundingSphere),
                n.applyMatrix4(c),
                !1 !== i.ray.intersectsSphere(n))
              ) {
                t.getInverse(c), e.copy(i.ray).applyMatrix4(t);
                var l = new ke(),
                  h = new ke(),
                  u = new ke(),
                  d = new ke(),
                  p = this && this.isLineSegments ? 2 : 1;
                if (s.isBufferGeometry) {
                  var f = s.index,
                    m = s.attributes,
                    g = m.position.array;
                  if (null !== f)
                    for (
                      var v = f.array, y = 0, x = v.length - 1;
                      y < x;
                      y += p
                    ) {
                      var _ = v[y],
                        b = v[y + 1];
                      l.fromArray(g, 3 * _), h.fromArray(g, 3 * b);
                      var w = e.distanceSqToSegment(l, h, d, u);
                      if (!(w > o)) {
                        d.applyMatrix4(this.matrixWorld);
                        var M = i.ray.origin.distanceTo(d);
                        M < i.near ||
                          M > i.far ||
                          r.push({
                            distance: M,
                            point: u.clone().applyMatrix4(this.matrixWorld),
                            index: y,
                            face: null,
                            faceIndex: null,
                            object: this,
                          });
                      }
                    }
                  else
                    for (y = 0, x = g.length / 3 - 1; y < x; y += p) {
                      l.fromArray(g, 3 * y), h.fromArray(g, 3 * y + 3);
                      w = e.distanceSqToSegment(l, h, d, u);
                      if (!(w > o)) {
                        d.applyMatrix4(this.matrixWorld);
                        M = i.ray.origin.distanceTo(d);
                        M < i.near ||
                          M > i.far ||
                          r.push({
                            distance: M,
                            point: u.clone().applyMatrix4(this.matrixWorld),
                            index: y,
                            face: null,
                            faceIndex: null,
                            object: this,
                          });
                      }
                    }
                } else if (s.isGeometry) {
                  var S = s.vertices,
                    E = S.length;
                  for (y = 0; y < E - 1; y += p) {
                    w = e.distanceSqToSegment(S[y], S[y + 1], d, u);
                    if (!(w > o)) {
                      d.applyMatrix4(this.matrixWorld);
                      M = i.ray.origin.distanceTo(d);
                      M < i.near ||
                        M > i.far ||
                        r.push({
                          distance: M,
                          point: u.clone().applyMatrix4(this.matrixWorld),
                          index: y,
                          face: null,
                          faceIndex: null,
                          object: this,
                        });
                    }
                  }
                }
              }
            };
          })(),
          clone: function () {
            return new this.constructor(this.geometry, this.material).copy(
              this
            );
          },
        })),
        (Jo.prototype = Object.assign(Object.create(Yo.prototype), {
          constructor: Jo,
          isLineSegments: !0,
          computeLineDistances: (function () {
            var t = new ke(),
              e = new ke();
            return function () {
              var n = this.geometry;
              if (n.isBufferGeometry)
                if (null === n.index) {
                  for (
                    var i = n.attributes.position, r = [], a = 0, o = i.count;
                    a < o;
                    a += 2
                  )
                    t.fromBufferAttribute(i, a),
                      e.fromBufferAttribute(i, a + 1),
                      (r[a] = 0 === a ? 0 : r[a - 1]),
                      (r[a + 1] = r[a] + t.distanceTo(e));
                  n.addAttribute("lineDistance", new Lr(r, 1));
                } else
                  console.warn(
                    "THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
                  );
              else if (n.isGeometry) {
                var s = n.vertices;
                for (r = n.lineDistances, a = 0, o = s.length; a < o; a += 2)
                  t.copy(s[a]),
                    e.copy(s[a + 1]),
                    (r[a] = 0 === a ? 0 : r[a - 1]),
                    (r[a + 1] = r[a] + t.distanceTo(e));
              }
              return this;
            };
          })(),
        })),
        (Zo.prototype = Object.assign(Object.create(Yo.prototype), {
          constructor: Zo,
          isLineLoop: !0,
        })),
        (Ko.prototype = Object.create(kr.prototype)),
        (Ko.prototype.constructor = Ko),
        (Ko.prototype.isPointsMaterial = !0),
        (Ko.prototype.copy = function (t) {
          return (
            kr.prototype.copy.call(this, t),
            this.color.copy(t.color),
            (this.map = t.map),
            (this.size = t.size),
            (this.sizeAttenuation = t.sizeAttenuation),
            (this.morphTargets = t.morphTargets),
            this
          );
        }),
        ($o.prototype = Object.assign(Object.create(gr.prototype), {
          constructor: $o,
          isPoints: !0,
          raycast: (function () {
            var t = new Fe(),
              e = new Wr(),
              n = new Ze();
            return function (i, r) {
              var a = this,
                o = this.geometry,
                s = this.matrixWorld,
                c = i.params.Points.threshold;
              if (
                (null === o.boundingSphere && o.computeBoundingSphere(),
                n.copy(o.boundingSphere),
                n.applyMatrix4(s),
                (n.radius += c),
                !1 !== i.ray.intersectsSphere(n))
              ) {
                t.getInverse(s), e.copy(i.ray).applyMatrix4(t);
                var l = c / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                  h = l * l,
                  u = new ke(),
                  d = new ke();
                if (o.isBufferGeometry) {
                  var p = o.index,
                    f = o.attributes,
                    m = f.position.array;
                  if (null !== p)
                    for (var g = p.array, v = 0, y = g.length; v < y; v++) {
                      var x = g[v];
                      u.fromArray(m, 3 * x), w(u, x);
                    }
                  else {
                    v = 0;
                    for (var _ = m.length / 3; v < _; v++)
                      u.fromArray(m, 3 * v), w(u, v);
                  }
                } else {
                  var b = o.vertices;
                  for (v = 0, _ = b.length; v < _; v++) w(b[v], v);
                }
              }
              function w(t, n) {
                var o = e.distanceSqToPoint(t);
                if (o < h) {
                  e.closestPointToPoint(t, d), d.applyMatrix4(s);
                  var c = i.ray.origin.distanceTo(d);
                  if (c < i.near || c > i.far) return;
                  r.push({
                    distance: c,
                    distanceToRay: Math.sqrt(o),
                    point: d.clone(),
                    index: n,
                    face: null,
                    object: a,
                  });
                }
              }
            };
          })(),
          clone: function () {
            return new this.constructor(this.geometry, this.material).copy(
              this
            );
          },
        })),
        (Qo.prototype = Object.assign(Object.create(We.prototype), {
          constructor: Qo,
          isVideoTexture: !0,
          update: function () {
            var t = this.image;
            t.readyState >= t.HAVE_CURRENT_DATA && (this.needsUpdate = !0);
          },
        })),
        (ts.prototype = Object.create(We.prototype)),
        (ts.prototype.constructor = ts),
        (ts.prototype.isCompressedTexture = !0),
        (es.prototype = Object.create(We.prototype)),
        (es.prototype.constructor = es),
        (es.prototype.isDepthTexture = !0),
        (ns.prototype = Object.create(Nr.prototype)),
        (ns.prototype.constructor = ns),
        (is.prototype = Object.create(br.prototype)),
        (is.prototype.constructor = is),
        (rs.prototype = Object.create(Nr.prototype)),
        (rs.prototype.constructor = rs),
        (as.prototype = Object.create(br.prototype)),
        (as.prototype.constructor = as),
        (os.prototype = Object.create(Nr.prototype)),
        (os.prototype.constructor = os),
        (ss.prototype = Object.create(br.prototype)),
        (ss.prototype.constructor = ss),
        (cs.prototype = Object.create(os.prototype)),
        (cs.prototype.constructor = cs),
        (ls.prototype = Object.create(br.prototype)),
        (ls.prototype.constructor = ls),
        (hs.prototype = Object.create(os.prototype)),
        (hs.prototype.constructor = hs),
        (us.prototype = Object.create(br.prototype)),
        (us.prototype.constructor = us),
        (ds.prototype = Object.create(os.prototype)),
        (ds.prototype.constructor = ds),
        (ps.prototype = Object.create(br.prototype)),
        (ps.prototype.constructor = ps),
        (fs.prototype = Object.create(os.prototype)),
        (fs.prototype.constructor = fs),
        (ms.prototype = Object.create(br.prototype)),
        (ms.prototype.constructor = ms),
        (gs.prototype = Object.create(Nr.prototype)),
        (gs.prototype.constructor = gs),
        (vs.prototype = Object.create(br.prototype)),
        (vs.prototype.constructor = vs),
        (ys.prototype = Object.create(Nr.prototype)),
        (ys.prototype.constructor = ys),
        (xs.prototype = Object.create(br.prototype)),
        (xs.prototype.constructor = xs),
        (_s.prototype = Object.create(Nr.prototype)),
        (_s.prototype.constructor = _s);
      var bs = {
        triangulate: function (t, e, n) {
          n = n || 2;
          var i,
            r,
            a,
            o,
            s,
            c,
            l,
            h = e && e.length,
            u = h ? e[0] * n : t.length,
            d = ws(t, 0, u, n, !0),
            p = [];
          if (!d) return p;
          if ((h && (d = Rs(t, e, d, n)), t.length > 80 * n)) {
            (i = a = t[0]), (r = o = t[1]);
            for (var f = n; f < u; f += n)
              (s = t[f]),
                (c = t[f + 1]),
                s < i && (i = s),
                c < r && (r = c),
                s > a && (a = s),
                c > o && (o = c);
            (l = Math.max(a - i, o - r)), (l = 0 !== l ? 1 / l : 0);
          }
          return Ss(d, p, n, i, r, l), p;
        },
      };
      function ws(t, e, n, i, r) {
        var a, o;
        if (r === Js(t, e, n, i) > 0)
          for (a = e; a < n; a += i) o = qs(a, t[a], t[a + 1], o);
        else for (a = n - i; a >= e; a -= i) o = qs(a, t[a], t[a + 1], o);
        return o && Hs(o, o.next) && (Xs(o), (o = o.next)), o;
      }
      function Ms(t, e) {
        if (!t) return t;
        e || (e = t);
        var n,
          i = t;
        do {
          if (
            ((n = !1),
            i.steiner || (!Hs(i, i.next) && 0 !== Fs(i.prev, i, i.next)))
          )
            i = i.next;
          else {
            if ((Xs(i), (i = e = i.prev), i === i.next)) break;
            n = !0;
          }
        } while (n || i !== e);
        return e;
      }
      function Ss(t, e, n, i, r, a, o) {
        if (t) {
          !o && a && Is(t, i, r, a);
          var s,
            c,
            l = t;
          while (t.prev !== t.next)
            if (((s = t.prev), (c = t.next), a ? Ts(t, i, r, a) : Es(t)))
              e.push(s.i / n),
                e.push(t.i / n),
                e.push(c.i / n),
                Xs(t),
                (t = c.next),
                (l = c.next);
            else if (((t = c), t === l)) {
              o
                ? 1 === o
                  ? ((t = As(t, e, n)), Ss(t, e, n, i, r, a, 2))
                  : 2 === o && Cs(t, e, n, i, r, a)
                : Ss(Ms(t), e, n, i, r, a, 1);
              break;
            }
        }
      }
      function Es(t) {
        var e = t.prev,
          n = t,
          i = t.next;
        if (Fs(e, n, i) >= 0) return !1;
        var r = t.next.next;
        while (r !== t.prev) {
          if (
            zs(e.x, e.y, n.x, n.y, i.x, i.y, r.x, r.y) &&
            Fs(r.prev, r, r.next) >= 0
          )
            return !1;
          r = r.next;
        }
        return !0;
      }
      function Ts(t, e, n, i) {
        var r = t.prev,
          a = t,
          o = t.next;
        if (Fs(r, a, o) >= 0) return !1;
        var s = r.x < a.x ? (r.x < o.x ? r.x : o.x) : a.x < o.x ? a.x : o.x,
          c = r.y < a.y ? (r.y < o.y ? r.y : o.y) : a.y < o.y ? a.y : o.y,
          l = r.x > a.x ? (r.x > o.x ? r.x : o.x) : a.x > o.x ? a.x : o.x,
          h = r.y > a.y ? (r.y > o.y ? r.y : o.y) : a.y > o.y ? a.y : o.y,
          u = Ns(s, c, e, n, i),
          d = Ns(l, h, e, n, i),
          p = t.nextZ;
        while (p && p.z <= d) {
          if (
            p !== t.prev &&
            p !== t.next &&
            zs(r.x, r.y, a.x, a.y, o.x, o.y, p.x, p.y) &&
            Fs(p.prev, p, p.next) >= 0
          )
            return !1;
          p = p.nextZ;
        }
        p = t.prevZ;
        while (p && p.z >= u) {
          if (
            p !== t.prev &&
            p !== t.next &&
            zs(r.x, r.y, a.x, a.y, o.x, o.y, p.x, p.y) &&
            Fs(p.prev, p, p.next) >= 0
          )
            return !1;
          p = p.prevZ;
        }
        return !0;
      }
      function As(t, e, n) {
        var i = t;
        do {
          var r = i.prev,
            a = i.next.next;
          !Hs(r, a) &&
            ks(r, i, i.next, a) &&
            Vs(r, a) &&
            Vs(a, r) &&
            (e.push(r.i / n),
            e.push(i.i / n),
            e.push(a.i / n),
            Xs(i),
            Xs(i.next),
            (i = t = a)),
            (i = i.next);
        } while (i !== t);
        return i;
      }
      function Cs(t, e, n, i, r, a) {
        var o = t;
        do {
          var s = o.next.next;
          while (s !== o.prev) {
            if (o.i !== s.i && Us(o, s)) {
              var c = js(o, s);
              return (
                (o = Ms(o, o.next)),
                (c = Ms(c, c.next)),
                Ss(o, e, n, i, r, a),
                void Ss(c, e, n, i, r, a)
              );
            }
            s = s.next;
          }
          o = o.next;
        } while (o !== t);
      }
      function Rs(t, e, n, i) {
        var r,
          a,
          o,
          s,
          c,
          l = [];
        for (r = 0, a = e.length; r < a; r++)
          (o = e[r] * i),
            (s = r < a - 1 ? e[r + 1] * i : t.length),
            (c = ws(t, o, s, i, !1)),
            c === c.next && (c.steiner = !0),
            l.push(Bs(c));
        for (l.sort(Ls), r = 0; r < l.length; r++)
          Ps(l[r], n), (n = Ms(n, n.next));
        return n;
      }
      function Ls(t, e) {
        return t.x - e.x;
      }
      function Ps(t, e) {
        if (((e = Ds(t, e)), e)) {
          var n = js(e, t);
          Ms(n, n.next);
        }
      }
      function Ds(t, e) {
        var n,
          i = e,
          r = t.x,
          a = t.y,
          o = -1 / 0;
        do {
          if (a <= i.y && a >= i.next.y && i.next.y !== i.y) {
            var s = i.x + ((a - i.y) * (i.next.x - i.x)) / (i.next.y - i.y);
            if (s <= r && s > o) {
              if (((o = s), s === r)) {
                if (a === i.y) return i;
                if (a === i.next.y) return i.next;
              }
              n = i.x < i.next.x ? i : i.next;
            }
          }
          i = i.next;
        } while (i !== e);
        if (!n) return null;
        if (r === o) return n.prev;
        var c,
          l = n,
          h = n.x,
          u = n.y,
          d = 1 / 0;
        i = n.next;
        while (i !== l)
          r >= i.x &&
            i.x >= h &&
            r !== i.x &&
            zs(a < u ? r : o, a, h, u, a < u ? o : r, a, i.x, i.y) &&
            ((c = Math.abs(a - i.y) / (r - i.x)),
            (c < d || (c === d && i.x > n.x)) &&
              Vs(i, t) &&
              ((n = i), (d = c))),
            (i = i.next);
        return n;
      }
      function Is(t, e, n, i) {
        var r = t;
        do {
          null === r.z && (r.z = Ns(r.x, r.y, e, n, i)),
            (r.prevZ = r.prev),
            (r.nextZ = r.next),
            (r = r.next);
        } while (r !== t);
        (r.prevZ.nextZ = null), (r.prevZ = null), Os(r);
      }
      function Os(t) {
        var e,
          n,
          i,
          r,
          a,
          o,
          s,
          c,
          l = 1;
        do {
          (n = t), (t = null), (a = null), (o = 0);
          while (n) {
            for (o++, i = n, s = 0, e = 0; e < l; e++)
              if ((s++, (i = i.nextZ), !i)) break;
            c = l;
            while (s > 0 || (c > 0 && i))
              0 !== s && (0 === c || !i || n.z <= i.z)
                ? ((r = n), (n = n.nextZ), s--)
                : ((r = i), (i = i.nextZ), c--),
                a ? (a.nextZ = r) : (t = r),
                (r.prevZ = a),
                (a = r);
            n = i;
          }
          (a.nextZ = null), (l *= 2);
        } while (o > 1);
        return t;
      }
      function Ns(t, e, n, i, r) {
        return (
          (t = 32767 * (t - n) * r),
          (e = 32767 * (e - i) * r),
          (t = 16711935 & (t | (t << 8))),
          (t = 252645135 & (t | (t << 4))),
          (t = 858993459 & (t | (t << 2))),
          (t = 1431655765 & (t | (t << 1))),
          (e = 16711935 & (e | (e << 8))),
          (e = 252645135 & (e | (e << 4))),
          (e = 858993459 & (e | (e << 2))),
          (e = 1431655765 & (e | (e << 1))),
          t | (e << 1)
        );
      }
      function Bs(t) {
        var e = t,
          n = t;
        do {
          e.x < n.x && (n = e), (e = e.next);
        } while (e !== t);
        return n;
      }
      function zs(t, e, n, i, r, a, o, s) {
        return (
          (r - o) * (e - s) - (t - o) * (a - s) >= 0 &&
          (t - o) * (i - s) - (n - o) * (e - s) >= 0 &&
          (n - o) * (a - s) - (r - o) * (i - s) >= 0
        );
      }
      function Us(t, e) {
        return (
          t.next.i !== e.i &&
          t.prev.i !== e.i &&
          !Gs(t, e) &&
          Vs(t, e) &&
          Vs(e, t) &&
          Ws(t, e)
        );
      }
      function Fs(t, e, n) {
        return (e.y - t.y) * (n.x - e.x) - (e.x - t.x) * (n.y - e.y);
      }
      function Hs(t, e) {
        return t.x === e.x && t.y === e.y;
      }
      function ks(t, e, n, i) {
        return (
          !!((Hs(t, e) && Hs(n, i)) || (Hs(t, i) && Hs(n, e))) ||
          (Fs(t, e, n) > 0 !== Fs(t, e, i) > 0 &&
            Fs(n, i, t) > 0 !== Fs(n, i, e) > 0)
        );
      }
      function Gs(t, e) {
        var n = t;
        do {
          if (
            n.i !== t.i &&
            n.next.i !== t.i &&
            n.i !== e.i &&
            n.next.i !== e.i &&
            ks(n, n.next, t, e)
          )
            return !0;
          n = n.next;
        } while (n !== t);
        return !1;
      }
      function Vs(t, e) {
        return Fs(t.prev, t, t.next) < 0
          ? Fs(t, e, t.next) >= 0 && Fs(t, t.prev, e) >= 0
          : Fs(t, e, t.prev) < 0 || Fs(t, t.next, e) < 0;
      }
      function Ws(t, e) {
        var n = t,
          i = !1,
          r = (t.x + e.x) / 2,
          a = (t.y + e.y) / 2;
        do {
          n.y > a !== n.next.y > a &&
            n.next.y !== n.y &&
            r < ((n.next.x - n.x) * (a - n.y)) / (n.next.y - n.y) + n.x &&
            (i = !i),
            (n = n.next);
        } while (n !== t);
        return i;
      }
      function js(t, e) {
        var n = new Ys(t.i, t.x, t.y),
          i = new Ys(e.i, e.x, e.y),
          r = t.next,
          a = e.prev;
        return (
          (t.next = e),
          (e.prev = t),
          (n.next = r),
          (r.prev = n),
          (i.next = n),
          (n.prev = i),
          (a.next = i),
          (i.prev = a),
          i
        );
      }
      function qs(t, e, n, i) {
        var r = new Ys(t, e, n);
        return (
          i
            ? ((r.next = i.next), (r.prev = i), (i.next.prev = r), (i.next = r))
            : ((r.prev = r), (r.next = r)),
          r
        );
      }
      function Xs(t) {
        (t.next.prev = t.prev),
          (t.prev.next = t.next),
          t.prevZ && (t.prevZ.nextZ = t.nextZ),
          t.nextZ && (t.nextZ.prevZ = t.prevZ);
      }
      function Ys(t, e, n) {
        (this.i = t),
          (this.x = e),
          (this.y = n),
          (this.prev = null),
          (this.next = null),
          (this.z = null),
          (this.prevZ = null),
          (this.nextZ = null),
          (this.steiner = !1);
      }
      function Js(t, e, n, i) {
        for (var r = 0, a = e, o = n - i; a < n; a += i)
          (r += (t[o] - t[a]) * (t[a + 1] + t[o + 1])), (o = a);
        return r;
      }
      var Zs = {
        area: function (t) {
          for (var e = t.length, n = 0, i = e - 1, r = 0; r < e; i = r++)
            n += t[i].x * t[r].y - t[r].x * t[i].y;
          return 0.5 * n;
        },
        isClockWise: function (t) {
          return Zs.area(t) < 0;
        },
        triangulateShape: function (t, e) {
          var n = [],
            i = [],
            r = [];
          Ks(t), $s(n, t);
          var a = t.length;
          e.forEach(Ks);
          for (var o = 0; o < e.length; o++)
            i.push(a), (a += e[o].length), $s(n, e[o]);
          var s = bs.triangulate(n, i);
          for (o = 0; o < s.length; o += 3) r.push(s.slice(o, o + 3));
          return r;
        },
      };
      function Ks(t) {
        var e = t.length;
        e > 2 && t[e - 1].equals(t[0]) && t.pop();
      }
      function $s(t, e) {
        for (var n = 0; n < e.length; n++) t.push(e[n].x), t.push(e[n].y);
      }
      function Qs(t, e) {
        br.call(this),
          (this.type = "ExtrudeGeometry"),
          (this.parameters = { shapes: t, options: e }),
          this.fromBufferGeometry(new tc(t, e)),
          this.mergeVertices();
      }
      function tc(t, e) {
        Nr.call(this),
          (this.type = "ExtrudeBufferGeometry"),
          (this.parameters = { shapes: t, options: e }),
          (t = Array.isArray(t) ? t : [t]);
        for (var n = this, i = [], r = [], a = 0, o = t.length; a < o; a++) {
          var s = t[a];
          c(s);
        }
        function c(t) {
          var a = [],
            o = void 0 !== e.curveSegments ? e.curveSegments : 12,
            s = void 0 !== e.steps ? e.steps : 1,
            c = void 0 !== e.depth ? e.depth : 100,
            l = void 0 === e.bevelEnabled || e.bevelEnabled,
            h = void 0 !== e.bevelThickness ? e.bevelThickness : 6,
            u = void 0 !== e.bevelSize ? e.bevelSize : h - 2,
            d = void 0 !== e.bevelSegments ? e.bevelSegments : 3,
            p = e.extrudePath,
            f = void 0 !== e.UVGenerator ? e.UVGenerator : ec;
          void 0 !== e.amount &&
            (console.warn(
              "THREE.ExtrudeBufferGeometry: amount has been renamed to depth."
            ),
            (c = e.amount));
          var m,
            g,
            v,
            y,
            x,
            _,
            b,
            w,
            M = !1;
          p &&
            ((m = p.getSpacedPoints(s)),
            (M = !0),
            (l = !1),
            (g = p.computeFrenetFrames(s, !1)),
            (v = new ke()),
            (y = new ke()),
            (x = new ke())),
            l || ((d = 0), (h = 0), (u = 0));
          var S = t.extractPoints(o),
            E = S.shape,
            T = S.holes,
            A = !Zs.isClockWise(E);
          if (A)
            for (E = E.reverse(), b = 0, w = T.length; b < w; b++)
              (_ = T[b]), Zs.isClockWise(_) && (T[b] = _.reverse());
          var C = Zs.triangulateShape(E, T),
            R = E;
          for (b = 0, w = T.length; b < w; b++) (_ = T[b]), (E = E.concat(_));
          function L(t, e, n) {
            return (
              e || console.error("THREE.ExtrudeGeometry: vec does not exist"),
              e.clone().multiplyScalar(n).add(t)
            );
          }
          var P,
            D,
            I,
            O,
            N,
            B,
            z = E.length,
            U = C.length;
          function F(t, e, n) {
            var i,
              r,
              a,
              o = t.x - e.x,
              s = t.y - e.y,
              c = n.x - t.x,
              l = n.y - t.y,
              h = o * o + s * s,
              u = o * l - s * c;
            if (Math.abs(u) > Number.EPSILON) {
              var d = Math.sqrt(h),
                p = Math.sqrt(c * c + l * l),
                f = e.x - s / d,
                m = e.y + o / d,
                g = n.x - l / p,
                v = n.y + c / p,
                y = ((g - f) * l - (v - m) * c) / (o * l - s * c);
              (i = f + o * y - t.x), (r = m + s * y - t.y);
              var x = i * i + r * r;
              if (x <= 2) return new Ue(i, r);
              a = Math.sqrt(x / 2);
            } else {
              var _ = !1;
              o > Number.EPSILON
                ? c > Number.EPSILON && (_ = !0)
                : o < -Number.EPSILON
                ? c < -Number.EPSILON && (_ = !0)
                : Math.sign(s) === Math.sign(l) && (_ = !0),
                _
                  ? ((i = -s), (r = o), (a = Math.sqrt(h)))
                  : ((i = o), (r = s), (a = Math.sqrt(h / 2)));
            }
            return new Ue(i / a, r / a);
          }
          for (
            var H = [], k = 0, G = R.length, V = G - 1, W = k + 1;
            k < G;
            k++, V++, W++
          )
            V === G && (V = 0),
              W === G && (W = 0),
              (H[k] = F(R[k], R[V], R[W]));
          var j,
            q,
            X = [],
            Y = H.concat();
          for (b = 0, w = T.length; b < w; b++) {
            for (
              _ = T[b], j = [], k = 0, G = _.length, V = G - 1, W = k + 1;
              k < G;
              k++, V++, W++
            )
              V === G && (V = 0),
                W === G && (W = 0),
                (j[k] = F(_[k], _[V], _[W]));
            X.push(j), (Y = Y.concat(j));
          }
          for (P = 0; P < d; P++) {
            for (
              I = P / d,
                O = h * Math.cos((I * Math.PI) / 2),
                D = u * Math.sin((I * Math.PI) / 2),
                k = 0,
                G = R.length;
              k < G;
              k++
            )
              (N = L(R[k], H[k], D)), $(N.x, N.y, -O);
            for (b = 0, w = T.length; b < w; b++)
              for (_ = T[b], j = X[b], k = 0, G = _.length; k < G; k++)
                (N = L(_[k], j[k], D)), $(N.x, N.y, -O);
          }
          for (D = u, k = 0; k < z; k++)
            (N = l ? L(E[k], Y[k], D) : E[k]),
              M
                ? (y.copy(g.normals[0]).multiplyScalar(N.x),
                  v.copy(g.binormals[0]).multiplyScalar(N.y),
                  x.copy(m[0]).add(y).add(v),
                  $(x.x, x.y, x.z))
                : $(N.x, N.y, 0);
          for (q = 1; q <= s; q++)
            for (k = 0; k < z; k++)
              (N = l ? L(E[k], Y[k], D) : E[k]),
                M
                  ? (y.copy(g.normals[q]).multiplyScalar(N.x),
                    v.copy(g.binormals[q]).multiplyScalar(N.y),
                    x.copy(m[q]).add(y).add(v),
                    $(x.x, x.y, x.z))
                  : $(N.x, N.y, (c / s) * q);
          for (P = d - 1; P >= 0; P--) {
            for (
              I = P / d,
                O = h * Math.cos((I * Math.PI) / 2),
                D = u * Math.sin((I * Math.PI) / 2),
                k = 0,
                G = R.length;
              k < G;
              k++
            )
              (N = L(R[k], H[k], D)), $(N.x, N.y, c + O);
            for (b = 0, w = T.length; b < w; b++)
              for (_ = T[b], j = X[b], k = 0, G = _.length; k < G; k++)
                (N = L(_[k], j[k], D)),
                  M
                    ? $(N.x, N.y + m[s - 1].y, m[s - 1].x + O)
                    : $(N.x, N.y, c + O);
          }
          function J() {
            var t = i.length / 3;
            if (l) {
              var e = 0,
                r = z * e;
              for (k = 0; k < U; k++)
                (B = C[k]), Q(B[2] + r, B[1] + r, B[0] + r);
              for (e = s + 2 * d, r = z * e, k = 0; k < U; k++)
                (B = C[k]), Q(B[0] + r, B[1] + r, B[2] + r);
            } else {
              for (k = 0; k < U; k++) (B = C[k]), Q(B[2], B[1], B[0]);
              for (k = 0; k < U; k++)
                (B = C[k]), Q(B[0] + z * s, B[1] + z * s, B[2] + z * s);
            }
            n.addGroup(t, i.length / 3 - t, 0);
          }
          function Z() {
            var t = i.length / 3,
              e = 0;
            for (K(R, e), e += R.length, b = 0, w = T.length; b < w; b++)
              (_ = T[b]), K(_, e), (e += _.length);
            n.addGroup(t, i.length / 3 - t, 1);
          }
          function K(t, e) {
            var n, i;
            k = t.length;
            while (--k >= 0) {
              (n = k), (i = k - 1), i < 0 && (i = t.length - 1);
              var r = 0,
                a = s + 2 * d;
              for (r = 0; r < a; r++) {
                var o = z * r,
                  c = z * (r + 1),
                  l = e + n + o,
                  h = e + i + o,
                  u = e + i + c,
                  p = e + n + c;
                tt(l, h, u, p);
              }
            }
          }
          function $(t, e, n) {
            a.push(t), a.push(e), a.push(n);
          }
          function Q(t, e, r) {
            et(t), et(e), et(r);
            var a = i.length / 3,
              o = f.generateTopUV(n, i, a - 3, a - 2, a - 1);
            nt(o[0]), nt(o[1]), nt(o[2]);
          }
          function tt(t, e, r, a) {
            et(t), et(e), et(a), et(e), et(r), et(a);
            var o = i.length / 3,
              s = f.generateSideWallUV(n, i, o - 6, o - 3, o - 2, o - 1);
            nt(s[0]), nt(s[1]), nt(s[3]), nt(s[1]), nt(s[2]), nt(s[3]);
          }
          function et(t) {
            i.push(a[3 * t + 0]), i.push(a[3 * t + 1]), i.push(a[3 * t + 2]);
          }
          function nt(t) {
            r.push(t.x), r.push(t.y);
          }
          J(), Z();
        }
        this.addAttribute("position", new Lr(i, 3)),
          this.addAttribute("uv", new Lr(r, 2)),
          this.computeVertexNormals();
      }
      (Qs.prototype = Object.create(br.prototype)),
        (Qs.prototype.constructor = Qs),
        (Qs.prototype.toJSON = function () {
          var t = br.prototype.toJSON.call(this),
            e = this.parameters.shapes,
            n = this.parameters.options;
          return nc(e, n, t);
        }),
        (tc.prototype = Object.create(Nr.prototype)),
        (tc.prototype.constructor = tc),
        (tc.prototype.toJSON = function () {
          var t = Nr.prototype.toJSON.call(this),
            e = this.parameters.shapes,
            n = this.parameters.options;
          return nc(e, n, t);
        });
      var ec = {
        generateTopUV: function (t, e, n, i, r) {
          var a = e[3 * n],
            o = e[3 * n + 1],
            s = e[3 * i],
            c = e[3 * i + 1],
            l = e[3 * r],
            h = e[3 * r + 1];
          return [new Ue(a, o), new Ue(s, c), new Ue(l, h)];
        },
        generateSideWallUV: function (t, e, n, i, r, a) {
          var o = e[3 * n],
            s = e[3 * n + 1],
            c = e[3 * n + 2],
            l = e[3 * i],
            h = e[3 * i + 1],
            u = e[3 * i + 2],
            d = e[3 * r],
            p = e[3 * r + 1],
            f = e[3 * r + 2],
            m = e[3 * a],
            g = e[3 * a + 1],
            v = e[3 * a + 2];
          return Math.abs(s - h) < 0.01
            ? [
                new Ue(o, 1 - c),
                new Ue(l, 1 - u),
                new Ue(d, 1 - f),
                new Ue(m, 1 - v),
              ]
            : [
                new Ue(s, 1 - c),
                new Ue(h, 1 - u),
                new Ue(p, 1 - f),
                new Ue(g, 1 - v),
              ];
        },
      };
      function nc(t, e, n) {
        if (((n.shapes = []), Array.isArray(t)))
          for (var i = 0, r = t.length; i < r; i++) {
            var a = t[i];
            n.shapes.push(a.uuid);
          }
        else n.shapes.push(t.uuid);
        return (
          void 0 !== e.extrudePath &&
            (n.options.extrudePath = e.extrudePath.toJSON()),
          n
        );
      }
      function ic(t, e) {
        br.call(this),
          (this.type = "TextGeometry"),
          (this.parameters = { text: t, parameters: e }),
          this.fromBufferGeometry(new rc(t, e)),
          this.mergeVertices();
      }
      function rc(t, e) {
        e = e || {};
        var n = e.font;
        if (!n || !n.isFont)
          return (
            console.error(
              "THREE.TextGeometry: font parameter is not an instance of THREE.Font."
            ),
            new br()
          );
        var i = n.generateShapes(t, e.size);
        (e.depth = void 0 !== e.height ? e.height : 50),
          void 0 === e.bevelThickness && (e.bevelThickness = 10),
          void 0 === e.bevelSize && (e.bevelSize = 8),
          void 0 === e.bevelEnabled && (e.bevelEnabled = !1),
          tc.call(this, i, e),
          (this.type = "TextBufferGeometry");
      }
      function ac(t, e, n, i, r, a, o) {
        br.call(this),
          (this.type = "SphereGeometry"),
          (this.parameters = {
            radius: t,
            widthSegments: e,
            heightSegments: n,
            phiStart: i,
            phiLength: r,
            thetaStart: a,
            thetaLength: o,
          }),
          this.fromBufferGeometry(new oc(t, e, n, i, r, a, o)),
          this.mergeVertices();
      }
      function oc(t, e, n, i, r, a, o) {
        Nr.call(this),
          (this.type = "SphereBufferGeometry"),
          (this.parameters = {
            radius: t,
            widthSegments: e,
            heightSegments: n,
            phiStart: i,
            phiLength: r,
            thetaStart: a,
            thetaLength: o,
          }),
          (t = t || 1),
          (e = Math.max(3, Math.floor(e) || 8)),
          (n = Math.max(2, Math.floor(n) || 6)),
          (i = void 0 !== i ? i : 0),
          (r = void 0 !== r ? r : 2 * Math.PI),
          (a = void 0 !== a ? a : 0),
          (o = void 0 !== o ? o : Math.PI);
        var s,
          c,
          l = a + o,
          h = 0,
          u = [],
          d = new ke(),
          p = new ke(),
          f = [],
          m = [],
          g = [],
          v = [];
        for (c = 0; c <= n; c++) {
          var y = [],
            x = c / n;
          for (s = 0; s <= e; s++) {
            var _ = s / e;
            (d.x = -t * Math.cos(i + _ * r) * Math.sin(a + x * o)),
              (d.y = t * Math.cos(a + x * o)),
              (d.z = t * Math.sin(i + _ * r) * Math.sin(a + x * o)),
              m.push(d.x, d.y, d.z),
              p.set(d.x, d.y, d.z).normalize(),
              g.push(p.x, p.y, p.z),
              v.push(_, 1 - x),
              y.push(h++);
          }
          u.push(y);
        }
        for (c = 0; c < n; c++)
          for (s = 0; s < e; s++) {
            var b = u[c][s + 1],
              w = u[c][s],
              M = u[c + 1][s],
              S = u[c + 1][s + 1];
            (0 !== c || a > 0) && f.push(b, w, S),
              (c !== n - 1 || l < Math.PI) && f.push(w, M, S);
          }
        this.setIndex(f),
          this.addAttribute("position", new Lr(m, 3)),
          this.addAttribute("normal", new Lr(g, 3)),
          this.addAttribute("uv", new Lr(v, 2));
      }
      function sc(t, e, n, i, r, a) {
        br.call(this),
          (this.type = "RingGeometry"),
          (this.parameters = {
            innerRadius: t,
            outerRadius: e,
            thetaSegments: n,
            phiSegments: i,
            thetaStart: r,
            thetaLength: a,
          }),
          this.fromBufferGeometry(new cc(t, e, n, i, r, a)),
          this.mergeVertices();
      }
      function cc(t, e, n, i, r, a) {
        Nr.call(this),
          (this.type = "RingBufferGeometry"),
          (this.parameters = {
            innerRadius: t,
            outerRadius: e,
            thetaSegments: n,
            phiSegments: i,
            thetaStart: r,
            thetaLength: a,
          }),
          (t = t || 0.5),
          (e = e || 1),
          (r = void 0 !== r ? r : 0),
          (a = void 0 !== a ? a : 2 * Math.PI),
          (n = void 0 !== n ? Math.max(3, n) : 8),
          (i = void 0 !== i ? Math.max(1, i) : 1);
        var o,
          s,
          c,
          l = [],
          h = [],
          u = [],
          d = [],
          p = t,
          f = (e - t) / i,
          m = new ke(),
          g = new Ue();
        for (s = 0; s <= i; s++) {
          for (c = 0; c <= n; c++)
            (o = r + (c / n) * a),
              (m.x = p * Math.cos(o)),
              (m.y = p * Math.sin(o)),
              h.push(m.x, m.y, m.z),
              u.push(0, 0, 1),
              (g.x = (m.x / e + 1) / 2),
              (g.y = (m.y / e + 1) / 2),
              d.push(g.x, g.y);
          p += f;
        }
        for (s = 0; s < i; s++) {
          var v = s * (n + 1);
          for (c = 0; c < n; c++) {
            o = c + v;
            var y = o,
              x = o + n + 1,
              _ = o + n + 2,
              b = o + 1;
            l.push(y, x, b), l.push(x, _, b);
          }
        }
        this.setIndex(l),
          this.addAttribute("position", new Lr(h, 3)),
          this.addAttribute("normal", new Lr(u, 3)),
          this.addAttribute("uv", new Lr(d, 2));
      }
      function lc(t, e, n, i) {
        br.call(this),
          (this.type = "LatheGeometry"),
          (this.parameters = {
            points: t,
            segments: e,
            phiStart: n,
            phiLength: i,
          }),
          this.fromBufferGeometry(new hc(t, e, n, i)),
          this.mergeVertices();
      }
      function hc(t, e, n, i) {
        Nr.call(this),
          (this.type = "LatheBufferGeometry"),
          (this.parameters = {
            points: t,
            segments: e,
            phiStart: n,
            phiLength: i,
          }),
          (e = Math.floor(e) || 12),
          (n = n || 0),
          (i = i || 2 * Math.PI),
          (i = ze.clamp(i, 0, 2 * Math.PI));
        var r,
          a,
          o,
          s = [],
          c = [],
          l = [],
          h = 1 / e,
          u = new ke(),
          d = new Ue();
        for (a = 0; a <= e; a++) {
          var p = n + a * h * i,
            f = Math.sin(p),
            m = Math.cos(p);
          for (o = 0; o <= t.length - 1; o++)
            (u.x = t[o].x * f),
              (u.y = t[o].y),
              (u.z = t[o].x * m),
              c.push(u.x, u.y, u.z),
              (d.x = a / e),
              (d.y = o / (t.length - 1)),
              l.push(d.x, d.y);
        }
        for (a = 0; a < e; a++)
          for (o = 0; o < t.length - 1; o++) {
            r = o + a * t.length;
            var g = r,
              v = r + t.length,
              y = r + t.length + 1,
              x = r + 1;
            s.push(g, v, x), s.push(v, y, x);
          }
        if (
          (this.setIndex(s),
          this.addAttribute("position", new Lr(c, 3)),
          this.addAttribute("uv", new Lr(l, 2)),
          this.computeVertexNormals(),
          i === 2 * Math.PI)
        ) {
          var _ = this.attributes.normal.array,
            b = new ke(),
            w = new ke(),
            M = new ke();
          for (r = e * t.length * 3, a = 0, o = 0; a < t.length; a++, o += 3)
            (b.x = _[o + 0]),
              (b.y = _[o + 1]),
              (b.z = _[o + 2]),
              (w.x = _[r + o + 0]),
              (w.y = _[r + o + 1]),
              (w.z = _[r + o + 2]),
              M.addVectors(b, w).normalize(),
              (_[o + 0] = _[r + o + 0] = M.x),
              (_[o + 1] = _[r + o + 1] = M.y),
              (_[o + 2] = _[r + o + 2] = M.z);
        }
      }
      function uc(t, e) {
        br.call(this),
          (this.type = "ShapeGeometry"),
          "object" === typeof e &&
            (console.warn(
              "THREE.ShapeGeometry: Options parameter has been removed."
            ),
            (e = e.curveSegments)),
          (this.parameters = { shapes: t, curveSegments: e }),
          this.fromBufferGeometry(new dc(t, e)),
          this.mergeVertices();
      }
      function dc(t, e) {
        Nr.call(this),
          (this.type = "ShapeBufferGeometry"),
          (this.parameters = { shapes: t, curveSegments: e }),
          (e = e || 12);
        var n = [],
          i = [],
          r = [],
          a = [],
          o = 0,
          s = 0;
        if (!1 === Array.isArray(t)) l(t);
        else
          for (var c = 0; c < t.length; c++)
            l(t[c]), this.addGroup(o, s, c), (o += s), (s = 0);
        function l(t) {
          var o,
            c,
            l,
            h = i.length / 3,
            u = t.extractPoints(e),
            d = u.shape,
            p = u.holes;
          if (!1 === Zs.isClockWise(d))
            for (d = d.reverse(), o = 0, c = p.length; o < c; o++)
              (l = p[o]), !0 === Zs.isClockWise(l) && (p[o] = l.reverse());
          var f = Zs.triangulateShape(d, p);
          for (o = 0, c = p.length; o < c; o++) (l = p[o]), (d = d.concat(l));
          for (o = 0, c = d.length; o < c; o++) {
            var m = d[o];
            i.push(m.x, m.y, 0), r.push(0, 0, 1), a.push(m.x, m.y);
          }
          for (o = 0, c = f.length; o < c; o++) {
            var g = f[o],
              v = g[0] + h,
              y = g[1] + h,
              x = g[2] + h;
            n.push(v, y, x), (s += 3);
          }
        }
        this.setIndex(n),
          this.addAttribute("position", new Lr(i, 3)),
          this.addAttribute("normal", new Lr(r, 3)),
          this.addAttribute("uv", new Lr(a, 2));
      }
      function pc(t, e) {
        if (((e.shapes = []), Array.isArray(t)))
          for (var n = 0, i = t.length; n < i; n++) {
            var r = t[n];
            e.shapes.push(r.uuid);
          }
        else e.shapes.push(t.uuid);
        return e;
      }
      function fc(t, e) {
        Nr.call(this),
          (this.type = "EdgesGeometry"),
          (this.parameters = { thresholdAngle: e }),
          (e = void 0 !== e ? e : 1);
        var n,
          i,
          r,
          a,
          o = [],
          s = Math.cos(ze.DEG2RAD * e),
          c = [0, 0],
          l = {},
          h = ["a", "b", "c"];
        t.isBufferGeometry
          ? ((a = new br()), a.fromBufferGeometry(t))
          : (a = t.clone()),
          a.mergeVertices(),
          a.computeFaceNormals();
        for (var u = a.vertices, d = a.faces, p = 0, f = d.length; p < f; p++)
          for (var m = d[p], g = 0; g < 3; g++)
            (n = m[h[g]]),
              (i = m[h[(g + 1) % 3]]),
              (c[0] = Math.min(n, i)),
              (c[1] = Math.max(n, i)),
              (r = c[0] + "," + c[1]),
              void 0 === l[r]
                ? (l[r] = {
                    index1: c[0],
                    index2: c[1],
                    face1: p,
                    face2: void 0,
                  })
                : (l[r].face2 = p);
        for (r in l) {
          var v = l[r];
          if (
            void 0 === v.face2 ||
            d[v.face1].normal.dot(d[v.face2].normal) <= s
          ) {
            var y = u[v.index1];
            o.push(y.x, y.y, y.z), (y = u[v.index2]), o.push(y.x, y.y, y.z);
          }
        }
        this.addAttribute("position", new Lr(o, 3));
      }
      function mc(t, e, n, i, r, a, o, s) {
        br.call(this),
          (this.type = "CylinderGeometry"),
          (this.parameters = {
            radiusTop: t,
            radiusBottom: e,
            height: n,
            radialSegments: i,
            heightSegments: r,
            openEnded: a,
            thetaStart: o,
            thetaLength: s,
          }),
          this.fromBufferGeometry(new gc(t, e, n, i, r, a, o, s)),
          this.mergeVertices();
      }
      function gc(t, e, n, i, r, a, o, s) {
        Nr.call(this),
          (this.type = "CylinderBufferGeometry"),
          (this.parameters = {
            radiusTop: t,
            radiusBottom: e,
            height: n,
            radialSegments: i,
            heightSegments: r,
            openEnded: a,
            thetaStart: o,
            thetaLength: s,
          });
        var c = this;
        (t = void 0 !== t ? t : 1),
          (e = void 0 !== e ? e : 1),
          (n = n || 1),
          (i = Math.floor(i) || 8),
          (r = Math.floor(r) || 1),
          (a = void 0 !== a && a),
          (o = void 0 !== o ? o : 0),
          (s = void 0 !== s ? s : 2 * Math.PI);
        var l = [],
          h = [],
          u = [],
          d = [],
          p = 0,
          f = [],
          m = n / 2,
          g = 0;
        function v() {
          var a,
            v,
            y = new ke(),
            x = new ke(),
            _ = 0,
            b = (e - t) / n;
          for (v = 0; v <= r; v++) {
            var w = [],
              M = v / r,
              S = M * (e - t) + t;
            for (a = 0; a <= i; a++) {
              var E = a / i,
                T = E * s + o,
                A = Math.sin(T),
                C = Math.cos(T);
              (x.x = S * A),
                (x.y = -M * n + m),
                (x.z = S * C),
                h.push(x.x, x.y, x.z),
                y.set(A, b, C).normalize(),
                u.push(y.x, y.y, y.z),
                d.push(E, 1 - M),
                w.push(p++);
            }
            f.push(w);
          }
          for (a = 0; a < i; a++)
            for (v = 0; v < r; v++) {
              var R = f[v][a],
                L = f[v + 1][a],
                P = f[v + 1][a + 1],
                D = f[v][a + 1];
              l.push(R, L, D), l.push(L, P, D), (_ += 6);
            }
          c.addGroup(g, _, 0), (g += _);
        }
        function y(n) {
          var r,
            a,
            f,
            v = new Ue(),
            y = new ke(),
            x = 0,
            _ = !0 === n ? t : e,
            b = !0 === n ? 1 : -1;
          for (a = p, r = 1; r <= i; r++)
            h.push(0, m * b, 0), u.push(0, b, 0), d.push(0.5, 0.5), p++;
          for (f = p, r = 0; r <= i; r++) {
            var w = r / i,
              M = w * s + o,
              S = Math.cos(M),
              E = Math.sin(M);
            (y.x = _ * E),
              (y.y = m * b),
              (y.z = _ * S),
              h.push(y.x, y.y, y.z),
              u.push(0, b, 0),
              (v.x = 0.5 * S + 0.5),
              (v.y = 0.5 * E * b + 0.5),
              d.push(v.x, v.y),
              p++;
          }
          for (r = 0; r < i; r++) {
            var T = a + r,
              A = f + r;
            !0 === n ? l.push(A, A + 1, T) : l.push(A + 1, A, T), (x += 3);
          }
          c.addGroup(g, x, !0 === n ? 1 : 2), (g += x);
        }
        v(),
          !1 === a && (t > 0 && y(!0), e > 0 && y(!1)),
          this.setIndex(l),
          this.addAttribute("position", new Lr(h, 3)),
          this.addAttribute("normal", new Lr(u, 3)),
          this.addAttribute("uv", new Lr(d, 2));
      }
      function vc(t, e, n, i, r, a, o) {
        mc.call(this, 0, t, e, n, i, r, a, o),
          (this.type = "ConeGeometry"),
          (this.parameters = {
            radius: t,
            height: e,
            radialSegments: n,
            heightSegments: i,
            openEnded: r,
            thetaStart: a,
            thetaLength: o,
          });
      }
      function yc(t, e, n, i, r, a, o) {
        gc.call(this, 0, t, e, n, i, r, a, o),
          (this.type = "ConeBufferGeometry"),
          (this.parameters = {
            radius: t,
            height: e,
            radialSegments: n,
            heightSegments: i,
            openEnded: r,
            thetaStart: a,
            thetaLength: o,
          });
      }
      function xc(t, e, n, i) {
        br.call(this),
          (this.type = "CircleGeometry"),
          (this.parameters = {
            radius: t,
            segments: e,
            thetaStart: n,
            thetaLength: i,
          }),
          this.fromBufferGeometry(new _c(t, e, n, i)),
          this.mergeVertices();
      }
      function _c(t, e, n, i) {
        Nr.call(this),
          (this.type = "CircleBufferGeometry"),
          (this.parameters = {
            radius: t,
            segments: e,
            thetaStart: n,
            thetaLength: i,
          }),
          (t = t || 1),
          (e = void 0 !== e ? Math.max(3, e) : 8),
          (n = void 0 !== n ? n : 0),
          (i = void 0 !== i ? i : 2 * Math.PI);
        var r,
          a,
          o = [],
          s = [],
          c = [],
          l = [],
          h = new ke(),
          u = new Ue();
        for (
          s.push(0, 0, 0), c.push(0, 0, 1), l.push(0.5, 0.5), a = 0, r = 3;
          a <= e;
          a++, r += 3
        ) {
          var d = n + (a / e) * i;
          (h.x = t * Math.cos(d)),
            (h.y = t * Math.sin(d)),
            s.push(h.x, h.y, h.z),
            c.push(0, 0, 1),
            (u.x = (s[r] / t + 1) / 2),
            (u.y = (s[r + 1] / t + 1) / 2),
            l.push(u.x, u.y);
        }
        for (r = 1; r <= e; r++) o.push(r, r + 1, 0);
        this.setIndex(o),
          this.addAttribute("position", new Lr(s, 3)),
          this.addAttribute("normal", new Lr(c, 3)),
          this.addAttribute("uv", new Lr(l, 2));
      }
      (ic.prototype = Object.create(br.prototype)),
        (ic.prototype.constructor = ic),
        (rc.prototype = Object.create(tc.prototype)),
        (rc.prototype.constructor = rc),
        (ac.prototype = Object.create(br.prototype)),
        (ac.prototype.constructor = ac),
        (oc.prototype = Object.create(Nr.prototype)),
        (oc.prototype.constructor = oc),
        (sc.prototype = Object.create(br.prototype)),
        (sc.prototype.constructor = sc),
        (cc.prototype = Object.create(Nr.prototype)),
        (cc.prototype.constructor = cc),
        (lc.prototype = Object.create(br.prototype)),
        (lc.prototype.constructor = lc),
        (hc.prototype = Object.create(Nr.prototype)),
        (hc.prototype.constructor = hc),
        (uc.prototype = Object.create(br.prototype)),
        (uc.prototype.constructor = uc),
        (uc.prototype.toJSON = function () {
          var t = br.prototype.toJSON.call(this),
            e = this.parameters.shapes;
          return pc(e, t);
        }),
        (dc.prototype = Object.create(Nr.prototype)),
        (dc.prototype.constructor = dc),
        (dc.prototype.toJSON = function () {
          var t = Nr.prototype.toJSON.call(this),
            e = this.parameters.shapes;
          return pc(e, t);
        }),
        (fc.prototype = Object.create(Nr.prototype)),
        (fc.prototype.constructor = fc),
        (mc.prototype = Object.create(br.prototype)),
        (mc.prototype.constructor = mc),
        (gc.prototype = Object.create(Nr.prototype)),
        (gc.prototype.constructor = gc),
        (vc.prototype = Object.create(mc.prototype)),
        (vc.prototype.constructor = vc),
        (yc.prototype = Object.create(gc.prototype)),
        (yc.prototype.constructor = yc),
        (xc.prototype = Object.create(br.prototype)),
        (xc.prototype.constructor = xc),
        (_c.prototype = Object.create(Nr.prototype)),
        (_c.prototype.constructor = _c);
      var bc = Object.freeze({
        WireframeGeometry: ns,
        ParametricGeometry: is,
        ParametricBufferGeometry: rs,
        TetrahedronGeometry: ss,
        TetrahedronBufferGeometry: cs,
        OctahedronGeometry: ls,
        OctahedronBufferGeometry: hs,
        IcosahedronGeometry: us,
        IcosahedronBufferGeometry: ds,
        DodecahedronGeometry: ps,
        DodecahedronBufferGeometry: fs,
        PolyhedronGeometry: as,
        PolyhedronBufferGeometry: os,
        TubeGeometry: ms,
        TubeBufferGeometry: gs,
        TorusKnotGeometry: vs,
        TorusKnotBufferGeometry: ys,
        TorusGeometry: xs,
        TorusBufferGeometry: _s,
        TextGeometry: ic,
        TextBufferGeometry: rc,
        SphereGeometry: ac,
        SphereBufferGeometry: oc,
        RingGeometry: sc,
        RingBufferGeometry: cc,
        PlaneGeometry: Ur,
        PlaneBufferGeometry: Fr,
        LatheGeometry: lc,
        LatheBufferGeometry: hc,
        ShapeGeometry: uc,
        ShapeBufferGeometry: dc,
        ExtrudeGeometry: Qs,
        ExtrudeBufferGeometry: tc,
        EdgesGeometry: fc,
        ConeGeometry: vc,
        ConeBufferGeometry: yc,
        CylinderGeometry: mc,
        CylinderBufferGeometry: gc,
        CircleGeometry: xc,
        CircleBufferGeometry: _c,
        BoxGeometry: Br,
        BoxBufferGeometry: zr,
      });
      function wc(t) {
        kr.call(this),
          (this.type = "ShadowMaterial"),
          (this.color = new cr(0)),
          (this.transparent = !0),
          this.setValues(t);
      }
      function Mc(t) {
        Vr.call(this, t), (this.type = "RawShaderMaterial");
      }
      function Sc(t) {
        kr.call(this),
          (this.defines = { STANDARD: "" }),
          (this.type = "MeshStandardMaterial"),
          (this.color = new cr(16777215)),
          (this.roughness = 0.5),
          (this.metalness = 0.5),
          (this.map = null),
          (this.lightMap = null),
          (this.lightMapIntensity = 1),
          (this.aoMap = null),
          (this.aoMapIntensity = 1),
          (this.emissive = new cr(0)),
          (this.emissiveIntensity = 1),
          (this.emissiveMap = null),
          (this.bumpMap = null),
          (this.bumpScale = 1),
          (this.normalMap = null),
          (this.normalMapType = Ne),
          (this.normalScale = new Ue(1, 1)),
          (this.displacementMap = null),
          (this.displacementScale = 1),
          (this.displacementBias = 0),
          (this.roughnessMap = null),
          (this.metalnessMap = null),
          (this.alphaMap = null),
          (this.envMap = null),
          (this.envMapIntensity = 1),
          (this.refractionRatio = 0.98),
          (this.wireframe = !1),
          (this.wireframeLinewidth = 1),
          (this.wireframeLinecap = "round"),
          (this.wireframeLinejoin = "round"),
          (this.skinning = !1),
          (this.morphTargets = !1),
          (this.morphNormals = !1),
          this.setValues(t);
      }
      function Ec(t) {
        Sc.call(this),
          (this.defines = { PHYSICAL: "" }),
          (this.type = "MeshPhysicalMaterial"),
          (this.reflectivity = 0.5),
          (this.clearCoat = 0),
          (this.clearCoatRoughness = 0),
          this.setValues(t);
      }
      function Tc(t) {
        kr.call(this),
          (this.type = "MeshPhongMaterial"),
          (this.color = new cr(16777215)),
          (this.specular = new cr(1118481)),
          (this.shininess = 30),
          (this.map = null),
          (this.lightMap = null),
          (this.lightMapIntensity = 1),
          (this.aoMap = null),
          (this.aoMapIntensity = 1),
          (this.emissive = new cr(0)),
          (this.emissiveIntensity = 1),
          (this.emissiveMap = null),
          (this.bumpMap = null),
          (this.bumpScale = 1),
          (this.normalMap = null),
          (this.normalMapType = Ne),
          (this.normalScale = new Ue(1, 1)),
          (this.displacementMap = null),
          (this.displacementScale = 1),
          (this.displacementBias = 0),
          (this.specularMap = null),
          (this.alphaMap = null),
          (this.envMap = null),
          (this.combine = Q),
          (this.reflectivity = 1),
          (this.refractionRatio = 0.98),
          (this.wireframe = !1),
          (this.wireframeLinewidth = 1),
          (this.wireframeLinecap = "round"),
          (this.wireframeLinejoin = "round"),
          (this.skinning = !1),
          (this.morphTargets = !1),
          (this.morphNormals = !1),
          this.setValues(t);
      }
      function Ac(t) {
        Tc.call(this),
          (this.defines = { TOON: "" }),
          (this.type = "MeshToonMaterial"),
          (this.gradientMap = null),
          this.setValues(t);
      }
      function Cc(t) {
        kr.call(this),
          (this.type = "MeshNormalMaterial"),
          (this.bumpMap = null),
          (this.bumpScale = 1),
          (this.normalMap = null),
          (this.normalMapType = Ne),
          (this.normalScale = new Ue(1, 1)),
          (this.displacementMap = null),
          (this.displacementScale = 1),
          (this.displacementBias = 0),
          (this.wireframe = !1),
          (this.wireframeLinewidth = 1),
          (this.fog = !1),
          (this.lights = !1),
          (this.skinning = !1),
          (this.morphTargets = !1),
          (this.morphNormals = !1),
          this.setValues(t);
      }
      function Rc(t) {
        kr.call(this),
          (this.type = "MeshLambertMaterial"),
          (this.color = new cr(16777215)),
          (this.map = null),
          (this.lightMap = null),
          (this.lightMapIntensity = 1),
          (this.aoMap = null),
          (this.aoMapIntensity = 1),
          (this.emissive = new cr(0)),
          (this.emissiveIntensity = 1),
          (this.emissiveMap = null),
          (this.specularMap = null),
          (this.alphaMap = null),
          (this.envMap = null),
          (this.combine = Q),
          (this.reflectivity = 1),
          (this.refractionRatio = 0.98),
          (this.wireframe = !1),
          (this.wireframeLinewidth = 1),
          (this.wireframeLinecap = "round"),
          (this.wireframeLinejoin = "round"),
          (this.skinning = !1),
          (this.morphTargets = !1),
          (this.morphNormals = !1),
          this.setValues(t);
      }
      function Lc(t) {
        Xo.call(this),
          (this.type = "LineDashedMaterial"),
          (this.scale = 1),
          (this.dashSize = 3),
          (this.gapSize = 1),
          this.setValues(t);
      }
      (wc.prototype = Object.create(kr.prototype)),
        (wc.prototype.constructor = wc),
        (wc.prototype.isShadowMaterial = !0),
        (wc.prototype.copy = function (t) {
          return (
            kr.prototype.copy.call(this, t), this.color.copy(t.color), this
          );
        }),
        (Mc.prototype = Object.create(Vr.prototype)),
        (Mc.prototype.constructor = Mc),
        (Mc.prototype.isRawShaderMaterial = !0),
        (Sc.prototype = Object.create(kr.prototype)),
        (Sc.prototype.constructor = Sc),
        (Sc.prototype.isMeshStandardMaterial = !0),
        (Sc.prototype.copy = function (t) {
          return (
            kr.prototype.copy.call(this, t),
            (this.defines = { STANDARD: "" }),
            this.color.copy(t.color),
            (this.roughness = t.roughness),
            (this.metalness = t.metalness),
            (this.map = t.map),
            (this.lightMap = t.lightMap),
            (this.lightMapIntensity = t.lightMapIntensity),
            (this.aoMap = t.aoMap),
            (this.aoMapIntensity = t.aoMapIntensity),
            this.emissive.copy(t.emissive),
            (this.emissiveMap = t.emissiveMap),
            (this.emissiveIntensity = t.emissiveIntensity),
            (this.bumpMap = t.bumpMap),
            (this.bumpScale = t.bumpScale),
            (this.normalMap = t.normalMap),
            (this.normalMapType = t.normalMapType),
            this.normalScale.copy(t.normalScale),
            (this.displacementMap = t.displacementMap),
            (this.displacementScale = t.displacementScale),
            (this.displacementBias = t.displacementBias),
            (this.roughnessMap = t.roughnessMap),
            (this.metalnessMap = t.metalnessMap),
            (this.alphaMap = t.alphaMap),
            (this.envMap = t.envMap),
            (this.envMapIntensity = t.envMapIntensity),
            (this.refractionRatio = t.refractionRatio),
            (this.wireframe = t.wireframe),
            (this.wireframeLinewidth = t.wireframeLinewidth),
            (this.wireframeLinecap = t.wireframeLinecap),
            (this.wireframeLinejoin = t.wireframeLinejoin),
            (this.skinning = t.skinning),
            (this.morphTargets = t.morphTargets),
            (this.morphNormals = t.morphNormals),
            this
          );
        }),
        (Ec.prototype = Object.create(Sc.prototype)),
        (Ec.prototype.constructor = Ec),
        (Ec.prototype.isMeshPhysicalMaterial = !0),
        (Ec.prototype.copy = function (t) {
          return (
            Sc.prototype.copy.call(this, t),
            (this.defines = { PHYSICAL: "" }),
            (this.reflectivity = t.reflectivity),
            (this.clearCoat = t.clearCoat),
            (this.clearCoatRoughness = t.clearCoatRoughness),
            this
          );
        }),
        (Tc.prototype = Object.create(kr.prototype)),
        (Tc.prototype.constructor = Tc),
        (Tc.prototype.isMeshPhongMaterial = !0),
        (Tc.prototype.copy = function (t) {
          return (
            kr.prototype.copy.call(this, t),
            this.color.copy(t.color),
            this.specular.copy(t.specular),
            (this.shininess = t.shininess),
            (this.map = t.map),
            (this.lightMap = t.lightMap),
            (this.lightMapIntensity = t.lightMapIntensity),
            (this.aoMap = t.aoMap),
            (this.aoMapIntensity = t.aoMapIntensity),
            this.emissive.copy(t.emissive),
            (this.emissiveMap = t.emissiveMap),
            (this.emissiveIntensity = t.emissiveIntensity),
            (this.bumpMap = t.bumpMap),
            (this.bumpScale = t.bumpScale),
            (this.normalMap = t.normalMap),
            (this.normalMapType = t.normalMapType),
            this.normalScale.copy(t.normalScale),
            (this.displacementMap = t.displacementMap),
            (this.displacementScale = t.displacementScale),
            (this.displacementBias = t.displacementBias),
            (this.specularMap = t.specularMap),
            (this.alphaMap = t.alphaMap),
            (this.envMap = t.envMap),
            (this.combine = t.combine),
            (this.reflectivity = t.reflectivity),
            (this.refractionRatio = t.refractionRatio),
            (this.wireframe = t.wireframe),
            (this.wireframeLinewidth = t.wireframeLinewidth),
            (this.wireframeLinecap = t.wireframeLinecap),
            (this.wireframeLinejoin = t.wireframeLinejoin),
            (this.skinning = t.skinning),
            (this.morphTargets = t.morphTargets),
            (this.morphNormals = t.morphNormals),
            this
          );
        }),
        (Ac.prototype = Object.create(Tc.prototype)),
        (Ac.prototype.constructor = Ac),
        (Ac.prototype.isMeshToonMaterial = !0),
        (Ac.prototype.copy = function (t) {
          return (
            Tc.prototype.copy.call(this, t),
            (this.gradientMap = t.gradientMap),
            this
          );
        }),
        (Cc.prototype = Object.create(kr.prototype)),
        (Cc.prototype.constructor = Cc),
        (Cc.prototype.isMeshNormalMaterial = !0),
        (Cc.prototype.copy = function (t) {
          return (
            kr.prototype.copy.call(this, t),
            (this.bumpMap = t.bumpMap),
            (this.bumpScale = t.bumpScale),
            (this.normalMap = t.normalMap),
            (this.normalMapType = t.normalMapType),
            this.normalScale.copy(t.normalScale),
            (this.displacementMap = t.displacementMap),
            (this.displacementScale = t.displacementScale),
            (this.displacementBias = t.displacementBias),
            (this.wireframe = t.wireframe),
            (this.wireframeLinewidth = t.wireframeLinewidth),
            (this.skinning = t.skinning),
            (this.morphTargets = t.morphTargets),
            (this.morphNormals = t.morphNormals),
            this
          );
        }),
        (Rc.prototype = Object.create(kr.prototype)),
        (Rc.prototype.constructor = Rc),
        (Rc.prototype.isMeshLambertMaterial = !0),
        (Rc.prototype.copy = function (t) {
          return (
            kr.prototype.copy.call(this, t),
            this.color.copy(t.color),
            (this.map = t.map),
            (this.lightMap = t.lightMap),
            (this.lightMapIntensity = t.lightMapIntensity),
            (this.aoMap = t.aoMap),
            (this.aoMapIntensity = t.aoMapIntensity),
            this.emissive.copy(t.emissive),
            (this.emissiveMap = t.emissiveMap),
            (this.emissiveIntensity = t.emissiveIntensity),
            (this.specularMap = t.specularMap),
            (this.alphaMap = t.alphaMap),
            (this.envMap = t.envMap),
            (this.combine = t.combine),
            (this.reflectivity = t.reflectivity),
            (this.refractionRatio = t.refractionRatio),
            (this.wireframe = t.wireframe),
            (this.wireframeLinewidth = t.wireframeLinewidth),
            (this.wireframeLinecap = t.wireframeLinecap),
            (this.wireframeLinejoin = t.wireframeLinejoin),
            (this.skinning = t.skinning),
            (this.morphTargets = t.morphTargets),
            (this.morphNormals = t.morphNormals),
            this
          );
        }),
        (Lc.prototype = Object.create(Xo.prototype)),
        (Lc.prototype.constructor = Lc),
        (Lc.prototype.isLineDashedMaterial = !0),
        (Lc.prototype.copy = function (t) {
          return (
            Xo.prototype.copy.call(this, t),
            (this.scale = t.scale),
            (this.dashSize = t.dashSize),
            (this.gapSize = t.gapSize),
            this
          );
        });
      var Pc = Object.freeze({
          ShadowMaterial: wc,
          SpriteMaterial: ko,
          RawShaderMaterial: Mc,
          ShaderMaterial: Vr,
          PointsMaterial: Ko,
          MeshPhysicalMaterial: Ec,
          MeshStandardMaterial: Sc,
          MeshPhongMaterial: Tc,
          MeshToonMaterial: Ac,
          MeshNormalMaterial: Cc,
          MeshLambertMaterial: Rc,
          MeshDepthMaterial: So,
          MeshDistanceMaterial: Eo,
          MeshBasicMaterial: Gr,
          LineDashedMaterial: Lc,
          LineBasicMaterial: Xo,
          Material: kr,
        }),
        Dc = {
          enabled: !1,
          files: {},
          add: function (t, e) {
            !1 !== this.enabled && (this.files[t] = e);
          },
          get: function (t) {
            if (!1 !== this.enabled) return this.files[t];
          },
          remove: function (t) {
            delete this.files[t];
          },
          clear: function () {
            this.files = {};
          },
        };
      function Ic(t, e, n) {
        var i = this,
          r = !1,
          a = 0,
          o = 0,
          s = void 0;
        (this.onStart = void 0),
          (this.onLoad = t),
          (this.onProgress = e),
          (this.onError = n),
          (this.itemStart = function (t) {
            o++,
              !1 === r && void 0 !== i.onStart && i.onStart(t, a, o),
              (r = !0);
          }),
          (this.itemEnd = function (t) {
            a++,
              void 0 !== i.onProgress && i.onProgress(t, a, o),
              a === o && ((r = !1), void 0 !== i.onLoad && i.onLoad());
          }),
          (this.itemError = function (t) {
            void 0 !== i.onError && i.onError(t);
          }),
          (this.resolveURL = function (t) {
            return s ? s(t) : t;
          }),
          (this.setURLModifier = function (t) {
            return (s = t), this;
          });
      }
      var Oc = new Ic(),
        Nc = {};
      function Bc(t) {
        this.manager = void 0 !== t ? t : Oc;
      }
      function zc(t) {
        (this.manager = void 0 !== t ? t : Oc), (this._parser = null);
      }
      function Uc(t) {
        (this.manager = void 0 !== t ? t : Oc), (this._parser = null);
      }
      function Fc(t) {
        this.manager = void 0 !== t ? t : Oc;
      }
      function Hc(t) {
        this.manager = void 0 !== t ? t : Oc;
      }
      function kc(t) {
        this.manager = void 0 !== t ? t : Oc;
      }
      function Gc() {
        (this.type = "Curve"), (this.arcLengthDivisions = 200);
      }
      function Vc(t, e, n, i, r, a, o, s) {
        Gc.call(this),
          (this.type = "EllipseCurve"),
          (this.aX = t || 0),
          (this.aY = e || 0),
          (this.xRadius = n || 1),
          (this.yRadius = i || 1),
          (this.aStartAngle = r || 0),
          (this.aEndAngle = a || 2 * Math.PI),
          (this.aClockwise = o || !1),
          (this.aRotation = s || 0);
      }
      function Wc(t, e, n, i, r, a) {
        Vc.call(this, t, e, n, n, i, r, a), (this.type = "ArcCurve");
      }
      function jc() {
        var t = 0,
          e = 0,
          n = 0,
          i = 0;
        function r(r, a, o, s) {
          (t = r),
            (e = o),
            (n = -3 * r + 3 * a - 2 * o - s),
            (i = 2 * r - 2 * a + o + s);
        }
        return {
          initCatmullRom: function (t, e, n, i, a) {
            r(e, n, a * (n - t), a * (i - e));
          },
          initNonuniformCatmullRom: function (t, e, n, i, a, o, s) {
            var c = (e - t) / a - (n - t) / (a + o) + (n - e) / o,
              l = (n - e) / o - (i - e) / (o + s) + (i - n) / s;
            (c *= o), (l *= o), r(e, n, c, l);
          },
          calc: function (r) {
            var a = r * r,
              o = a * r;
            return t + e * r + n * a + i * o;
          },
        };
      }
      Object.assign(Bc.prototype, {
        load: function (t, e, n, i) {
          void 0 === t && (t = ""),
            void 0 !== this.path && (t = this.path + t),
            (t = this.manager.resolveURL(t));
          var r = this,
            a = Dc.get(t);
          if (void 0 !== a)
            return (
              r.manager.itemStart(t),
              setTimeout(function () {
                e && e(a), r.manager.itemEnd(t);
              }, 0),
              a
            );
          if (void 0 === Nc[t]) {
            var o = /^data:(.*?)(;base64)?,(.*)$/,
              s = t.match(o);
            if (s) {
              var c = s[1],
                l = !!s[2],
                h = s[3];
              (h = window.decodeURIComponent(h)), l && (h = window.atob(h));
              try {
                var u,
                  d = (this.responseType || "").toLowerCase();
                switch (d) {
                  case "arraybuffer":
                  case "blob":
                    for (
                      var p = new Uint8Array(h.length), f = 0;
                      f < h.length;
                      f++
                    )
                      p[f] = h.charCodeAt(f);
                    u =
                      "blob" === d
                        ? new Blob([p.buffer], { type: c })
                        : p.buffer;
                    break;
                  case "document":
                    var m = new DOMParser();
                    u = m.parseFromString(h, c);
                    break;
                  case "json":
                    u = JSON.parse(h);
                    break;
                  default:
                    u = h;
                    break;
                }
                window.setTimeout(function () {
                  e && e(u), r.manager.itemEnd(t);
                }, 0);
              } catch (y) {
                window.setTimeout(function () {
                  i && i(y), r.manager.itemEnd(t), r.manager.itemError(t);
                }, 0);
              }
            } else {
              (Nc[t] = []),
                Nc[t].push({ onLoad: e, onProgress: n, onError: i });
              var g = new XMLHttpRequest();
              for (var v in (g.open("GET", t, !0),
              g.addEventListener(
                "load",
                function (e) {
                  var n = this.response;
                  Dc.add(t, n);
                  var i = Nc[t];
                  if (
                    (delete Nc[t], 200 === this.status || 0 === this.status)
                  ) {
                    0 === this.status &&
                      console.warn("THREE.FileLoader: HTTP Status 0 received.");
                    for (var a = 0, o = i.length; a < o; a++) {
                      var s = i[a];
                      s.onLoad && s.onLoad(n);
                    }
                    r.manager.itemEnd(t);
                  } else {
                    for (a = 0, o = i.length; a < o; a++) {
                      s = i[a];
                      s.onError && s.onError(e);
                    }
                    r.manager.itemEnd(t), r.manager.itemError(t);
                  }
                },
                !1
              ),
              g.addEventListener(
                "progress",
                function (e) {
                  for (var n = Nc[t], i = 0, r = n.length; i < r; i++) {
                    var a = n[i];
                    a.onProgress && a.onProgress(e);
                  }
                },
                !1
              ),
              g.addEventListener(
                "error",
                function (e) {
                  var n = Nc[t];
                  delete Nc[t];
                  for (var i = 0, a = n.length; i < a; i++) {
                    var o = n[i];
                    o.onError && o.onError(e);
                  }
                  r.manager.itemEnd(t), r.manager.itemError(t);
                },
                !1
              ),
              void 0 !== this.responseType &&
                (g.responseType = this.responseType),
              void 0 !== this.withCredentials &&
                (g.withCredentials = this.withCredentials),
              g.overrideMimeType &&
                g.overrideMimeType(
                  void 0 !== this.mimeType ? this.mimeType : "text/plain"
                ),
              this.requestHeader))
                g.setRequestHeader(v, this.requestHeader[v]);
              g.send(null);
            }
            return r.manager.itemStart(t), g;
          }
          Nc[t].push({ onLoad: e, onProgress: n, onError: i });
        },
        setPath: function (t) {
          return (this.path = t), this;
        },
        setResponseType: function (t) {
          return (this.responseType = t), this;
        },
        setWithCredentials: function (t) {
          return (this.withCredentials = t), this;
        },
        setMimeType: function (t) {
          return (this.mimeType = t), this;
        },
        setRequestHeader: function (t) {
          return (this.requestHeader = t), this;
        },
      }),
        Object.assign(zc.prototype, {
          load: function (t, e, n, i) {
            var r = this,
              a = [],
              o = new ts();
            o.image = a;
            var s = new Bc(this.manager);
            function c(c) {
              s.load(
                t[c],
                function (t) {
                  var n = r._parser(t, !0);
                  (a[c] = {
                    width: n.width,
                    height: n.height,
                    format: n.format,
                    mipmaps: n.mipmaps,
                  }),
                    (l += 1),
                    6 === l &&
                      (1 === n.mipmapCount && (o.minFilter = bt),
                      (o.format = n.format),
                      (o.needsUpdate = !0),
                      e && e(o));
                },
                n,
                i
              );
            }
            if (
              (s.setPath(this.path),
              s.setResponseType("arraybuffer"),
              Array.isArray(t))
            )
              for (var l = 0, h = 0, u = t.length; h < u; ++h) c(h);
            else
              s.load(
                t,
                function (t) {
                  var n = r._parser(t, !0);
                  if (n.isCubemap)
                    for (
                      var i = n.mipmaps.length / n.mipmapCount, s = 0;
                      s < i;
                      s++
                    ) {
                      a[s] = { mipmaps: [] };
                      for (var c = 0; c < n.mipmapCount; c++)
                        a[s].mipmaps.push(n.mipmaps[s * n.mipmapCount + c]),
                          (a[s].format = n.format),
                          (a[s].width = n.width),
                          (a[s].height = n.height);
                    }
                  else
                    (o.image.width = n.width),
                      (o.image.height = n.height),
                      (o.mipmaps = n.mipmaps);
                  1 === n.mipmapCount && (o.minFilter = bt),
                    (o.format = n.format),
                    (o.needsUpdate = !0),
                    e && e(o);
                },
                n,
                i
              );
            return o;
          },
          setPath: function (t) {
            return (this.path = t), this;
          },
        }),
        Object.assign(Uc.prototype, {
          load: function (t, e, n, i) {
            var r = this,
              a = new Ye(),
              o = new Bc(this.manager);
            return (
              o.setResponseType("arraybuffer"),
              o.load(
                t,
                function (t) {
                  var n = r._parser(t);
                  n &&
                    (void 0 !== n.image
                      ? (a.image = n.image)
                      : void 0 !== n.data &&
                        ((a.image.width = n.width),
                        (a.image.height = n.height),
                        (a.image.data = n.data)),
                    (a.wrapS = void 0 !== n.wrapS ? n.wrapS : gt),
                    (a.wrapT = void 0 !== n.wrapT ? n.wrapT : gt),
                    (a.magFilter = void 0 !== n.magFilter ? n.magFilter : bt),
                    (a.minFilter = void 0 !== n.minFilter ? n.minFilter : Mt),
                    (a.anisotropy = void 0 !== n.anisotropy ? n.anisotropy : 1),
                    void 0 !== n.format && (a.format = n.format),
                    void 0 !== n.type && (a.type = n.type),
                    void 0 !== n.mipmaps && (a.mipmaps = n.mipmaps),
                    1 === n.mipmapCount && (a.minFilter = bt),
                    (a.needsUpdate = !0),
                    e && e(a, n));
                },
                n,
                i
              ),
              a
            );
          },
        }),
        Object.assign(Fc.prototype, {
          crossOrigin: "anonymous",
          load: function (t, e, n, i) {
            void 0 === t && (t = ""),
              void 0 !== this.path && (t = this.path + t),
              (t = this.manager.resolveURL(t));
            var r = this,
              a = Dc.get(t);
            if (void 0 !== a)
              return (
                r.manager.itemStart(t),
                setTimeout(function () {
                  e && e(a), r.manager.itemEnd(t);
                }, 0),
                a
              );
            var o = document.createElementNS(
              "http://www.w3.org/1999/xhtml",
              "img"
            );
            function s() {
              o.removeEventListener("load", s, !1),
                o.removeEventListener("error", c, !1),
                Dc.add(t, this),
                e && e(this),
                r.manager.itemEnd(t);
            }
            function c(e) {
              o.removeEventListener("load", s, !1),
                o.removeEventListener("error", c, !1),
                i && i(e),
                r.manager.itemEnd(t),
                r.manager.itemError(t);
            }
            return (
              o.addEventListener("load", s, !1),
              o.addEventListener("error", c, !1),
              "data:" !== t.substr(0, 5) &&
                void 0 !== this.crossOrigin &&
                (o.crossOrigin = this.crossOrigin),
              r.manager.itemStart(t),
              (o.src = t),
              o
            );
          },
          setCrossOrigin: function (t) {
            return (this.crossOrigin = t), this;
          },
          setPath: function (t) {
            return (this.path = t), this;
          },
        }),
        Object.assign(Hc.prototype, {
          crossOrigin: "anonymous",
          load: function (t, e, n, i) {
            var r = new aa(),
              a = new Fc(this.manager);
            a.setCrossOrigin(this.crossOrigin), a.setPath(this.path);
            var o = 0;
            function s(n) {
              a.load(
                t[n],
                function (t) {
                  (r.images[n] = t),
                    o++,
                    6 === o && ((r.needsUpdate = !0), e && e(r));
                },
                void 0,
                i
              );
            }
            for (var c = 0; c < t.length; ++c) s(c);
            return r;
          },
          setCrossOrigin: function (t) {
            return (this.crossOrigin = t), this;
          },
          setPath: function (t) {
            return (this.path = t), this;
          },
        }),
        Object.assign(kc.prototype, {
          crossOrigin: "anonymous",
          load: function (t, e, n, i) {
            var r = new We(),
              a = new Fc(this.manager);
            return (
              a.setCrossOrigin(this.crossOrigin),
              a.setPath(this.path),
              a.load(
                t,
                function (n) {
                  r.image = n;
                  var i =
                    t.search(/\.(jpg|jpeg)$/) > 0 ||
                    0 === t.search(/^data\:image\/jpeg/);
                  (r.format = i ? zt : Ut),
                    (r.needsUpdate = !0),
                    void 0 !== e && e(r);
                },
                n,
                i
              ),
              r
            );
          },
          setCrossOrigin: function (t) {
            return (this.crossOrigin = t), this;
          },
          setPath: function (t) {
            return (this.path = t), this;
          },
        }),
        Object.assign(Gc.prototype, {
          getPoint: function () {
            return (
              console.warn("THREE.Curve: .getPoint() not implemented."), null
            );
          },
          getPointAt: function (t, e) {
            var n = this.getUtoTmapping(t);
            return this.getPoint(n, e);
          },
          getPoints: function (t) {
            void 0 === t && (t = 5);
            for (var e = [], n = 0; n <= t; n++) e.push(this.getPoint(n / t));
            return e;
          },
          getSpacedPoints: function (t) {
            void 0 === t && (t = 5);
            for (var e = [], n = 0; n <= t; n++) e.push(this.getPointAt(n / t));
            return e;
          },
          getLength: function () {
            var t = this.getLengths();
            return t[t.length - 1];
          },
          getLengths: function (t) {
            if (
              (void 0 === t && (t = this.arcLengthDivisions),
              this.cacheArcLengths &&
                this.cacheArcLengths.length === t + 1 &&
                !this.needsUpdate)
            )
              return this.cacheArcLengths;
            this.needsUpdate = !1;
            var e,
              n,
              i = [],
              r = this.getPoint(0),
              a = 0;
            for (i.push(0), n = 1; n <= t; n++)
              (e = this.getPoint(n / t)),
                (a += e.distanceTo(r)),
                i.push(a),
                (r = e);
            return (this.cacheArcLengths = i), i;
          },
          updateArcLengths: function () {
            (this.needsUpdate = !0), this.getLengths();
          },
          getUtoTmapping: function (t, e) {
            var n,
              i = this.getLengths(),
              r = 0,
              a = i.length;
            n = e || t * i[a - 1];
            var o,
              s = 0,
              c = a - 1;
            while (s <= c)
              if (((r = Math.floor(s + (c - s) / 2)), (o = i[r] - n), o < 0))
                s = r + 1;
              else {
                if (!(o > 0)) {
                  c = r;
                  break;
                }
                c = r - 1;
              }
            if (((r = c), i[r] === n)) return r / (a - 1);
            var l = i[r],
              h = i[r + 1],
              u = h - l,
              d = (n - l) / u,
              p = (r + d) / (a - 1);
            return p;
          },
          getTangent: function (t) {
            var e = 1e-4,
              n = t - e,
              i = t + e;
            n < 0 && (n = 0), i > 1 && (i = 1);
            var r = this.getPoint(n),
              a = this.getPoint(i),
              o = a.clone().sub(r);
            return o.normalize();
          },
          getTangentAt: function (t) {
            var e = this.getUtoTmapping(t);
            return this.getTangent(e);
          },
          computeFrenetFrames: function (t, e) {
            var n,
              i,
              r,
              a = new ke(),
              o = [],
              s = [],
              c = [],
              l = new ke(),
              h = new Fe();
            for (n = 0; n <= t; n++)
              (i = n / t), (o[n] = this.getTangentAt(i)), o[n].normalize();
            (s[0] = new ke()), (c[0] = new ke());
            var u = Number.MAX_VALUE,
              d = Math.abs(o[0].x),
              p = Math.abs(o[0].y),
              f = Math.abs(o[0].z);
            for (
              d <= u && ((u = d), a.set(1, 0, 0)),
                p <= u && ((u = p), a.set(0, 1, 0)),
                f <= u && a.set(0, 0, 1),
                l.crossVectors(o[0], a).normalize(),
                s[0].crossVectors(o[0], l),
                c[0].crossVectors(o[0], s[0]),
                n = 1;
              n <= t;
              n++
            )
              (s[n] = s[n - 1].clone()),
                (c[n] = c[n - 1].clone()),
                l.crossVectors(o[n - 1], o[n]),
                l.length() > Number.EPSILON &&
                  (l.normalize(),
                  (r = Math.acos(ze.clamp(o[n - 1].dot(o[n]), -1, 1))),
                  s[n].applyMatrix4(h.makeRotationAxis(l, r))),
                c[n].crossVectors(o[n], s[n]);
            if (!0 === e)
              for (
                r = Math.acos(ze.clamp(s[0].dot(s[t]), -1, 1)),
                  r /= t,
                  o[0].dot(l.crossVectors(s[0], s[t])) > 0 && (r = -r),
                  n = 1;
                n <= t;
                n++
              )
                s[n].applyMatrix4(h.makeRotationAxis(o[n], r * n)),
                  c[n].crossVectors(o[n], s[n]);
            return { tangents: o, normals: s, binormals: c };
          },
          clone: function () {
            return new this.constructor().copy(this);
          },
          copy: function (t) {
            return (this.arcLengthDivisions = t.arcLengthDivisions), this;
          },
          toJSON: function () {
            var t = {
              metadata: {
                version: 4.5,
                type: "Curve",
                generator: "Curve.toJSON",
              },
            };
            return (
              (t.arcLengthDivisions = this.arcLengthDivisions),
              (t.type = this.type),
              t
            );
          },
          fromJSON: function (t) {
            return (this.arcLengthDivisions = t.arcLengthDivisions), this;
          },
        }),
        (Vc.prototype = Object.create(Gc.prototype)),
        (Vc.prototype.constructor = Vc),
        (Vc.prototype.isEllipseCurve = !0),
        (Vc.prototype.getPoint = function (t, e) {
          var n = e || new Ue(),
            i = 2 * Math.PI,
            r = this.aEndAngle - this.aStartAngle,
            a = Math.abs(r) < Number.EPSILON;
          while (r < 0) r += i;
          while (r > i) r -= i;
          r < Number.EPSILON && (r = a ? 0 : i),
            !0 !== this.aClockwise || a || (r === i ? (r = -i) : (r -= i));
          var o = this.aStartAngle + t * r,
            s = this.aX + this.xRadius * Math.cos(o),
            c = this.aY + this.yRadius * Math.sin(o);
          if (0 !== this.aRotation) {
            var l = Math.cos(this.aRotation),
              h = Math.sin(this.aRotation),
              u = s - this.aX,
              d = c - this.aY;
            (s = u * l - d * h + this.aX), (c = u * h + d * l + this.aY);
          }
          return n.set(s, c);
        }),
        (Vc.prototype.copy = function (t) {
          return (
            Gc.prototype.copy.call(this, t),
            (this.aX = t.aX),
            (this.aY = t.aY),
            (this.xRadius = t.xRadius),
            (this.yRadius = t.yRadius),
            (this.aStartAngle = t.aStartAngle),
            (this.aEndAngle = t.aEndAngle),
            (this.aClockwise = t.aClockwise),
            (this.aRotation = t.aRotation),
            this
          );
        }),
        (Vc.prototype.toJSON = function () {
          var t = Gc.prototype.toJSON.call(this);
          return (
            (t.aX = this.aX),
            (t.aY = this.aY),
            (t.xRadius = this.xRadius),
            (t.yRadius = this.yRadius),
            (t.aStartAngle = this.aStartAngle),
            (t.aEndAngle = this.aEndAngle),
            (t.aClockwise = this.aClockwise),
            (t.aRotation = this.aRotation),
            t
          );
        }),
        (Vc.prototype.fromJSON = function (t) {
          return (
            Gc.prototype.fromJSON.call(this, t),
            (this.aX = t.aX),
            (this.aY = t.aY),
            (this.xRadius = t.xRadius),
            (this.yRadius = t.yRadius),
            (this.aStartAngle = t.aStartAngle),
            (this.aEndAngle = t.aEndAngle),
            (this.aClockwise = t.aClockwise),
            (this.aRotation = t.aRotation),
            this
          );
        }),
        (Wc.prototype = Object.create(Vc.prototype)),
        (Wc.prototype.constructor = Wc),
        (Wc.prototype.isArcCurve = !0);
      var qc = new ke(),
        Xc = new jc(),
        Yc = new jc(),
        Jc = new jc();
      function Zc(t, e, n, i) {
        Gc.call(this),
          (this.type = "CatmullRomCurve3"),
          (this.points = t || []),
          (this.closed = e || !1),
          (this.curveType = n || "centripetal"),
          (this.tension = i || 0.5);
      }
      function Kc(t, e, n, i, r) {
        var a = 0.5 * (i - e),
          o = 0.5 * (r - n),
          s = t * t,
          c = t * s;
        return (
          (2 * n - 2 * i + a + o) * c +
          (-3 * n + 3 * i - 2 * a - o) * s +
          a * t +
          n
        );
      }
      function $c(t, e) {
        var n = 1 - t;
        return n * n * e;
      }
      function Qc(t, e) {
        return 2 * (1 - t) * t * e;
      }
      function tl(t, e) {
        return t * t * e;
      }
      function el(t, e, n, i) {
        return $c(t, e) + Qc(t, n) + tl(t, i);
      }
      function nl(t, e) {
        var n = 1 - t;
        return n * n * n * e;
      }
      function il(t, e) {
        var n = 1 - t;
        return 3 * n * n * t * e;
      }
      function rl(t, e) {
        return 3 * (1 - t) * t * t * e;
      }
      function al(t, e) {
        return t * t * t * e;
      }
      function ol(t, e, n, i, r) {
        return nl(t, e) + il(t, n) + rl(t, i) + al(t, r);
      }
      function sl(t, e, n, i) {
        Gc.call(this),
          (this.type = "CubicBezierCurve"),
          (this.v0 = t || new Ue()),
          (this.v1 = e || new Ue()),
          (this.v2 = n || new Ue()),
          (this.v3 = i || new Ue());
      }
      function cl(t, e, n, i) {
        Gc.call(this),
          (this.type = "CubicBezierCurve3"),
          (this.v0 = t || new ke()),
          (this.v1 = e || new ke()),
          (this.v2 = n || new ke()),
          (this.v3 = i || new ke());
      }
      function ll(t, e) {
        Gc.call(this),
          (this.type = "LineCurve"),
          (this.v1 = t || new Ue()),
          (this.v2 = e || new Ue());
      }
      function hl(t, e) {
        Gc.call(this),
          (this.type = "LineCurve3"),
          (this.v1 = t || new ke()),
          (this.v2 = e || new ke());
      }
      function ul(t, e, n) {
        Gc.call(this),
          (this.type = "QuadraticBezierCurve"),
          (this.v0 = t || new Ue()),
          (this.v1 = e || new Ue()),
          (this.v2 = n || new Ue());
      }
      function dl(t, e, n) {
        Gc.call(this),
          (this.type = "QuadraticBezierCurve3"),
          (this.v0 = t || new ke()),
          (this.v1 = e || new ke()),
          (this.v2 = n || new ke());
      }
      function pl(t) {
        Gc.call(this), (this.type = "SplineCurve"), (this.points = t || []);
      }
      (Zc.prototype = Object.create(Gc.prototype)),
        (Zc.prototype.constructor = Zc),
        (Zc.prototype.isCatmullRomCurve3 = !0),
        (Zc.prototype.getPoint = function (t, e) {
          var n,
            i,
            r,
            a,
            o = e || new ke(),
            s = this.points,
            c = s.length,
            l = (c - (this.closed ? 0 : 1)) * t,
            h = Math.floor(l),
            u = l - h;
          if (
            (this.closed
              ? (h += h > 0 ? 0 : (Math.floor(Math.abs(h) / c) + 1) * c)
              : 0 === u && h === c - 1 && ((h = c - 2), (u = 1)),
            this.closed || h > 0
              ? (n = s[(h - 1) % c])
              : (qc.subVectors(s[0], s[1]).add(s[0]), (n = qc)),
            (i = s[h % c]),
            (r = s[(h + 1) % c]),
            this.closed || h + 2 < c
              ? (a = s[(h + 2) % c])
              : (qc.subVectors(s[c - 1], s[c - 2]).add(s[c - 1]), (a = qc)),
            "centripetal" === this.curveType || "chordal" === this.curveType)
          ) {
            var d = "chordal" === this.curveType ? 0.5 : 0.25,
              p = Math.pow(n.distanceToSquared(i), d),
              f = Math.pow(i.distanceToSquared(r), d),
              m = Math.pow(r.distanceToSquared(a), d);
            f < 1e-4 && (f = 1),
              p < 1e-4 && (p = f),
              m < 1e-4 && (m = f),
              Xc.initNonuniformCatmullRom(n.x, i.x, r.x, a.x, p, f, m),
              Yc.initNonuniformCatmullRom(n.y, i.y, r.y, a.y, p, f, m),
              Jc.initNonuniformCatmullRom(n.z, i.z, r.z, a.z, p, f, m);
          } else
            "catmullrom" === this.curveType &&
              (Xc.initCatmullRom(n.x, i.x, r.x, a.x, this.tension),
              Yc.initCatmullRom(n.y, i.y, r.y, a.y, this.tension),
              Jc.initCatmullRom(n.z, i.z, r.z, a.z, this.tension));
          return o.set(Xc.calc(u), Yc.calc(u), Jc.calc(u)), o;
        }),
        (Zc.prototype.copy = function (t) {
          Gc.prototype.copy.call(this, t), (this.points = []);
          for (var e = 0, n = t.points.length; e < n; e++) {
            var i = t.points[e];
            this.points.push(i.clone());
          }
          return (
            (this.closed = t.closed),
            (this.curveType = t.curveType),
            (this.tension = t.tension),
            this
          );
        }),
        (Zc.prototype.toJSON = function () {
          var t = Gc.prototype.toJSON.call(this);
          t.points = [];
          for (var e = 0, n = this.points.length; e < n; e++) {
            var i = this.points[e];
            t.points.push(i.toArray());
          }
          return (
            (t.closed = this.closed),
            (t.curveType = this.curveType),
            (t.tension = this.tension),
            t
          );
        }),
        (Zc.prototype.fromJSON = function (t) {
          Gc.prototype.fromJSON.call(this, t), (this.points = []);
          for (var e = 0, n = t.points.length; e < n; e++) {
            var i = t.points[e];
            this.points.push(new ke().fromArray(i));
          }
          return (
            (this.closed = t.closed),
            (this.curveType = t.curveType),
            (this.tension = t.tension),
            this
          );
        }),
        (sl.prototype = Object.create(Gc.prototype)),
        (sl.prototype.constructor = sl),
        (sl.prototype.isCubicBezierCurve = !0),
        (sl.prototype.getPoint = function (t, e) {
          var n = e || new Ue(),
            i = this.v0,
            r = this.v1,
            a = this.v2,
            o = this.v3;
          return n.set(ol(t, i.x, r.x, a.x, o.x), ol(t, i.y, r.y, a.y, o.y)), n;
        }),
        (sl.prototype.copy = function (t) {
          return (
            Gc.prototype.copy.call(this, t),
            this.v0.copy(t.v0),
            this.v1.copy(t.v1),
            this.v2.copy(t.v2),
            this.v3.copy(t.v3),
            this
          );
        }),
        (sl.prototype.toJSON = function () {
          var t = Gc.prototype.toJSON.call(this);
          return (
            (t.v0 = this.v0.toArray()),
            (t.v1 = this.v1.toArray()),
            (t.v2 = this.v2.toArray()),
            (t.v3 = this.v3.toArray()),
            t
          );
        }),
        (sl.prototype.fromJSON = function (t) {
          return (
            Gc.prototype.fromJSON.call(this, t),
            this.v0.fromArray(t.v0),
            this.v1.fromArray(t.v1),
            this.v2.fromArray(t.v2),
            this.v3.fromArray(t.v3),
            this
          );
        }),
        (cl.prototype = Object.create(Gc.prototype)),
        (cl.prototype.constructor = cl),
        (cl.prototype.isCubicBezierCurve3 = !0),
        (cl.prototype.getPoint = function (t, e) {
          var n = e || new ke(),
            i = this.v0,
            r = this.v1,
            a = this.v2,
            o = this.v3;
          return (
            n.set(
              ol(t, i.x, r.x, a.x, o.x),
              ol(t, i.y, r.y, a.y, o.y),
              ol(t, i.z, r.z, a.z, o.z)
            ),
            n
          );
        }),
        (cl.prototype.copy = function (t) {
          return (
            Gc.prototype.copy.call(this, t),
            this.v0.copy(t.v0),
            this.v1.copy(t.v1),
            this.v2.copy(t.v2),
            this.v3.copy(t.v3),
            this
          );
        }),
        (cl.prototype.toJSON = function () {
          var t = Gc.prototype.toJSON.call(this);
          return (
            (t.v0 = this.v0.toArray()),
            (t.v1 = this.v1.toArray()),
            (t.v2 = this.v2.toArray()),
            (t.v3 = this.v3.toArray()),
            t
          );
        }),
        (cl.prototype.fromJSON = function (t) {
          return (
            Gc.prototype.fromJSON.call(this, t),
            this.v0.fromArray(t.v0),
            this.v1.fromArray(t.v1),
            this.v2.fromArray(t.v2),
            this.v3.fromArray(t.v3),
            this
          );
        }),
        (ll.prototype = Object.create(Gc.prototype)),
        (ll.prototype.constructor = ll),
        (ll.prototype.isLineCurve = !0),
        (ll.prototype.getPoint = function (t, e) {
          var n = e || new Ue();
          return (
            1 === t
              ? n.copy(this.v2)
              : (n.copy(this.v2).sub(this.v1),
                n.multiplyScalar(t).add(this.v1)),
            n
          );
        }),
        (ll.prototype.getPointAt = function (t, e) {
          return this.getPoint(t, e);
        }),
        (ll.prototype.getTangent = function () {
          var t = this.v2.clone().sub(this.v1);
          return t.normalize();
        }),
        (ll.prototype.copy = function (t) {
          return (
            Gc.prototype.copy.call(this, t),
            this.v1.copy(t.v1),
            this.v2.copy(t.v2),
            this
          );
        }),
        (ll.prototype.toJSON = function () {
          var t = Gc.prototype.toJSON.call(this);
          return (t.v1 = this.v1.toArray()), (t.v2 = this.v2.toArray()), t;
        }),
        (ll.prototype.fromJSON = function (t) {
          return (
            Gc.prototype.fromJSON.call(this, t),
            this.v1.fromArray(t.v1),
            this.v2.fromArray(t.v2),
            this
          );
        }),
        (hl.prototype = Object.create(Gc.prototype)),
        (hl.prototype.constructor = hl),
        (hl.prototype.isLineCurve3 = !0),
        (hl.prototype.getPoint = function (t, e) {
          var n = e || new ke();
          return (
            1 === t
              ? n.copy(this.v2)
              : (n.copy(this.v2).sub(this.v1),
                n.multiplyScalar(t).add(this.v1)),
            n
          );
        }),
        (hl.prototype.getPointAt = function (t, e) {
          return this.getPoint(t, e);
        }),
        (hl.prototype.copy = function (t) {
          return (
            Gc.prototype.copy.call(this, t),
            this.v1.copy(t.v1),
            this.v2.copy(t.v2),
            this
          );
        }),
        (hl.prototype.toJSON = function () {
          var t = Gc.prototype.toJSON.call(this);
          return (t.v1 = this.v1.toArray()), (t.v2 = this.v2.toArray()), t;
        }),
        (hl.prototype.fromJSON = function (t) {
          return (
            Gc.prototype.fromJSON.call(this, t),
            this.v1.fromArray(t.v1),
            this.v2.fromArray(t.v2),
            this
          );
        }),
        (ul.prototype = Object.create(Gc.prototype)),
        (ul.prototype.constructor = ul),
        (ul.prototype.isQuadraticBezierCurve = !0),
        (ul.prototype.getPoint = function (t, e) {
          var n = e || new Ue(),
            i = this.v0,
            r = this.v1,
            a = this.v2;
          return n.set(el(t, i.x, r.x, a.x), el(t, i.y, r.y, a.y)), n;
        }),
        (ul.prototype.copy = function (t) {
          return (
            Gc.prototype.copy.call(this, t),
            this.v0.copy(t.v0),
            this.v1.copy(t.v1),
            this.v2.copy(t.v2),
            this
          );
        }),
        (ul.prototype.toJSON = function () {
          var t = Gc.prototype.toJSON.call(this);
          return (
            (t.v0 = this.v0.toArray()),
            (t.v1 = this.v1.toArray()),
            (t.v2 = this.v2.toArray()),
            t
          );
        }),
        (ul.prototype.fromJSON = function (t) {
          return (
            Gc.prototype.fromJSON.call(this, t),
            this.v0.fromArray(t.v0),
            this.v1.fromArray(t.v1),
            this.v2.fromArray(t.v2),
            this
          );
        }),
        (dl.prototype = Object.create(Gc.prototype)),
        (dl.prototype.constructor = dl),
        (dl.prototype.isQuadraticBezierCurve3 = !0),
        (dl.prototype.getPoint = function (t, e) {
          var n = e || new ke(),
            i = this.v0,
            r = this.v1,
            a = this.v2;
          return (
            n.set(
              el(t, i.x, r.x, a.x),
              el(t, i.y, r.y, a.y),
              el(t, i.z, r.z, a.z)
            ),
            n
          );
        }),
        (dl.prototype.copy = function (t) {
          return (
            Gc.prototype.copy.call(this, t),
            this.v0.copy(t.v0),
            this.v1.copy(t.v1),
            this.v2.copy(t.v2),
            this
          );
        }),
        (dl.prototype.toJSON = function () {
          var t = Gc.prototype.toJSON.call(this);
          return (
            (t.v0 = this.v0.toArray()),
            (t.v1 = this.v1.toArray()),
            (t.v2 = this.v2.toArray()),
            t
          );
        }),
        (dl.prototype.fromJSON = function (t) {
          return (
            Gc.prototype.fromJSON.call(this, t),
            this.v0.fromArray(t.v0),
            this.v1.fromArray(t.v1),
            this.v2.fromArray(t.v2),
            this
          );
        }),
        (pl.prototype = Object.create(Gc.prototype)),
        (pl.prototype.constructor = pl),
        (pl.prototype.isSplineCurve = !0),
        (pl.prototype.getPoint = function (t, e) {
          var n = e || new Ue(),
            i = this.points,
            r = (i.length - 1) * t,
            a = Math.floor(r),
            o = r - a,
            s = i[0 === a ? a : a - 1],
            c = i[a],
            l = i[a > i.length - 2 ? i.length - 1 : a + 1],
            h = i[a > i.length - 3 ? i.length - 1 : a + 2];
          return n.set(Kc(o, s.x, c.x, l.x, h.x), Kc(o, s.y, c.y, l.y, h.y)), n;
        }),
        (pl.prototype.copy = function (t) {
          Gc.prototype.copy.call(this, t), (this.points = []);
          for (var e = 0, n = t.points.length; e < n; e++) {
            var i = t.points[e];
            this.points.push(i.clone());
          }
          return this;
        }),
        (pl.prototype.toJSON = function () {
          var t = Gc.prototype.toJSON.call(this);
          t.points = [];
          for (var e = 0, n = this.points.length; e < n; e++) {
            var i = this.points[e];
            t.points.push(i.toArray());
          }
          return t;
        }),
        (pl.prototype.fromJSON = function (t) {
          Gc.prototype.fromJSON.call(this, t), (this.points = []);
          for (var e = 0, n = t.points.length; e < n; e++) {
            var i = t.points[e];
            this.points.push(new Ue().fromArray(i));
          }
          return this;
        });
      var fl = Object.freeze({
        ArcCurve: Wc,
        CatmullRomCurve3: Zc,
        CubicBezierCurve: sl,
        CubicBezierCurve3: cl,
        EllipseCurve: Vc,
        LineCurve: ll,
        LineCurve3: hl,
        QuadraticBezierCurve: ul,
        QuadraticBezierCurve3: dl,
        SplineCurve: pl,
      });
      function ml() {
        Gc.call(this),
          (this.type = "CurvePath"),
          (this.curves = []),
          (this.autoClose = !1);
      }
      function gl(t) {
        ml.call(this),
          (this.type = "Path"),
          (this.currentPoint = new Ue()),
          t && this.setFromPoints(t);
      }
      function vl(t) {
        gl.call(this, t),
          (this.uuid = ze.generateUUID()),
          (this.type = "Shape"),
          (this.holes = []);
      }
      function yl(t, e) {
        gr.call(this),
          (this.type = "Light"),
          (this.color = new cr(t)),
          (this.intensity = void 0 !== e ? e : 1),
          (this.receiveShadow = void 0);
      }
      function xl(t, e, n) {
        yl.call(this, t, n),
          (this.type = "HemisphereLight"),
          (this.castShadow = void 0),
          this.position.copy(gr.DefaultUp),
          this.updateMatrix(),
          (this.groundColor = new cr(e));
      }
      function _l(t) {
        (this.camera = t),
          (this.bias = 0),
          (this.radius = 1),
          (this.mapSize = new Ue(512, 512)),
          (this.map = null),
          (this.matrix = new Fe());
      }
      function bl() {
        _l.call(this, new Io(50, 1, 0.5, 500));
      }
      function wl(t, e, n, i, r, a) {
        yl.call(this, t, e),
          (this.type = "SpotLight"),
          this.position.copy(gr.DefaultUp),
          this.updateMatrix(),
          (this.target = new gr()),
          Object.defineProperty(this, "power", {
            get: function () {
              return this.intensity * Math.PI;
            },
            set: function (t) {
              this.intensity = t / Math.PI;
            },
          }),
          (this.distance = void 0 !== n ? n : 0),
          (this.angle = void 0 !== i ? i : Math.PI / 3),
          (this.penumbra = void 0 !== r ? r : 0),
          (this.decay = void 0 !== a ? a : 1),
          (this.shadow = new bl());
      }
      function Ml(t, e, n, i) {
        yl.call(this, t, e),
          (this.type = "PointLight"),
          Object.defineProperty(this, "power", {
            get: function () {
              return 4 * this.intensity * Math.PI;
            },
            set: function (t) {
              this.intensity = t / (4 * Math.PI);
            },
          }),
          (this.distance = void 0 !== n ? n : 0),
          (this.decay = void 0 !== i ? i : 1),
          (this.shadow = new _l(new Io(90, 1, 0.5, 500)));
      }
      function Sl() {
        _l.call(this, new yr(-5, 5, 5, -5, 0.5, 500));
      }
      function El(t, e) {
        yl.call(this, t, e),
          (this.type = "DirectionalLight"),
          this.position.copy(gr.DefaultUp),
          this.updateMatrix(),
          (this.target = new gr()),
          (this.shadow = new Sl());
      }
      function Tl(t, e) {
        yl.call(this, t, e),
          (this.type = "AmbientLight"),
          (this.castShadow = void 0);
      }
      function Al(t, e, n, i) {
        yl.call(this, t, e),
          (this.type = "RectAreaLight"),
          (this.width = void 0 !== n ? n : 10),
          (this.height = void 0 !== i ? i : 10);
      }
      function Cl(t, e, n, i) {
        Fl.call(this, t, e, n, i);
      }
      function Rl(t, e, n) {
        Fl.call(this, t, e, n);
      }
      function Ll(t, e, n, i) {
        (this.parameterPositions = t),
          (this._cachedIndex = 0),
          (this.resultBuffer = void 0 !== i ? i : new e.constructor(n)),
          (this.sampleValues = e),
          (this.valueSize = n);
      }
      function Pl(t, e, n, i) {
        Ll.call(this, t, e, n, i);
      }
      function Dl(t, e, n, i) {
        Fl.call(this, t, e, n, i);
      }
      function Il(t, e, n, i) {
        Fl.call(this, t, e, n, i);
      }
      function Ol(t, e, n, i) {
        Fl.call(this, t, e, n, i);
      }
      function Nl(t, e, n, i) {
        Ll.call(this, t, e, n, i),
          (this._weightPrev = -0),
          (this._offsetPrev = -0),
          (this._weightNext = -0),
          (this._offsetNext = -0);
      }
      function Bl(t, e, n, i) {
        Ll.call(this, t, e, n, i);
      }
      function zl(t, e, n, i) {
        Ll.call(this, t, e, n, i);
      }
      (ml.prototype = Object.assign(Object.create(Gc.prototype), {
        constructor: ml,
        add: function (t) {
          this.curves.push(t);
        },
        closePath: function () {
          var t = this.curves[0].getPoint(0),
            e = this.curves[this.curves.length - 1].getPoint(1);
          t.equals(e) || this.curves.push(new ll(e, t));
        },
        getPoint: function (t) {
          var e = t * this.getLength(),
            n = this.getCurveLengths(),
            i = 0;
          while (i < n.length) {
            if (n[i] >= e) {
              var r = n[i] - e,
                a = this.curves[i],
                o = a.getLength(),
                s = 0 === o ? 0 : 1 - r / o;
              return a.getPointAt(s);
            }
            i++;
          }
          return null;
        },
        getLength: function () {
          var t = this.getCurveLengths();
          return t[t.length - 1];
        },
        updateArcLengths: function () {
          (this.needsUpdate = !0),
            (this.cacheLengths = null),
            this.getCurveLengths();
        },
        getCurveLengths: function () {
          if (
            this.cacheLengths &&
            this.cacheLengths.length === this.curves.length
          )
            return this.cacheLengths;
          for (var t = [], e = 0, n = 0, i = this.curves.length; n < i; n++)
            (e += this.curves[n].getLength()), t.push(e);
          return (this.cacheLengths = t), t;
        },
        getSpacedPoints: function (t) {
          void 0 === t && (t = 40);
          for (var e = [], n = 0; n <= t; n++) e.push(this.getPoint(n / t));
          return this.autoClose && e.push(e[0]), e;
        },
        getPoints: function (t) {
          t = t || 12;
          for (var e, n = [], i = 0, r = this.curves; i < r.length; i++)
            for (
              var a = r[i],
                o =
                  a && a.isEllipseCurve
                    ? 2 * t
                    : a && (a.isLineCurve || a.isLineCurve3)
                    ? 1
                    : a && a.isSplineCurve
                    ? t * a.points.length
                    : t,
                s = a.getPoints(o),
                c = 0;
              c < s.length;
              c++
            ) {
              var l = s[c];
              (e && e.equals(l)) || (n.push(l), (e = l));
            }
          return (
            this.autoClose &&
              n.length > 1 &&
              !n[n.length - 1].equals(n[0]) &&
              n.push(n[0]),
            n
          );
        },
        copy: function (t) {
          Gc.prototype.copy.call(this, t), (this.curves = []);
          for (var e = 0, n = t.curves.length; e < n; e++) {
            var i = t.curves[e];
            this.curves.push(i.clone());
          }
          return (this.autoClose = t.autoClose), this;
        },
        toJSON: function () {
          var t = Gc.prototype.toJSON.call(this);
          (t.autoClose = this.autoClose), (t.curves = []);
          for (var e = 0, n = this.curves.length; e < n; e++) {
            var i = this.curves[e];
            t.curves.push(i.toJSON());
          }
          return t;
        },
        fromJSON: function (t) {
          Gc.prototype.fromJSON.call(this, t),
            (this.autoClose = t.autoClose),
            (this.curves = []);
          for (var e = 0, n = t.curves.length; e < n; e++) {
            var i = t.curves[e];
            this.curves.push(new fl[i.type]().fromJSON(i));
          }
          return this;
        },
      })),
        (gl.prototype = Object.assign(Object.create(ml.prototype), {
          constructor: gl,
          setFromPoints: function (t) {
            this.moveTo(t[0].x, t[0].y);
            for (var e = 1, n = t.length; e < n; e++)
              this.lineTo(t[e].x, t[e].y);
          },
          moveTo: function (t, e) {
            this.currentPoint.set(t, e);
          },
          lineTo: function (t, e) {
            var n = new ll(this.currentPoint.clone(), new Ue(t, e));
            this.curves.push(n), this.currentPoint.set(t, e);
          },
          quadraticCurveTo: function (t, e, n, i) {
            var r = new ul(
              this.currentPoint.clone(),
              new Ue(t, e),
              new Ue(n, i)
            );
            this.curves.push(r), this.currentPoint.set(n, i);
          },
          bezierCurveTo: function (t, e, n, i, r, a) {
            var o = new sl(
              this.currentPoint.clone(),
              new Ue(t, e),
              new Ue(n, i),
              new Ue(r, a)
            );
            this.curves.push(o), this.currentPoint.set(r, a);
          },
          splineThru: function (t) {
            var e = [this.currentPoint.clone()].concat(t),
              n = new pl(e);
            this.curves.push(n), this.currentPoint.copy(t[t.length - 1]);
          },
          arc: function (t, e, n, i, r, a) {
            var o = this.currentPoint.x,
              s = this.currentPoint.y;
            this.absarc(t + o, e + s, n, i, r, a);
          },
          absarc: function (t, e, n, i, r, a) {
            this.absellipse(t, e, n, n, i, r, a);
          },
          ellipse: function (t, e, n, i, r, a, o, s) {
            var c = this.currentPoint.x,
              l = this.currentPoint.y;
            this.absellipse(t + c, e + l, n, i, r, a, o, s);
          },
          absellipse: function (t, e, n, i, r, a, o, s) {
            var c = new Vc(t, e, n, i, r, a, o, s);
            if (this.curves.length > 0) {
              var l = c.getPoint(0);
              l.equals(this.currentPoint) || this.lineTo(l.x, l.y);
            }
            this.curves.push(c);
            var h = c.getPoint(1);
            this.currentPoint.copy(h);
          },
          copy: function (t) {
            return (
              ml.prototype.copy.call(this, t),
              this.currentPoint.copy(t.currentPoint),
              this
            );
          },
          toJSON: function () {
            var t = ml.prototype.toJSON.call(this);
            return (t.currentPoint = this.currentPoint.toArray()), t;
          },
          fromJSON: function (t) {
            return (
              ml.prototype.fromJSON.call(this, t),
              this.currentPoint.fromArray(t.currentPoint),
              this
            );
          },
        })),
        (vl.prototype = Object.assign(Object.create(gl.prototype), {
          constructor: vl,
          getPointsHoles: function (t) {
            for (var e = [], n = 0, i = this.holes.length; n < i; n++)
              e[n] = this.holes[n].getPoints(t);
            return e;
          },
          extractPoints: function (t) {
            return { shape: this.getPoints(t), holes: this.getPointsHoles(t) };
          },
          copy: function (t) {
            gl.prototype.copy.call(this, t), (this.holes = []);
            for (var e = 0, n = t.holes.length; e < n; e++) {
              var i = t.holes[e];
              this.holes.push(i.clone());
            }
            return this;
          },
          toJSON: function () {
            var t = gl.prototype.toJSON.call(this);
            (t.uuid = this.uuid), (t.holes = []);
            for (var e = 0, n = this.holes.length; e < n; e++) {
              var i = this.holes[e];
              t.holes.push(i.toJSON());
            }
            return t;
          },
          fromJSON: function (t) {
            gl.prototype.fromJSON.call(this, t),
              (this.uuid = t.uuid),
              (this.holes = []);
            for (var e = 0, n = t.holes.length; e < n; e++) {
              var i = t.holes[e];
              this.holes.push(new gl().fromJSON(i));
            }
            return this;
          },
        })),
        (yl.prototype = Object.assign(Object.create(gr.prototype), {
          constructor: yl,
          isLight: !0,
          copy: function (t) {
            return (
              gr.prototype.copy.call(this, t),
              this.color.copy(t.color),
              (this.intensity = t.intensity),
              this
            );
          },
          toJSON: function (t) {
            var e = gr.prototype.toJSON.call(this, t);
            return (
              (e.object.color = this.color.getHex()),
              (e.object.intensity = this.intensity),
              void 0 !== this.groundColor &&
                (e.object.groundColor = this.groundColor.getHex()),
              void 0 !== this.distance && (e.object.distance = this.distance),
              void 0 !== this.angle && (e.object.angle = this.angle),
              void 0 !== this.decay && (e.object.decay = this.decay),
              void 0 !== this.penumbra && (e.object.penumbra = this.penumbra),
              void 0 !== this.shadow &&
                (e.object.shadow = this.shadow.toJSON()),
              e
            );
          },
        })),
        (xl.prototype = Object.assign(Object.create(yl.prototype), {
          constructor: xl,
          isHemisphereLight: !0,
          copy: function (t) {
            return (
              yl.prototype.copy.call(this, t),
              this.groundColor.copy(t.groundColor),
              this
            );
          },
        })),
        Object.assign(_l.prototype, {
          copy: function (t) {
            return (
              (this.camera = t.camera.clone()),
              (this.bias = t.bias),
              (this.radius = t.radius),
              this.mapSize.copy(t.mapSize),
              this
            );
          },
          clone: function () {
            return new this.constructor().copy(this);
          },
          toJSON: function () {
            var t = {};
            return (
              0 !== this.bias && (t.bias = this.bias),
              1 !== this.radius && (t.radius = this.radius),
              (512 === this.mapSize.x && 512 === this.mapSize.y) ||
                (t.mapSize = this.mapSize.toArray()),
              (t.camera = this.camera.toJSON(!1).object),
              delete t.camera.matrix,
              t
            );
          },
        }),
        (bl.prototype = Object.assign(Object.create(_l.prototype), {
          constructor: bl,
          isSpotLightShadow: !0,
          update: function (t) {
            var e = this.camera,
              n = 2 * ze.RAD2DEG * t.angle,
              i = this.mapSize.width / this.mapSize.height,
              r = t.distance || e.far;
            (n === e.fov && i === e.aspect && r === e.far) ||
              ((e.fov = n),
              (e.aspect = i),
              (e.far = r),
              e.updateProjectionMatrix());
          },
        })),
        (wl.prototype = Object.assign(Object.create(yl.prototype), {
          constructor: wl,
          isSpotLight: !0,
          copy: function (t) {
            return (
              yl.prototype.copy.call(this, t),
              (this.distance = t.distance),
              (this.angle = t.angle),
              (this.penumbra = t.penumbra),
              (this.decay = t.decay),
              (this.target = t.target.clone()),
              (this.shadow = t.shadow.clone()),
              this
            );
          },
        })),
        (Ml.prototype = Object.assign(Object.create(yl.prototype), {
          constructor: Ml,
          isPointLight: !0,
          copy: function (t) {
            return (
              yl.prototype.copy.call(this, t),
              (this.distance = t.distance),
              (this.decay = t.decay),
              (this.shadow = t.shadow.clone()),
              this
            );
          },
        })),
        (Sl.prototype = Object.assign(Object.create(_l.prototype), {
          constructor: Sl,
        })),
        (El.prototype = Object.assign(Object.create(yl.prototype), {
          constructor: El,
          isDirectionalLight: !0,
          copy: function (t) {
            return (
              yl.prototype.copy.call(this, t),
              (this.target = t.target.clone()),
              (this.shadow = t.shadow.clone()),
              this
            );
          },
        })),
        (Tl.prototype = Object.assign(Object.create(yl.prototype), {
          constructor: Tl,
          isAmbientLight: !0,
        })),
        (Al.prototype = Object.assign(Object.create(yl.prototype), {
          constructor: Al,
          isRectAreaLight: !0,
          copy: function (t) {
            return (
              yl.prototype.copy.call(this, t),
              (this.width = t.width),
              (this.height = t.height),
              this
            );
          },
          toJSON: function (t) {
            var e = yl.prototype.toJSON.call(this, t);
            return (
              (e.object.width = this.width), (e.object.height = this.height), e
            );
          },
        })),
        (Cl.prototype = Object.assign(Object.create(Fl.prototype), {
          constructor: Cl,
          ValueTypeName: "string",
          ValueBufferType: Array,
          DefaultInterpolation: ge,
          InterpolantFactoryMethodLinear: void 0,
          InterpolantFactoryMethodSmooth: void 0,
        })),
        (Rl.prototype = Object.assign(Object.create(Fl.prototype), {
          constructor: Rl,
          ValueTypeName: "bool",
          ValueBufferType: Array,
          DefaultInterpolation: ge,
          InterpolantFactoryMethodLinear: void 0,
          InterpolantFactoryMethodSmooth: void 0,
        })),
        Object.assign(Ll.prototype, {
          evaluate: function (t) {
            var e = this.parameterPositions,
              n = this._cachedIndex,
              i = e[n],
              r = e[n - 1];
            t: {
              e: {
                var a;
                n: {
                  i: if (!(t < i)) {
                    for (var o = n + 2; ; ) {
                      if (void 0 === i) {
                        if (t < r) break i;
                        return (
                          (n = e.length),
                          (this._cachedIndex = n),
                          this.afterEnd_(n - 1, t, r)
                        );
                      }
                      if (n === o) break;
                      if (((r = i), (i = e[++n]), t < i)) break e;
                    }
                    a = e.length;
                    break n;
                  }
                  if (t >= r) break t;
                  var s = e[1];
                  t < s && ((n = 2), (r = s));
                  for (o = n - 2; ; ) {
                    if (void 0 === r)
                      return (
                        (this._cachedIndex = 0), this.beforeStart_(0, t, i)
                      );
                    if (n === o) break;
                    if (((i = r), (r = e[--n - 1]), t >= r)) break e;
                  }
                  (a = n), (n = 0);
                }
                while (n < a) {
                  var c = (n + a) >>> 1;
                  t < e[c] ? (a = c) : (n = c + 1);
                }
                if (((i = e[n]), (r = e[n - 1]), void 0 === r))
                  return (this._cachedIndex = 0), this.beforeStart_(0, t, i);
                if (void 0 === i)
                  return (
                    (n = e.length),
                    (this._cachedIndex = n),
                    this.afterEnd_(n - 1, r, t)
                  );
              }
              (this._cachedIndex = n), this.intervalChanged_(n, r, i);
            }
            return this.interpolate_(n, r, t, i);
          },
          settings: null,
          DefaultSettings_: {},
          getSettings_: function () {
            return this.settings || this.DefaultSettings_;
          },
          copySampleValue_: function (t) {
            for (
              var e = this.resultBuffer,
                n = this.sampleValues,
                i = this.valueSize,
                r = t * i,
                a = 0;
              a !== i;
              ++a
            )
              e[a] = n[r + a];
            return e;
          },
          interpolate_: function () {
            throw new Error("call to abstract method");
          },
          intervalChanged_: function () {},
        }),
        //!\ DECLARE ALIAS AFTER assign prototype !
        Object.assign(Ll.prototype, {
          beforeStart_: Ll.prototype.copySampleValue_,
          afterEnd_: Ll.prototype.copySampleValue_,
        }),
        (Pl.prototype = Object.assign(Object.create(Ll.prototype), {
          constructor: Pl,
          interpolate_: function (t, e, n, i) {
            for (
              var r = this.resultBuffer,
                a = this.sampleValues,
                o = this.valueSize,
                s = t * o,
                c = (n - e) / (i - e),
                l = s + o;
              s !== l;
              s += 4
            )
              He.slerpFlat(r, 0, a, s - o, a, s, c);
            return r;
          },
        })),
        (Dl.prototype = Object.assign(Object.create(Fl.prototype), {
          constructor: Dl,
          ValueTypeName: "quaternion",
          DefaultInterpolation: ve,
          InterpolantFactoryMethodLinear: function (t) {
            return new Pl(this.times, this.values, this.getValueSize(), t);
          },
          InterpolantFactoryMethodSmooth: void 0,
        })),
        (Il.prototype = Object.assign(Object.create(Fl.prototype), {
          constructor: Il,
          ValueTypeName: "color",
        })),
        (Ol.prototype = Object.assign(Object.create(Fl.prototype), {
          constructor: Ol,
          ValueTypeName: "number",
        })),
        (Nl.prototype = Object.assign(Object.create(Ll.prototype), {
          constructor: Nl,
          DefaultSettings_: { endingStart: xe, endingEnd: xe },
          intervalChanged_: function (t, e, n) {
            var i = this.parameterPositions,
              r = t - 2,
              a = t + 1,
              o = i[r],
              s = i[a];
            if (void 0 === o)
              switch (this.getSettings_().endingStart) {
                case _e:
                  (r = t), (o = 2 * e - n);
                  break;
                case be:
                  (r = i.length - 2), (o = e + i[r] - i[r + 1]);
                  break;
                default:
                  (r = t), (o = n);
              }
            if (void 0 === s)
              switch (this.getSettings_().endingEnd) {
                case _e:
                  (a = t), (s = 2 * n - e);
                  break;
                case be:
                  (a = 1), (s = n + i[1] - i[0]);
                  break;
                default:
                  (a = t - 1), (s = e);
              }
            var c = 0.5 * (n - e),
              l = this.valueSize;
            (this._weightPrev = c / (e - o)),
              (this._weightNext = c / (s - n)),
              (this._offsetPrev = r * l),
              (this._offsetNext = a * l);
          },
          interpolate_: function (t, e, n, i) {
            for (
              var r = this.resultBuffer,
                a = this.sampleValues,
                o = this.valueSize,
                s = t * o,
                c = s - o,
                l = this._offsetPrev,
                h = this._offsetNext,
                u = this._weightPrev,
                d = this._weightNext,
                p = (n - e) / (i - e),
                f = p * p,
                m = f * p,
                g = -u * m + 2 * u * f - u * p,
                v = (1 + u) * m + (-1.5 - 2 * u) * f + (-0.5 + u) * p + 1,
                y = (-1 - d) * m + (1.5 + d) * f + 0.5 * p,
                x = d * m - d * f,
                _ = 0;
              _ !== o;
              ++_
            )
              r[_] = g * a[l + _] + v * a[c + _] + y * a[s + _] + x * a[h + _];
            return r;
          },
        })),
        (Bl.prototype = Object.assign(Object.create(Ll.prototype), {
          constructor: Bl,
          interpolate_: function (t, e, n, i) {
            for (
              var r = this.resultBuffer,
                a = this.sampleValues,
                o = this.valueSize,
                s = t * o,
                c = s - o,
                l = (n - e) / (i - e),
                h = 1 - l,
                u = 0;
              u !== o;
              ++u
            )
              r[u] = a[c + u] * h + a[s + u] * l;
            return r;
          },
        })),
        (zl.prototype = Object.assign(Object.create(Ll.prototype), {
          constructor: zl,
          interpolate_: function (t) {
            return this.copySampleValue_(t - 1);
          },
        }));
      var Ul = {
        arraySlice: function (t, e, n) {
          return Ul.isTypedArray(t)
            ? new t.constructor(t.subarray(e, void 0 !== n ? n : t.length))
            : t.slice(e, n);
        },
        convertArray: function (t, e, n) {
          return !t || (!n && t.constructor === e)
            ? t
            : "number" === typeof e.BYTES_PER_ELEMENT
            ? new e(t)
            : Array.prototype.slice.call(t);
        },
        isTypedArray: function (t) {
          return ArrayBuffer.isView(t) && !(t instanceof DataView);
        },
        getKeyframeOrder: function (t) {
          function e(e, n) {
            return t[e] - t[n];
          }
          for (var n = t.length, i = new Array(n), r = 0; r !== n; ++r)
            i[r] = r;
          return i.sort(e), i;
        },
        sortedArray: function (t, e, n) {
          for (
            var i = t.length, r = new t.constructor(i), a = 0, o = 0;
            o !== i;
            ++a
          )
            for (var s = n[a] * e, c = 0; c !== e; ++c) r[o++] = t[s + c];
          return r;
        },
        flattenJSON: function (t, e, n, i) {
          var r = 1,
            a = t[0];
          while (void 0 !== a && void 0 === a[i]) a = t[r++];
          if (void 0 !== a) {
            var o = a[i];
            if (void 0 !== o)
              if (Array.isArray(o))
                do {
                  (o = a[i]),
                    void 0 !== o && (e.push(a.time), n.push.apply(n, o)),
                    (a = t[r++]);
                } while (void 0 !== a);
              else if (void 0 !== o.toArray)
                do {
                  (o = a[i]),
                    void 0 !== o && (e.push(a.time), o.toArray(n, n.length)),
                    (a = t[r++]);
                } while (void 0 !== a);
              else
                do {
                  (o = a[i]),
                    void 0 !== o && (e.push(a.time), n.push(o)),
                    (a = t[r++]);
                } while (void 0 !== a);
          }
        },
      };
      function Fl(t, e, n, i) {
        if (void 0 === t)
          throw new Error("THREE.KeyframeTrack: track name is undefined");
        if (void 0 === e || 0 === e.length)
          throw new Error(
            "THREE.KeyframeTrack: no keyframes in track named " + t
          );
        (this.name = t),
          (this.times = Ul.convertArray(e, this.TimeBufferType)),
          (this.values = Ul.convertArray(n, this.ValueBufferType)),
          this.setInterpolation(i || this.DefaultInterpolation),
          this.validate(),
          this.optimize();
      }
      function Hl(t, e, n, i) {
        Fl.call(this, t, e, n, i);
      }
      function kl(t, e, n) {
        (this.name = t),
          (this.tracks = n),
          (this.duration = void 0 !== e ? e : -1),
          (this.uuid = ze.generateUUID()),
          this.duration < 0 && this.resetDuration(),
          this.optimize();
      }
      function Gl(t) {
        (this.manager = void 0 !== t ? t : Oc), (this.textures = {});
      }
      function Vl(t) {
        this.manager = void 0 !== t ? t : Oc;
      }
      Object.assign(Fl, {
        parse: function (t) {
          if (void 0 === t.type)
            throw new Error(
              "THREE.KeyframeTrack: track type undefined, can not parse"
            );
          var e = Fl._getTrackTypeForValueTypeName(t.type);
          if (void 0 === t.times) {
            var n = [],
              i = [];
            Ul.flattenJSON(t.keys, n, i, "value"),
              (t.times = n),
              (t.values = i);
          }
          return void 0 !== e.parse
            ? e.parse(t)
            : new e(t.name, t.times, t.values, t.interpolation);
        },
        toJSON: function (t) {
          var e,
            n = t.constructor;
          if (void 0 !== n.toJSON) e = n.toJSON(t);
          else {
            e = {
              name: t.name,
              times: Ul.convertArray(t.times, Array),
              values: Ul.convertArray(t.values, Array),
            };
            var i = t.getInterpolation();
            i !== t.DefaultInterpolation && (e.interpolation = i);
          }
          return (e.type = t.ValueTypeName), e;
        },
        _getTrackTypeForValueTypeName: function (t) {
          switch (t.toLowerCase()) {
            case "scalar":
            case "double":
            case "float":
            case "number":
            case "integer":
              return Ol;
            case "vector":
            case "vector2":
            case "vector3":
            case "vector4":
              return Hl;
            case "color":
              return Il;
            case "quaternion":
              return Dl;
            case "bool":
            case "boolean":
              return Rl;
            case "string":
              return Cl;
          }
          throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + t);
        },
      }),
        Object.assign(Fl.prototype, {
          constructor: Fl,
          TimeBufferType: Float32Array,
          ValueBufferType: Float32Array,
          DefaultInterpolation: ve,
          InterpolantFactoryMethodDiscrete: function (t) {
            return new zl(this.times, this.values, this.getValueSize(), t);
          },
          InterpolantFactoryMethodLinear: function (t) {
            return new Bl(this.times, this.values, this.getValueSize(), t);
          },
          InterpolantFactoryMethodSmooth: function (t) {
            return new Nl(this.times, this.values, this.getValueSize(), t);
          },
          setInterpolation: function (t) {
            var e;
            switch (t) {
              case ge:
                e = this.InterpolantFactoryMethodDiscrete;
                break;
              case ve:
                e = this.InterpolantFactoryMethodLinear;
                break;
              case ye:
                e = this.InterpolantFactoryMethodSmooth;
                break;
            }
            if (void 0 !== e) this.createInterpolant = e;
            else {
              var n =
                "unsupported interpolation for " +
                this.ValueTypeName +
                " keyframe track named " +
                this.name;
              if (void 0 === this.createInterpolant) {
                if (t === this.DefaultInterpolation) throw new Error(n);
                this.setInterpolation(this.DefaultInterpolation);
              }
              console.warn("THREE.KeyframeTrack:", n);
            }
          },
          getInterpolation: function () {
            switch (this.createInterpolant) {
              case this.InterpolantFactoryMethodDiscrete:
                return ge;
              case this.InterpolantFactoryMethodLinear:
                return ve;
              case this.InterpolantFactoryMethodSmooth:
                return ye;
            }
          },
          getValueSize: function () {
            return this.values.length / this.times.length;
          },
          shift: function (t) {
            if (0 !== t)
              for (var e = this.times, n = 0, i = e.length; n !== i; ++n)
                e[n] += t;
            return this;
          },
          scale: function (t) {
            if (1 !== t)
              for (var e = this.times, n = 0, i = e.length; n !== i; ++n)
                e[n] *= t;
            return this;
          },
          trim: function (t, e) {
            var n = this.times,
              i = n.length,
              r = 0,
              a = i - 1;
            while (r !== i && n[r] < t) ++r;
            while (-1 !== a && n[a] > e) --a;
            if ((++a, 0 !== r || a !== i)) {
              r >= a && ((a = Math.max(a, 1)), (r = a - 1));
              var o = this.getValueSize();
              (this.times = Ul.arraySlice(n, r, a)),
                (this.values = Ul.arraySlice(this.values, r * o, a * o));
            }
            return this;
          },
          validate: function () {
            var t = !0,
              e = this.getValueSize();
            e - Math.floor(e) !== 0 &&
              (console.error(
                "THREE.KeyframeTrack: Invalid value size in track.",
                this
              ),
              (t = !1));
            var n = this.times,
              i = this.values,
              r = n.length;
            0 === r &&
              (console.error("THREE.KeyframeTrack: Track is empty.", this),
              (t = !1));
            for (var a = null, o = 0; o !== r; o++) {
              var s = n[o];
              if ("number" === typeof s && isNaN(s)) {
                console.error(
                  "THREE.KeyframeTrack: Time is not a valid number.",
                  this,
                  o,
                  s
                ),
                  (t = !1);
                break;
              }
              if (null !== a && a > s) {
                console.error(
                  "THREE.KeyframeTrack: Out of order keys.",
                  this,
                  o,
                  s,
                  a
                ),
                  (t = !1);
                break;
              }
              a = s;
            }
            if (void 0 !== i && Ul.isTypedArray(i)) {
              o = 0;
              for (var c = i.length; o !== c; ++o) {
                var l = i[o];
                if (isNaN(l)) {
                  console.error(
                    "THREE.KeyframeTrack: Value is not a valid number.",
                    this,
                    o,
                    l
                  ),
                    (t = !1);
                  break;
                }
              }
            }
            return t;
          },
          optimize: function () {
            for (
              var t = this.times,
                e = this.values,
                n = this.getValueSize(),
                i = this.getInterpolation() === ye,
                r = 1,
                a = t.length - 1,
                o = 1;
              o < a;
              ++o
            ) {
              var s = !1,
                c = t[o],
                l = t[o + 1];
              if (c !== l && (1 !== o || c !== c[0]))
                if (i) s = !0;
                else
                  for (
                    var h = o * n, u = h - n, d = h + n, p = 0;
                    p !== n;
                    ++p
                  ) {
                    var f = e[h + p];
                    if (f !== e[u + p] || f !== e[d + p]) {
                      s = !0;
                      break;
                    }
                  }
              if (s) {
                if (o !== r) {
                  t[r] = t[o];
                  var m = o * n,
                    g = r * n;
                  for (p = 0; p !== n; ++p) e[g + p] = e[m + p];
                }
                ++r;
              }
            }
            if (a > 0) {
              t[r] = t[a];
              for (m = a * n, g = r * n, p = 0; p !== n; ++p)
                e[g + p] = e[m + p];
              ++r;
            }
            return (
              r !== t.length &&
                ((this.times = Ul.arraySlice(t, 0, r)),
                (this.values = Ul.arraySlice(e, 0, r * n))),
              this
            );
          },
        }),
        (Hl.prototype = Object.assign(Object.create(Fl.prototype), {
          constructor: Hl,
          ValueTypeName: "vector",
        })),
        Object.assign(kl, {
          parse: function (t) {
            for (
              var e = [],
                n = t.tracks,
                i = 1 / (t.fps || 1),
                r = 0,
                a = n.length;
              r !== a;
              ++r
            )
              e.push(Fl.parse(n[r]).scale(i));
            return new kl(t.name, t.duration, e);
          },
          toJSON: function (t) {
            for (
              var e = [],
                n = t.tracks,
                i = {
                  name: t.name,
                  duration: t.duration,
                  tracks: e,
                  uuid: t.uuid,
                },
                r = 0,
                a = n.length;
              r !== a;
              ++r
            )
              e.push(Fl.toJSON(n[r]));
            return i;
          },
          CreateFromMorphTargetSequence: function (t, e, n, i) {
            for (var r = e.length, a = [], o = 0; o < r; o++) {
              var s = [],
                c = [];
              s.push((o + r - 1) % r, o, (o + 1) % r), c.push(0, 1, 0);
              var l = Ul.getKeyframeOrder(s);
              (s = Ul.sortedArray(s, 1, l)),
                (c = Ul.sortedArray(c, 1, l)),
                i || 0 !== s[0] || (s.push(r), c.push(c[0])),
                a.push(
                  new Ol(
                    ".morphTargetInfluences[" + e[o].name + "]",
                    s,
                    c
                  ).scale(1 / n)
                );
            }
            return new kl(t, -1, a);
          },
          findByName: function (t, e) {
            var n = t;
            if (!Array.isArray(t)) {
              var i = t;
              n = (i.geometry && i.geometry.animations) || i.animations;
            }
            for (var r = 0; r < n.length; r++) if (n[r].name === e) return n[r];
            return null;
          },
          CreateClipsFromMorphTargetSequences: function (t, e, n) {
            for (
              var i = {}, r = /^([\w-]*?)([\d]+)$/, a = 0, o = t.length;
              a < o;
              a++
            ) {
              var s = t[a],
                c = s.name.match(r);
              if (c && c.length > 1) {
                var l = c[1],
                  h = i[l];
                h || (i[l] = h = []), h.push(s);
              }
            }
            var u = [];
            for (var l in i)
              u.push(kl.CreateFromMorphTargetSequence(l, i[l], e, n));
            return u;
          },
          parseAnimation: function (t, e) {
            if (!t)
              return (
                console.error(
                  "THREE.AnimationClip: No animation in JSONLoader data."
                ),
                null
              );
            for (
              var n = function (t, e, n, i, r) {
                  if (0 !== n.length) {
                    var a = [],
                      o = [];
                    Ul.flattenJSON(n, a, o, i),
                      0 !== a.length && r.push(new t(e, a, o));
                  }
                },
                i = [],
                r = t.name || "default",
                a = t.length || -1,
                o = t.fps || 30,
                s = t.hierarchy || [],
                c = 0;
              c < s.length;
              c++
            ) {
              var l = s[c].keys;
              if (l && 0 !== l.length)
                if (l[0].morphTargets) {
                  for (var h = {}, u = 0; u < l.length; u++)
                    if (l[u].morphTargets)
                      for (var d = 0; d < l[u].morphTargets.length; d++)
                        h[l[u].morphTargets[d]] = -1;
                  for (var p in h) {
                    var f = [],
                      m = [];
                    for (d = 0; d !== l[u].morphTargets.length; ++d) {
                      var g = l[u];
                      f.push(g.time), m.push(g.morphTarget === p ? 1 : 0);
                    }
                    i.push(new Ol(".morphTargetInfluence[" + p + "]", f, m));
                  }
                  a = h.length * (o || 1);
                } else {
                  var v = ".bones[" + e[c].name + "]";
                  n(Hl, v + ".position", l, "pos", i),
                    n(Dl, v + ".quaternion", l, "rot", i),
                    n(Hl, v + ".scale", l, "scl", i);
                }
            }
            if (0 === i.length) return null;
            var y = new kl(r, a, i);
            return y;
          },
        }),
        Object.assign(kl.prototype, {
          resetDuration: function () {
            for (
              var t = this.tracks, e = 0, n = 0, i = t.length;
              n !== i;
              ++n
            ) {
              var r = this.tracks[n];
              e = Math.max(e, r.times[r.times.length - 1]);
            }
            this.duration = e;
          },
          trim: function () {
            for (var t = 0; t < this.tracks.length; t++)
              this.tracks[t].trim(0, this.duration);
            return this;
          },
          optimize: function () {
            for (var t = 0; t < this.tracks.length; t++)
              this.tracks[t].optimize();
            return this;
          },
        }),
        Object.assign(Gl.prototype, {
          load: function (t, e, n, i) {
            var r = this,
              a = new Bc(r.manager);
            a.load(
              t,
              function (t) {
                e(r.parse(JSON.parse(t)));
              },
              n,
              i
            );
          },
          setTextures: function (t) {
            this.textures = t;
          },
          parse: function (t) {
            var e = this.textures;
            function n(t) {
              return (
                void 0 === e[t] &&
                  console.warn("THREE.MaterialLoader: Undefined texture", t),
                e[t]
              );
            }
            var i = new Pc[t.type]();
            if (
              (void 0 !== t.uuid && (i.uuid = t.uuid),
              void 0 !== t.name && (i.name = t.name),
              void 0 !== t.color && i.color.setHex(t.color),
              void 0 !== t.roughness && (i.roughness = t.roughness),
              void 0 !== t.metalness && (i.metalness = t.metalness),
              void 0 !== t.emissive && i.emissive.setHex(t.emissive),
              void 0 !== t.specular && i.specular.setHex(t.specular),
              void 0 !== t.shininess && (i.shininess = t.shininess),
              void 0 !== t.clearCoat && (i.clearCoat = t.clearCoat),
              void 0 !== t.clearCoatRoughness &&
                (i.clearCoatRoughness = t.clearCoatRoughness),
              void 0 !== t.uniforms && (i.uniforms = t.uniforms),
              void 0 !== t.vertexShader && (i.vertexShader = t.vertexShader),
              void 0 !== t.fragmentShader &&
                (i.fragmentShader = t.fragmentShader),
              void 0 !== t.vertexColors && (i.vertexColors = t.vertexColors),
              void 0 !== t.fog && (i.fog = t.fog),
              void 0 !== t.flatShading && (i.flatShading = t.flatShading),
              void 0 !== t.blending && (i.blending = t.blending),
              void 0 !== t.side && (i.side = t.side),
              void 0 !== t.opacity && (i.opacity = t.opacity),
              void 0 !== t.transparent && (i.transparent = t.transparent),
              void 0 !== t.alphaTest && (i.alphaTest = t.alphaTest),
              void 0 !== t.depthTest && (i.depthTest = t.depthTest),
              void 0 !== t.depthWrite && (i.depthWrite = t.depthWrite),
              void 0 !== t.colorWrite && (i.colorWrite = t.colorWrite),
              void 0 !== t.wireframe && (i.wireframe = t.wireframe),
              void 0 !== t.wireframeLinewidth &&
                (i.wireframeLinewidth = t.wireframeLinewidth),
              void 0 !== t.wireframeLinecap &&
                (i.wireframeLinecap = t.wireframeLinecap),
              void 0 !== t.wireframeLinejoin &&
                (i.wireframeLinejoin = t.wireframeLinejoin),
              void 0 !== t.rotation && (i.rotation = t.rotation),
              1 !== t.linewidth && (i.linewidth = t.linewidth),
              void 0 !== t.dashSize && (i.dashSize = t.dashSize),
              void 0 !== t.gapSize && (i.gapSize = t.gapSize),
              void 0 !== t.scale && (i.scale = t.scale),
              void 0 !== t.polygonOffset && (i.polygonOffset = t.polygonOffset),
              void 0 !== t.polygonOffsetFactor &&
                (i.polygonOffsetFactor = t.polygonOffsetFactor),
              void 0 !== t.polygonOffsetUnits &&
                (i.polygonOffsetUnits = t.polygonOffsetUnits),
              void 0 !== t.skinning && (i.skinning = t.skinning),
              void 0 !== t.morphTargets && (i.morphTargets = t.morphTargets),
              void 0 !== t.dithering && (i.dithering = t.dithering),
              void 0 !== t.visible && (i.visible = t.visible),
              void 0 !== t.userData && (i.userData = t.userData),
              void 0 !== t.shading && (i.flatShading = 1 === t.shading),
              void 0 !== t.size && (i.size = t.size),
              void 0 !== t.sizeAttenuation &&
                (i.sizeAttenuation = t.sizeAttenuation),
              void 0 !== t.map && (i.map = n(t.map)),
              void 0 !== t.alphaMap &&
                ((i.alphaMap = n(t.alphaMap)), (i.transparent = !0)),
              void 0 !== t.bumpMap && (i.bumpMap = n(t.bumpMap)),
              void 0 !== t.bumpScale && (i.bumpScale = t.bumpScale),
              void 0 !== t.normalMap && (i.normalMap = n(t.normalMap)),
              void 0 !== t.normalMapType && (i.normalMapType = t.normalMapType),
              void 0 !== t.normalScale)
            ) {
              var r = t.normalScale;
              !1 === Array.isArray(r) && (r = [r, r]),
                (i.normalScale = new Ue().fromArray(r));
            }
            return (
              void 0 !== t.displacementMap &&
                (i.displacementMap = n(t.displacementMap)),
              void 0 !== t.displacementScale &&
                (i.displacementScale = t.displacementScale),
              void 0 !== t.displacementBias &&
                (i.displacementBias = t.displacementBias),
              void 0 !== t.roughnessMap && (i.roughnessMap = n(t.roughnessMap)),
              void 0 !== t.metalnessMap && (i.metalnessMap = n(t.metalnessMap)),
              void 0 !== t.emissiveMap && (i.emissiveMap = n(t.emissiveMap)),
              void 0 !== t.emissiveIntensity &&
                (i.emissiveIntensity = t.emissiveIntensity),
              void 0 !== t.specularMap && (i.specularMap = n(t.specularMap)),
              void 0 !== t.envMap && (i.envMap = n(t.envMap)),
              void 0 !== t.reflectivity && (i.reflectivity = t.reflectivity),
              void 0 !== t.lightMap && (i.lightMap = n(t.lightMap)),
              void 0 !== t.lightMapIntensity &&
                (i.lightMapIntensity = t.lightMapIntensity),
              void 0 !== t.aoMap && (i.aoMap = n(t.aoMap)),
              void 0 !== t.aoMapIntensity &&
                (i.aoMapIntensity = t.aoMapIntensity),
              void 0 !== t.gradientMap && (i.gradientMap = n(t.gradientMap)),
              i
            );
          },
        }),
        Object.assign(Vl.prototype, {
          load: function (t, e, n, i) {
            var r = this,
              a = new Bc(r.manager);
            a.load(
              t,
              function (t) {
                e(r.parse(JSON.parse(t)));
              },
              n,
              i
            );
          },
          parse: function (t) {
            var e = new Nr(),
              n = t.data.index;
            if (void 0 !== n) {
              var i = new Wl[n.type](n.array);
              e.setIndex(new wr(i, 1));
            }
            var r = t.data.attributes;
            for (var a in r) {
              var o = r[a];
              i = new Wl[o.type](o.array);
              e.addAttribute(a, new wr(i, o.itemSize, o.normalized));
            }
            var s = t.data.groups || t.data.drawcalls || t.data.offsets;
            if (void 0 !== s)
              for (var c = 0, l = s.length; c !== l; ++c) {
                var h = s[c];
                e.addGroup(h.start, h.count, h.materialIndex);
              }
            var u = t.data.boundingSphere;
            if (void 0 !== u) {
              var d = new ke();
              void 0 !== u.center && d.fromArray(u.center),
                (e.boundingSphere = new Ze(d, u.radius));
            }
            return e;
          },
        });
      var Wl = {
        Int8Array: Int8Array,
        Uint8Array: Uint8Array,
        Uint8ClampedArray:
          "undefined" !== typeof Uint8ClampedArray
            ? Uint8ClampedArray
            : Uint8Array,
        Int16Array: Int16Array,
        Uint16Array: Uint16Array,
        Int32Array: Int32Array,
        Uint32Array: Uint32Array,
        Float32Array: Float32Array,
        Float64Array: Float64Array,
      };
      function jl() {}
      (jl.Handlers = {
        handlers: [],
        add: function (t, e) {
          this.handlers.push(t, e);
        },
        get: function (t) {
          for (var e = this.handlers, n = 0, i = e.length; n < i; n += 2) {
            var r = e[n],
              a = e[n + 1];
            if (r.test(t)) return a;
          }
          return null;
        },
      }),
        Object.assign(jl.prototype, {
          crossOrigin: "anonymous",
          onLoadStart: function () {},
          onLoadProgress: function () {},
          onLoadComplete: function () {},
          initMaterials: function (t, e, n) {
            for (var i = [], r = 0; r < t.length; ++r)
              i[r] = this.createMaterial(t[r], e, n);
            return i;
          },
          createMaterial: (function () {
            var t = {
                NoBlending: M,
                NormalBlending: S,
                AdditiveBlending: E,
                SubtractiveBlending: T,
                MultiplyBlending: A,
                CustomBlending: C,
              },
              e = new cr(),
              n = new kc(),
              i = new Gl();
            return function (r, a, o) {
              var s = {};
              function c(t, e, i, r, c) {
                var l,
                  h = a + t,
                  u = jl.Handlers.get(h);
                null !== u
                  ? (l = u.load(h))
                  : (n.setCrossOrigin(o), (l = n.load(h))),
                  void 0 !== e &&
                    (l.repeat.fromArray(e),
                    1 !== e[0] && (l.wrapS = mt),
                    1 !== e[1] && (l.wrapT = mt)),
                  void 0 !== i && l.offset.fromArray(i),
                  void 0 !== r &&
                    ("repeat" === r[0] && (l.wrapS = mt),
                    "mirror" === r[0] && (l.wrapS = vt),
                    "repeat" === r[1] && (l.wrapT = mt),
                    "mirror" === r[1] && (l.wrapT = vt)),
                  void 0 !== c && (l.anisotropy = c);
                var d = ze.generateUUID();
                return (s[d] = l), d;
              }
              var l = { uuid: ze.generateUUID(), type: "MeshLambertMaterial" };
              for (var h in r) {
                var u = r[h];
                switch (h) {
                  case "DbgColor":
                  case "DbgIndex":
                  case "opticalDensity":
                  case "illumination":
                    break;
                  case "DbgName":
                    l.name = u;
                    break;
                  case "blending":
                    l.blending = t[u];
                    break;
                  case "colorAmbient":
                  case "mapAmbient":
                    console.warn(
                      "THREE.Loader.createMaterial:",
                      h,
                      "is no longer supported."
                    );
                    break;
                  case "colorDiffuse":
                    l.color = e.fromArray(u).getHex();
                    break;
                  case "colorSpecular":
                    l.specular = e.fromArray(u).getHex();
                    break;
                  case "colorEmissive":
                    l.emissive = e.fromArray(u).getHex();
                    break;
                  case "specularCoef":
                    l.shininess = u;
                    break;
                  case "shading":
                    "basic" === u.toLowerCase() &&
                      (l.type = "MeshBasicMaterial"),
                      "phong" === u.toLowerCase() &&
                        (l.type = "MeshPhongMaterial"),
                      "standard" === u.toLowerCase() &&
                        (l.type = "MeshStandardMaterial");
                    break;
                  case "mapDiffuse":
                    l.map = c(
                      u,
                      r.mapDiffuseRepeat,
                      r.mapDiffuseOffset,
                      r.mapDiffuseWrap,
                      r.mapDiffuseAnisotropy
                    );
                    break;
                  case "mapDiffuseRepeat":
                  case "mapDiffuseOffset":
                  case "mapDiffuseWrap":
                  case "mapDiffuseAnisotropy":
                    break;
                  case "mapEmissive":
                    l.emissiveMap = c(
                      u,
                      r.mapEmissiveRepeat,
                      r.mapEmissiveOffset,
                      r.mapEmissiveWrap,
                      r.mapEmissiveAnisotropy
                    );
                    break;
                  case "mapEmissiveRepeat":
                  case "mapEmissiveOffset":
                  case "mapEmissiveWrap":
                  case "mapEmissiveAnisotropy":
                    break;
                  case "mapLight":
                    l.lightMap = c(
                      u,
                      r.mapLightRepeat,
                      r.mapLightOffset,
                      r.mapLightWrap,
                      r.mapLightAnisotropy
                    );
                    break;
                  case "mapLightRepeat":
                  case "mapLightOffset":
                  case "mapLightWrap":
                  case "mapLightAnisotropy":
                    break;
                  case "mapAO":
                    l.aoMap = c(
                      u,
                      r.mapAORepeat,
                      r.mapAOOffset,
                      r.mapAOWrap,
                      r.mapAOAnisotropy
                    );
                    break;
                  case "mapAORepeat":
                  case "mapAOOffset":
                  case "mapAOWrap":
                  case "mapAOAnisotropy":
                    break;
                  case "mapBump":
                    l.bumpMap = c(
                      u,
                      r.mapBumpRepeat,
                      r.mapBumpOffset,
                      r.mapBumpWrap,
                      r.mapBumpAnisotropy
                    );
                    break;
                  case "mapBumpScale":
                    l.bumpScale = u;
                    break;
                  case "mapBumpRepeat":
                  case "mapBumpOffset":
                  case "mapBumpWrap":
                  case "mapBumpAnisotropy":
                    break;
                  case "mapNormal":
                    l.normalMap = c(
                      u,
                      r.mapNormalRepeat,
                      r.mapNormalOffset,
                      r.mapNormalWrap,
                      r.mapNormalAnisotropy
                    );
                    break;
                  case "mapNormalFactor":
                    l.normalScale = u;
                    break;
                  case "mapNormalRepeat":
                  case "mapNormalOffset":
                  case "mapNormalWrap":
                  case "mapNormalAnisotropy":
                    break;
                  case "mapSpecular":
                    l.specularMap = c(
                      u,
                      r.mapSpecularRepeat,
                      r.mapSpecularOffset,
                      r.mapSpecularWrap,
                      r.mapSpecularAnisotropy
                    );
                    break;
                  case "mapSpecularRepeat":
                  case "mapSpecularOffset":
                  case "mapSpecularWrap":
                  case "mapSpecularAnisotropy":
                    break;
                  case "mapMetalness":
                    l.metalnessMap = c(
                      u,
                      r.mapMetalnessRepeat,
                      r.mapMetalnessOffset,
                      r.mapMetalnessWrap,
                      r.mapMetalnessAnisotropy
                    );
                    break;
                  case "mapMetalnessRepeat":
                  case "mapMetalnessOffset":
                  case "mapMetalnessWrap":
                  case "mapMetalnessAnisotropy":
                    break;
                  case "mapRoughness":
                    l.roughnessMap = c(
                      u,
                      r.mapRoughnessRepeat,
                      r.mapRoughnessOffset,
                      r.mapRoughnessWrap,
                      r.mapRoughnessAnisotropy
                    );
                    break;
                  case "mapRoughnessRepeat":
                  case "mapRoughnessOffset":
                  case "mapRoughnessWrap":
                  case "mapRoughnessAnisotropy":
                    break;
                  case "mapAlpha":
                    l.alphaMap = c(
                      u,
                      r.mapAlphaRepeat,
                      r.mapAlphaOffset,
                      r.mapAlphaWrap,
                      r.mapAlphaAnisotropy
                    );
                    break;
                  case "mapAlphaRepeat":
                  case "mapAlphaOffset":
                  case "mapAlphaWrap":
                  case "mapAlphaAnisotropy":
                    break;
                  case "flipSided":
                    l.side = g;
                    break;
                  case "doubleSided":
                    l.side = v;
                    break;
                  case "transparency":
                    console.warn(
                      "THREE.Loader.createMaterial: transparency has been renamed to opacity"
                    ),
                      (l.opacity = u);
                    break;
                  case "depthTest":
                  case "depthWrite":
                  case "colorWrite":
                  case "opacity":
                  case "reflectivity":
                  case "transparent":
                  case "visible":
                  case "wireframe":
                    l[h] = u;
                    break;
                  case "vertexColors":
                    !0 === u && (l.vertexColors = w),
                      "face" === u && (l.vertexColors = b);
                    break;
                  default:
                    console.error(
                      "THREE.Loader.createMaterial: Unsupported",
                      h,
                      u
                    );
                    break;
                }
              }
              return (
                "MeshBasicMaterial" === l.type && delete l.emissive,
                "MeshPhongMaterial" !== l.type && delete l.specular,
                l.opacity < 1 && (l.transparent = !0),
                i.setTextures(s),
                i.parse(l)
              );
            };
          })(),
        });
      var ql = {
        decodeText: function (t) {
          if ("undefined" !== typeof TextDecoder)
            return new TextDecoder().decode(t);
          for (var e = "", n = 0, i = t.length; n < i; n++)
            e += String.fromCharCode(t[n]);
          return decodeURIComponent(escape(e));
        },
        extractUrlBase: function (t) {
          var e = t.lastIndexOf("/");
          return -1 === e ? "./" : t.substr(0, e + 1);
        },
      };
      function Xl(t) {
        "boolean" === typeof t &&
          (console.warn(
            "THREE.JSONLoader: showStatus parameter has been removed from constructor."
          ),
          (t = void 0)),
          (this.manager = void 0 !== t ? t : Oc),
          (this.withCredentials = !1);
      }
      function Yl(t) {
        (this.manager = void 0 !== t ? t : Oc), (this.texturePath = "");
      }
      Object.assign(Xl.prototype, {
        crossOrigin: "anonymous",
        load: function (t, e, n, i) {
          var r = this,
            a =
              this.texturePath && "string" === typeof this.texturePath
                ? this.texturePath
                : ql.extractUrlBase(t),
            o = new Bc(this.manager);
          o.setWithCredentials(this.withCredentials),
            o.load(
              t,
              function (n) {
                var i = JSON.parse(n),
                  o = i.metadata;
                if (void 0 !== o) {
                  var s = o.type;
                  if (void 0 !== s && "object" === s.toLowerCase())
                    return void console.error(
                      "THREE.JSONLoader: " +
                        t +
                        " should be loaded with THREE.ObjectLoader instead."
                    );
                }
                var c = r.parse(i, a);
                e(c.geometry, c.materials);
              },
              n,
              i
            );
        },
        setCrossOrigin: function (t) {
          return (this.crossOrigin = t), this;
        },
        setTexturePath: function (t) {
          return (this.texturePath = t), this;
        },
        parse: (function () {
          function t(t, e) {
            function n(t, e) {
              return t & (1 << e);
            }
            var i,
              r,
              a,
              o,
              s,
              c,
              l,
              h,
              u,
              d,
              p,
              f,
              m,
              g,
              v,
              y,
              x,
              _,
              b,
              w,
              M,
              S,
              E,
              T,
              A,
              C,
              R,
              L = t.faces,
              P = t.vertices,
              D = t.normals,
              I = t.colors,
              O = t.scale,
              N = 0;
            if (void 0 !== t.uvs) {
              for (i = 0; i < t.uvs.length; i++) t.uvs[i].length && N++;
              for (i = 0; i < N; i++) e.faceVertexUvs[i] = [];
            }
            (o = 0), (s = P.length);
            while (o < s)
              (_ = new ke()),
                (_.x = P[o++] * O),
                (_.y = P[o++] * O),
                (_.z = P[o++] * O),
                e.vertices.push(_);
            (o = 0), (s = L.length);
            while (o < s)
              if (
                ((d = L[o++]),
                (p = n(d, 0)),
                (f = n(d, 1)),
                (m = n(d, 3)),
                (g = n(d, 4)),
                (v = n(d, 5)),
                (y = n(d, 6)),
                (x = n(d, 7)),
                p)
              ) {
                if (
                  ((w = new xr()),
                  (w.a = L[o]),
                  (w.b = L[o + 1]),
                  (w.c = L[o + 3]),
                  (M = new xr()),
                  (M.a = L[o + 1]),
                  (M.b = L[o + 2]),
                  (M.c = L[o + 3]),
                  (o += 4),
                  f &&
                    ((u = L[o++]),
                    (w.materialIndex = u),
                    (M.materialIndex = u)),
                  (a = e.faces.length),
                  m)
                )
                  for (i = 0; i < N; i++)
                    for (
                      T = t.uvs[i],
                        e.faceVertexUvs[i][a] = [],
                        e.faceVertexUvs[i][a + 1] = [],
                        r = 0;
                      r < 4;
                      r++
                    )
                      (h = L[o++]),
                        (C = T[2 * h]),
                        (R = T[2 * h + 1]),
                        (A = new Ue(C, R)),
                        2 !== r && e.faceVertexUvs[i][a].push(A),
                        0 !== r && e.faceVertexUvs[i][a + 1].push(A);
                if (
                  (g &&
                    ((l = 3 * L[o++]),
                    w.normal.set(D[l++], D[l++], D[l]),
                    M.normal.copy(w.normal)),
                  v)
                )
                  for (i = 0; i < 4; i++)
                    (l = 3 * L[o++]),
                      (E = new ke(D[l++], D[l++], D[l])),
                      2 !== i && w.vertexNormals.push(E),
                      0 !== i && M.vertexNormals.push(E);
                if (
                  (y &&
                    ((c = L[o++]),
                    (S = I[c]),
                    w.color.setHex(S),
                    M.color.setHex(S)),
                  x)
                )
                  for (i = 0; i < 4; i++)
                    (c = L[o++]),
                      (S = I[c]),
                      2 !== i && w.vertexColors.push(new cr(S)),
                      0 !== i && M.vertexColors.push(new cr(S));
                e.faces.push(w), e.faces.push(M);
              } else {
                if (
                  ((b = new xr()),
                  (b.a = L[o++]),
                  (b.b = L[o++]),
                  (b.c = L[o++]),
                  f && ((u = L[o++]), (b.materialIndex = u)),
                  (a = e.faces.length),
                  m)
                )
                  for (i = 0; i < N; i++)
                    for (
                      T = t.uvs[i], e.faceVertexUvs[i][a] = [], r = 0;
                      r < 3;
                      r++
                    )
                      (h = L[o++]),
                        (C = T[2 * h]),
                        (R = T[2 * h + 1]),
                        (A = new Ue(C, R)),
                        e.faceVertexUvs[i][a].push(A);
                if (
                  (g && ((l = 3 * L[o++]), b.normal.set(D[l++], D[l++], D[l])),
                  v)
                )
                  for (i = 0; i < 3; i++)
                    (l = 3 * L[o++]),
                      (E = new ke(D[l++], D[l++], D[l])),
                      b.vertexNormals.push(E);
                if ((y && ((c = L[o++]), b.color.setHex(I[c])), x))
                  for (i = 0; i < 3; i++)
                    (c = L[o++]), b.vertexColors.push(new cr(I[c]));
                e.faces.push(b);
              }
          }
          function e(t, e) {
            var n =
              void 0 !== t.influencesPerVertex ? t.influencesPerVertex : 2;
            if (t.skinWeights)
              for (var i = 0, r = t.skinWeights.length; i < r; i += n) {
                var a = t.skinWeights[i],
                  o = n > 1 ? t.skinWeights[i + 1] : 0,
                  s = n > 2 ? t.skinWeights[i + 2] : 0,
                  c = n > 3 ? t.skinWeights[i + 3] : 0;
                e.skinWeights.push(new je(a, o, s, c));
              }
            if (t.skinIndices)
              for (i = 0, r = t.skinIndices.length; i < r; i += n) {
                var l = t.skinIndices[i],
                  h = n > 1 ? t.skinIndices[i + 1] : 0,
                  u = n > 2 ? t.skinIndices[i + 2] : 0,
                  d = n > 3 ? t.skinIndices[i + 3] : 0;
                e.skinIndices.push(new je(l, h, u, d));
              }
            (e.bones = t.bones),
              e.bones &&
                e.bones.length > 0 &&
                (e.skinWeights.length !== e.skinIndices.length ||
                  e.skinIndices.length !== e.vertices.length) &&
                console.warn(
                  "When skinning, number of vertices (" +
                    e.vertices.length +
                    "), skinIndices (" +
                    e.skinIndices.length +
                    "), and skinWeights (" +
                    e.skinWeights.length +
                    ") should match."
                );
          }
          function n(t, e) {
            var n = t.scale;
            if (void 0 !== t.morphTargets)
              for (var i = 0, r = t.morphTargets.length; i < r; i++) {
                (e.morphTargets[i] = {}),
                  (e.morphTargets[i].name = t.morphTargets[i].name),
                  (e.morphTargets[i].vertices = []);
                for (
                  var a = e.morphTargets[i].vertices,
                    o = t.morphTargets[i].vertices,
                    s = 0,
                    c = o.length;
                  s < c;
                  s += 3
                ) {
                  var l = new ke();
                  (l.x = o[s] * n),
                    (l.y = o[s + 1] * n),
                    (l.z = o[s + 2] * n),
                    a.push(l);
                }
              }
            if (void 0 !== t.morphColors && t.morphColors.length > 0) {
              console.warn(
                'THREE.JSONLoader: "morphColors" no longer supported. Using them as face colors.'
              );
              var h = e.faces,
                u = t.morphColors[0].colors;
              for (i = 0, r = h.length; i < r; i++)
                h[i].color.fromArray(u, 3 * i);
            }
          }
          function i(t, e) {
            var n = [],
              i = [];
            void 0 !== t.animation && i.push(t.animation),
              void 0 !== t.animations &&
                (t.animations.length
                  ? (i = i.concat(t.animations))
                  : i.push(t.animations));
            for (var r = 0; r < i.length; r++) {
              var a = kl.parseAnimation(i[r], e.bones);
              a && n.push(a);
            }
            if (e.morphTargets) {
              var o = kl.CreateClipsFromMorphTargetSequences(
                e.morphTargets,
                10
              );
              n = n.concat(o);
            }
            n.length > 0 && (e.animations = n);
          }
          return function (r, a) {
            void 0 !== r.data && (r = r.data),
              void 0 !== r.scale ? (r.scale = 1 / r.scale) : (r.scale = 1);
            var o = new br();
            if (
              (t(r, o),
              e(r, o),
              n(r, o),
              i(r, o),
              o.computeFaceNormals(),
              o.computeBoundingSphere(),
              void 0 === r.materials || 0 === r.materials.length)
            )
              return { geometry: o };
            var s = jl.prototype.initMaterials(
              r.materials,
              a,
              this.crossOrigin
            );
            return { geometry: o, materials: s };
          };
        })(),
      }),
        Object.assign(Yl.prototype, {
          crossOrigin: "anonymous",
          load: function (t, e, n, i) {
            "" === this.texturePath &&
              (this.texturePath = t.substring(0, t.lastIndexOf("/") + 1));
            var r = this,
              a = new Bc(r.manager);
            a.load(
              t,
              function (n) {
                var a = null;
                try {
                  a = JSON.parse(n);
                } catch (s) {
                  return (
                    void 0 !== i && i(s),
                    void console.error(
                      "THREE:ObjectLoader: Can't parse " + t + ".",
                      s.message
                    )
                  );
                }
                var o = a.metadata;
                void 0 !== o &&
                void 0 !== o.type &&
                "geometry" !== o.type.toLowerCase()
                  ? r.parse(a, e)
                  : console.error(
                      "THREE.ObjectLoader: Can't load " +
                        t +
                        ". Use THREE.JSONLoader instead."
                    );
              },
              n,
              i
            );
          },
          setTexturePath: function (t) {
            return (this.texturePath = t), this;
          },
          setCrossOrigin: function (t) {
            return (this.crossOrigin = t), this;
          },
          parse: function (t, e) {
            var n = this.parseShape(t.shapes),
              i = this.parseGeometries(t.geometries, n),
              r = this.parseImages(t.images, function () {
                void 0 !== e && e(s);
              }),
              a = this.parseTextures(t.textures, r),
              o = this.parseMaterials(t.materials, a),
              s = this.parseObject(t.object, i, o);
            return (
              t.animations &&
                (s.animations = this.parseAnimations(t.animations)),
              (void 0 !== t.images && 0 !== t.images.length) ||
                (void 0 !== e && e(s)),
              s
            );
          },
          parseShape: function (t) {
            var e = {};
            if (void 0 !== t)
              for (var n = 0, i = t.length; n < i; n++) {
                var r = new vl().fromJSON(t[n]);
                e[r.uuid] = r;
              }
            return e;
          },
          parseGeometries: function (t, e) {
            var n = {};
            if (void 0 !== t)
              for (
                var i = new Xl(), r = new Vl(), a = 0, o = t.length;
                a < o;
                a++
              ) {
                var s,
                  c = t[a];
                switch (c.type) {
                  case "PlaneGeometry":
                  case "PlaneBufferGeometry":
                    s = new bc[c.type](
                      c.width,
                      c.height,
                      c.widthSegments,
                      c.heightSegments
                    );
                    break;
                  case "BoxGeometry":
                  case "BoxBufferGeometry":
                  case "CubeGeometry":
                    s = new bc[c.type](
                      c.width,
                      c.height,
                      c.depth,
                      c.widthSegments,
                      c.heightSegments,
                      c.depthSegments
                    );
                    break;
                  case "CircleGeometry":
                  case "CircleBufferGeometry":
                    s = new bc[c.type](
                      c.radius,
                      c.segments,
                      c.thetaStart,
                      c.thetaLength
                    );
                    break;
                  case "CylinderGeometry":
                  case "CylinderBufferGeometry":
                    s = new bc[c.type](
                      c.radiusTop,
                      c.radiusBottom,
                      c.height,
                      c.radialSegments,
                      c.heightSegments,
                      c.openEnded,
                      c.thetaStart,
                      c.thetaLength
                    );
                    break;
                  case "ConeGeometry":
                  case "ConeBufferGeometry":
                    s = new bc[c.type](
                      c.radius,
                      c.height,
                      c.radialSegments,
                      c.heightSegments,
                      c.openEnded,
                      c.thetaStart,
                      c.thetaLength
                    );
                    break;
                  case "SphereGeometry":
                  case "SphereBufferGeometry":
                    s = new bc[c.type](
                      c.radius,
                      c.widthSegments,
                      c.heightSegments,
                      c.phiStart,
                      c.phiLength,
                      c.thetaStart,
                      c.thetaLength
                    );
                    break;
                  case "DodecahedronGeometry":
                  case "DodecahedronBufferGeometry":
                  case "IcosahedronGeometry":
                  case "IcosahedronBufferGeometry":
                  case "OctahedronGeometry":
                  case "OctahedronBufferGeometry":
                  case "TetrahedronGeometry":
                  case "TetrahedronBufferGeometry":
                    s = new bc[c.type](c.radius, c.detail);
                    break;
                  case "RingGeometry":
                  case "RingBufferGeometry":
                    s = new bc[c.type](
                      c.innerRadius,
                      c.outerRadius,
                      c.thetaSegments,
                      c.phiSegments,
                      c.thetaStart,
                      c.thetaLength
                    );
                    break;
                  case "TorusGeometry":
                  case "TorusBufferGeometry":
                    s = new bc[c.type](
                      c.radius,
                      c.tube,
                      c.radialSegments,
                      c.tubularSegments,
                      c.arc
                    );
                    break;
                  case "TorusKnotGeometry":
                  case "TorusKnotBufferGeometry":
                    s = new bc[c.type](
                      c.radius,
                      c.tube,
                      c.tubularSegments,
                      c.radialSegments,
                      c.p,
                      c.q
                    );
                    break;
                  case "LatheGeometry":
                  case "LatheBufferGeometry":
                    s = new bc[c.type](
                      c.points,
                      c.segments,
                      c.phiStart,
                      c.phiLength
                    );
                    break;
                  case "PolyhedronGeometry":
                  case "PolyhedronBufferGeometry":
                    s = new bc[c.type](
                      c.vertices,
                      c.indices,
                      c.radius,
                      c.details
                    );
                    break;
                  case "ShapeGeometry":
                  case "ShapeBufferGeometry":
                    for (var l = [], h = 0, u = c.shapes.length; h < u; h++) {
                      var d = e[c.shapes[h]];
                      l.push(d);
                    }
                    s = new bc[c.type](l, c.curveSegments);
                    break;
                  case "ExtrudeGeometry":
                  case "ExtrudeBufferGeometry":
                    for (l = [], h = 0, u = c.shapes.length; h < u; h++) {
                      d = e[c.shapes[h]];
                      l.push(d);
                    }
                    var p = c.options.extrudePath;
                    void 0 !== p &&
                      (c.options.extrudePath = new fl[p.type]().fromJSON(p)),
                      (s = new bc[c.type](l, c.options));
                    break;
                  case "BufferGeometry":
                    s = r.parse(c);
                    break;
                  case "Geometry":
                    s = i.parse(c, this.texturePath).geometry;
                    break;
                  default:
                    console.warn(
                      'THREE.ObjectLoader: Unsupported geometry type "' +
                        c.type +
                        '"'
                    );
                    continue;
                }
                (s.uuid = c.uuid),
                  void 0 !== c.name && (s.name = c.name),
                  !0 === s.isBufferGeometry &&
                    void 0 !== c.userData &&
                    (s.userData = c.userData),
                  (n[c.uuid] = s);
              }
            return n;
          },
          parseMaterials: function (t, e) {
            var n = {};
            if (void 0 !== t) {
              var i = new Gl();
              i.setTextures(e);
              for (var r = 0, a = t.length; r < a; r++) {
                var o = t[r];
                if ("MultiMaterial" === o.type) {
                  for (var s = [], c = 0; c < o.materials.length; c++)
                    s.push(i.parse(o.materials[c]));
                  n[o.uuid] = s;
                } else n[o.uuid] = i.parse(o);
              }
            }
            return n;
          },
          parseAnimations: function (t) {
            for (var e = [], n = 0; n < t.length; n++) {
              var i = t[n],
                r = kl.parse(i);
              void 0 !== i.uuid && (r.uuid = i.uuid), e.push(r);
            }
            return e;
          },
          parseImages: function (t, e) {
            var n = this,
              i = {};
            function r(t) {
              return (
                n.manager.itemStart(t),
                o.load(
                  t,
                  function () {
                    n.manager.itemEnd(t);
                  },
                  void 0,
                  function () {
                    n.manager.itemEnd(t), n.manager.itemError(t);
                  }
                )
              );
            }
            if (void 0 !== t && t.length > 0) {
              var a = new Ic(e),
                o = new Fc(a);
              o.setCrossOrigin(this.crossOrigin);
              for (var s = 0, c = t.length; s < c; s++) {
                var l = t[s],
                  h = l.url;
                if (Array.isArray(h)) {
                  i[l.uuid] = [];
                  for (var u = 0, d = h.length; u < d; u++) {
                    var p = h[u],
                      f = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(p)
                        ? p
                        : n.texturePath + p;
                    i[l.uuid].push(r(f));
                  }
                } else {
                  f = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(l.url)
                    ? l.url
                    : n.texturePath + l.url;
                  i[l.uuid] = r(f);
                }
              }
            }
            return i;
          },
          parseTextures: function (t, e) {
            function n(t, e) {
              return "number" === typeof t
                ? t
                : (console.warn(
                    "THREE.ObjectLoader.parseTexture: Constant should be in numeric form.",
                    t
                  ),
                  e[t]);
            }
            var i = {};
            if (void 0 !== t)
              for (var r = 0, a = t.length; r < a; r++) {
                var o,
                  s = t[r];
                void 0 === s.image &&
                  console.warn(
                    'THREE.ObjectLoader: No "image" specified for',
                    s.uuid
                  ),
                  void 0 === e[s.image] &&
                    console.warn(
                      "THREE.ObjectLoader: Undefined image",
                      s.image
                    ),
                  (o = Array.isArray(e[s.image])
                    ? new aa(e[s.image])
                    : new We(e[s.image])),
                  (o.needsUpdate = !0),
                  (o.uuid = s.uuid),
                  void 0 !== s.name && (o.name = s.name),
                  void 0 !== s.mapping && (o.mapping = n(s.mapping, Zl)),
                  void 0 !== s.offset && o.offset.fromArray(s.offset),
                  void 0 !== s.repeat && o.repeat.fromArray(s.repeat),
                  void 0 !== s.center && o.center.fromArray(s.center),
                  void 0 !== s.rotation && (o.rotation = s.rotation),
                  void 0 !== s.wrap &&
                    ((o.wrapS = n(s.wrap[0], Kl)),
                    (o.wrapT = n(s.wrap[1], Kl))),
                  void 0 !== s.format && (o.format = s.format),
                  void 0 !== s.minFilter && (o.minFilter = n(s.minFilter, $l)),
                  void 0 !== s.magFilter && (o.magFilter = n(s.magFilter, $l)),
                  void 0 !== s.anisotropy && (o.anisotropy = s.anisotropy),
                  void 0 !== s.flipY && (o.flipY = s.flipY),
                  (i[s.uuid] = o);
              }
            return i;
          },
          parseObject: function (t, e, n) {
            var i;
            function r(t) {
              return (
                void 0 === e[t] &&
                  console.warn("THREE.ObjectLoader: Undefined geometry", t),
                e[t]
              );
            }
            function a(t) {
              if (void 0 !== t) {
                if (Array.isArray(t)) {
                  for (var e = [], i = 0, r = t.length; i < r; i++) {
                    var a = t[i];
                    void 0 === n[a] &&
                      console.warn("THREE.ObjectLoader: Undefined material", a),
                      e.push(n[a]);
                  }
                  return e;
                }
                return (
                  void 0 === n[t] &&
                    console.warn("THREE.ObjectLoader: Undefined material", t),
                  n[t]
                );
              }
            }
            switch (t.type) {
              case "Scene":
                (i = new Ho()),
                  void 0 !== t.background &&
                    Number.isInteger(t.background) &&
                    (i.background = new cr(t.background)),
                  void 0 !== t.fog &&
                    ("Fog" === t.fog.type
                      ? (i.fog = new Fo(t.fog.color, t.fog.near, t.fog.far))
                      : "FogExp2" === t.fog.type &&
                        (i.fog = new Uo(t.fog.color, t.fog.density)));
                break;
              case "PerspectiveCamera":
                (i = new Io(t.fov, t.aspect, t.near, t.far)),
                  void 0 !== t.focus && (i.focus = t.focus),
                  void 0 !== t.zoom && (i.zoom = t.zoom),
                  void 0 !== t.filmGauge && (i.filmGauge = t.filmGauge),
                  void 0 !== t.filmOffset && (i.filmOffset = t.filmOffset),
                  void 0 !== t.view && (i.view = Object.assign({}, t.view));
                break;
              case "OrthographicCamera":
                (i = new yr(t.left, t.right, t.top, t.bottom, t.near, t.far)),
                  void 0 !== t.zoom && (i.zoom = t.zoom),
                  void 0 !== t.view && (i.view = Object.assign({}, t.view));
                break;
              case "AmbientLight":
                i = new Tl(t.color, t.intensity);
                break;
              case "DirectionalLight":
                i = new El(t.color, t.intensity);
                break;
              case "PointLight":
                i = new Ml(t.color, t.intensity, t.distance, t.decay);
                break;
              case "RectAreaLight":
                i = new Al(t.color, t.intensity, t.width, t.height);
                break;
              case "SpotLight":
                i = new wl(
                  t.color,
                  t.intensity,
                  t.distance,
                  t.angle,
                  t.penumbra,
                  t.decay
                );
                break;
              case "HemisphereLight":
                i = new xl(t.color, t.groundColor, t.intensity);
                break;
              case "SkinnedMesh":
                console.warn(
                  "THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet."
                );
              case "Mesh":
                var o = r(t.geometry),
                  s = a(t.material);
                i = o.bones && o.bones.length > 0 ? new qo(o, s) : new Xr(o, s);
                break;
              case "LOD":
                i = new Vo();
                break;
              case "Line":
                i = new Yo(r(t.geometry), a(t.material), t.mode);
                break;
              case "LineLoop":
                i = new Zo(r(t.geometry), a(t.material));
                break;
              case "LineSegments":
                i = new Jo(r(t.geometry), a(t.material));
                break;
              case "PointCloud":
              case "Points":
                i = new $o(r(t.geometry), a(t.material));
                break;
              case "Sprite":
                i = new Go(a(t.material));
                break;
              case "Group":
                i = new Do();
                break;
              default:
                i = new gr();
            }
            if (
              ((i.uuid = t.uuid),
              void 0 !== t.name && (i.name = t.name),
              void 0 !== t.matrix
                ? (i.matrix.fromArray(t.matrix),
                  void 0 !== t.matrixAutoUpdate &&
                    (i.matrixAutoUpdate = t.matrixAutoUpdate),
                  i.matrixAutoUpdate &&
                    i.matrix.decompose(i.position, i.quaternion, i.scale))
                : (void 0 !== t.position && i.position.fromArray(t.position),
                  void 0 !== t.rotation && i.rotation.fromArray(t.rotation),
                  void 0 !== t.quaternion &&
                    i.quaternion.fromArray(t.quaternion),
                  void 0 !== t.scale && i.scale.fromArray(t.scale)),
              void 0 !== t.castShadow && (i.castShadow = t.castShadow),
              void 0 !== t.receiveShadow && (i.receiveShadow = t.receiveShadow),
              t.shadow &&
                (void 0 !== t.shadow.bias && (i.shadow.bias = t.shadow.bias),
                void 0 !== t.shadow.radius &&
                  (i.shadow.radius = t.shadow.radius),
                void 0 !== t.shadow.mapSize &&
                  i.shadow.mapSize.fromArray(t.shadow.mapSize),
                void 0 !== t.shadow.camera &&
                  (i.shadow.camera = this.parseObject(t.shadow.camera))),
              void 0 !== t.visible && (i.visible = t.visible),
              void 0 !== t.frustumCulled && (i.frustumCulled = t.frustumCulled),
              void 0 !== t.renderOrder && (i.renderOrder = t.renderOrder),
              void 0 !== t.userData && (i.userData = t.userData),
              void 0 !== t.layers && (i.layers.mask = t.layers),
              void 0 !== t.children)
            )
              for (var c = t.children, l = 0; l < c.length; l++)
                i.add(this.parseObject(c[l], e, n));
            if ("LOD" === t.type)
              for (var h = t.levels, u = 0; u < h.length; u++) {
                var d = h[u],
                  p = i.getObjectByProperty("uuid", d.object);
                void 0 !== p && i.addLevel(p, d.distance);
              }
            return i;
          },
        });
      var Jl,
        Zl = {
          UVMapping: st,
          CubeReflectionMapping: ct,
          CubeRefractionMapping: lt,
          EquirectangularReflectionMapping: ht,
          EquirectangularRefractionMapping: ut,
          SphericalReflectionMapping: dt,
          CubeUVReflectionMapping: pt,
          CubeUVRefractionMapping: ft,
        },
        Kl = {
          RepeatWrapping: mt,
          ClampToEdgeWrapping: gt,
          MirroredRepeatWrapping: vt,
        },
        $l = {
          NearestFilter: yt,
          NearestMipMapNearestFilter: xt,
          NearestMipMapLinearFilter: _t,
          LinearFilter: bt,
          LinearMipMapNearestFilter: wt,
          LinearMipMapLinearFilter: Mt,
        };
      function Ql(t) {
        "undefined" === typeof createImageBitmap &&
          console.warn(
            "THREE.ImageBitmapLoader: createImageBitmap() not supported."
          ),
          "undefined" === typeof fetch &&
            console.warn("THREE.ImageBitmapLoader: fetch() not supported."),
          (this.manager = void 0 !== t ? t : Oc),
          (this.options = void 0);
      }
      function th() {
        (this.type = "ShapePath"),
          (this.color = new cr()),
          (this.subPaths = []),
          (this.currentPath = null);
      }
      function eh(t) {
        (this.type = "Font"), (this.data = t);
      }
      function nh(t, e, n) {
        for (
          var i = Array.from ? Array.from(t) : String(t).split(""),
            r = e / n.resolution,
            a =
              (n.boundingBox.yMax - n.boundingBox.yMin + n.underlineThickness) *
              r,
            o = [],
            s = 0,
            c = 0,
            l = 0;
          l < i.length;
          l++
        ) {
          var h = i[l];
          if ("\n" === h) (s = 0), (c -= a);
          else {
            var u = ih(h, r, s, c, n);
            (s += u.offsetX), o.push(u.path);
          }
        }
        return o;
      }
      function ih(t, e, n, i, r) {
        var a = r.glyphs[t] || r.glyphs["?"];
        if (a) {
          var o,
            s,
            c,
            l,
            h,
            u,
            d,
            p,
            f = new th();
          if (a.o)
            for (
              var m = a._cachedOutline || (a._cachedOutline = a.o.split(" ")),
                g = 0,
                v = m.length;
              g < v;

            ) {
              var y = m[g++];
              switch (y) {
                case "m":
                  (o = m[g++] * e + n), (s = m[g++] * e + i), f.moveTo(o, s);
                  break;
                case "l":
                  (o = m[g++] * e + n), (s = m[g++] * e + i), f.lineTo(o, s);
                  break;
                case "q":
                  (c = m[g++] * e + n),
                    (l = m[g++] * e + i),
                    (h = m[g++] * e + n),
                    (u = m[g++] * e + i),
                    f.quadraticCurveTo(h, u, c, l);
                  break;
                case "b":
                  (c = m[g++] * e + n),
                    (l = m[g++] * e + i),
                    (h = m[g++] * e + n),
                    (u = m[g++] * e + i),
                    (d = m[g++] * e + n),
                    (p = m[g++] * e + i),
                    f.bezierCurveTo(h, u, d, p, c, l);
                  break;
              }
            }
          return { offsetX: a.ha * e, path: f };
        }
      }
      function rh(t) {
        this.manager = void 0 !== t ? t : Oc;
      }
      (Ql.prototype = {
        constructor: Ql,
        setOptions: function (t) {
          return (this.options = t), this;
        },
        load: function (t, e, n, i) {
          void 0 === t && (t = ""),
            void 0 !== this.path && (t = this.path + t),
            (t = this.manager.resolveURL(t));
          var r = this,
            a = Dc.get(t);
          if (void 0 !== a)
            return (
              r.manager.itemStart(t),
              setTimeout(function () {
                e && e(a), r.manager.itemEnd(t);
              }, 0),
              a
            );
          fetch(t)
            .then(function (t) {
              return t.blob();
            })
            .then(function (t) {
              return createImageBitmap(t, r.options);
            })
            .then(function (n) {
              Dc.add(t, n), e && e(n), r.manager.itemEnd(t);
            })
            .catch(function (e) {
              i && i(e), r.manager.itemEnd(t), r.manager.itemError(t);
            });
        },
        setCrossOrigin: function () {
          return this;
        },
        setPath: function (t) {
          return (this.path = t), this;
        },
      }),
        Object.assign(th.prototype, {
          moveTo: function (t, e) {
            (this.currentPath = new gl()),
              this.subPaths.push(this.currentPath),
              this.currentPath.moveTo(t, e);
          },
          lineTo: function (t, e) {
            this.currentPath.lineTo(t, e);
          },
          quadraticCurveTo: function (t, e, n, i) {
            this.currentPath.quadraticCurveTo(t, e, n, i);
          },
          bezierCurveTo: function (t, e, n, i, r, a) {
            this.currentPath.bezierCurveTo(t, e, n, i, r, a);
          },
          splineThru: function (t) {
            this.currentPath.splineThru(t);
          },
          toShapes: function (t, e) {
            function n(t) {
              for (var e = [], n = 0, i = t.length; n < i; n++) {
                var r = t[n],
                  a = new vl();
                (a.curves = r.curves), e.push(a);
              }
              return e;
            }
            function i(t, e) {
              for (var n = e.length, i = !1, r = n - 1, a = 0; a < n; r = a++) {
                var o = e[r],
                  s = e[a],
                  c = s.x - o.x,
                  l = s.y - o.y;
                if (Math.abs(l) > Number.EPSILON) {
                  if (
                    (l < 0 && ((o = e[a]), (c = -c), (s = e[r]), (l = -l)),
                    t.y < o.y || t.y > s.y)
                  )
                    continue;
                  if (t.y === o.y) {
                    if (t.x === o.x) return !0;
                  } else {
                    var h = l * (t.x - o.x) - c * (t.y - o.y);
                    if (0 === h) return !0;
                    if (h < 0) continue;
                    i = !i;
                  }
                } else {
                  if (t.y !== o.y) continue;
                  if ((s.x <= t.x && t.x <= o.x) || (o.x <= t.x && t.x <= s.x))
                    return !0;
                }
              }
              return i;
            }
            var r = Zs.isClockWise,
              a = this.subPaths;
            if (0 === a.length) return [];
            if (!0 === e) return n(a);
            var o,
              s,
              c,
              l = [];
            if (1 === a.length)
              return (
                (s = a[0]), (c = new vl()), (c.curves = s.curves), l.push(c), l
              );
            var h = !r(a[0].getPoints());
            h = t ? !h : h;
            var u,
              d,
              p = [],
              f = [],
              m = [],
              g = 0;
            (f[g] = void 0), (m[g] = []);
            for (var v = 0, y = a.length; v < y; v++)
              (s = a[v]),
                (u = s.getPoints()),
                (o = r(u)),
                (o = t ? !o : o),
                o
                  ? (!h && f[g] && g++,
                    (f[g] = { s: new vl(), p: u }),
                    (f[g].s.curves = s.curves),
                    h && g++,
                    (m[g] = []))
                  : m[g].push({ h: s, p: u[0] });
            if (!f[0]) return n(a);
            if (f.length > 1) {
              for (var x = !1, _ = [], b = 0, w = f.length; b < w; b++)
                p[b] = [];
              for (b = 0, w = f.length; b < w; b++)
                for (var M = m[b], S = 0; S < M.length; S++) {
                  for (var E = M[S], T = !0, A = 0; A < f.length; A++)
                    i(E.p, f[A].p) &&
                      (b !== A && _.push({ froms: b, tos: A, hole: S }),
                      T ? ((T = !1), p[A].push(E)) : (x = !0));
                  T && p[b].push(E);
                }
              _.length > 0 && (x || (m = p));
            }
            v = 0;
            for (var C = f.length; v < C; v++) {
              (c = f[v].s), l.push(c), (d = m[v]);
              for (var R = 0, L = d.length; R < L; R++) c.holes.push(d[R].h);
            }
            return l;
          },
        }),
        Object.assign(eh.prototype, {
          isFont: !0,
          generateShapes: function (t, e) {
            void 0 === e && (e = 100);
            for (
              var n = [], i = nh(t, e, this.data), r = 0, a = i.length;
              r < a;
              r++
            )
              Array.prototype.push.apply(n, i[r].toShapes());
            return n;
          },
        }),
        Object.assign(rh.prototype, {
          load: function (t, e, n, i) {
            var r = this,
              a = new Bc(this.manager);
            a.setPath(this.path),
              a.load(
                t,
                function (t) {
                  var n;
                  try {
                    n = JSON.parse(t);
                  } catch (a) {
                    console.warn(
                      "THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."
                    ),
                      (n = JSON.parse(t.substring(65, t.length - 2)));
                  }
                  var i = r.parse(n);
                  e && e(i);
                },
                n,
                i
              );
          },
          parse: function (t) {
            return new eh(t);
          },
          setPath: function (t) {
            return (this.path = t), this;
          },
        });
      var ah = {
        getContext: function () {
          return (
            void 0 === Jl &&
              (Jl = new (window.AudioContext || window.webkitAudioContext)()),
            Jl
          );
        },
        setContext: function (t) {
          Jl = t;
        },
      };
      function oh(t) {
        this.manager = void 0 !== t ? t : Oc;
      }
      function sh() {
        (this.type = "StereoCamera"),
          (this.aspect = 1),
          (this.eyeSep = 0.064),
          (this.cameraL = new Io()),
          this.cameraL.layers.enable(1),
          (this.cameraL.matrixAutoUpdate = !1),
          (this.cameraR = new Io()),
          this.cameraR.layers.enable(2),
          (this.cameraR.matrixAutoUpdate = !1);
      }
      function ch(t, e, n) {
        gr.call(this), (this.type = "CubeCamera");
        var i = 90,
          r = 1,
          a = new Io(i, r, t, e);
        a.up.set(0, -1, 0), a.lookAt(new ke(1, 0, 0)), this.add(a);
        var o = new Io(i, r, t, e);
        o.up.set(0, -1, 0), o.lookAt(new ke(-1, 0, 0)), this.add(o);
        var s = new Io(i, r, t, e);
        s.up.set(0, 0, 1), s.lookAt(new ke(0, 1, 0)), this.add(s);
        var c = new Io(i, r, t, e);
        c.up.set(0, 0, -1), c.lookAt(new ke(0, -1, 0)), this.add(c);
        var l = new Io(i, r, t, e);
        l.up.set(0, -1, 0), l.lookAt(new ke(0, 0, 1)), this.add(l);
        var h = new Io(i, r, t, e);
        h.up.set(0, -1, 0), h.lookAt(new ke(0, 0, -1)), this.add(h);
        var u = { format: zt, magFilter: bt, minFilter: bt };
        (this.renderTarget = new Xe(n, n, u)),
          (this.renderTarget.texture.name = "CubeCamera"),
          (this.update = function (t, e) {
            null === this.parent && this.updateMatrixWorld();
            var n = this.renderTarget,
              i = n.texture.generateMipmaps;
            (n.texture.generateMipmaps = !1),
              (n.activeCubeFace = 0),
              t.render(e, a, n),
              (n.activeCubeFace = 1),
              t.render(e, o, n),
              (n.activeCubeFace = 2),
              t.render(e, s, n),
              (n.activeCubeFace = 3),
              t.render(e, c, n),
              (n.activeCubeFace = 4),
              t.render(e, l, n),
              (n.texture.generateMipmaps = i),
              (n.activeCubeFace = 5),
              t.render(e, h, n),
              t.setRenderTarget(null);
          }),
          (this.clear = function (t, e, n, i) {
            for (var r = this.renderTarget, a = 0; a < 6; a++)
              (r.activeCubeFace = a), t.setRenderTarget(r), t.clear(e, n, i);
            t.setRenderTarget(null);
          });
      }
      function lh() {
        gr.call(this),
          (this.type = "AudioListener"),
          (this.context = ah.getContext()),
          (this.gain = this.context.createGain()),
          this.gain.connect(this.context.destination),
          (this.filter = null);
      }
      function hh(t) {
        gr.call(this),
          (this.type = "Audio"),
          (this.context = t.context),
          (this.gain = this.context.createGain()),
          this.gain.connect(t.getInput()),
          (this.autoplay = !1),
          (this.buffer = null),
          (this.loop = !1),
          (this.startTime = 0),
          (this.offset = 0),
          (this.playbackRate = 1),
          (this.isPlaying = !1),
          (this.hasPlaybackControl = !0),
          (this.sourceType = "empty"),
          (this.filters = []);
      }
      function uh(t) {
        hh.call(this, t),
          (this.panner = this.context.createPanner()),
          this.panner.connect(this.gain);
      }
      function dh(t, e) {
        (this.analyser = t.context.createAnalyser()),
          (this.analyser.fftSize = void 0 !== e ? e : 2048),
          (this.data = new Uint8Array(this.analyser.frequencyBinCount)),
          t.getOutput().connect(this.analyser);
      }
      function ph(t, e, n) {
        (this.binding = t), (this.valueSize = n);
        var i,
          r = Float64Array;
        switch (e) {
          case "quaternion":
            i = this._slerp;
            break;
          case "string":
          case "bool":
            (r = Array), (i = this._select);
            break;
          default:
            i = this._lerp;
        }
        (this.buffer = new r(4 * n)),
          (this._mixBufferRegion = i),
          (this.cumulativeWeight = 0),
          (this.useCount = 0),
          (this.referenceCount = 0);
      }
      Object.assign(oh.prototype, {
        load: function (t, e, n, i) {
          var r = new Bc(this.manager);
          r.setResponseType("arraybuffer"),
            r.load(
              t,
              function (t) {
                var n = t.slice(0),
                  i = ah.getContext();
                i.decodeAudioData(n, function (t) {
                  e(t);
                });
              },
              n,
              i
            );
        },
      }),
        Object.assign(sh.prototype, {
          update: (function () {
            var t,
              e,
              n,
              i,
              r,
              a,
              o,
              s,
              c = new Fe(),
              l = new Fe();
            return function (h) {
              var u =
                t !== this ||
                e !== h.focus ||
                n !== h.fov ||
                i !== h.aspect * this.aspect ||
                r !== h.near ||
                a !== h.far ||
                o !== h.zoom ||
                s !== this.eyeSep;
              if (u) {
                (t = this),
                  (e = h.focus),
                  (n = h.fov),
                  (i = h.aspect * this.aspect),
                  (r = h.near),
                  (a = h.far),
                  (o = h.zoom);
                var d = h.projectionMatrix.clone();
                s = this.eyeSep / 2;
                var p,
                  f,
                  m = (s * r) / e,
                  g = (r * Math.tan(ze.DEG2RAD * n * 0.5)) / o;
                (l.elements[12] = -s),
                  (c.elements[12] = s),
                  (p = -g * i + m),
                  (f = g * i + m),
                  (d.elements[0] = (2 * r) / (f - p)),
                  (d.elements[8] = (f + p) / (f - p)),
                  this.cameraL.projectionMatrix.copy(d),
                  (p = -g * i - m),
                  (f = g * i - m),
                  (d.elements[0] = (2 * r) / (f - p)),
                  (d.elements[8] = (f + p) / (f - p)),
                  this.cameraR.projectionMatrix.copy(d);
              }
              this.cameraL.matrixWorld.copy(h.matrixWorld).multiply(l),
                this.cameraR.matrixWorld.copy(h.matrixWorld).multiply(c);
            };
          })(),
        }),
        (ch.prototype = Object.create(gr.prototype)),
        (ch.prototype.constructor = ch),
        (lh.prototype = Object.assign(Object.create(gr.prototype), {
          constructor: lh,
          getInput: function () {
            return this.gain;
          },
          removeFilter: function () {
            return (
              null !== this.filter &&
                (this.gain.disconnect(this.filter),
                this.filter.disconnect(this.context.destination),
                this.gain.connect(this.context.destination),
                (this.filter = null)),
              this
            );
          },
          getFilter: function () {
            return this.filter;
          },
          setFilter: function (t) {
            return (
              null !== this.filter
                ? (this.gain.disconnect(this.filter),
                  this.filter.disconnect(this.context.destination))
                : this.gain.disconnect(this.context.destination),
              (this.filter = t),
              this.gain.connect(this.filter),
              this.filter.connect(this.context.destination),
              this
            );
          },
          getMasterVolume: function () {
            return this.gain.gain.value;
          },
          setMasterVolume: function (t) {
            return (
              this.gain.gain.setTargetAtTime(t, this.context.currentTime, 0.01),
              this
            );
          },
          updateMatrixWorld: (function () {
            var t = new ke(),
              e = new He(),
              n = new ke(),
              i = new ke();
            return function (r) {
              gr.prototype.updateMatrixWorld.call(this, r);
              var a = this.context.listener,
                o = this.up;
              this.matrixWorld.decompose(t, e, n),
                i.set(0, 0, -1).applyQuaternion(e),
                a.positionX
                  ? (a.positionX.setValueAtTime(t.x, this.context.currentTime),
                    a.positionY.setValueAtTime(t.y, this.context.currentTime),
                    a.positionZ.setValueAtTime(t.z, this.context.currentTime),
                    a.forwardX.setValueAtTime(i.x, this.context.currentTime),
                    a.forwardY.setValueAtTime(i.y, this.context.currentTime),
                    a.forwardZ.setValueAtTime(i.z, this.context.currentTime),
                    a.upX.setValueAtTime(o.x, this.context.currentTime),
                    a.upY.setValueAtTime(o.y, this.context.currentTime),
                    a.upZ.setValueAtTime(o.z, this.context.currentTime))
                  : (a.setPosition(t.x, t.y, t.z),
                    a.setOrientation(i.x, i.y, i.z, o.x, o.y, o.z));
            };
          })(),
        })),
        (hh.prototype = Object.assign(Object.create(gr.prototype), {
          constructor: hh,
          getOutput: function () {
            return this.gain;
          },
          setNodeSource: function (t) {
            return (
              (this.hasPlaybackControl = !1),
              (this.sourceType = "audioNode"),
              (this.source = t),
              this.connect(),
              this
            );
          },
          setMediaElementSource: function (t) {
            return (
              (this.hasPlaybackControl = !1),
              (this.sourceType = "mediaNode"),
              (this.source = this.context.createMediaElementSource(t)),
              this.connect(),
              this
            );
          },
          setBuffer: function (t) {
            return (
              (this.buffer = t),
              (this.sourceType = "buffer"),
              this.autoplay && this.play(),
              this
            );
          },
          play: function () {
            if (!0 !== this.isPlaying) {
              if (!1 !== this.hasPlaybackControl) {
                var t = this.context.createBufferSource();
                return (
                  (t.buffer = this.buffer),
                  (t.loop = this.loop),
                  (t.onended = this.onEnded.bind(this)),
                  t.playbackRate.setValueAtTime(
                    this.playbackRate,
                    this.startTime
                  ),
                  (this.startTime = this.context.currentTime),
                  t.start(this.startTime, this.offset),
                  (this.isPlaying = !0),
                  (this.source = t),
                  this.connect()
                );
              }
              console.warn("THREE.Audio: this Audio has no playback control.");
            } else console.warn("THREE.Audio: Audio is already playing.");
          },
          pause: function () {
            if (!1 !== this.hasPlaybackControl)
              return (
                !0 === this.isPlaying &&
                  (this.source.stop(),
                  (this.offset +=
                    (this.context.currentTime - this.startTime) *
                    this.playbackRate),
                  (this.isPlaying = !1)),
                this
              );
            console.warn("THREE.Audio: this Audio has no playback control.");
          },
          stop: function () {
            if (!1 !== this.hasPlaybackControl)
              return (
                this.source.stop(),
                (this.offset = 0),
                (this.isPlaying = !1),
                this
              );
            console.warn("THREE.Audio: this Audio has no playback control.");
          },
          connect: function () {
            if (this.filters.length > 0) {
              this.source.connect(this.filters[0]);
              for (var t = 1, e = this.filters.length; t < e; t++)
                this.filters[t - 1].connect(this.filters[t]);
              this.filters[this.filters.length - 1].connect(this.getOutput());
            } else this.source.connect(this.getOutput());
            return this;
          },
          disconnect: function () {
            if (this.filters.length > 0) {
              this.source.disconnect(this.filters[0]);
              for (var t = 1, e = this.filters.length; t < e; t++)
                this.filters[t - 1].disconnect(this.filters[t]);
              this.filters[this.filters.length - 1].disconnect(
                this.getOutput()
              );
            } else this.source.disconnect(this.getOutput());
            return this;
          },
          getFilters: function () {
            return this.filters;
          },
          setFilters: function (t) {
            return (
              t || (t = []),
              !0 === this.isPlaying
                ? (this.disconnect(), (this.filters = t), this.connect())
                : (this.filters = t),
              this
            );
          },
          getFilter: function () {
            return this.getFilters()[0];
          },
          setFilter: function (t) {
            return this.setFilters(t ? [t] : []);
          },
          setPlaybackRate: function (t) {
            if (!1 !== this.hasPlaybackControl)
              return (
                (this.playbackRate = t),
                !0 === this.isPlaying &&
                  this.source.playbackRate.setValueAtTime(
                    this.playbackRate,
                    this.context.currentTime
                  ),
                this
              );
            console.warn("THREE.Audio: this Audio has no playback control.");
          },
          getPlaybackRate: function () {
            return this.playbackRate;
          },
          onEnded: function () {
            this.isPlaying = !1;
          },
          getLoop: function () {
            return !1 === this.hasPlaybackControl
              ? (console.warn(
                  "THREE.Audio: this Audio has no playback control."
                ),
                !1)
              : this.loop;
          },
          setLoop: function (t) {
            if (!1 !== this.hasPlaybackControl)
              return (
                (this.loop = t),
                !0 === this.isPlaying && (this.source.loop = this.loop),
                this
              );
            console.warn("THREE.Audio: this Audio has no playback control.");
          },
          getVolume: function () {
            return this.gain.gain.value;
          },
          setVolume: function (t) {
            return (
              this.gain.gain.setTargetAtTime(t, this.context.currentTime, 0.01),
              this
            );
          },
        })),
        (uh.prototype = Object.assign(Object.create(hh.prototype), {
          constructor: uh,
          getOutput: function () {
            return this.panner;
          },
          getRefDistance: function () {
            return this.panner.refDistance;
          },
          setRefDistance: function (t) {
            return (this.panner.refDistance = t), this;
          },
          getRolloffFactor: function () {
            return this.panner.rolloffFactor;
          },
          setRolloffFactor: function (t) {
            return (this.panner.rolloffFactor = t), this;
          },
          getDistanceModel: function () {
            return this.panner.distanceModel;
          },
          setDistanceModel: function (t) {
            return (this.panner.distanceModel = t), this;
          },
          getMaxDistance: function () {
            return this.panner.maxDistance;
          },
          setMaxDistance: function (t) {
            return (this.panner.maxDistance = t), this;
          },
          setDirectionalCone: function (t, e, n) {
            return (
              (this.panner.coneInnerAngle = t),
              (this.panner.coneOuterAngle = e),
              (this.panner.coneOuterGain = n),
              this
            );
          },
          updateMatrixWorld: (function () {
            var t = new ke(),
              e = new He(),
              n = new ke(),
              i = new ke();
            return function (r) {
              gr.prototype.updateMatrixWorld.call(this, r);
              var a = this.panner;
              this.matrixWorld.decompose(t, e, n),
                i.set(0, 0, 1).applyQuaternion(e),
                a.setPosition(t.x, t.y, t.z),
                a.setOrientation(i.x, i.y, i.z);
            };
          })(),
        })),
        Object.assign(dh.prototype, {
          getFrequencyData: function () {
            return this.analyser.getByteFrequencyData(this.data), this.data;
          },
          getAverageFrequency: function () {
            for (
              var t = 0, e = this.getFrequencyData(), n = 0;
              n < e.length;
              n++
            )
              t += e[n];
            return t / e.length;
          },
        }),
        Object.assign(ph.prototype, {
          accumulate: function (t, e) {
            var n = this.buffer,
              i = this.valueSize,
              r = t * i + i,
              a = this.cumulativeWeight;
            if (0 === a) {
              for (var o = 0; o !== i; ++o) n[r + o] = n[o];
              a = e;
            } else {
              a += e;
              var s = e / a;
              this._mixBufferRegion(n, r, 0, s, i);
            }
            this.cumulativeWeight = a;
          },
          apply: function (t) {
            var e = this.valueSize,
              n = this.buffer,
              i = t * e + e,
              r = this.cumulativeWeight,
              a = this.binding;
            if (((this.cumulativeWeight = 0), r < 1)) {
              var o = 3 * e;
              this._mixBufferRegion(n, i, o, 1 - r, e);
            }
            for (var s = e, c = e + e; s !== c; ++s)
              if (n[s] !== n[s + e]) {
                a.setValue(n, i);
                break;
              }
          },
          saveOriginalState: function () {
            var t = this.binding,
              e = this.buffer,
              n = this.valueSize,
              i = 3 * n;
            t.getValue(e, i);
            for (var r = n, a = i; r !== a; ++r) e[r] = e[i + (r % n)];
            this.cumulativeWeight = 0;
          },
          restoreOriginalState: function () {
            var t = 3 * this.valueSize;
            this.binding.setValue(this.buffer, t);
          },
          _select: function (t, e, n, i, r) {
            if (i >= 0.5) for (var a = 0; a !== r; ++a) t[e + a] = t[n + a];
          },
          _slerp: function (t, e, n, i) {
            He.slerpFlat(t, e, t, e, t, n, i);
          },
          _lerp: function (t, e, n, i, r) {
            for (var a = 1 - i, o = 0; o !== r; ++o) {
              var s = e + o;
              t[s] = t[s] * a + t[n + o] * i;
            }
          },
        });
      var fh,
        mh,
        gh = "\\[\\]\\.:\\/";
      function vh(t, e, n) {
        var i = n || yh.parseTrackName(e);
        (this._targetGroup = t), (this._bindings = t.subscribe_(e, i));
      }
      function yh(t, e, n) {
        (this.path = e),
          (this.parsedPath = n || yh.parseTrackName(e)),
          (this.node = yh.findNode(t, this.parsedPath.nodeName) || t),
          (this.rootNode = t);
      }
      function xh() {
        (this.uuid = ze.generateUUID()),
          (this._objects = Array.prototype.slice.call(arguments)),
          (this.nCachedObjects_ = 0);
        var t = {};
        this._indicesByUUID = t;
        for (var e = 0, n = arguments.length; e !== n; ++e)
          t[arguments[e].uuid] = e;
        (this._paths = []),
          (this._parsedPaths = []),
          (this._bindings = []),
          (this._bindingsIndicesByPath = {});
        var i = this;
        this.stats = {
          objects: {
            get total() {
              return i._objects.length;
            },
            get inUse() {
              return this.total - i.nCachedObjects_;
            },
          },
          get bindingsPerObject() {
            return i._bindings.length;
          },
        };
      }
      function _h(t, e, n) {
        (this._mixer = t), (this._clip = e), (this._localRoot = n || null);
        for (
          var i = e.tracks,
            r = i.length,
            a = new Array(r),
            o = { endingStart: xe, endingEnd: xe },
            s = 0;
          s !== r;
          ++s
        ) {
          var c = i[s].createInterpolant(null);
          (a[s] = c), (c.settings = o);
        }
        (this._interpolantSettings = o),
          (this._interpolants = a),
          (this._propertyBindings = new Array(r)),
          (this._cacheIndex = null),
          (this._byClipCacheIndex = null),
          (this._timeScaleInterpolant = null),
          (this._weightInterpolant = null),
          (this.loop = fe),
          (this._loopCount = -1),
          (this._startTime = null),
          (this.time = 0),
          (this.timeScale = 1),
          (this._effectiveTimeScale = 1),
          (this.weight = 1),
          (this._effectiveWeight = 1),
          (this.repetitions = 1 / 0),
          (this.paused = !1),
          (this.enabled = !0),
          (this.clampWhenFinished = !1),
          (this.zeroSlopeAtStart = !0),
          (this.zeroSlopeAtEnd = !0);
      }
      function bh(t) {
        (this._root = t),
          this._initMemoryManager(),
          (this._accuIndex = 0),
          (this.time = 0),
          (this.timeScale = 1);
      }
      function wh(t) {
        "string" === typeof t &&
          (console.warn("THREE.Uniform: Type parameter is no longer needed."),
          (t = arguments[1])),
          (this.value = t);
      }
      function Mh() {
        Nr.call(this),
          (this.type = "InstancedBufferGeometry"),
          (this.maxInstancedCount = void 0);
      }
      function Sh(t, e, n, i) {
        (this.data = t),
          (this.itemSize = e),
          (this.offset = n),
          (this.normalized = !0 === i);
      }
      function Eh(t, e) {
        (this.array = t),
          (this.stride = e),
          (this.count = void 0 !== t ? t.length / e : 0),
          (this.dynamic = !1),
          (this.updateRange = { offset: 0, count: -1 }),
          (this.version = 0);
      }
      function Th(t, e, n) {
        Eh.call(this, t, e), (this.meshPerAttribute = n || 1);
      }
      function Ah(t, e, n) {
        wr.call(this, t, e), (this.meshPerAttribute = n || 1);
      }
      function Ch(t, e, n, i) {
        (this.ray = new Wr(t, e)),
          (this.near = n || 0),
          (this.far = i || 1 / 0),
          (this.params = {
            Mesh: {},
            Line: {},
            LOD: {},
            Points: { threshold: 1 },
            Sprite: {},
          }),
          Object.defineProperties(this.params, {
            PointCloud: {
              get: function () {
                return (
                  console.warn(
                    "THREE.Raycaster: params.PointCloud has been renamed to params.Points."
                  ),
                  this.Points
                );
              },
            },
          });
      }
      function Rh(t, e) {
        return t.distance - e.distance;
      }
      function Lh(t, e, n, i) {
        if (!1 !== t.visible && (t.raycast(e, n), !0 === i))
          for (var r = t.children, a = 0, o = r.length; a < o; a++)
            Lh(r[a], e, n, !0);
      }
      function Ph(t) {
        (this.autoStart = void 0 === t || t),
          (this.startTime = 0),
          (this.oldTime = 0),
          (this.elapsedTime = 0),
          (this.running = !1);
      }
      function Dh(t, e, n) {
        return (
          (this.radius = void 0 !== t ? t : 1),
          (this.phi = void 0 !== e ? e : 0),
          (this.theta = void 0 !== n ? n : 0),
          this
        );
      }
      function Ih(t, e, n) {
        return (
          (this.radius = void 0 !== t ? t : 1),
          (this.theta = void 0 !== e ? e : 0),
          (this.y = void 0 !== n ? n : 0),
          this
        );
      }
      function Oh(t, e) {
        (this.min = void 0 !== t ? t : new Ue(1 / 0, 1 / 0)),
          (this.max = void 0 !== e ? e : new Ue(-1 / 0, -1 / 0));
      }
      function Nh(t) {
        gr.call(this), (this.material = t), (this.render = function () {});
      }
      function Bh(t, e, n, i) {
        (this.object = t), (this.size = void 0 !== e ? e : 1);
        var r = void 0 !== n ? n : 16711680,
          a = void 0 !== i ? i : 1,
          o = 0,
          s = this.object.geometry;
        s && s.isGeometry
          ? (o = 3 * s.faces.length)
          : s && s.isBufferGeometry && (o = s.attributes.normal.count);
        var c = new Nr(),
          l = new Lr(2 * o * 3, 3);
        c.addAttribute("position", l),
          Jo.call(this, c, new Xo({ color: r, linewidth: a })),
          (this.matrixAutoUpdate = !1),
          this.update();
      }
      function zh(t, e) {
        gr.call(this),
          (this.light = t),
          this.light.updateMatrixWorld(),
          (this.matrix = t.matrixWorld),
          (this.matrixAutoUpdate = !1),
          (this.color = e);
        for (
          var n = new Nr(),
            i = [
              0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0,
              1, 1, 0, 0, 0, 0, -1, 1,
            ],
            r = 0,
            a = 1,
            o = 32;
          r < o;
          r++, a++
        ) {
          var s = (r / o) * Math.PI * 2,
            c = (a / o) * Math.PI * 2;
          i.push(Math.cos(s), Math.sin(s), 1, Math.cos(c), Math.sin(c), 1);
        }
        n.addAttribute("position", new Lr(i, 3));
        var l = new Xo({ fog: !1 });
        (this.cone = new Jo(n, l)), this.add(this.cone), this.update();
      }
      function Uh(t) {
        var e = [];
        t && t.isBone && e.push(t);
        for (var n = 0; n < t.children.length; n++)
          e.push.apply(e, Uh(t.children[n]));
        return e;
      }
      function Fh(t) {
        for (
          var e = Uh(t),
            n = new Nr(),
            i = [],
            r = [],
            a = new cr(0, 0, 1),
            o = new cr(0, 1, 0),
            s = 0;
          s < e.length;
          s++
        ) {
          var c = e[s];
          c.parent &&
            c.parent.isBone &&
            (i.push(0, 0, 0),
            i.push(0, 0, 0),
            r.push(a.r, a.g, a.b),
            r.push(o.r, o.g, o.b));
        }
        n.addAttribute("position", new Lr(i, 3)),
          n.addAttribute("color", new Lr(r, 3));
        var l = new Xo({
          vertexColors: w,
          depthTest: !1,
          depthWrite: !1,
          transparent: !0,
        });
        Jo.call(this, n, l),
          (this.root = t),
          (this.bones = e),
          (this.matrix = t.matrixWorld),
          (this.matrixAutoUpdate = !1);
      }
      function Hh(t, e, n) {
        (this.light = t), this.light.updateMatrixWorld(), (this.color = n);
        var i = new oc(e, 4, 2),
          r = new Gr({ wireframe: !0, fog: !1 });
        Xr.call(this, i, r),
          (this.matrix = this.light.matrixWorld),
          (this.matrixAutoUpdate = !1),
          this.update();
      }
      function kh(t, e) {
        gr.call(this),
          (this.light = t),
          this.light.updateMatrixWorld(),
          (this.matrix = t.matrixWorld),
          (this.matrixAutoUpdate = !1),
          (this.color = e);
        var n = new Xo({ fog: !1 }),
          i = new Nr();
        i.addAttribute("position", new wr(new Float32Array(15), 3)),
          (this.line = new Yo(i, n)),
          this.add(this.line),
          this.update();
      }
      function Gh(t, e, n) {
        gr.call(this),
          (this.light = t),
          this.light.updateMatrixWorld(),
          (this.matrix = t.matrixWorld),
          (this.matrixAutoUpdate = !1),
          (this.color = n);
        var i = new hs(e);
        i.rotateY(0.5 * Math.PI),
          (this.material = new Gr({ wireframe: !0, fog: !1 })),
          void 0 === this.color && (this.material.vertexColors = w);
        var r = i.getAttribute("position"),
          a = new Float32Array(3 * r.count);
        i.addAttribute("color", new wr(a, 3)),
          this.add(new Xr(i, this.material)),
          this.update();
      }
      function Vh(t, e, n, i) {
        (t = t || 10),
          (e = e || 10),
          (n = new cr(void 0 !== n ? n : 4473924)),
          (i = new cr(void 0 !== i ? i : 8947848));
        for (
          var r = e / 2,
            a = t / e,
            o = t / 2,
            s = [],
            c = [],
            l = 0,
            h = 0,
            u = -o;
          l <= e;
          l++, u += a
        ) {
          s.push(-o, 0, u, o, 0, u), s.push(u, 0, -o, u, 0, o);
          var d = l === r ? n : i;
          d.toArray(c, h),
            (h += 3),
            d.toArray(c, h),
            (h += 3),
            d.toArray(c, h),
            (h += 3),
            d.toArray(c, h),
            (h += 3);
        }
        var p = new Nr();
        p.addAttribute("position", new Lr(s, 3)),
          p.addAttribute("color", new Lr(c, 3));
        var f = new Xo({ vertexColors: w });
        Jo.call(this, p, f);
      }
      function Wh(t, e, n, i, r, a) {
        (t = t || 10),
          (e = e || 16),
          (n = n || 8),
          (i = i || 64),
          (r = new cr(void 0 !== r ? r : 4473924)),
          (a = new cr(void 0 !== a ? a : 8947848));
        var o,
          s,
          c,
          l,
          h,
          u,
          d,
          p = [],
          f = [];
        for (l = 0; l <= e; l++)
          (c = (l / e) * (2 * Math.PI)),
            (o = Math.sin(c) * t),
            (s = Math.cos(c) * t),
            p.push(0, 0, 0),
            p.push(o, 0, s),
            (d = 1 & l ? r : a),
            f.push(d.r, d.g, d.b),
            f.push(d.r, d.g, d.b);
        for (l = 0; l <= n; l++)
          for (d = 1 & l ? r : a, u = t - (t / n) * l, h = 0; h < i; h++)
            (c = (h / i) * (2 * Math.PI)),
              (o = Math.sin(c) * u),
              (s = Math.cos(c) * u),
              p.push(o, 0, s),
              f.push(d.r, d.g, d.b),
              (c = ((h + 1) / i) * (2 * Math.PI)),
              (o = Math.sin(c) * u),
              (s = Math.cos(c) * u),
              p.push(o, 0, s),
              f.push(d.r, d.g, d.b);
        var m = new Nr();
        m.addAttribute("position", new Lr(p, 3)),
          m.addAttribute("color", new Lr(f, 3));
        var g = new Xo({ vertexColors: w });
        Jo.call(this, m, g);
      }
      function jh(t, e, n, i) {
        (this.object = t), (this.size = void 0 !== e ? e : 1);
        var r = void 0 !== n ? n : 16776960,
          a = void 0 !== i ? i : 1,
          o = 0,
          s = this.object.geometry;
        s && s.isGeometry
          ? (o = s.faces.length)
          : console.warn(
              "THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead."
            );
        var c = new Nr(),
          l = new Lr(2 * o * 3, 3);
        c.addAttribute("position", l),
          Jo.call(this, c, new Xo({ color: r, linewidth: a })),
          (this.matrixAutoUpdate = !1),
          this.update();
      }
      function qh(t, e, n) {
        gr.call(this),
          (this.light = t),
          this.light.updateMatrixWorld(),
          (this.matrix = t.matrixWorld),
          (this.matrixAutoUpdate = !1),
          (this.color = n),
          void 0 === e && (e = 1);
        var i = new Nr();
        i.addAttribute(
          "position",
          new Lr([-e, e, 0, e, e, 0, e, -e, 0, -e, -e, 0, -e, e, 0], 3)
        );
        var r = new Xo({ fog: !1 });
        (this.lightPlane = new Yo(i, r)),
          this.add(this.lightPlane),
          (i = new Nr()),
          i.addAttribute("position", new Lr([0, 0, 0, 0, 0, 1], 3)),
          (this.targetLine = new Yo(i, r)),
          this.add(this.targetLine),
          this.update();
      }
      function Xh(t) {
        var e = new Nr(),
          n = new Xo({ color: 16777215, vertexColors: b }),
          i = [],
          r = [],
          a = {},
          o = new cr(16755200),
          s = new cr(16711680),
          c = new cr(43775),
          l = new cr(16777215),
          h = new cr(3355443);
        function u(t, e, n) {
          d(t, n), d(e, n);
        }
        function d(t, e) {
          i.push(0, 0, 0),
            r.push(e.r, e.g, e.b),
            void 0 === a[t] && (a[t] = []),
            a[t].push(i.length / 3 - 1);
        }
        u("n1", "n2", o),
          u("n2", "n4", o),
          u("n4", "n3", o),
          u("n3", "n1", o),
          u("f1", "f2", o),
          u("f2", "f4", o),
          u("f4", "f3", o),
          u("f3", "f1", o),
          u("n1", "f1", o),
          u("n2", "f2", o),
          u("n3", "f3", o),
          u("n4", "f4", o),
          u("p", "n1", s),
          u("p", "n2", s),
          u("p", "n3", s),
          u("p", "n4", s),
          u("u1", "u2", c),
          u("u2", "u3", c),
          u("u3", "u1", c),
          u("c", "t", l),
          u("p", "c", h),
          u("cn1", "cn2", h),
          u("cn3", "cn4", h),
          u("cf1", "cf2", h),
          u("cf3", "cf4", h),
          e.addAttribute("position", new Lr(i, 3)),
          e.addAttribute("color", new Lr(r, 3)),
          Jo.call(this, e, n),
          (this.camera = t),
          this.camera.updateProjectionMatrix &&
            this.camera.updateProjectionMatrix(),
          (this.matrix = t.matrixWorld),
          (this.matrixAutoUpdate = !1),
          (this.pointMap = a),
          this.update();
      }
      function Yh(t, e) {
        (this.object = t), void 0 === e && (e = 16776960);
        var n = new Uint16Array([
            0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3,
            7,
          ]),
          i = new Float32Array(24),
          r = new Nr();
        r.setIndex(new wr(n, 1)),
          r.addAttribute("position", new wr(i, 3)),
          Jo.call(this, r, new Xo({ color: e })),
          (this.matrixAutoUpdate = !1),
          this.update();
      }
      function Jh(t, e) {
        (this.type = "Box3Helper"), (this.box = t);
        var n = void 0 !== e ? e : 16776960,
          i = new Uint16Array([
            0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3,
            7,
          ]),
          r = [
            1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1,
            -1, 1, -1, -1,
          ],
          a = new Nr();
        a.setIndex(new wr(i, 1)),
          a.addAttribute("position", new Lr(r, 3)),
          Jo.call(this, a, new Xo({ color: n })),
          this.geometry.computeBoundingSphere();
      }
      function Zh(t, e, n) {
        (this.type = "PlaneHelper"),
          (this.plane = t),
          (this.size = void 0 === e ? 1 : e);
        var i = void 0 !== n ? n : 16776960,
          r = [
            1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1,
            1, 1, 1, 1, 0, 0, 1, 0, 0, 0,
          ],
          a = new Nr();
        a.addAttribute("position", new Lr(r, 3)),
          a.computeBoundingSphere(),
          Yo.call(this, a, new Xo({ color: i }));
        var o = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1],
          s = new Nr();
        s.addAttribute("position", new Lr(o, 3)),
          s.computeBoundingSphere(),
          this.add(
            new Xr(
              s,
              new Gr({
                color: i,
                opacity: 0.2,
                transparent: !0,
                depthWrite: !1,
              })
            )
          );
      }
      function Kh(t, e, n, i, r, a) {
        gr.call(this),
          void 0 === i && (i = 16776960),
          void 0 === n && (n = 1),
          void 0 === r && (r = 0.2 * n),
          void 0 === a && (a = 0.2 * r),
          void 0 === fh &&
            ((fh = new Nr()),
            fh.addAttribute("position", new Lr([0, 0, 0, 0, 1, 0], 3)),
            (mh = new gc(0, 0.5, 1, 5, 1)),
            mh.translate(0, -0.5, 0)),
          this.position.copy(e),
          (this.line = new Yo(fh, new Xo({ color: i }))),
          (this.line.matrixAutoUpdate = !1),
          this.add(this.line),
          (this.cone = new Xr(mh, new Gr({ color: i }))),
          (this.cone.matrixAutoUpdate = !1),
          this.add(this.cone),
          this.setDirection(t),
          this.setLength(n, r, a);
      }
      function $h(t) {
        t = t || 1;
        var e = [0, 0, 0, t, 0, 0, 0, 0, 0, 0, t, 0, 0, 0, 0, 0, 0, t],
          n = [1, 0, 0, 1, 0.6, 0, 0, 1, 0, 0.6, 1, 0, 0, 0, 1, 0, 0.6, 1],
          i = new Nr();
        i.addAttribute("position", new Lr(e, 3)),
          i.addAttribute("color", new Lr(n, 3));
        var r = new Xo({ vertexColors: w });
        Jo.call(this, i, r);
      }
      function Qh(t, e, n, i, r, a, o) {
        return (
          console.warn(
            "THREE.Face4 has been removed. A THREE.Face3 will be created instead."
          ),
          new xr(t, e, n, r, a, o)
        );
      }
      Object.assign(vh.prototype, {
        getValue: function (t, e) {
          this.bind();
          var n = this._targetGroup.nCachedObjects_,
            i = this._bindings[n];
          void 0 !== i && i.getValue(t, e);
        },
        setValue: function (t, e) {
          for (
            var n = this._bindings,
              i = this._targetGroup.nCachedObjects_,
              r = n.length;
            i !== r;
            ++i
          )
            n[i].setValue(t, e);
        },
        bind: function () {
          for (
            var t = this._bindings,
              e = this._targetGroup.nCachedObjects_,
              n = t.length;
            e !== n;
            ++e
          )
            t[e].bind();
        },
        unbind: function () {
          for (
            var t = this._bindings,
              e = this._targetGroup.nCachedObjects_,
              n = t.length;
            e !== n;
            ++e
          )
            t[e].unbind();
        },
      }),
        Object.assign(yh, {
          Composite: vh,
          create: function (t, e, n) {
            return t && t.isAnimationObjectGroup
              ? new yh.Composite(t, e, n)
              : new yh(t, e, n);
          },
          sanitizeNodeName: (function () {
            var t = new RegExp("[" + gh + "]", "g");
            return function (e) {
              return e.replace(/\s/g, "_").replace(t, "");
            };
          })(),
          parseTrackName: (function () {
            var t = "[^" + gh + "]",
              e = "[^" + gh.replace("\\.", "") + "]",
              n = /((?:WC+[\/:])*)/.source.replace("WC", t),
              i = /(WCOD+)?/.source.replace("WCOD", e),
              r = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", t),
              a = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", t),
              o = new RegExp("^" + n + i + r + a + "$"),
              s = ["material", "materials", "bones"];
            return function (t) {
              var e = o.exec(t);
              if (!e)
                throw new Error(
                  "PropertyBinding: Cannot parse trackName: " + t
                );
              var n = {
                  nodeName: e[2],
                  objectName: e[3],
                  objectIndex: e[4],
                  propertyName: e[5],
                  propertyIndex: e[6],
                },
                i = n.nodeName && n.nodeName.lastIndexOf(".");
              if (void 0 !== i && -1 !== i) {
                var r = n.nodeName.substring(i + 1);
                -1 !== s.indexOf(r) &&
                  ((n.nodeName = n.nodeName.substring(0, i)),
                  (n.objectName = r));
              }
              if (null === n.propertyName || 0 === n.propertyName.length)
                throw new Error(
                  "PropertyBinding: can not parse propertyName from trackName: " +
                    t
                );
              return n;
            };
          })(),
          findNode: function (t, e) {
            if (
              !e ||
              "" === e ||
              "root" === e ||
              "." === e ||
              -1 === e ||
              e === t.name ||
              e === t.uuid
            )
              return t;
            if (t.skeleton) {
              var n = t.skeleton.getBoneByName(e);
              if (void 0 !== n) return n;
            }
            if (t.children) {
              var i = function (t) {
                  for (var n = 0; n < t.length; n++) {
                    var r = t[n];
                    if (r.name === e || r.uuid === e) return r;
                    var a = i(r.children);
                    if (a) return a;
                  }
                  return null;
                },
                r = i(t.children);
              if (r) return r;
            }
            return null;
          },
        }),
        Object.assign(yh.prototype, {
          _getValue_unavailable: function () {},
          _setValue_unavailable: function () {},
          BindingType: {
            Direct: 0,
            EntireArray: 1,
            ArrayElement: 2,
            HasFromToArray: 3,
          },
          Versioning: { None: 0, NeedsUpdate: 1, MatrixWorldNeedsUpdate: 2 },
          GetterByBindingType: [
            function (t, e) {
              t[e] = this.node[this.propertyName];
            },
            function (t, e) {
              for (
                var n = this.resolvedProperty, i = 0, r = n.length;
                i !== r;
                ++i
              )
                t[e++] = n[i];
            },
            function (t, e) {
              t[e] = this.resolvedProperty[this.propertyIndex];
            },
            function (t, e) {
              this.resolvedProperty.toArray(t, e);
            },
          ],
          SetterByBindingTypeAndVersioning: [
            [
              function (t, e) {
                this.targetObject[this.propertyName] = t[e];
              },
              function (t, e) {
                (this.targetObject[this.propertyName] = t[e]),
                  (this.targetObject.needsUpdate = !0);
              },
              function (t, e) {
                (this.targetObject[this.propertyName] = t[e]),
                  (this.targetObject.matrixWorldNeedsUpdate = !0);
              },
            ],
            [
              function (t, e) {
                for (
                  var n = this.resolvedProperty, i = 0, r = n.length;
                  i !== r;
                  ++i
                )
                  n[i] = t[e++];
              },
              function (t, e) {
                for (
                  var n = this.resolvedProperty, i = 0, r = n.length;
                  i !== r;
                  ++i
                )
                  n[i] = t[e++];
                this.targetObject.needsUpdate = !0;
              },
              function (t, e) {
                for (
                  var n = this.resolvedProperty, i = 0, r = n.length;
                  i !== r;
                  ++i
                )
                  n[i] = t[e++];
                this.targetObject.matrixWorldNeedsUpdate = !0;
              },
            ],
            [
              function (t, e) {
                this.resolvedProperty[this.propertyIndex] = t[e];
              },
              function (t, e) {
                (this.resolvedProperty[this.propertyIndex] = t[e]),
                  (this.targetObject.needsUpdate = !0);
              },
              function (t, e) {
                (this.resolvedProperty[this.propertyIndex] = t[e]),
                  (this.targetObject.matrixWorldNeedsUpdate = !0);
              },
            ],
            [
              function (t, e) {
                this.resolvedProperty.fromArray(t, e);
              },
              function (t, e) {
                this.resolvedProperty.fromArray(t, e),
                  (this.targetObject.needsUpdate = !0);
              },
              function (t, e) {
                this.resolvedProperty.fromArray(t, e),
                  (this.targetObject.matrixWorldNeedsUpdate = !0);
              },
            ],
          ],
          getValue: function (t, e) {
            this.bind(), this.getValue(t, e);
          },
          setValue: function (t, e) {
            this.bind(), this.setValue(t, e);
          },
          bind: function () {
            var t = this.node,
              e = this.parsedPath,
              n = e.objectName,
              i = e.propertyName,
              r = e.propertyIndex;
            if (
              (t ||
                ((t = yh.findNode(this.rootNode, e.nodeName) || this.rootNode),
                (this.node = t)),
              (this.getValue = this._getValue_unavailable),
              (this.setValue = this._setValue_unavailable),
              t)
            ) {
              if (n) {
                var a = e.objectIndex;
                switch (n) {
                  case "materials":
                    if (!t.material)
                      return void console.error(
                        "THREE.PropertyBinding: Can not bind to material as node does not have a material.",
                        this
                      );
                    if (!t.material.materials)
                      return void console.error(
                        "THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",
                        this
                      );
                    t = t.material.materials;
                    break;
                  case "bones":
                    if (!t.skeleton)
                      return void console.error(
                        "THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",
                        this
                      );
                    t = t.skeleton.bones;
                    for (var o = 0; o < t.length; o++)
                      if (t[o].name === a) {
                        a = o;
                        break;
                      }
                    break;
                  default:
                    if (void 0 === t[n])
                      return void console.error(
                        "THREE.PropertyBinding: Can not bind to objectName of node undefined.",
                        this
                      );
                    t = t[n];
                }
                if (void 0 !== a) {
                  if (void 0 === t[a])
                    return void console.error(
                      "THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",
                      this,
                      t
                    );
                  t = t[a];
                }
              }
              var s = t[i];
              if (void 0 !== s) {
                var c = this.Versioning.None;
                void 0 !== t.needsUpdate
                  ? ((c = this.Versioning.NeedsUpdate), (this.targetObject = t))
                  : void 0 !== t.matrixWorldNeedsUpdate &&
                    ((c = this.Versioning.MatrixWorldNeedsUpdate),
                    (this.targetObject = t));
                var l = this.BindingType.Direct;
                if (void 0 !== r) {
                  if ("morphTargetInfluences" === i) {
                    if (!t.geometry)
                      return void console.error(
                        "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",
                        this
                      );
                    if (t.geometry.isBufferGeometry) {
                      if (!t.geometry.morphAttributes)
                        return void console.error(
                          "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",
                          this
                        );
                      for (
                        o = 0;
                        o < this.node.geometry.morphAttributes.position.length;
                        o++
                      )
                        if (t.geometry.morphAttributes.position[o].name === r) {
                          r = o;
                          break;
                        }
                    } else {
                      if (!t.geometry.morphTargets)
                        return void console.error(
                          "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphTargets.",
                          this
                        );
                      for (
                        o = 0;
                        o < this.node.geometry.morphTargets.length;
                        o++
                      )
                        if (t.geometry.morphTargets[o].name === r) {
                          r = o;
                          break;
                        }
                    }
                  }
                  (l = this.BindingType.ArrayElement),
                    (this.resolvedProperty = s),
                    (this.propertyIndex = r);
                } else
                  void 0 !== s.fromArray && void 0 !== s.toArray
                    ? ((l = this.BindingType.HasFromToArray),
                      (this.resolvedProperty = s))
                    : Array.isArray(s)
                    ? ((l = this.BindingType.EntireArray),
                      (this.resolvedProperty = s))
                    : (this.propertyName = i);
                (this.getValue = this.GetterByBindingType[l]),
                  (this.setValue = this.SetterByBindingTypeAndVersioning[l][c]);
              } else {
                var h = e.nodeName;
                console.error(
                  "THREE.PropertyBinding: Trying to update property for track: " +
                    h +
                    "." +
                    i +
                    " but it wasn't found.",
                  t
                );
              }
            } else
              console.error(
                "THREE.PropertyBinding: Trying to update node for track: " +
                  this.path +
                  " but it wasn't found."
              );
          },
          unbind: function () {
            (this.node = null),
              (this.getValue = this._getValue_unbound),
              (this.setValue = this._setValue_unbound);
          },
        }),
        //!\ DECLARE ALIAS AFTER assign prototype !
        Object.assign(yh.prototype, {
          _getValue_unbound: yh.prototype.getValue,
          _setValue_unbound: yh.prototype.setValue,
        }),
        Object.assign(xh.prototype, {
          isAnimationObjectGroup: !0,
          add: function () {
            for (
              var t = this._objects,
                e = t.length,
                n = this.nCachedObjects_,
                i = this._indicesByUUID,
                r = this._paths,
                a = this._parsedPaths,
                o = this._bindings,
                s = o.length,
                c = void 0,
                l = 0,
                h = arguments.length;
              l !== h;
              ++l
            ) {
              var u = arguments[l],
                d = u.uuid,
                p = i[d];
              if (void 0 === p) {
                (p = e++), (i[d] = p), t.push(u);
                for (var f = 0, m = s; f !== m; ++f)
                  o[f].push(new yh(u, r[f], a[f]));
              } else if (p < n) {
                c = t[p];
                var g = --n,
                  v = t[g];
                (i[v.uuid] = p), (t[p] = v), (i[d] = g), (t[g] = u);
                for (f = 0, m = s; f !== m; ++f) {
                  var y = o[f],
                    x = y[g],
                    _ = y[p];
                  (y[p] = x),
                    void 0 === _ && (_ = new yh(u, r[f], a[f])),
                    (y[g] = _);
                }
              } else
                t[p] !== c &&
                  console.error(
                    "THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes."
                  );
            }
            this.nCachedObjects_ = n;
          },
          remove: function () {
            for (
              var t = this._objects,
                e = this.nCachedObjects_,
                n = this._indicesByUUID,
                i = this._bindings,
                r = i.length,
                a = 0,
                o = arguments.length;
              a !== o;
              ++a
            ) {
              var s = arguments[a],
                c = s.uuid,
                l = n[c];
              if (void 0 !== l && l >= e) {
                var h = e++,
                  u = t[h];
                (n[u.uuid] = l), (t[l] = u), (n[c] = h), (t[h] = s);
                for (var d = 0, p = r; d !== p; ++d) {
                  var f = i[d],
                    m = f[h],
                    g = f[l];
                  (f[l] = m), (f[h] = g);
                }
              }
            }
            this.nCachedObjects_ = e;
          },
          uncache: function () {
            for (
              var t = this._objects,
                e = t.length,
                n = this.nCachedObjects_,
                i = this._indicesByUUID,
                r = this._bindings,
                a = r.length,
                o = 0,
                s = arguments.length;
              o !== s;
              ++o
            ) {
              var c = arguments[o],
                l = c.uuid,
                h = i[l];
              if (void 0 !== h)
                if ((delete i[l], h < n)) {
                  var u = --n,
                    d = t[u],
                    p = --e,
                    f = t[p];
                  (i[d.uuid] = h),
                    (t[h] = d),
                    (i[f.uuid] = u),
                    (t[u] = f),
                    t.pop();
                  for (var m = 0, g = a; m !== g; ++m) {
                    var v = r[m],
                      y = v[u],
                      x = v[p];
                    (v[h] = y), (v[u] = x), v.pop();
                  }
                } else {
                  (p = --e), (f = t[p]);
                  (i[f.uuid] = h), (t[h] = f), t.pop();
                  for (m = 0, g = a; m !== g; ++m) {
                    v = r[m];
                    (v[h] = v[p]), v.pop();
                  }
                }
            }
            this.nCachedObjects_ = n;
          },
          subscribe_: function (t, e) {
            var n = this._bindingsIndicesByPath,
              i = n[t],
              r = this._bindings;
            if (void 0 !== i) return r[i];
            var a = this._paths,
              o = this._parsedPaths,
              s = this._objects,
              c = s.length,
              l = this.nCachedObjects_,
              h = new Array(c);
            (i = r.length), (n[t] = i), a.push(t), o.push(e), r.push(h);
            for (var u = l, d = s.length; u !== d; ++u) {
              var p = s[u];
              h[u] = new yh(p, t, e);
            }
            return h;
          },
          unsubscribe_: function (t) {
            var e = this._bindingsIndicesByPath,
              n = e[t];
            if (void 0 !== n) {
              var i = this._paths,
                r = this._parsedPaths,
                a = this._bindings,
                o = a.length - 1,
                s = a[o],
                c = t[o];
              (e[c] = n),
                (a[n] = s),
                a.pop(),
                (r[n] = r[o]),
                r.pop(),
                (i[n] = i[o]),
                i.pop();
            }
          },
        }),
        Object.assign(_h.prototype, {
          play: function () {
            return this._mixer._activateAction(this), this;
          },
          stop: function () {
            return this._mixer._deactivateAction(this), this.reset();
          },
          reset: function () {
            return (
              (this.paused = !1),
              (this.enabled = !0),
              (this.time = 0),
              (this._loopCount = -1),
              (this._startTime = null),
              this.stopFading().stopWarping()
            );
          },
          isRunning: function () {
            return (
              this.enabled &&
              !this.paused &&
              0 !== this.timeScale &&
              null === this._startTime &&
              this._mixer._isActiveAction(this)
            );
          },
          isScheduled: function () {
            return this._mixer._isActiveAction(this);
          },
          startAt: function (t) {
            return (this._startTime = t), this;
          },
          setLoop: function (t, e) {
            return (this.loop = t), (this.repetitions = e), this;
          },
          setEffectiveWeight: function (t) {
            return (
              (this.weight = t),
              (this._effectiveWeight = this.enabled ? t : 0),
              this.stopFading()
            );
          },
          getEffectiveWeight: function () {
            return this._effectiveWeight;
          },
          fadeIn: function (t) {
            return this._scheduleFading(t, 0, 1);
          },
          fadeOut: function (t) {
            return this._scheduleFading(t, 1, 0);
          },
          crossFadeFrom: function (t, e, n) {
            if ((t.fadeOut(e), this.fadeIn(e), n)) {
              var i = this._clip.duration,
                r = t._clip.duration,
                a = r / i,
                o = i / r;
              t.warp(1, a, e), this.warp(o, 1, e);
            }
            return this;
          },
          crossFadeTo: function (t, e, n) {
            return t.crossFadeFrom(this, e, n);
          },
          stopFading: function () {
            var t = this._weightInterpolant;
            return (
              null !== t &&
                ((this._weightInterpolant = null),
                this._mixer._takeBackControlInterpolant(t)),
              this
            );
          },
          setEffectiveTimeScale: function (t) {
            return (
              (this.timeScale = t),
              (this._effectiveTimeScale = this.paused ? 0 : t),
              this.stopWarping()
            );
          },
          getEffectiveTimeScale: function () {
            return this._effectiveTimeScale;
          },
          setDuration: function (t) {
            return (
              (this.timeScale = this._clip.duration / t), this.stopWarping()
            );
          },
          syncWith: function (t) {
            return (
              (this.time = t.time),
              (this.timeScale = t.timeScale),
              this.stopWarping()
            );
          },
          halt: function (t) {
            return this.warp(this._effectiveTimeScale, 0, t);
          },
          warp: function (t, e, n) {
            var i = this._mixer,
              r = i.time,
              a = this._timeScaleInterpolant,
              o = this.timeScale;
            null === a &&
              ((a = i._lendControlInterpolant()),
              (this._timeScaleInterpolant = a));
            var s = a.parameterPositions,
              c = a.sampleValues;
            return (
              (s[0] = r), (s[1] = r + n), (c[0] = t / o), (c[1] = e / o), this
            );
          },
          stopWarping: function () {
            var t = this._timeScaleInterpolant;
            return (
              null !== t &&
                ((this._timeScaleInterpolant = null),
                this._mixer._takeBackControlInterpolant(t)),
              this
            );
          },
          getMixer: function () {
            return this._mixer;
          },
          getClip: function () {
            return this._clip;
          },
          getRoot: function () {
            return this._localRoot || this._mixer._root;
          },
          _update: function (t, e, n, i) {
            if (this.enabled) {
              var r = this._startTime;
              if (null !== r) {
                var a = (t - r) * n;
                if (a < 0 || 0 === n) return;
                (this._startTime = null), (e = n * a);
              }
              e *= this._updateTimeScale(t);
              var o = this._updateTime(e),
                s = this._updateWeight(t);
              if (s > 0)
                for (
                  var c = this._interpolants,
                    l = this._propertyBindings,
                    h = 0,
                    u = c.length;
                  h !== u;
                  ++h
                )
                  c[h].evaluate(o), l[h].accumulate(i, s);
            } else this._updateWeight(t);
          },
          _updateWeight: function (t) {
            var e = 0;
            if (this.enabled) {
              e = this.weight;
              var n = this._weightInterpolant;
              if (null !== n) {
                var i = n.evaluate(t)[0];
                (e *= i),
                  t > n.parameterPositions[1] &&
                    (this.stopFading(), 0 === i && (this.enabled = !1));
              }
            }
            return (this._effectiveWeight = e), e;
          },
          _updateTimeScale: function (t) {
            var e = 0;
            if (!this.paused) {
              e = this.timeScale;
              var n = this._timeScaleInterpolant;
              if (null !== n) {
                var i = n.evaluate(t)[0];
                (e *= i),
                  t > n.parameterPositions[1] &&
                    (this.stopWarping(),
                    0 === e ? (this.paused = !0) : (this.timeScale = e));
              }
            }
            return (this._effectiveTimeScale = e), e;
          },
          _updateTime: function (t) {
            var e = this.time + t;
            if (0 === t) return e;
            var n = this._clip.duration,
              i = this.loop,
              r = this._loopCount;
            if (i === pe) {
              -1 === r && ((this._loopCount = 0), this._setEndings(!0, !0, !1));
              t: {
                if (e >= n) e = n;
                else {
                  if (!(e < 0)) break t;
                  e = 0;
                }
                this.clampWhenFinished
                  ? (this.paused = !0)
                  : (this.enabled = !1),
                  this._mixer.dispatchEvent({
                    type: "finished",
                    action: this,
                    direction: t < 0 ? -1 : 1,
                  });
              }
            } else {
              var a = i === me;
              if (
                (-1 === r &&
                  (t >= 0
                    ? ((r = 0), this._setEndings(!0, 0 === this.repetitions, a))
                    : this._setEndings(0 === this.repetitions, !0, a)),
                e >= n || e < 0)
              ) {
                var o = Math.floor(e / n);
                (e -= n * o), (r += Math.abs(o));
                var s = this.repetitions - r;
                if (s <= 0)
                  this.clampWhenFinished
                    ? (this.paused = !0)
                    : (this.enabled = !1),
                    (e = t > 0 ? n : 0),
                    this._mixer.dispatchEvent({
                      type: "finished",
                      action: this,
                      direction: t > 0 ? 1 : -1,
                    });
                else {
                  if (1 === s) {
                    var c = t < 0;
                    this._setEndings(c, !c, a);
                  } else this._setEndings(!1, !1, a);
                  (this._loopCount = r),
                    this._mixer.dispatchEvent({
                      type: "loop",
                      action: this,
                      loopDelta: o,
                    });
                }
              }
              if (a && 1 === (1 & r)) return (this.time = e), n - e;
            }
            return (this.time = e), e;
          },
          _setEndings: function (t, e, n) {
            var i = this._interpolantSettings;
            n
              ? ((i.endingStart = _e), (i.endingEnd = _e))
              : ((i.endingStart = t ? (this.zeroSlopeAtStart ? _e : xe) : be),
                (i.endingEnd = e ? (this.zeroSlopeAtEnd ? _e : xe) : be));
          },
          _scheduleFading: function (t, e, n) {
            var i = this._mixer,
              r = i.time,
              a = this._weightInterpolant;
            null === a &&
              ((a = i._lendControlInterpolant()),
              (this._weightInterpolant = a));
            var o = a.parameterPositions,
              s = a.sampleValues;
            return (o[0] = r), (s[0] = e), (o[1] = r + t), (s[1] = n), this;
          },
        }),
        (bh.prototype = Object.assign(Object.create(i.prototype), {
          constructor: bh,
          _bindAction: function (t, e) {
            var n = t._localRoot || this._root,
              i = t._clip.tracks,
              r = i.length,
              a = t._propertyBindings,
              o = t._interpolants,
              s = n.uuid,
              c = this._bindingsByRootAndName,
              l = c[s];
            void 0 === l && ((l = {}), (c[s] = l));
            for (var h = 0; h !== r; ++h) {
              var u = i[h],
                d = u.name,
                p = l[d];
              if (void 0 !== p) a[h] = p;
              else {
                if (((p = a[h]), void 0 !== p)) {
                  null === p._cacheIndex &&
                    (++p.referenceCount, this._addInactiveBinding(p, s, d));
                  continue;
                }
                var f = e && e._propertyBindings[h].binding.parsedPath;
                (p = new ph(
                  yh.create(n, d, f),
                  u.ValueTypeName,
                  u.getValueSize()
                )),
                  ++p.referenceCount,
                  this._addInactiveBinding(p, s, d),
                  (a[h] = p);
              }
              o[h].resultBuffer = p.buffer;
            }
          },
          _activateAction: function (t) {
            if (!this._isActiveAction(t)) {
              if (null === t._cacheIndex) {
                var e = (t._localRoot || this._root).uuid,
                  n = t._clip.uuid,
                  i = this._actionsByClip[n];
                this._bindAction(t, i && i.knownActions[0]),
                  this._addInactiveAction(t, n, e);
              }
              for (
                var r = t._propertyBindings, a = 0, o = r.length;
                a !== o;
                ++a
              ) {
                var s = r[a];
                0 === s.useCount++ &&
                  (this._lendBinding(s), s.saveOriginalState());
              }
              this._lendAction(t);
            }
          },
          _deactivateAction: function (t) {
            if (this._isActiveAction(t)) {
              for (
                var e = t._propertyBindings, n = 0, i = e.length;
                n !== i;
                ++n
              ) {
                var r = e[n];
                0 === --r.useCount &&
                  (r.restoreOriginalState(), this._takeBackBinding(r));
              }
              this._takeBackAction(t);
            }
          },
          _initMemoryManager: function () {
            (this._actions = []),
              (this._nActiveActions = 0),
              (this._actionsByClip = {}),
              (this._bindings = []),
              (this._nActiveBindings = 0),
              (this._bindingsByRootAndName = {}),
              (this._controlInterpolants = []),
              (this._nActiveControlInterpolants = 0);
            var t = this;
            this.stats = {
              actions: {
                get total() {
                  return t._actions.length;
                },
                get inUse() {
                  return t._nActiveActions;
                },
              },
              bindings: {
                get total() {
                  return t._bindings.length;
                },
                get inUse() {
                  return t._nActiveBindings;
                },
              },
              controlInterpolants: {
                get total() {
                  return t._controlInterpolants.length;
                },
                get inUse() {
                  return t._nActiveControlInterpolants;
                },
              },
            };
          },
          _isActiveAction: function (t) {
            var e = t._cacheIndex;
            return null !== e && e < this._nActiveActions;
          },
          _addInactiveAction: function (t, e, n) {
            var i = this._actions,
              r = this._actionsByClip,
              a = r[e];
            if (void 0 === a)
              (a = { knownActions: [t], actionByRoot: {} }),
                (t._byClipCacheIndex = 0),
                (r[e] = a);
            else {
              var o = a.knownActions;
              (t._byClipCacheIndex = o.length), o.push(t);
            }
            (t._cacheIndex = i.length), i.push(t), (a.actionByRoot[n] = t);
          },
          _removeInactiveAction: function (t) {
            var e = this._actions,
              n = e[e.length - 1],
              i = t._cacheIndex;
            (n._cacheIndex = i), (e[i] = n), e.pop(), (t._cacheIndex = null);
            var r = t._clip.uuid,
              a = this._actionsByClip,
              o = a[r],
              s = o.knownActions,
              c = s[s.length - 1],
              l = t._byClipCacheIndex;
            (c._byClipCacheIndex = l),
              (s[l] = c),
              s.pop(),
              (t._byClipCacheIndex = null);
            var h = o.actionByRoot,
              u = (t._localRoot || this._root).uuid;
            delete h[u],
              0 === s.length && delete a[r],
              this._removeInactiveBindingsForAction(t);
          },
          _removeInactiveBindingsForAction: function (t) {
            for (
              var e = t._propertyBindings, n = 0, i = e.length;
              n !== i;
              ++n
            ) {
              var r = e[n];
              0 === --r.referenceCount && this._removeInactiveBinding(r);
            }
          },
          _lendAction: function (t) {
            var e = this._actions,
              n = t._cacheIndex,
              i = this._nActiveActions++,
              r = e[i];
            (t._cacheIndex = i), (e[i] = t), (r._cacheIndex = n), (e[n] = r);
          },
          _takeBackAction: function (t) {
            var e = this._actions,
              n = t._cacheIndex,
              i = --this._nActiveActions,
              r = e[i];
            (t._cacheIndex = i), (e[i] = t), (r._cacheIndex = n), (e[n] = r);
          },
          _addInactiveBinding: function (t, e, n) {
            var i = this._bindingsByRootAndName,
              r = i[e],
              a = this._bindings;
            void 0 === r && ((r = {}), (i[e] = r)),
              (r[n] = t),
              (t._cacheIndex = a.length),
              a.push(t);
          },
          _removeInactiveBinding: function (t) {
            var e = this._bindings,
              n = t.binding,
              i = n.rootNode.uuid,
              r = n.path,
              a = this._bindingsByRootAndName,
              o = a[i],
              s = e[e.length - 1],
              c = t._cacheIndex;
            (s._cacheIndex = c), (e[c] = s), e.pop(), delete o[r];
            t: {
              for (var l in o) break t;
              delete a[i];
            }
          },
          _lendBinding: function (t) {
            var e = this._bindings,
              n = t._cacheIndex,
              i = this._nActiveBindings++,
              r = e[i];
            (t._cacheIndex = i), (e[i] = t), (r._cacheIndex = n), (e[n] = r);
          },
          _takeBackBinding: function (t) {
            var e = this._bindings,
              n = t._cacheIndex,
              i = --this._nActiveBindings,
              r = e[i];
            (t._cacheIndex = i), (e[i] = t), (r._cacheIndex = n), (e[n] = r);
          },
          _lendControlInterpolant: function () {
            var t = this._controlInterpolants,
              e = this._nActiveControlInterpolants++,
              n = t[e];
            return (
              void 0 === n &&
                ((n = new Bl(
                  new Float32Array(2),
                  new Float32Array(2),
                  1,
                  this._controlInterpolantsResultBuffer
                )),
                (n.__cacheIndex = e),
                (t[e] = n)),
              n
            );
          },
          _takeBackControlInterpolant: function (t) {
            var e = this._controlInterpolants,
              n = t.__cacheIndex,
              i = --this._nActiveControlInterpolants,
              r = e[i];
            (t.__cacheIndex = i), (e[i] = t), (r.__cacheIndex = n), (e[n] = r);
          },
          _controlInterpolantsResultBuffer: new Float32Array(1),
          clipAction: function (t, e) {
            var n = e || this._root,
              i = n.uuid,
              r = "string" === typeof t ? kl.findByName(n, t) : t,
              a = null !== r ? r.uuid : t,
              o = this._actionsByClip[a],
              s = null;
            if (void 0 !== o) {
              var c = o.actionByRoot[i];
              if (void 0 !== c) return c;
              (s = o.knownActions[0]), null === r && (r = s._clip);
            }
            if (null === r) return null;
            var l = new _h(this, r, e);
            return this._bindAction(l, s), this._addInactiveAction(l, a, i), l;
          },
          existingAction: function (t, e) {
            var n = e || this._root,
              i = n.uuid,
              r = "string" === typeof t ? kl.findByName(n, t) : t,
              a = r ? r.uuid : t,
              o = this._actionsByClip[a];
            return (void 0 !== o && o.actionByRoot[i]) || null;
          },
          stopAllAction: function () {
            var t = this._actions,
              e = this._nActiveActions,
              n = this._bindings,
              i = this._nActiveBindings;
            (this._nActiveActions = 0), (this._nActiveBindings = 0);
            for (var r = 0; r !== e; ++r) t[r].reset();
            for (r = 0; r !== i; ++r) n[r].useCount = 0;
            return this;
          },
          update: function (t) {
            t *= this.timeScale;
            for (
              var e = this._actions,
                n = this._nActiveActions,
                i = (this.time += t),
                r = Math.sign(t),
                a = (this._accuIndex ^= 1),
                o = 0;
              o !== n;
              ++o
            ) {
              var s = e[o];
              s._update(i, t, r, a);
            }
            var c = this._bindings,
              l = this._nActiveBindings;
            for (o = 0; o !== l; ++o) c[o].apply(a);
            return this;
          },
          getRoot: function () {
            return this._root;
          },
          uncacheClip: function (t) {
            var e = this._actions,
              n = t.uuid,
              i = this._actionsByClip,
              r = i[n];
            if (void 0 !== r) {
              for (var a = r.knownActions, o = 0, s = a.length; o !== s; ++o) {
                var c = a[o];
                this._deactivateAction(c);
                var l = c._cacheIndex,
                  h = e[e.length - 1];
                (c._cacheIndex = null),
                  (c._byClipCacheIndex = null),
                  (h._cacheIndex = l),
                  (e[l] = h),
                  e.pop(),
                  this._removeInactiveBindingsForAction(c);
              }
              delete i[n];
            }
          },
          uncacheRoot: function (t) {
            var e = t.uuid,
              n = this._actionsByClip;
            for (var i in n) {
              var r = n[i].actionByRoot,
                a = r[e];
              void 0 !== a &&
                (this._deactivateAction(a), this._removeInactiveAction(a));
            }
            var o = this._bindingsByRootAndName,
              s = o[e];
            if (void 0 !== s)
              for (var c in s) {
                var l = s[c];
                l.restoreOriginalState(), this._removeInactiveBinding(l);
              }
          },
          uncacheAction: function (t, e) {
            var n = this.existingAction(t, e);
            null !== n &&
              (this._deactivateAction(n), this._removeInactiveAction(n));
          },
        })),
        (wh.prototype.clone = function () {
          return new wh(
            void 0 === this.value.clone ? this.value : this.value.clone()
          );
        }),
        (Mh.prototype = Object.assign(Object.create(Nr.prototype), {
          constructor: Mh,
          isInstancedBufferGeometry: !0,
          copy: function (t) {
            return (
              Nr.prototype.copy.call(this, t),
              (this.maxInstancedCount = t.maxInstancedCount),
              this
            );
          },
          clone: function () {
            return new this.constructor().copy(this);
          },
        })),
        Object.defineProperties(Sh.prototype, {
          count: {
            get: function () {
              return this.data.count;
            },
          },
          array: {
            get: function () {
              return this.data.array;
            },
          },
        }),
        Object.assign(Sh.prototype, {
          isInterleavedBufferAttribute: !0,
          setX: function (t, e) {
            return (
              (this.data.array[t * this.data.stride + this.offset] = e), this
            );
          },
          setY: function (t, e) {
            return (
              (this.data.array[t * this.data.stride + this.offset + 1] = e),
              this
            );
          },
          setZ: function (t, e) {
            return (
              (this.data.array[t * this.data.stride + this.offset + 2] = e),
              this
            );
          },
          setW: function (t, e) {
            return (
              (this.data.array[t * this.data.stride + this.offset + 3] = e),
              this
            );
          },
          getX: function (t) {
            return this.data.array[t * this.data.stride + this.offset];
          },
          getY: function (t) {
            return this.data.array[t * this.data.stride + this.offset + 1];
          },
          getZ: function (t) {
            return this.data.array[t * this.data.stride + this.offset + 2];
          },
          getW: function (t) {
            return this.data.array[t * this.data.stride + this.offset + 3];
          },
          setXY: function (t, e, n) {
            return (
              (t = t * this.data.stride + this.offset),
              (this.data.array[t + 0] = e),
              (this.data.array[t + 1] = n),
              this
            );
          },
          setXYZ: function (t, e, n, i) {
            return (
              (t = t * this.data.stride + this.offset),
              (this.data.array[t + 0] = e),
              (this.data.array[t + 1] = n),
              (this.data.array[t + 2] = i),
              this
            );
          },
          setXYZW: function (t, e, n, i, r) {
            return (
              (t = t * this.data.stride + this.offset),
              (this.data.array[t + 0] = e),
              (this.data.array[t + 1] = n),
              (this.data.array[t + 2] = i),
              (this.data.array[t + 3] = r),
              this
            );
          },
        }),
        Object.defineProperty(Eh.prototype, "needsUpdate", {
          set: function (t) {
            !0 === t && this.version++;
          },
        }),
        Object.assign(Eh.prototype, {
          isInterleavedBuffer: !0,
          onUploadCallback: function () {},
          setArray: function (t) {
            if (Array.isArray(t))
              throw new TypeError(
                "THREE.BufferAttribute: array should be a Typed Array."
              );
            return (
              (this.count = void 0 !== t ? t.length / this.stride : 0),
              (this.array = t),
              this
            );
          },
          setDynamic: function (t) {
            return (this.dynamic = t), this;
          },
          copy: function (t) {
            return (
              (this.array = new t.array.constructor(t.array)),
              (this.count = t.count),
              (this.stride = t.stride),
              (this.dynamic = t.dynamic),
              this
            );
          },
          copyAt: function (t, e, n) {
            (t *= this.stride), (n *= e.stride);
            for (var i = 0, r = this.stride; i < r; i++)
              this.array[t + i] = e.array[n + i];
            return this;
          },
          set: function (t, e) {
            return void 0 === e && (e = 0), this.array.set(t, e), this;
          },
          clone: function () {
            return new this.constructor().copy(this);
          },
          onUpload: function (t) {
            return (this.onUploadCallback = t), this;
          },
        }),
        (Th.prototype = Object.assign(Object.create(Eh.prototype), {
          constructor: Th,
          isInstancedInterleavedBuffer: !0,
          copy: function (t) {
            return (
              Eh.prototype.copy.call(this, t),
              (this.meshPerAttribute = t.meshPerAttribute),
              this
            );
          },
        })),
        (Ah.prototype = Object.assign(Object.create(wr.prototype), {
          constructor: Ah,
          isInstancedBufferAttribute: !0,
          copy: function (t) {
            return (
              wr.prototype.copy.call(this, t),
              (this.meshPerAttribute = t.meshPerAttribute),
              this
            );
          },
        })),
        Object.assign(Ch.prototype, {
          linePrecision: 1,
          set: function (t, e) {
            this.ray.set(t, e);
          },
          setFromCamera: function (t, e) {
            e && e.isPerspectiveCamera
              ? (this.ray.origin.setFromMatrixPosition(e.matrixWorld),
                this.ray.direction
                  .set(t.x, t.y, 0.5)
                  .unproject(e)
                  .sub(this.ray.origin)
                  .normalize())
              : e && e.isOrthographicCamera
              ? (this.ray.origin
                  .set(t.x, t.y, (e.near + e.far) / (e.near - e.far))
                  .unproject(e),
                this.ray.direction
                  .set(0, 0, -1)
                  .transformDirection(e.matrixWorld))
              : console.error("THREE.Raycaster: Unsupported camera type.");
          },
          intersectObject: function (t, e, n) {
            var i = n || [];
            return Lh(t, this, i, e), i.sort(Rh), i;
          },
          intersectObjects: function (t, e, n) {
            var i = n || [];
            if (!1 === Array.isArray(t))
              return (
                console.warn(
                  "THREE.Raycaster.intersectObjects: objects is not an Array."
                ),
                i
              );
            for (var r = 0, a = t.length; r < a; r++) Lh(t[r], this, i, e);
            return i.sort(Rh), i;
          },
        }),
        Object.assign(Ph.prototype, {
          start: function () {
            (this.startTime = (
              "undefined" === typeof performance ? Date : performance
            ).now()),
              (this.oldTime = this.startTime),
              (this.elapsedTime = 0),
              (this.running = !0);
          },
          stop: function () {
            this.getElapsedTime(), (this.running = !1), (this.autoStart = !1);
          },
          getElapsedTime: function () {
            return this.getDelta(), this.elapsedTime;
          },
          getDelta: function () {
            var t = 0;
            if (this.autoStart && !this.running) return this.start(), 0;
            if (this.running) {
              var e = (
                "undefined" === typeof performance ? Date : performance
              ).now();
              (t = (e - this.oldTime) / 1e3),
                (this.oldTime = e),
                (this.elapsedTime += t);
            }
            return t;
          },
        }),
        Object.assign(Dh.prototype, {
          set: function (t, e, n) {
            return (this.radius = t), (this.phi = e), (this.theta = n), this;
          },
          clone: function () {
            return new this.constructor().copy(this);
          },
          copy: function (t) {
            return (
              (this.radius = t.radius),
              (this.phi = t.phi),
              (this.theta = t.theta),
              this
            );
          },
          makeSafe: function () {
            var t = 1e-6;
            return (
              (this.phi = Math.max(t, Math.min(Math.PI - t, this.phi))), this
            );
          },
          setFromVector3: function (t) {
            return (
              (this.radius = t.length()),
              0 === this.radius
                ? ((this.theta = 0), (this.phi = 0))
                : ((this.theta = Math.atan2(t.x, t.z)),
                  (this.phi = Math.acos(ze.clamp(t.y / this.radius, -1, 1)))),
              this
            );
          },
        }),
        Object.assign(Ih.prototype, {
          set: function (t, e, n) {
            return (this.radius = t), (this.theta = e), (this.y = n), this;
          },
          clone: function () {
            return new this.constructor().copy(this);
          },
          copy: function (t) {
            return (
              (this.radius = t.radius),
              (this.theta = t.theta),
              (this.y = t.y),
              this
            );
          },
          setFromVector3: function (t) {
            return (
              (this.radius = Math.sqrt(t.x * t.x + t.z * t.z)),
              (this.theta = Math.atan2(t.x, t.z)),
              (this.y = t.y),
              this
            );
          },
        }),
        Object.assign(Oh.prototype, {
          set: function (t, e) {
            return this.min.copy(t), this.max.copy(e), this;
          },
          setFromPoints: function (t) {
            this.makeEmpty();
            for (var e = 0, n = t.length; e < n; e++) this.expandByPoint(t[e]);
            return this;
          },
          setFromCenterAndSize: (function () {
            var t = new Ue();
            return function (e, n) {
              var i = t.copy(n).multiplyScalar(0.5);
              return this.min.copy(e).sub(i), this.max.copy(e).add(i), this;
            };
          })(),
          clone: function () {
            return new this.constructor().copy(this);
          },
          copy: function (t) {
            return this.min.copy(t.min), this.max.copy(t.max), this;
          },
          makeEmpty: function () {
            return (
              (this.min.x = this.min.y = 1 / 0),
              (this.max.x = this.max.y = -1 / 0),
              this
            );
          },
          isEmpty: function () {
            return this.max.x < this.min.x || this.max.y < this.min.y;
          },
          getCenter: function (t) {
            return (
              void 0 === t &&
                (console.warn(
                  "THREE.Box2: .getCenter() target is now required"
                ),
                (t = new Ue())),
              this.isEmpty()
                ? t.set(0, 0)
                : t.addVectors(this.min, this.max).multiplyScalar(0.5)
            );
          },
          getSize: function (t) {
            return (
              void 0 === t &&
                (console.warn("THREE.Box2: .getSize() target is now required"),
                (t = new Ue())),
              this.isEmpty() ? t.set(0, 0) : t.subVectors(this.max, this.min)
            );
          },
          expandByPoint: function (t) {
            return this.min.min(t), this.max.max(t), this;
          },
          expandByVector: function (t) {
            return this.min.sub(t), this.max.add(t), this;
          },
          expandByScalar: function (t) {
            return this.min.addScalar(-t), this.max.addScalar(t), this;
          },
          containsPoint: function (t) {
            return !(
              t.x < this.min.x ||
              t.x > this.max.x ||
              t.y < this.min.y ||
              t.y > this.max.y
            );
          },
          containsBox: function (t) {
            return (
              this.min.x <= t.min.x &&
              t.max.x <= this.max.x &&
              this.min.y <= t.min.y &&
              t.max.y <= this.max.y
            );
          },
          getParameter: function (t, e) {
            return (
              void 0 === e &&
                (console.warn(
                  "THREE.Box2: .getParameter() target is now required"
                ),
                (e = new Ue())),
              e.set(
                (t.x - this.min.x) / (this.max.x - this.min.x),
                (t.y - this.min.y) / (this.max.y - this.min.y)
              )
            );
          },
          intersectsBox: function (t) {
            return !(
              t.max.x < this.min.x ||
              t.min.x > this.max.x ||
              t.max.y < this.min.y ||
              t.min.y > this.max.y
            );
          },
          clampPoint: function (t, e) {
            return (
              void 0 === e &&
                (console.warn(
                  "THREE.Box2: .clampPoint() target is now required"
                ),
                (e = new Ue())),
              e.copy(t).clamp(this.min, this.max)
            );
          },
          distanceToPoint: (function () {
            var t = new Ue();
            return function (e) {
              var n = t.copy(e).clamp(this.min, this.max);
              return n.sub(e).length();
            };
          })(),
          intersect: function (t) {
            return this.min.max(t.min), this.max.min(t.max), this;
          },
          union: function (t) {
            return this.min.min(t.min), this.max.max(t.max), this;
          },
          translate: function (t) {
            return this.min.add(t), this.max.add(t), this;
          },
          equals: function (t) {
            return t.min.equals(this.min) && t.max.equals(this.max);
          },
        }),
        (Nh.prototype = Object.create(gr.prototype)),
        (Nh.prototype.constructor = Nh),
        (Nh.prototype.isImmediateRenderObject = !0),
        (Bh.prototype = Object.create(Jo.prototype)),
        (Bh.prototype.constructor = Bh),
        (Bh.prototype.update = (function () {
          var t = new ke(),
            e = new ke(),
            n = new Ge();
          return function () {
            var i = ["a", "b", "c"];
            this.object.updateMatrixWorld(!0),
              n.getNormalMatrix(this.object.matrixWorld);
            var r = this.object.matrixWorld,
              a = this.geometry.attributes.position,
              o = this.object.geometry;
            if (o && o.isGeometry)
              for (
                var s = o.vertices, c = o.faces, l = 0, h = 0, u = c.length;
                h < u;
                h++
              )
                for (
                  var d = c[h], p = 0, f = d.vertexNormals.length;
                  p < f;
                  p++
                ) {
                  var m = s[d[i[p]]],
                    g = d.vertexNormals[p];
                  t.copy(m).applyMatrix4(r),
                    e
                      .copy(g)
                      .applyMatrix3(n)
                      .normalize()
                      .multiplyScalar(this.size)
                      .add(t),
                    a.setXYZ(l, t.x, t.y, t.z),
                    (l += 1),
                    a.setXYZ(l, e.x, e.y, e.z),
                    (l += 1);
                }
            else if (o && o.isBufferGeometry) {
              var v = o.attributes.position,
                y = o.attributes.normal;
              for (l = 0, p = 0, f = v.count; p < f; p++)
                t.set(v.getX(p), v.getY(p), v.getZ(p)).applyMatrix4(r),
                  e.set(y.getX(p), y.getY(p), y.getZ(p)),
                  e
                    .applyMatrix3(n)
                    .normalize()
                    .multiplyScalar(this.size)
                    .add(t),
                  a.setXYZ(l, t.x, t.y, t.z),
                  (l += 1),
                  a.setXYZ(l, e.x, e.y, e.z),
                  (l += 1);
            }
            a.needsUpdate = !0;
          };
        })()),
        (zh.prototype = Object.create(gr.prototype)),
        (zh.prototype.constructor = zh),
        (zh.prototype.dispose = function () {
          this.cone.geometry.dispose(), this.cone.material.dispose();
        }),
        (zh.prototype.update = (function () {
          var t = new ke(),
            e = new ke();
          return function () {
            this.light.updateMatrixWorld();
            var n = this.light.distance ? this.light.distance : 1e3,
              i = n * Math.tan(this.light.angle);
            this.cone.scale.set(i, i, n),
              t.setFromMatrixPosition(this.light.matrixWorld),
              e.setFromMatrixPosition(this.light.target.matrixWorld),
              this.cone.lookAt(e.sub(t)),
              void 0 !== this.color
                ? this.cone.material.color.set(this.color)
                : this.cone.material.color.copy(this.light.color);
          };
        })()),
        (Fh.prototype = Object.create(Jo.prototype)),
        (Fh.prototype.constructor = Fh),
        (Fh.prototype.updateMatrixWorld = (function () {
          var t = new ke(),
            e = new Fe(),
            n = new Fe();
          return function (i) {
            var r = this.bones,
              a = this.geometry,
              o = a.getAttribute("position");
            n.getInverse(this.root.matrixWorld);
            for (var s = 0, c = 0; s < r.length; s++) {
              var l = r[s];
              l.parent &&
                l.parent.isBone &&
                (e.multiplyMatrices(n, l.matrixWorld),
                t.setFromMatrixPosition(e),
                o.setXYZ(c, t.x, t.y, t.z),
                e.multiplyMatrices(n, l.parent.matrixWorld),
                t.setFromMatrixPosition(e),
                o.setXYZ(c + 1, t.x, t.y, t.z),
                (c += 2));
            }
            (a.getAttribute("position").needsUpdate = !0),
              gr.prototype.updateMatrixWorld.call(this, i);
          };
        })()),
        (Hh.prototype = Object.create(Xr.prototype)),
        (Hh.prototype.constructor = Hh),
        (Hh.prototype.dispose = function () {
          this.geometry.dispose(), this.material.dispose();
        }),
        (Hh.prototype.update = function () {
          void 0 !== this.color
            ? this.material.color.set(this.color)
            : this.material.color.copy(this.light.color);
        }),
        (kh.prototype = Object.create(gr.prototype)),
        (kh.prototype.constructor = kh),
        (kh.prototype.dispose = function () {
          this.children[0].geometry.dispose(),
            this.children[0].material.dispose();
        }),
        (kh.prototype.update = function () {
          var t = 0.5 * this.light.width,
            e = 0.5 * this.light.height,
            n = this.line.geometry.attributes.position,
            i = n.array;
          (i[0] = t),
            (i[1] = -e),
            (i[2] = 0),
            (i[3] = t),
            (i[4] = e),
            (i[5] = 0),
            (i[6] = -t),
            (i[7] = e),
            (i[8] = 0),
            (i[9] = -t),
            (i[10] = -e),
            (i[11] = 0),
            (i[12] = t),
            (i[13] = -e),
            (i[14] = 0),
            (n.needsUpdate = !0),
            void 0 !== this.color
              ? this.line.material.color.set(this.color)
              : this.line.material.color.copy(this.light.color);
        }),
        (Gh.prototype = Object.create(gr.prototype)),
        (Gh.prototype.constructor = Gh),
        (Gh.prototype.dispose = function () {
          this.children[0].geometry.dispose(),
            this.children[0].material.dispose();
        }),
        (Gh.prototype.update = (function () {
          var t = new ke(),
            e = new cr(),
            n = new cr();
          return function () {
            var i = this.children[0];
            if (void 0 !== this.color) this.material.color.set(this.color);
            else {
              var r = i.geometry.getAttribute("color");
              e.copy(this.light.color), n.copy(this.light.groundColor);
              for (var a = 0, o = r.count; a < o; a++) {
                var s = a < o / 2 ? e : n;
                r.setXYZ(a, s.r, s.g, s.b);
              }
              r.needsUpdate = !0;
            }
            i.lookAt(t.setFromMatrixPosition(this.light.matrixWorld).negate());
          };
        })()),
        (Vh.prototype = Object.create(Jo.prototype)),
        (Vh.prototype.constructor = Vh),
        (Wh.prototype = Object.create(Jo.prototype)),
        (Wh.prototype.constructor = Wh),
        (jh.prototype = Object.create(Jo.prototype)),
        (jh.prototype.constructor = jh),
        (jh.prototype.update = (function () {
          var t = new ke(),
            e = new ke(),
            n = new Ge();
          return function () {
            this.object.updateMatrixWorld(!0),
              n.getNormalMatrix(this.object.matrixWorld);
            for (
              var i = this.object.matrixWorld,
                r = this.geometry.attributes.position,
                a = this.object.geometry,
                o = a.vertices,
                s = a.faces,
                c = 0,
                l = 0,
                h = s.length;
              l < h;
              l++
            ) {
              var u = s[l],
                d = u.normal;
              t
                .copy(o[u.a])
                .add(o[u.b])
                .add(o[u.c])
                .divideScalar(3)
                .applyMatrix4(i),
                e
                  .copy(d)
                  .applyMatrix3(n)
                  .normalize()
                  .multiplyScalar(this.size)
                  .add(t),
                r.setXYZ(c, t.x, t.y, t.z),
                (c += 1),
                r.setXYZ(c, e.x, e.y, e.z),
                (c += 1);
            }
            r.needsUpdate = !0;
          };
        })()),
        (qh.prototype = Object.create(gr.prototype)),
        (qh.prototype.constructor = qh),
        (qh.prototype.dispose = function () {
          this.lightPlane.geometry.dispose(),
            this.lightPlane.material.dispose(),
            this.targetLine.geometry.dispose(),
            this.targetLine.material.dispose();
        }),
        (qh.prototype.update = (function () {
          var t = new ke(),
            e = new ke(),
            n = new ke();
          return function () {
            t.setFromMatrixPosition(this.light.matrixWorld),
              e.setFromMatrixPosition(this.light.target.matrixWorld),
              n.subVectors(e, t),
              this.lightPlane.lookAt(n),
              void 0 !== this.color
                ? (this.lightPlane.material.color.set(this.color),
                  this.targetLine.material.color.set(this.color))
                : (this.lightPlane.material.color.copy(this.light.color),
                  this.targetLine.material.color.copy(this.light.color)),
              this.targetLine.lookAt(n),
              (this.targetLine.scale.z = n.length());
          };
        })()),
        (Xh.prototype = Object.create(Jo.prototype)),
        (Xh.prototype.constructor = Xh),
        (Xh.prototype.update = (function () {
          var t,
            e,
            n = new ke(),
            i = new vr();
          function r(r, a, o, s) {
            n.set(a, o, s).unproject(i);
            var c = e[r];
            if (void 0 !== c)
              for (
                var l = t.getAttribute("position"), h = 0, u = c.length;
                h < u;
                h++
              )
                l.setXYZ(c[h], n.x, n.y, n.z);
          }
          return function () {
            (t = this.geometry), (e = this.pointMap);
            var n = 1,
              a = 1;
            i.projectionMatrix.copy(this.camera.projectionMatrix),
              r("c", 0, 0, -1),
              r("t", 0, 0, 1),
              r("n1", -n, -a, -1),
              r("n2", n, -a, -1),
              r("n3", -n, a, -1),
              r("n4", n, a, -1),
              r("f1", -n, -a, 1),
              r("f2", n, -a, 1),
              r("f3", -n, a, 1),
              r("f4", n, a, 1),
              r("u1", 0.7 * n, 1.1 * a, -1),
              r("u2", 0.7 * -n, 1.1 * a, -1),
              r("u3", 0, 2 * a, -1),
              r("cf1", -n, 0, 1),
              r("cf2", n, 0, 1),
              r("cf3", 0, -a, 1),
              r("cf4", 0, a, 1),
              r("cn1", -n, 0, -1),
              r("cn2", n, 0, -1),
              r("cn3", 0, -a, -1),
              r("cn4", 0, a, -1),
              (t.getAttribute("position").needsUpdate = !0);
          };
        })()),
        (Yh.prototype = Object.create(Jo.prototype)),
        (Yh.prototype.constructor = Yh),
        (Yh.prototype.update = (function () {
          var t = new Je();
          return function (e) {
            if (
              (void 0 !== e &&
                console.warn(
                  "THREE.BoxHelper: .update() has no longer arguments."
                ),
              void 0 !== this.object && t.setFromObject(this.object),
              !t.isEmpty())
            ) {
              var n = t.min,
                i = t.max,
                r = this.geometry.attributes.position,
                a = r.array;
              (a[0] = i.x),
                (a[1] = i.y),
                (a[2] = i.z),
                (a[3] = n.x),
                (a[4] = i.y),
                (a[5] = i.z),
                (a[6] = n.x),
                (a[7] = n.y),
                (a[8] = i.z),
                (a[9] = i.x),
                (a[10] = n.y),
                (a[11] = i.z),
                (a[12] = i.x),
                (a[13] = i.y),
                (a[14] = n.z),
                (a[15] = n.x),
                (a[16] = i.y),
                (a[17] = n.z),
                (a[18] = n.x),
                (a[19] = n.y),
                (a[20] = n.z),
                (a[21] = i.x),
                (a[22] = n.y),
                (a[23] = n.z),
                (r.needsUpdate = !0),
                this.geometry.computeBoundingSphere();
            }
          };
        })()),
        (Yh.prototype.setFromObject = function (t) {
          return (this.object = t), this.update(), this;
        }),
        (Jh.prototype = Object.create(Jo.prototype)),
        (Jh.prototype.constructor = Jh),
        (Jh.prototype.updateMatrixWorld = function (t) {
          var e = this.box;
          e.isEmpty() ||
            (e.getCenter(this.position),
            e.getSize(this.scale),
            this.scale.multiplyScalar(0.5),
            gr.prototype.updateMatrixWorld.call(this, t));
        }),
        (Zh.prototype = Object.create(Yo.prototype)),
        (Zh.prototype.constructor = Zh),
        (Zh.prototype.updateMatrixWorld = function (t) {
          var e = -this.plane.constant;
          Math.abs(e) < 1e-8 && (e = 1e-8),
            this.scale.set(0.5 * this.size, 0.5 * this.size, e),
            (this.children[0].material.side = e < 0 ? g : m),
            this.lookAt(this.plane.normal),
            gr.prototype.updateMatrixWorld.call(this, t);
        }),
        (Kh.prototype = Object.create(gr.prototype)),
        (Kh.prototype.constructor = Kh),
        (Kh.prototype.setDirection = (function () {
          var t,
            e = new ke();
          return function (n) {
            n.y > 0.99999
              ? this.quaternion.set(0, 0, 0, 1)
              : n.y < -0.99999
              ? this.quaternion.set(1, 0, 0, 0)
              : (e.set(n.z, 0, -n.x).normalize(),
                (t = Math.acos(n.y)),
                this.quaternion.setFromAxisAngle(e, t));
          };
        })()),
        (Kh.prototype.setLength = function (t, e, n) {
          void 0 === e && (e = 0.2 * t),
            void 0 === n && (n = 0.2 * e),
            this.line.scale.set(1, Math.max(0, t - e), 1),
            this.line.updateMatrix(),
            this.cone.scale.set(n, e, n),
            (this.cone.position.y = t),
            this.cone.updateMatrix();
        }),
        (Kh.prototype.setColor = function (t) {
          this.line.material.color.copy(t), this.cone.material.color.copy(t);
        }),
        ($h.prototype = Object.create(Jo.prototype)),
        ($h.prototype.constructor = $h);
      var tu = 0,
        eu = 1;
      function nu(t) {
        return (
          console.warn(
            "THREE.MeshFaceMaterial has been removed. Use an Array instead."
          ),
          t
        );
      }
      function iu(t) {
        return (
          void 0 === t && (t = []),
          console.warn(
            "THREE.MultiMaterial has been removed. Use an Array instead."
          ),
          (t.isMultiMaterial = !0),
          (t.materials = t),
          (t.clone = function () {
            return t.slice();
          }),
          t
        );
      }
      function ru(t, e) {
        return (
          console.warn("THREE.PointCloud has been renamed to THREE.Points."),
          new $o(t, e)
        );
      }
      function au(t) {
        return (
          console.warn("THREE.Particle has been renamed to THREE.Sprite."),
          new Go(t)
        );
      }
      function ou(t, e) {
        return (
          console.warn(
            "THREE.ParticleSystem has been renamed to THREE.Points."
          ),
          new $o(t, e)
        );
      }
      function su(t) {
        return (
          console.warn(
            "THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial."
          ),
          new Ko(t)
        );
      }
      function cu(t) {
        return (
          console.warn(
            "THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial."
          ),
          new Ko(t)
        );
      }
      function lu(t) {
        return (
          console.warn(
            "THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial."
          ),
          new Ko(t)
        );
      }
      function hu(t, e, n) {
        return (
          console.warn(
            "THREE.Vertex has been removed. Use THREE.Vector3 instead."
          ),
          new ke(t, e, n)
        );
      }
      function uu(t, e) {
        return (
          console.warn(
            "THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead."
          ),
          new wr(t, e).setDynamic(!0)
        );
      }
      function du(t, e) {
        return (
          console.warn(
            "THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead."
          ),
          new Mr(t, e)
        );
      }
      function pu(t, e) {
        return (
          console.warn(
            "THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead."
          ),
          new Sr(t, e)
        );
      }
      function fu(t, e) {
        return (
          console.warn(
            "THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead."
          ),
          new Er(t, e)
        );
      }
      function mu(t, e) {
        return (
          console.warn(
            "THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead."
          ),
          new Tr(t, e)
        );
      }
      function gu(t, e) {
        return (
          console.warn(
            "THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead."
          ),
          new Ar(t, e)
        );
      }
      function vu(t, e) {
        return (
          console.warn(
            "THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead."
          ),
          new Cr(t, e)
        );
      }
      function yu(t, e) {
        return (
          console.warn(
            "THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead."
          ),
          new Rr(t, e)
        );
      }
      function xu(t, e) {
        return (
          console.warn(
            "THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead."
          ),
          new Lr(t, e)
        );
      }
      function _u(t, e) {
        return (
          console.warn(
            "THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead."
          ),
          new Pr(t, e)
        );
      }
      function bu(t) {
        console.warn(
          "THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."
        ),
          Zc.call(this, t),
          (this.type = "catmullrom"),
          (this.closed = !0);
      }
      function wu(t) {
        console.warn(
          "THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."
        ),
          Zc.call(this, t),
          (this.type = "catmullrom");
      }
      function Mu(t) {
        console.warn(
          "THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead."
        ),
          Zc.call(this, t),
          (this.type = "catmullrom");
      }
      function Su(t) {
        return (
          console.warn(
            "THREE.AxisHelper has been renamed to THREE.AxesHelper."
          ),
          new $h(t)
        );
      }
      function Eu(t, e) {
        return (
          console.warn(
            "THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead."
          ),
          new Yh(t, e)
        );
      }
      function Tu(t, e) {
        return (
          console.warn(
            "THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead."
          ),
          new Jo(
            new fc(t.geometry),
            new Xo({ color: void 0 !== e ? e : 16777215 })
          )
        );
      }
      function Au(t, e) {
        return (
          console.warn(
            "THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead."
          ),
          new Jo(
            new ns(t.geometry),
            new Xo({ color: void 0 !== e ? e : 16777215 })
          )
        );
      }
      function Cu(t) {
        return (
          console.warn("THREE.XHRLoader has been renamed to THREE.FileLoader."),
          new Bc(t)
        );
      }
      function Ru(t) {
        return (
          console.warn(
            "THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader."
          ),
          new Uc(t)
        );
      }
      (Gc.create = function (t, e) {
        return (
          console.log("THREE.Curve.create() has been deprecated"),
          (t.prototype = Object.create(Gc.prototype)),
          (t.prototype.constructor = t),
          (t.prototype.getPoint = e),
          t
        );
      }),
        Object.assign(ml.prototype, {
          createPointsGeometry: function (t) {
            console.warn(
              "THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead."
            );
            var e = this.getPoints(t);
            return this.createGeometry(e);
          },
          createSpacedPointsGeometry: function (t) {
            console.warn(
              "THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead."
            );
            var e = this.getSpacedPoints(t);
            return this.createGeometry(e);
          },
          createGeometry: function (t) {
            console.warn(
              "THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead."
            );
            for (var e = new br(), n = 0, i = t.length; n < i; n++) {
              var r = t[n];
              e.vertices.push(new ke(r.x, r.y, r.z || 0));
            }
            return e;
          },
        }),
        Object.assign(gl.prototype, {
          fromPoints: function (t) {
            console.warn(
              "THREE.Path: .fromPoints() has been renamed to .setFromPoints()."
            ),
              this.setFromPoints(t);
          },
        }),
        (bu.prototype = Object.create(Zc.prototype)),
        (wu.prototype = Object.create(Zc.prototype)),
        (Mu.prototype = Object.create(Zc.prototype)),
        Object.assign(Mu.prototype, {
          initFromArray: function () {
            console.error("THREE.Spline: .initFromArray() has been removed.");
          },
          getControlPointsArray: function () {
            console.error(
              "THREE.Spline: .getControlPointsArray() has been removed."
            );
          },
          reparametrizeByArcLength: function () {
            console.error(
              "THREE.Spline: .reparametrizeByArcLength() has been removed."
            );
          },
        }),
        (Vh.prototype.setColors = function () {
          console.error(
            "THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead."
          );
        }),
        (Fh.prototype.update = function () {
          console.error(
            "THREE.SkeletonHelper: update() no longer needs to be called."
          );
        }),
        Object.assign(jl.prototype, {
          extractUrlBase: function (t) {
            return (
              console.warn(
                "THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."
              ),
              ql.extractUrlBase(t)
            );
          },
        }),
        Object.assign(Oh.prototype, {
          center: function (t) {
            return (
              console.warn(
                "THREE.Box2: .center() has been renamed to .getCenter()."
              ),
              this.getCenter(t)
            );
          },
          empty: function () {
            return (
              console.warn(
                "THREE.Box2: .empty() has been renamed to .isEmpty()."
              ),
              this.isEmpty()
            );
          },
          isIntersectionBox: function (t) {
            return (
              console.warn(
                "THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."
              ),
              this.intersectsBox(t)
            );
          },
          size: function (t) {
            return (
              console.warn(
                "THREE.Box2: .size() has been renamed to .getSize()."
              ),
              this.getSize(t)
            );
          },
        }),
        Object.assign(Je.prototype, {
          center: function (t) {
            return (
              console.warn(
                "THREE.Box3: .center() has been renamed to .getCenter()."
              ),
              this.getCenter(t)
            );
          },
          empty: function () {
            return (
              console.warn(
                "THREE.Box3: .empty() has been renamed to .isEmpty()."
              ),
              this.isEmpty()
            );
          },
          isIntersectionBox: function (t) {
            return (
              console.warn(
                "THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."
              ),
              this.intersectsBox(t)
            );
          },
          isIntersectionSphere: function (t) {
            return (
              console.warn(
                "THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."
              ),
              this.intersectsSphere(t)
            );
          },
          size: function (t) {
            return (
              console.warn(
                "THREE.Box3: .size() has been renamed to .getSize()."
              ),
              this.getSize(t)
            );
          },
        }),
        (jr.prototype.center = function (t) {
          return (
            console.warn(
              "THREE.Line3: .center() has been renamed to .getCenter()."
            ),
            this.getCenter(t)
          );
        }),
        Object.assign(ze, {
          random16: function () {
            return (
              console.warn(
                "THREE.Math: .random16() has been deprecated. Use Math.random() instead."
              ),
              Math.random()
            );
          },
          nearestPowerOfTwo: function (t) {
            return (
              console.warn(
                "THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo()."
              ),
              ze.floorPowerOfTwo(t)
            );
          },
          nextPowerOfTwo: function (t) {
            return (
              console.warn(
                "THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo()."
              ),
              ze.ceilPowerOfTwo(t)
            );
          },
        }),
        Object.assign(Ge.prototype, {
          flattenToArrayOffset: function (t, e) {
            return (
              console.warn(
                "THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."
              ),
              this.toArray(t, e)
            );
          },
          multiplyVector3: function (t) {
            return (
              console.warn(
                "THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."
              ),
              t.applyMatrix3(this)
            );
          },
          multiplyVector3Array: function () {
            console.error(
              "THREE.Matrix3: .multiplyVector3Array() has been removed."
            );
          },
          applyToBuffer: function (t) {
            return (
              console.warn(
                "THREE.Matrix3: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead."
              ),
              this.applyToBufferAttribute(t)
            );
          },
          applyToVector3Array: function () {
            console.error(
              "THREE.Matrix3: .applyToVector3Array() has been removed."
            );
          },
        }),
        Object.assign(Fe.prototype, {
          extractPosition: function (t) {
            return (
              console.warn(
                "THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."
              ),
              this.copyPosition(t)
            );
          },
          flattenToArrayOffset: function (t, e) {
            return (
              console.warn(
                "THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."
              ),
              this.toArray(t, e)
            );
          },
          getPosition: (function () {
            var t;
            return function () {
              return (
                void 0 === t && (t = new ke()),
                console.warn(
                  "THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."
                ),
                t.setFromMatrixColumn(this, 3)
              );
            };
          })(),
          setRotationFromQuaternion: function (t) {
            return (
              console.warn(
                "THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."
              ),
              this.makeRotationFromQuaternion(t)
            );
          },
          multiplyToArray: function () {
            console.warn("THREE.Matrix4: .multiplyToArray() has been removed.");
          },
          multiplyVector3: function (t) {
            return (
              console.warn(
                "THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."
              ),
              t.applyMatrix4(this)
            );
          },
          multiplyVector4: function (t) {
            return (
              console.warn(
                "THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."
              ),
              t.applyMatrix4(this)
            );
          },
          multiplyVector3Array: function () {
            console.error(
              "THREE.Matrix4: .multiplyVector3Array() has been removed."
            );
          },
          rotateAxis: function (t) {
            console.warn(
              "THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."
            ),
              t.transformDirection(this);
          },
          crossVector: function (t) {
            return (
              console.warn(
                "THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."
              ),
              t.applyMatrix4(this)
            );
          },
          translate: function () {
            console.error("THREE.Matrix4: .translate() has been removed.");
          },
          rotateX: function () {
            console.error("THREE.Matrix4: .rotateX() has been removed.");
          },
          rotateY: function () {
            console.error("THREE.Matrix4: .rotateY() has been removed.");
          },
          rotateZ: function () {
            console.error("THREE.Matrix4: .rotateZ() has been removed.");
          },
          rotateByAxis: function () {
            console.error("THREE.Matrix4: .rotateByAxis() has been removed.");
          },
          applyToBuffer: function (t) {
            return (
              console.warn(
                "THREE.Matrix4: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead."
              ),
              this.applyToBufferAttribute(t)
            );
          },
          applyToVector3Array: function () {
            console.error(
              "THREE.Matrix4: .applyToVector3Array() has been removed."
            );
          },
          makeFrustum: function (t, e, n, i, r, a) {
            return (
              console.warn(
                "THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."
              ),
              this.makePerspective(t, e, i, n, r, a)
            );
          },
        }),
        (Ke.prototype.isIntersectionLine = function (t) {
          return (
            console.warn(
              "THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."
            ),
            this.intersectsLine(t)
          );
        }),
        (He.prototype.multiplyVector3 = function (t) {
          return (
            console.warn(
              "THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."
            ),
            t.applyQuaternion(this)
          );
        }),
        Object.assign(Wr.prototype, {
          isIntersectionBox: function (t) {
            return (
              console.warn(
                "THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."
              ),
              this.intersectsBox(t)
            );
          },
          isIntersectionPlane: function (t) {
            return (
              console.warn(
                "THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."
              ),
              this.intersectsPlane(t)
            );
          },
          isIntersectionSphere: function (t) {
            return (
              console.warn(
                "THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."
              ),
              this.intersectsSphere(t)
            );
          },
        }),
        Object.assign(qr.prototype, {
          area: function () {
            return (
              console.warn(
                "THREE.Triangle: .area() has been renamed to .getArea()."
              ),
              this.getArea()
            );
          },
          barycoordFromPoint: function (t, e) {
            return (
              console.warn(
                "THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."
              ),
              this.getBarycoord(t, e)
            );
          },
          midpoint: function (t) {
            return (
              console.warn(
                "THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."
              ),
              this.getMidpoint(t)
            );
          },
          normal: function (t) {
            return (
              console.warn(
                "THREE.Triangle: .normal() has been renamed to .getNormal()."
              ),
              this.getNormal(t)
            );
          },
          plane: function (t) {
            return (
              console.warn(
                "THREE.Triangle: .plane() has been renamed to .getPlane()."
              ),
              this.getPlane(t)
            );
          },
        }),
        Object.assign(qr, {
          barycoordFromPoint: function (t, e, n, i, r) {
            return (
              console.warn(
                "THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."
              ),
              qr.getBarycoord(t, e, n, i, r)
            );
          },
          normal: function (t, e, n, i) {
            return (
              console.warn(
                "THREE.Triangle: .normal() has been renamed to .getNormal()."
              ),
              qr.getNormal(t, e, n, i)
            );
          },
        }),
        Object.assign(vl.prototype, {
          extractAllPoints: function (t) {
            return (
              console.warn(
                "THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."
              ),
              this.extractPoints(t)
            );
          },
          extrude: function (t) {
            return (
              console.warn(
                "THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."
              ),
              new Qs(this, t)
            );
          },
          makeGeometry: function (t) {
            return (
              console.warn(
                "THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."
              ),
              new uc(this, t)
            );
          },
        }),
        Object.assign(Ue.prototype, {
          fromAttribute: function (t, e, n) {
            return (
              console.warn(
                "THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."
              ),
              this.fromBufferAttribute(t, e, n)
            );
          },
          distanceToManhattan: function (t) {
            return (
              console.warn(
                "THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."
              ),
              this.manhattanDistanceTo(t)
            );
          },
          lengthManhattan: function () {
            return (
              console.warn(
                "THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."
              ),
              this.manhattanLength()
            );
          },
        }),
        Object.assign(ke.prototype, {
          setEulerFromRotationMatrix: function () {
            console.error(
              "THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead."
            );
          },
          setEulerFromQuaternion: function () {
            console.error(
              "THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead."
            );
          },
          getPositionFromMatrix: function (t) {
            return (
              console.warn(
                "THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."
              ),
              this.setFromMatrixPosition(t)
            );
          },
          getScaleFromMatrix: function (t) {
            return (
              console.warn(
                "THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."
              ),
              this.setFromMatrixScale(t)
            );
          },
          getColumnFromMatrix: function (t, e) {
            return (
              console.warn(
                "THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."
              ),
              this.setFromMatrixColumn(e, t)
            );
          },
          applyProjection: function (t) {
            return (
              console.warn(
                "THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."
              ),
              this.applyMatrix4(t)
            );
          },
          fromAttribute: function (t, e, n) {
            return (
              console.warn(
                "THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."
              ),
              this.fromBufferAttribute(t, e, n)
            );
          },
          distanceToManhattan: function (t) {
            return (
              console.warn(
                "THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."
              ),
              this.manhattanDistanceTo(t)
            );
          },
          lengthManhattan: function () {
            return (
              console.warn(
                "THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."
              ),
              this.manhattanLength()
            );
          },
        }),
        Object.assign(je.prototype, {
          fromAttribute: function (t, e, n) {
            return (
              console.warn(
                "THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."
              ),
              this.fromBufferAttribute(t, e, n)
            );
          },
          lengthManhattan: function () {
            return (
              console.warn(
                "THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."
              ),
              this.manhattanLength()
            );
          },
        }),
        Object.assign(br.prototype, {
          computeTangents: function () {
            console.error(
              "THREE.Geometry: .computeTangents() has been removed."
            );
          },
          computeLineDistances: function () {
            console.error(
              "THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead."
            );
          },
        }),
        Object.assign(gr.prototype, {
          getChildByName: function (t) {
            return (
              console.warn(
                "THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."
              ),
              this.getObjectByName(t)
            );
          },
          renderDepth: function () {
            console.warn(
              "THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead."
            );
          },
          translate: function (t, e) {
            return (
              console.warn(
                "THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."
              ),
              this.translateOnAxis(e, t)
            );
          },
          getWorldRotation: function () {
            console.error(
              "THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead."
            );
          },
        }),
        Object.defineProperties(gr.prototype, {
          eulerOrder: {
            get: function () {
              return (
                console.warn(
                  "THREE.Object3D: .eulerOrder is now .rotation.order."
                ),
                this.rotation.order
              );
            },
            set: function (t) {
              console.warn(
                "THREE.Object3D: .eulerOrder is now .rotation.order."
              ),
                (this.rotation.order = t);
            },
          },
          useQuaternion: {
            get: function () {
              console.warn(
                "THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default."
              );
            },
            set: function () {
              console.warn(
                "THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default."
              );
            },
          },
        }),
        Object.defineProperties(Vo.prototype, {
          objects: {
            get: function () {
              return (
                console.warn(
                  "THREE.LOD: .objects has been renamed to .levels."
                ),
                this.levels
              );
            },
          },
        }),
        Object.defineProperty(Wo.prototype, "useVertexTexture", {
          get: function () {
            console.warn("THREE.Skeleton: useVertexTexture has been removed.");
          },
          set: function () {
            console.warn("THREE.Skeleton: useVertexTexture has been removed.");
          },
        }),
        Object.defineProperty(Gc.prototype, "__arcLengthDivisions", {
          get: function () {
            return (
              console.warn(
                "THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."
              ),
              this.arcLengthDivisions
            );
          },
          set: function (t) {
            console.warn(
              "THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."
            ),
              (this.arcLengthDivisions = t);
          },
        }),
        (Io.prototype.setLens = function (t, e) {
          console.warn(
            "THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."
          ),
            void 0 !== e && (this.filmGauge = e),
            this.setFocalLength(t);
        }),
        Object.defineProperties(yl.prototype, {
          onlyShadow: {
            set: function () {
              console.warn("THREE.Light: .onlyShadow has been removed.");
            },
          },
          shadowCameraFov: {
            set: function (t) {
              console.warn(
                "THREE.Light: .shadowCameraFov is now .shadow.camera.fov."
              ),
                (this.shadow.camera.fov = t);
            },
          },
          shadowCameraLeft: {
            set: function (t) {
              console.warn(
                "THREE.Light: .shadowCameraLeft is now .shadow.camera.left."
              ),
                (this.shadow.camera.left = t);
            },
          },
          shadowCameraRight: {
            set: function (t) {
              console.warn(
                "THREE.Light: .shadowCameraRight is now .shadow.camera.right."
              ),
                (this.shadow.camera.right = t);
            },
          },
          shadowCameraTop: {
            set: function (t) {
              console.warn(
                "THREE.Light: .shadowCameraTop is now .shadow.camera.top."
              ),
                (this.shadow.camera.top = t);
            },
          },
          shadowCameraBottom: {
            set: function (t) {
              console.warn(
                "THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."
              ),
                (this.shadow.camera.bottom = t);
            },
          },
          shadowCameraNear: {
            set: function (t) {
              console.warn(
                "THREE.Light: .shadowCameraNear is now .shadow.camera.near."
              ),
                (this.shadow.camera.near = t);
            },
          },
          shadowCameraFar: {
            set: function (t) {
              console.warn(
                "THREE.Light: .shadowCameraFar is now .shadow.camera.far."
              ),
                (this.shadow.camera.far = t);
            },
          },
          shadowCameraVisible: {
            set: function () {
              console.warn(
                "THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead."
              );
            },
          },
          shadowBias: {
            set: function (t) {
              console.warn("THREE.Light: .shadowBias is now .shadow.bias."),
                (this.shadow.bias = t);
            },
          },
          shadowDarkness: {
            set: function () {
              console.warn("THREE.Light: .shadowDarkness has been removed.");
            },
          },
          shadowMapWidth: {
            set: function (t) {
              console.warn(
                "THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."
              ),
                (this.shadow.mapSize.width = t);
            },
          },
          shadowMapHeight: {
            set: function (t) {
              console.warn(
                "THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."
              ),
                (this.shadow.mapSize.height = t);
            },
          },
        }),
        Object.defineProperties(wr.prototype, {
          length: {
            get: function () {
              return (
                console.warn(
                  "THREE.BufferAttribute: .length has been deprecated. Use .count instead."
                ),
                this.array.length
              );
            },
          },
          copyIndicesArray: function () {
            console.error(
              "THREE.BufferAttribute: .copyIndicesArray() has been removed."
            );
          },
        }),
        Object.assign(Nr.prototype, {
          addIndex: function (t) {
            console.warn(
              "THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."
            ),
              this.setIndex(t);
          },
          addDrawCall: function (t, e, n) {
            void 0 !== n &&
              console.warn(
                "THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."
              ),
              console.warn(
                "THREE.BufferGeometry: .addDrawCall() is now .addGroup()."
              ),
              this.addGroup(t, e);
          },
          clearDrawCalls: function () {
            console.warn(
              "THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."
            ),
              this.clearGroups();
          },
          computeTangents: function () {
            console.warn(
              "THREE.BufferGeometry: .computeTangents() has been removed."
            );
          },
          computeOffsets: function () {
            console.warn(
              "THREE.BufferGeometry: .computeOffsets() has been removed."
            );
          },
        }),
        Object.defineProperties(Nr.prototype, {
          drawcalls: {
            get: function () {
              return (
                console.error(
                  "THREE.BufferGeometry: .drawcalls has been renamed to .groups."
                ),
                this.groups
              );
            },
          },
          offsets: {
            get: function () {
              return (
                console.warn(
                  "THREE.BufferGeometry: .offsets has been renamed to .groups."
                ),
                this.groups
              );
            },
          },
        }),
        Object.assign(tc.prototype, {
          getArrays: function () {
            console.error(
              "THREE.ExtrudeBufferGeometry: .getArrays() has been removed."
            );
          },
          addShapeList: function () {
            console.error(
              "THREE.ExtrudeBufferGeometry: .addShapeList() has been removed."
            );
          },
          addShape: function () {
            console.error(
              "THREE.ExtrudeBufferGeometry: .addShape() has been removed."
            );
          },
        }),
        Object.defineProperties(wh.prototype, {
          dynamic: {
            set: function () {
              console.warn(
                "THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead."
              );
            },
          },
          onUpdate: {
            value: function () {
              return (
                console.warn(
                  "THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."
                ),
                this
              );
            },
          },
        }),
        Object.defineProperties(kr.prototype, {
          wrapAround: {
            get: function () {
              console.warn("THREE.Material: .wrapAround has been removed.");
            },
            set: function () {
              console.warn("THREE.Material: .wrapAround has been removed.");
            },
          },
          wrapRGB: {
            get: function () {
              return (
                console.warn("THREE.Material: .wrapRGB has been removed."),
                new cr()
              );
            },
          },
          shading: {
            get: function () {
              console.error(
                "THREE." +
                  this.type +
                  ": .shading has been removed. Use the boolean .flatShading instead."
              );
            },
            set: function (t) {
              console.warn(
                "THREE." +
                  this.type +
                  ": .shading has been removed. Use the boolean .flatShading instead."
              ),
                (this.flatShading = t === y);
            },
          },
        }),
        Object.defineProperties(Tc.prototype, {
          metal: {
            get: function () {
              return (
                console.warn(
                  "THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead."
                ),
                !1
              );
            },
            set: function () {
              console.warn(
                "THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead"
              );
            },
          },
        }),
        Object.defineProperties(Vr.prototype, {
          derivatives: {
            get: function () {
              return (
                console.warn(
                  "THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."
                ),
                this.extensions.derivatives
              );
            },
            set: function (t) {
              console.warn(
                "THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."
              ),
                (this.extensions.derivatives = t);
            },
          },
        }),
        Object.assign(zo.prototype, {
          animate: function (t) {
            console.warn(
              "THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."
            ),
              this.setAnimationLoop(t);
          },
          getCurrentRenderTarget: function () {
            return (
              console.warn(
                "THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."
              ),
              this.getRenderTarget()
            );
          },
          getMaxAnisotropy: function () {
            return (
              console.warn(
                "THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."
              ),
              this.capabilities.getMaxAnisotropy()
            );
          },
          getPrecision: function () {
            return (
              console.warn(
                "THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."
              ),
              this.capabilities.precision
            );
          },
          resetGLState: function () {
            return (
              console.warn(
                "THREE.WebGLRenderer: .resetGLState() is now .state.reset()."
              ),
              this.state.reset()
            );
          },
          supportsFloatTextures: function () {
            return (
              console.warn(
                "THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."
              ),
              this.extensions.get("OES_texture_float")
            );
          },
          supportsHalfFloatTextures: function () {
            return (
              console.warn(
                "THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."
              ),
              this.extensions.get("OES_texture_half_float")
            );
          },
          supportsStandardDerivatives: function () {
            return (
              console.warn(
                "THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."
              ),
              this.extensions.get("OES_standard_derivatives")
            );
          },
          supportsCompressedTextureS3TC: function () {
            return (
              console.warn(
                "THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."
              ),
              this.extensions.get("WEBGL_compressed_texture_s3tc")
            );
          },
          supportsCompressedTexturePVRTC: function () {
            return (
              console.warn(
                "THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."
              ),
              this.extensions.get("WEBGL_compressed_texture_pvrtc")
            );
          },
          supportsBlendMinMax: function () {
            return (
              console.warn(
                "THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."
              ),
              this.extensions.get("EXT_blend_minmax")
            );
          },
          supportsVertexTextures: function () {
            return (
              console.warn(
                "THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."
              ),
              this.capabilities.vertexTextures
            );
          },
          supportsInstancedArrays: function () {
            return (
              console.warn(
                "THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."
              ),
              this.extensions.get("ANGLE_instanced_arrays")
            );
          },
          enableScissorTest: function (t) {
            console.warn(
              "THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."
            ),
              this.setScissorTest(t);
          },
          initMaterial: function () {
            console.warn(
              "THREE.WebGLRenderer: .initMaterial() has been removed."
            );
          },
          addPrePlugin: function () {
            console.warn(
              "THREE.WebGLRenderer: .addPrePlugin() has been removed."
            );
          },
          addPostPlugin: function () {
            console.warn(
              "THREE.WebGLRenderer: .addPostPlugin() has been removed."
            );
          },
          updateShadowMap: function () {
            console.warn(
              "THREE.WebGLRenderer: .updateShadowMap() has been removed."
            );
          },
          setFaceCulling: function () {
            console.warn(
              "THREE.WebGLRenderer: .setFaceCulling() has been removed."
            );
          },
        }),
        Object.defineProperties(zo.prototype, {
          shadowMapEnabled: {
            get: function () {
              return this.shadowMap.enabled;
            },
            set: function (t) {
              console.warn(
                "THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."
              ),
                (this.shadowMap.enabled = t);
            },
          },
          shadowMapType: {
            get: function () {
              return this.shadowMap.type;
            },
            set: function (t) {
              console.warn(
                "THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."
              ),
                (this.shadowMap.type = t);
            },
          },
          shadowMapCullFace: {
            get: function () {
              console.warn(
                "THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead."
              );
            },
            set: function () {
              console.warn(
                "THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead."
              );
            },
          },
        }),
        Object.defineProperties(To.prototype, {
          cullFace: {
            get: function () {
              console.warn(
                "THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead."
              );
            },
            set: function () {
              console.warn(
                "THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead."
              );
            },
          },
          renderReverseSided: {
            get: function () {
              console.warn(
                "THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead."
              );
            },
            set: function () {
              console.warn(
                "THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead."
              );
            },
          },
          renderSingleSided: {
            get: function () {
              console.warn(
                "THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead."
              );
            },
            set: function () {
              console.warn(
                "THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead."
              );
            },
          },
        }),
        Object.defineProperties(qe.prototype, {
          wrapS: {
            get: function () {
              return (
                console.warn(
                  "THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."
                ),
                this.texture.wrapS
              );
            },
            set: function (t) {
              console.warn(
                "THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."
              ),
                (this.texture.wrapS = t);
            },
          },
          wrapT: {
            get: function () {
              return (
                console.warn(
                  "THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."
                ),
                this.texture.wrapT
              );
            },
            set: function (t) {
              console.warn(
                "THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."
              ),
                (this.texture.wrapT = t);
            },
          },
          magFilter: {
            get: function () {
              return (
                console.warn(
                  "THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."
                ),
                this.texture.magFilter
              );
            },
            set: function (t) {
              console.warn(
                "THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."
              ),
                (this.texture.magFilter = t);
            },
          },
          minFilter: {
            get: function () {
              return (
                console.warn(
                  "THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."
                ),
                this.texture.minFilter
              );
            },
            set: function (t) {
              console.warn(
                "THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."
              ),
                (this.texture.minFilter = t);
            },
          },
          anisotropy: {
            get: function () {
              return (
                console.warn(
                  "THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."
                ),
                this.texture.anisotropy
              );
            },
            set: function (t) {
              console.warn(
                "THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."
              ),
                (this.texture.anisotropy = t);
            },
          },
          offset: {
            get: function () {
              return (
                console.warn(
                  "THREE.WebGLRenderTarget: .offset is now .texture.offset."
                ),
                this.texture.offset
              );
            },
            set: function (t) {
              console.warn(
                "THREE.WebGLRenderTarget: .offset is now .texture.offset."
              ),
                (this.texture.offset = t);
            },
          },
          repeat: {
            get: function () {
              return (
                console.warn(
                  "THREE.WebGLRenderTarget: .repeat is now .texture.repeat."
                ),
                this.texture.repeat
              );
            },
            set: function (t) {
              console.warn(
                "THREE.WebGLRenderTarget: .repeat is now .texture.repeat."
              ),
                (this.texture.repeat = t);
            },
          },
          format: {
            get: function () {
              return (
                console.warn(
                  "THREE.WebGLRenderTarget: .format is now .texture.format."
                ),
                this.texture.format
              );
            },
            set: function (t) {
              console.warn(
                "THREE.WebGLRenderTarget: .format is now .texture.format."
              ),
                (this.texture.format = t);
            },
          },
          type: {
            get: function () {
              return (
                console.warn(
                  "THREE.WebGLRenderTarget: .type is now .texture.type."
                ),
                this.texture.type
              );
            },
            set: function (t) {
              console.warn(
                "THREE.WebGLRenderTarget: .type is now .texture.type."
              ),
                (this.texture.type = t);
            },
          },
          generateMipmaps: {
            get: function () {
              return (
                console.warn(
                  "THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."
                ),
                this.texture.generateMipmaps
              );
            },
            set: function (t) {
              console.warn(
                "THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."
              ),
                (this.texture.generateMipmaps = t);
            },
          },
        }),
        Object.defineProperties(No.prototype, {
          standing: {
            set: function () {
              console.warn("THREE.WebVRManager: .standing has been removed.");
            },
          },
        }),
        (hh.prototype.load = function (t) {
          console.warn(
            "THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead."
          );
          var e = this,
            n = new oh();
          return (
            n.load(t, function (t) {
              e.setBuffer(t);
            }),
            this
          );
        }),
        (dh.prototype.getData = function () {
          return (
            console.warn(
              "THREE.AudioAnalyser: .getData() is now .getFrequencyData()."
            ),
            this.getFrequencyData()
          );
        }),
        (ch.prototype.updateCubeMap = function (t, e) {
          return (
            console.warn(
              "THREE.CubeCamera: .updateCubeMap() is now .update()."
            ),
            this.update(t, e)
          );
        });
      var Lu = {
          merge: function (t, e, n) {
            var i;
            console.warn(
              "THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead."
            ),
              e.isMesh &&
                (e.matrixAutoUpdate && e.updateMatrix(),
                (i = e.matrix),
                (e = e.geometry)),
              t.merge(e, i, n);
          },
          center: function (t) {
            return (
              console.warn(
                "THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead."
              ),
              t.center()
            );
          },
        },
        Pu = {
          crossOrigin: void 0,
          loadTexture: function (t, e, n, i) {
            console.warn(
              "THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead."
            );
            var r = new kc();
            r.setCrossOrigin(this.crossOrigin);
            var a = r.load(t, n, void 0, i);
            return e && (a.mapping = e), a;
          },
          loadTextureCube: function (t, e, n, i) {
            console.warn(
              "THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead."
            );
            var r = new Hc();
            r.setCrossOrigin(this.crossOrigin);
            var a = r.load(t, n, void 0, i);
            return e && (a.mapping = e), a;
          },
          loadCompressedTexture: function () {
            console.error(
              "THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead."
            );
          },
          loadCompressedTextureCube: function () {
            console.error(
              "THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead."
            );
          },
        };
      function Du() {
        console.error(
          "THREE.Projector has been moved to /examples/js/renderers/Projector.js."
        ),
          (this.projectVector = function (t, e) {
            console.warn(
              "THREE.Projector: .projectVector() is now vector.project()."
            ),
              t.project(e);
          }),
          (this.unprojectVector = function (t, e) {
            console.warn(
              "THREE.Projector: .unprojectVector() is now vector.unproject()."
            ),
              t.unproject(e);
          }),
          (this.pickingRay = function () {
            console.error(
              "THREE.Projector: .pickingRay() is now raycaster.setFromCamera()."
            );
          });
      }
      function Iu() {
        console.error(
          "THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js"
        ),
          (this.domElement = document.createElementNS(
            "http://www.w3.org/1999/xhtml",
            "canvas"
          )),
          (this.clear = function () {}),
          (this.render = function () {}),
          (this.setClearColor = function () {}),
          (this.setSize = function () {});
      }
      var Ou = {
        createMultiMaterialObject: function () {
          console.error(
            "THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js"
          );
        },
        detach: function () {
          console.error(
            "THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js"
          );
        },
        attach: function () {
          console.error(
            "THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js"
          );
        },
      };
      function Nu() {
        console.error(
          "THREE.LensFlare has been moved to /examples/js/objects/Lensflare.js"
        );
      }
    },
    "30b5": function (t, e, n) {
      "use strict";
      var i = n("c532");
      function r(t) {
        return encodeURIComponent(t)
          .replace(/%3A/gi, ":")
          .replace(/%24/g, "$")
          .replace(/%2C/gi, ",")
          .replace(/%20/g, "+")
          .replace(/%5B/gi, "[")
          .replace(/%5D/gi, "]");
      }
      t.exports = function (t, e, n) {
        if (!e) return t;
        var a;
        if (n) a = n(e);
        else if (i.isURLSearchParams(e)) a = e.toString();
        else {
          var o = [];
          i.forEach(e, function (t, e) {
            null !== t &&
              "undefined" !== typeof t &&
              (i.isArray(t) ? (e += "[]") : (t = [t]),
              i.forEach(t, function (t) {
                i.isDate(t)
                  ? (t = t.toISOString())
                  : i.isObject(t) && (t = JSON.stringify(t)),
                  o.push(r(e) + "=" + r(t));
              }));
          }),
            (a = o.join("&"));
        }
        if (a) {
          var s = t.indexOf("#");
          -1 !== s && (t = t.slice(0, s)),
            (t += (-1 === t.indexOf("?") ? "?" : "&") + a);
        }
        return t;
      };
    },
    3252: function (t, e, n) {
      (function (e, i) {
        t.exports = i(n("21bf"));
      })(0, function (t) {
        return (
          (function (e) {
            var n = t,
              i = n.lib,
              r = i.Base,
              a = i.WordArray,
              o = (n.x64 = {});
            (o.Word = r.extend({
              init: function (t, e) {
                (this.high = t), (this.low = e);
              },
            })),
              (o.WordArray = r.extend({
                init: function (t, n) {
                  (t = this.words = t || []),
                    (this.sigBytes = n != e ? n : 8 * t.length);
                },
                toX32: function () {
                  for (
                    var t = this.words, e = t.length, n = [], i = 0;
                    i < e;
                    i++
                  ) {
                    var r = t[i];
                    n.push(r.high), n.push(r.low);
                  }
                  return a.create(n, this.sigBytes);
                },
                clone: function () {
                  for (
                    var t = r.clone.call(this),
                      e = (t.words = this.words.slice(0)),
                      n = e.length,
                      i = 0;
                    i < n;
                    i++
                  )
                    e[i] = e[i].clone();
                  return t;
                },
              }));
          })(),
          t
        );
      });
    },
    3316: function (t, e, n) {},
    "342f": function (t, e) {
      t.exports =
        ("undefined" != typeof navigator && String(navigator.userAgent)) || "";
    },
    3452: function (t, e, n) {
      (function (e, i, r) {
        t.exports = i(
          n("21bf"),
          n("3252"),
          n("17e1"),
          n("a8ce"),
          n("1132"),
          n("c1bc"),
          n("72fe"),
          n("df2f"),
          n("94f8"),
          n("191b"),
          n("d6e6"),
          n("b86b"),
          n("e61b"),
          n("10b7"),
          n("5980"),
          n("7bbc"),
          n("2b79"),
          n("38ba"),
          n("00bb"),
          n("f4ea"),
          n("aaef"),
          n("4ba9"),
          n("81bf"),
          n("a817"),
          n("a11b"),
          n("8cef"),
          n("2a66"),
          n("b86c"),
          n("6d08"),
          n("c198"),
          n("a40e"),
          n("c3b6"),
          n("1382"),
          n("3d5a")
        );
      })(0, function (t) {
        return t;
      });
    },
    3511: function (t, e) {
      var n = TypeError,
        i = 9007199254740991;
      t.exports = function (t) {
        if (t > i) throw n("Maximum allowed index exceeded");
        return t;
      };
    },
    "387f": function (t, e, n) {
      "use strict";
      t.exports = function (t, e, n, i, r) {
        return (
          (t.config = e),
          n && (t.code = n),
          (t.request = i),
          (t.response = r),
          (t.isAxiosError = !0),
          (t.toJSON = function () {
            return {
              message: this.message,
              name: this.name,
              description: this.description,
              number: this.number,
              fileName: this.fileName,
              lineNumber: this.lineNumber,
              columnNumber: this.columnNumber,
              stack: this.stack,
              config: this.config,
              code: this.code,
            };
          }),
          t
        );
      };
    },
    "38ba": function (t, e, n) {
      (function (e, i, r) {
        t.exports = i(n("21bf"), n("2b79"));
      })(0, function (t) {
        t.lib.Cipher ||
          (function (e) {
            var n = t,
              i = n.lib,
              r = i.Base,
              a = i.WordArray,
              o = i.BufferedBlockAlgorithm,
              s = n.enc,
              c = (s.Utf8, s.Base64),
              l = n.algo,
              h = l.EvpKDF,
              u = (i.Cipher = o.extend({
                cfg: r.extend(),
                createEncryptor: function (t, e) {
                  return this.create(this._ENC_XFORM_MODE, t, e);
                },
                createDecryptor: function (t, e) {
                  return this.create(this._DEC_XFORM_MODE, t, e);
                },
                init: function (t, e, n) {
                  (this.cfg = this.cfg.extend(n)),
                    (this._xformMode = t),
                    (this._key = e),
                    this.reset();
                },
                reset: function () {
                  o.reset.call(this), this._doReset();
                },
                process: function (t) {
                  return this._append(t), this._process();
                },
                finalize: function (t) {
                  t && this._append(t);
                  var e = this._doFinalize();
                  return e;
                },
                keySize: 4,
                ivSize: 4,
                _ENC_XFORM_MODE: 1,
                _DEC_XFORM_MODE: 2,
                _createHelper: (function () {
                  function t(t) {
                    return "string" == typeof t ? M : _;
                  }
                  return function (e) {
                    return {
                      encrypt: function (n, i, r) {
                        return t(i).encrypt(e, n, i, r);
                      },
                      decrypt: function (n, i, r) {
                        return t(i).decrypt(e, n, i, r);
                      },
                    };
                  };
                })(),
              })),
              d =
                ((i.StreamCipher = u.extend({
                  _doFinalize: function () {
                    var t = this._process(!0);
                    return t;
                  },
                  blockSize: 1,
                })),
                (n.mode = {})),
              p = (i.BlockCipherMode = r.extend({
                createEncryptor: function (t, e) {
                  return this.Encryptor.create(t, e);
                },
                createDecryptor: function (t, e) {
                  return this.Decryptor.create(t, e);
                },
                init: function (t, e) {
                  (this._cipher = t), (this._iv = e);
                },
              })),
              f = (d.CBC = (function () {
                var t = p.extend();
                function n(t, n, i) {
                  var r,
                    a = this._iv;
                  a ? ((r = a), (this._iv = e)) : (r = this._prevBlock);
                  for (var o = 0; o < i; o++) t[n + o] ^= r[o];
                }
                return (
                  (t.Encryptor = t.extend({
                    processBlock: function (t, e) {
                      var i = this._cipher,
                        r = i.blockSize;
                      n.call(this, t, e, r),
                        i.encryptBlock(t, e),
                        (this._prevBlock = t.slice(e, e + r));
                    },
                  })),
                  (t.Decryptor = t.extend({
                    processBlock: function (t, e) {
                      var i = this._cipher,
                        r = i.blockSize,
                        a = t.slice(e, e + r);
                      i.decryptBlock(t, e),
                        n.call(this, t, e, r),
                        (this._prevBlock = a);
                    },
                  })),
                  t
                );
              })()),
              m = (n.pad = {}),
              g = (m.Pkcs7 = {
                pad: function (t, e) {
                  for (
                    var n = 4 * e,
                      i = n - (t.sigBytes % n),
                      r = (i << 24) | (i << 16) | (i << 8) | i,
                      o = [],
                      s = 0;
                    s < i;
                    s += 4
                  )
                    o.push(r);
                  var c = a.create(o, i);
                  t.concat(c);
                },
                unpad: function (t) {
                  var e = 255 & t.words[(t.sigBytes - 1) >>> 2];
                  t.sigBytes -= e;
                },
              }),
              v =
                ((i.BlockCipher = u.extend({
                  cfg: u.cfg.extend({ mode: f, padding: g }),
                  reset: function () {
                    var t;
                    u.reset.call(this);
                    var e = this.cfg,
                      n = e.iv,
                      i = e.mode;
                    this._xformMode == this._ENC_XFORM_MODE
                      ? (t = i.createEncryptor)
                      : ((t = i.createDecryptor), (this._minBufferSize = 1)),
                      this._mode && this._mode.__creator == t
                        ? this._mode.init(this, n && n.words)
                        : ((this._mode = t.call(i, this, n && n.words)),
                          (this._mode.__creator = t));
                  },
                  _doProcessBlock: function (t, e) {
                    this._mode.processBlock(t, e);
                  },
                  _doFinalize: function () {
                    var t,
                      e = this.cfg.padding;
                    return (
                      this._xformMode == this._ENC_XFORM_MODE
                        ? (e.pad(this._data, this.blockSize),
                          (t = this._process(!0)))
                        : ((t = this._process(!0)), e.unpad(t)),
                      t
                    );
                  },
                  blockSize: 4,
                })),
                (i.CipherParams = r.extend({
                  init: function (t) {
                    this.mixIn(t);
                  },
                  toString: function (t) {
                    return (t || this.formatter).stringify(this);
                  },
                }))),
              y = (n.format = {}),
              x = (y.OpenSSL = {
                stringify: function (t) {
                  var e,
                    n = t.ciphertext,
                    i = t.salt;
                  return (
                    (e = i
                      ? a.create([1398893684, 1701076831]).concat(i).concat(n)
                      : n),
                    e.toString(c)
                  );
                },
                parse: function (t) {
                  var e,
                    n = c.parse(t),
                    i = n.words;
                  return (
                    1398893684 == i[0] &&
                      1701076831 == i[1] &&
                      ((e = a.create(i.slice(2, 4))),
                      i.splice(0, 4),
                      (n.sigBytes -= 16)),
                    v.create({ ciphertext: n, salt: e })
                  );
                },
              }),
              _ = (i.SerializableCipher = r.extend({
                cfg: r.extend({ format: x }),
                encrypt: function (t, e, n, i) {
                  i = this.cfg.extend(i);
                  var r = t.createEncryptor(n, i),
                    a = r.finalize(e),
                    o = r.cfg;
                  return v.create({
                    ciphertext: a,
                    key: n,
                    iv: o.iv,
                    algorithm: t,
                    mode: o.mode,
                    padding: o.padding,
                    blockSize: t.blockSize,
                    formatter: i.format,
                  });
                },
                decrypt: function (t, e, n, i) {
                  (i = this.cfg.extend(i)), (e = this._parse(e, i.format));
                  var r = t.createDecryptor(n, i).finalize(e.ciphertext);
                  return r;
                },
                _parse: function (t, e) {
                  return "string" == typeof t ? e.parse(t, this) : t;
                },
              })),
              b = (n.kdf = {}),
              w = (b.OpenSSL = {
                execute: function (t, e, n, i) {
                  i || (i = a.random(8));
                  var r = h.create({ keySize: e + n }).compute(t, i),
                    o = a.create(r.words.slice(e), 4 * n);
                  return (
                    (r.sigBytes = 4 * e), v.create({ key: r, iv: o, salt: i })
                  );
                },
              }),
              M = (i.PasswordBasedCipher = _.extend({
                cfg: _.cfg.extend({ kdf: w }),
                encrypt: function (t, e, n, i) {
                  i = this.cfg.extend(i);
                  var r = i.kdf.execute(n, t.keySize, t.ivSize);
                  i.iv = r.iv;
                  var a = _.encrypt.call(this, t, e, r.key, i);
                  return a.mixIn(r), a;
                },
                decrypt: function (t, e, n, i) {
                  (i = this.cfg.extend(i)), (e = this._parse(e, i.format));
                  var r = i.kdf.execute(n, t.keySize, t.ivSize, e.salt);
                  i.iv = r.iv;
                  var a = _.decrypt.call(this, t, e, r.key, i);
                  return a;
                },
              }));
          })();
      });
    },
    3934: function (t, e, n) {
      "use strict";
      var i = n("c532");
      t.exports = i.isStandardBrowserEnv()
        ? (function () {
            var t,
              e = /(msie|trident)/i.test(navigator.userAgent),
              n = document.createElement("a");
            function r(t) {
              var i = t;
              return (
                e && (n.setAttribute("href", i), (i = n.href)),
                n.setAttribute("href", i),
                {
                  href: n.href,
                  protocol: n.protocol ? n.protocol.replace(/:$/, "") : "",
                  host: n.host,
                  search: n.search ? n.search.replace(/^\?/, "") : "",
                  hash: n.hash ? n.hash.replace(/^#/, "") : "",
                  hostname: n.hostname,
                  port: n.port,
                  pathname:
                    "/" === n.pathname.charAt(0)
                      ? n.pathname
                      : "/" + n.pathname,
                }
              );
            }
            return (
              (t = r(window.location.href)),
              function (e) {
                var n = i.isString(e) ? r(e) : e;
                return n.protocol === t.protocol && n.host === t.host;
              }
            );
          })()
        : (function () {
            return function () {
              return !0;
            };
          })();
    },
    "3a34": function (t, e, n) {
      "use strict";
      var i = n("83ab"),
        r = n("e8b5"),
        a = TypeError,
        o = Object.getOwnPropertyDescriptor,
        s =
          i &&
          !(function () {
            if (void 0 !== this) return !0;
            try {
              Object.defineProperty([], "length", { writable: !1 }).length = 1;
            } catch (t) {
              return t instanceof TypeError;
            }
          })();
      t.exports = s
        ? function (t, e) {
            if (r(t) && !o(t, "length").writable)
              throw a("Cannot set read only .length");
            return (t.length = e);
          }
        : function (t, e) {
            return (t.length = e);
          };
    },
    "3a9b": function (t, e, n) {
      var i = n("e330");
      t.exports = i({}.isPrototypeOf);
    },
    "3bbe": function (t, e, n) {
      var i = n("1626"),
        r = String,
        a = TypeError;
      t.exports = function (t) {
        if ("object" == typeof t || i(t)) return t;
        throw a("Can't set " + r(t) + " as a prototype");
      };
    },
    "3d5a": function (t, e, n) {
      (function (e, i, r) {
        t.exports = i(n("21bf"), n("1132"), n("72fe"), n("2b79"), n("38ba"));
      })(0, function (t) {
        return (
          (function () {
            var e = t,
              n = e.lib,
              i = n.StreamCipher,
              r = e.algo,
              a = [],
              o = [],
              s = [],
              c = (r.RabbitLegacy = i.extend({
                _doReset: function () {
                  var t = this._key.words,
                    e = this.cfg.iv,
                    n = (this._X = [
                      t[0],
                      (t[3] << 16) | (t[2] >>> 16),
                      t[1],
                      (t[0] << 16) | (t[3] >>> 16),
                      t[2],
                      (t[1] << 16) | (t[0] >>> 16),
                      t[3],
                      (t[2] << 16) | (t[1] >>> 16),
                    ]),
                    i = (this._C = [
                      (t[2] << 16) | (t[2] >>> 16),
                      (4294901760 & t[0]) | (65535 & t[1]),
                      (t[3] << 16) | (t[3] >>> 16),
                      (4294901760 & t[1]) | (65535 & t[2]),
                      (t[0] << 16) | (t[0] >>> 16),
                      (4294901760 & t[2]) | (65535 & t[3]),
                      (t[1] << 16) | (t[1] >>> 16),
                      (4294901760 & t[3]) | (65535 & t[0]),
                    ]);
                  this._b = 0;
                  for (var r = 0; r < 4; r++) l.call(this);
                  for (r = 0; r < 8; r++) i[r] ^= n[(r + 4) & 7];
                  if (e) {
                    var a = e.words,
                      o = a[0],
                      s = a[1],
                      c =
                        (16711935 & ((o << 8) | (o >>> 24))) |
                        (4278255360 & ((o << 24) | (o >>> 8))),
                      h =
                        (16711935 & ((s << 8) | (s >>> 24))) |
                        (4278255360 & ((s << 24) | (s >>> 8))),
                      u = (c >>> 16) | (4294901760 & h),
                      d = (h << 16) | (65535 & c);
                    (i[0] ^= c),
                      (i[1] ^= u),
                      (i[2] ^= h),
                      (i[3] ^= d),
                      (i[4] ^= c),
                      (i[5] ^= u),
                      (i[6] ^= h),
                      (i[7] ^= d);
                    for (r = 0; r < 4; r++) l.call(this);
                  }
                },
                _doProcessBlock: function (t, e) {
                  var n = this._X;
                  l.call(this),
                    (a[0] = n[0] ^ (n[5] >>> 16) ^ (n[3] << 16)),
                    (a[1] = n[2] ^ (n[7] >>> 16) ^ (n[5] << 16)),
                    (a[2] = n[4] ^ (n[1] >>> 16) ^ (n[7] << 16)),
                    (a[3] = n[6] ^ (n[3] >>> 16) ^ (n[1] << 16));
                  for (var i = 0; i < 4; i++)
                    (a[i] =
                      (16711935 & ((a[i] << 8) | (a[i] >>> 24))) |
                      (4278255360 & ((a[i] << 24) | (a[i] >>> 8)))),
                      (t[e + i] ^= a[i]);
                },
                blockSize: 4,
                ivSize: 2,
              }));
            function l() {
              for (var t = this._X, e = this._C, n = 0; n < 8; n++) o[n] = e[n];
              (e[0] = (e[0] + 1295307597 + this._b) | 0),
                (e[1] =
                  (e[1] + 3545052371 + (e[0] >>> 0 < o[0] >>> 0 ? 1 : 0)) | 0),
                (e[2] =
                  (e[2] + 886263092 + (e[1] >>> 0 < o[1] >>> 0 ? 1 : 0)) | 0),
                (e[3] =
                  (e[3] + 1295307597 + (e[2] >>> 0 < o[2] >>> 0 ? 1 : 0)) | 0),
                (e[4] =
                  (e[4] + 3545052371 + (e[3] >>> 0 < o[3] >>> 0 ? 1 : 0)) | 0),
                (e[5] =
                  (e[5] + 886263092 + (e[4] >>> 0 < o[4] >>> 0 ? 1 : 0)) | 0),
                (e[6] =
                  (e[6] + 1295307597 + (e[5] >>> 0 < o[5] >>> 0 ? 1 : 0)) | 0),
                (e[7] =
                  (e[7] + 3545052371 + (e[6] >>> 0 < o[6] >>> 0 ? 1 : 0)) | 0),
                (this._b = e[7] >>> 0 < o[7] >>> 0 ? 1 : 0);
              for (n = 0; n < 8; n++) {
                var i = t[n] + e[n],
                  r = 65535 & i,
                  a = i >>> 16,
                  c = ((((r * r) >>> 17) + r * a) >>> 15) + a * a,
                  l = (((4294901760 & i) * i) | 0) + (((65535 & i) * i) | 0);
                s[n] = c ^ l;
              }
              (t[0] =
                (s[0] +
                  ((s[7] << 16) | (s[7] >>> 16)) +
                  ((s[6] << 16) | (s[6] >>> 16))) |
                0),
                (t[1] = (s[1] + ((s[0] << 8) | (s[0] >>> 24)) + s[7]) | 0),
                (t[2] =
                  (s[2] +
                    ((s[1] << 16) | (s[1] >>> 16)) +
                    ((s[0] << 16) | (s[0] >>> 16))) |
                  0),
                (t[3] = (s[3] + ((s[2] << 8) | (s[2] >>> 24)) + s[1]) | 0),
                (t[4] =
                  (s[4] +
                    ((s[3] << 16) | (s[3] >>> 16)) +
                    ((s[2] << 16) | (s[2] >>> 16))) |
                  0),
                (t[5] = (s[5] + ((s[4] << 8) | (s[4] >>> 24)) + s[3]) | 0),
                (t[6] =
                  (s[6] +
                    ((s[5] << 16) | (s[5] >>> 16)) +
                    ((s[4] << 16) | (s[4] >>> 16))) |
                  0),
                (t[7] = (s[7] + ((s[6] << 8) | (s[6] >>> 24)) + s[5]) | 0);
            }
            e.RabbitLegacy = i._createHelper(c);
          })(),
          t.RabbitLegacy
        );
      });
    },
    "40d5": function (t, e, n) {
      var i = n("d039");
      t.exports = !i(function () {
        var t = function () {}.bind();
        return "function" != typeof t || t.hasOwnProperty("prototype");
      });
    },
    4362: function (t, e, n) {
      (e.nextTick = function (t) {
        var e = Array.prototype.slice.call(arguments);
        e.shift(),
          setTimeout(function () {
            t.apply(null, e);
          }, 0);
      }),
        (e.platform = e.arch = e.execPath = e.title = "browser"),
        (e.pid = 1),
        (e.browser = !0),
        (e.env = {}),
        (e.argv = []),
        (e.binding = function (t) {
          throw new Error("No such module. (Possibly not yet loaded)");
        }),
        (function () {
          var t,
            i = "/";
          (e.cwd = function () {
            return i;
          }),
            (e.chdir = function (e) {
              t || (t = n("df7c")), (i = t.resolve(e, i));
            });
        })(),
        (e.exit =
          e.kill =
          e.umask =
          e.dlopen =
          e.uptime =
          e.memoryUsage =
          e.uvCounters =
            function () {}),
        (e.features = {});
    },
    "44ad": function (t, e, n) {
      var i = n("e330"),
        r = n("d039"),
        a = n("c6b6"),
        o = Object,
        s = i("".split);
      t.exports = r(function () {
        return !o("z").propertyIsEnumerable(0);
      })
        ? function (t) {
            return "String" == a(t) ? s(t, "") : o(t);
          }
        : o;
    },
    "467f": function (t, e, n) {
      "use strict";
      var i = n("2d83");
      t.exports = function (t, e, n) {
        var r = n.config.validateStatus;
        n.status && r && !r(n.status)
          ? e(
              i(
                "Request failed with status code " + n.status,
                n.config,
                null,
                n.request,
                n
              )
            )
          : t(n);
      };
    },
    "485a": function (t, e, n) {
      var i = n("c65b"),
        r = n("1626"),
        a = n("861d"),
        o = TypeError;
      t.exports = function (t, e) {
        var n, s;
        if ("string" === e && r((n = t.toString)) && !a((s = i(n, t))))
          return s;
        if (r((n = t.valueOf)) && !a((s = i(n, t)))) return s;
        if ("string" !== e && r((n = t.toString)) && !a((s = i(n, t))))
          return s;
        throw o("Can't convert object to primitive value");
      };
    },
    "4a0c": function (t) {
      t.exports = JSON.parse(
        '{"name":"axios","version":"0.21.4","description":"Promise based HTTP client for the browser and node.js","main":"index.js","scripts":{"test":"grunt test","start":"node ./sandbox/server.js","build":"NODE_ENV=production grunt build","preversion":"npm test","version":"npm run build && grunt version && git add -A dist && git add CHANGELOG.md bower.json package.json","postversion":"git push && git push --tags","examples":"node ./examples/server.js","coveralls":"cat coverage/lcov.info | ./node_modules/coveralls/bin/coveralls.js","fix":"eslint --fix lib/**/*.js"},"repository":{"type":"git","url":"https://github.com/axios/axios.git"},"keywords":["xhr","http","ajax","promise","node"],"author":"Matt Zabriskie","license":"MIT","bugs":{"url":"https://github.com/axios/axios/issues"},"homepage":"https://axios-http.com","devDependencies":{"coveralls":"^3.0.0","es6-promise":"^4.2.4","grunt":"^1.3.0","grunt-banner":"^0.6.0","grunt-cli":"^1.2.0","grunt-contrib-clean":"^1.1.0","grunt-contrib-watch":"^1.0.0","grunt-eslint":"^23.0.0","grunt-karma":"^4.0.0","grunt-mocha-test":"^0.13.3","grunt-ts":"^6.0.0-beta.19","grunt-webpack":"^4.0.2","istanbul-instrumenter-loader":"^1.0.0","jasmine-core":"^2.4.1","karma":"^6.3.2","karma-chrome-launcher":"^3.1.0","karma-firefox-launcher":"^2.1.0","karma-jasmine":"^1.1.1","karma-jasmine-ajax":"^0.1.13","karma-safari-launcher":"^1.0.0","karma-sauce-launcher":"^4.3.6","karma-sinon":"^1.0.5","karma-sourcemap-loader":"^0.3.8","karma-webpack":"^4.0.2","load-grunt-tasks":"^3.5.2","minimist":"^1.2.0","mocha":"^8.2.1","sinon":"^4.5.0","terser-webpack-plugin":"^4.2.3","typescript":"^4.0.5","url-search-params":"^0.10.0","webpack":"^4.44.2","webpack-dev-server":"^3.11.0"},"browser":{"./lib/adapters/http.js":"./lib/adapters/xhr.js"},"jsdelivr":"dist/axios.min.js","unpkg":"dist/axios.min.js","typings":"./index.d.ts","dependencies":{"follow-redirects":"^1.14.0"},"bundlesize":[{"path":"./dist/axios.min.js","threshold":"5kB"}]}'
      );
    },
    "4a7b": function (t, e, n) {
      "use strict";
      var i = n("c532");
      t.exports = function (t, e) {
        e = e || {};
        var n = {},
          r = ["url", "method", "data"],
          a = ["headers", "auth", "proxy", "params"],
          o = [
            "baseURL",
            "transformRequest",
            "transformResponse",
            "paramsSerializer",
            "timeout",
            "timeoutMessage",
            "withCredentials",
            "adapter",
            "responseType",
            "xsrfCookieName",
            "xsrfHeaderName",
            "onUploadProgress",
            "onDownloadProgress",
            "decompress",
            "maxContentLength",
            "maxBodyLength",
            "maxRedirects",
            "transport",
            "httpAgent",
            "httpsAgent",
            "cancelToken",
            "socketPath",
            "responseEncoding",
          ],
          s = ["validateStatus"];
        function c(t, e) {
          return i.isPlainObject(t) && i.isPlainObject(e)
            ? i.merge(t, e)
            : i.isPlainObject(e)
            ? i.merge({}, e)
            : i.isArray(e)
            ? e.slice()
            : e;
        }
        function l(r) {
          i.isUndefined(e[r])
            ? i.isUndefined(t[r]) || (n[r] = c(void 0, t[r]))
            : (n[r] = c(t[r], e[r]));
        }
        i.forEach(r, function (t) {
          i.isUndefined(e[t]) || (n[t] = c(void 0, e[t]));
        }),
          i.forEach(a, l),
          i.forEach(o, function (r) {
            i.isUndefined(e[r])
              ? i.isUndefined(t[r]) || (n[r] = c(void 0, t[r]))
              : (n[r] = c(void 0, e[r]));
          }),
          i.forEach(s, function (i) {
            i in e
              ? (n[i] = c(t[i], e[i]))
              : i in t && (n[i] = c(void 0, t[i]));
          });
        var h = r.concat(a).concat(o).concat(s),
          u = Object.keys(t)
            .concat(Object.keys(e))
            .filter(function (t) {
              return -1 === h.indexOf(t);
            });
        return i.forEach(u, l), n;
      };
    },
    "4ba9": function (t, e, n) {
      (function (e, i, r) {
        t.exports = i(n("21bf"), n("38ba"));
      })(0, function (t) {
        return (
          (t.mode.OFB = (function () {
            var e = t.lib.BlockCipherMode.extend(),
              n = (e.Encryptor = e.extend({
                processBlock: function (t, e) {
                  var n = this._cipher,
                    i = n.blockSize,
                    r = this._iv,
                    a = this._keystream;
                  r &&
                    ((a = this._keystream = r.slice(0)), (this._iv = void 0)),
                    n.encryptBlock(a, 0);
                  for (var o = 0; o < i; o++) t[e + o] ^= a[o];
                },
              }));
            return (e.Decryptor = n), e;
          })()),
          t.mode.OFB
        );
      });
    },
    "4d64": function (t, e, n) {
      var i = n("fc6a"),
        r = n("23cb"),
        a = n("07fa"),
        o = function (t) {
          return function (e, n, o) {
            var s,
              c = i(e),
              l = a(c),
              h = r(o, l);
            if (t && n != n) {
              while (l > h) if (((s = c[h++]), s != s)) return !0;
            } else
              for (; l > h; h++)
                if ((t || h in c) && c[h] === n) return t || h || 0;
            return !t && -1;
          };
        };
      t.exports = { includes: o(!0), indexOf: o(!1) };
    },
    "50c4": function (t, e, n) {
      var i = n("5926"),
        r = Math.min;
      t.exports = function (t) {
        return t > 0 ? r(i(t), 9007199254740991) : 0;
      };
    },
    5270: function (t, e, n) {
      "use strict";
      var i = n("c532"),
        r = n("c401"),
        a = n("2e67"),
        o = n("2444");
      function s(t) {
        t.cancelToken && t.cancelToken.throwIfRequested();
      }
      t.exports = function (t) {
        s(t),
          (t.headers = t.headers || {}),
          (t.data = r.call(t, t.data, t.headers, t.transformRequest)),
          (t.headers = i.merge(
            t.headers.common || {},
            t.headers[t.method] || {},
            t.headers
          )),
          i.forEach(
            ["delete", "get", "head", "post", "put", "patch", "common"],
            function (e) {
              delete t.headers[e];
            }
          );
        var e = t.adapter || o.adapter;
        return e(t).then(
          function (e) {
            return (
              s(t),
              (e.data = r.call(t, e.data, e.headers, t.transformResponse)),
              e
            );
          },
          function (e) {
            return (
              a(e) ||
                (s(t),
                e &&
                  e.response &&
                  (e.response.data = r.call(
                    t,
                    e.response.data,
                    e.response.headers,
                    t.transformResponse
                  ))),
              Promise.reject(e)
            );
          }
        );
      };
    },
    5692: function (t, e, n) {
      var i = n("c430"),
        r = n("c6cd");
      (t.exports = function (t, e) {
        return r[t] || (r[t] = void 0 !== e ? e : {});
      })("versions", []).push({
        version: "3.30.1",
        mode: i ? "pure" : "global",
        copyright: "Â© 2014-2023 Denis Pushkarev (zloirock.ru)",
        license: "https://github.com/zloirock/core-js/blob/v3.30.1/LICENSE",
        source: "https://github.com/zloirock/core-js",
      });
    },
    "56ef": function (t, e, n) {
      var i = n("d066"),
        r = n("e330"),
        a = n("241c"),
        o = n("7418"),
        s = n("825a"),
        c = r([].concat);
      t.exports =
        i("Reflect", "ownKeys") ||
        function (t) {
          var e = a.f(s(t)),
            n = o.f;
          return n ? c(e, n(t)) : e;
        };
    },
    "577e": function (t, e, n) {
      var i = n("f5df"),
        r = String;
      t.exports = function (t) {
        if ("Symbol" === i(t))
          throw TypeError("Cannot convert a Symbol value to a string");
        return r(t);
      };
    },
    5926: function (t, e, n) {
      var i = n("b42e");
      t.exports = function (t) {
        var e = +t;
        return e !== e || 0 === e ? 0 : i(e);
      };
    },
    5980: function (t, e, n) {
      (function (e, i) {
        t.exports = i(n("21bf"));
      })(0, function (t) {
        (function () {
          var e = t,
            n = e.lib,
            i = n.Base,
            r = e.enc,
            a = r.Utf8,
            o = e.algo;
          o.HMAC = i.extend({
            init: function (t, e) {
              (t = this._hasher = new t.init()),
                "string" == typeof e && (e = a.parse(e));
              var n = t.blockSize,
                i = 4 * n;
              e.sigBytes > i && (e = t.finalize(e)), e.clamp();
              for (
                var r = (this._oKey = e.clone()),
                  o = (this._iKey = e.clone()),
                  s = r.words,
                  c = o.words,
                  l = 0;
                l < n;
                l++
              )
                (s[l] ^= 1549556828), (c[l] ^= 909522486);
              (r.sigBytes = o.sigBytes = i), this.reset();
            },
            reset: function () {
              var t = this._hasher;
              t.reset(), t.update(this._iKey);
            },
            update: function (t) {
              return this._hasher.update(t), this;
            },
            finalize: function (t) {
              var e = this._hasher,
                n = e.finalize(t);
              e.reset();
              var i = e.finalize(this._oKey.clone().concat(n));
              return i;
            },
          });
        })();
      });
    },
    "59ed": function (t, e, n) {
      var i = n("1626"),
        r = n("0d51"),
        a = TypeError;
      t.exports = function (t) {
        if (i(t)) return t;
        throw a(r(t) + " is not a function");
      };
    },
    "5c6c": function (t, e) {
      t.exports = function (t, e) {
        return {
          enumerable: !(1 & t),
          configurable: !(2 & t),
          writable: !(4 & t),
          value: e,
        };
      };
    },
    "5e77": function (t, e, n) {
      var i = n("83ab"),
        r = n("1a2d"),
        a = Function.prototype,
        o = i && Object.getOwnPropertyDescriptor,
        s = r(a, "name"),
        c = s && "something" === function () {}.name,
        l = s && (!i || (i && o(a, "name").configurable));
      t.exports = { EXISTS: s, PROPER: c, CONFIGURABLE: l };
    },
    "5f02": function (t, e, n) {
      "use strict";
      t.exports = function (t) {
        return "object" === typeof t && !0 === t.isAxiosError;
      };
    },
    6374: function (t, e, n) {
      var i = n("da84"),
        r = Object.defineProperty;
      t.exports = function (t, e) {
        try {
          r(i, t, { value: e, configurable: !0, writable: !0 });
        } catch (n) {
          i[t] = e;
        }
        return e;
      };
    },
    "69f3": function (t, e, n) {
      var i,
        r,
        a,
        o = n("cdce"),
        s = n("da84"),
        c = n("861d"),
        l = n("9112"),
        h = n("1a2d"),
        u = n("c6cd"),
        d = n("f772"),
        p = n("d012"),
        f = "Object already initialized",
        m = s.TypeError,
        g = s.WeakMap,
        v = function (t) {
          return a(t) ? r(t) : i(t, {});
        },
        y = function (t) {
          return function (e) {
            var n;
            if (!c(e) || (n = r(e)).type !== t)
              throw m("Incompatible receiver, " + t + " required");
            return n;
          };
        };
      if (o || u.state) {
        var x = u.state || (u.state = new g());
        (x.get = x.get),
          (x.has = x.has),
          (x.set = x.set),
          (i = function (t, e) {
            if (x.has(t)) throw m(f);
            return (e.facade = t), x.set(t, e), e;
          }),
          (r = function (t) {
            return x.get(t) || {};
          }),
          (a = function (t) {
            return x.has(t);
          });
      } else {
        var _ = d("state");
        (p[_] = !0),
          (i = function (t, e) {
            if (h(t, _)) throw m(f);
            return (e.facade = t), l(t, _, e), e;
          }),
          (r = function (t) {
            return h(t, _) ? t[_] : {};
          }),
          (a = function (t) {
            return h(t, _);
          });
      }
      t.exports = { set: i, get: r, has: a, enforce: v, getterFor: y };
    },
    "6d08": function (t, e, n) {
      (function (e, i, r) {
        t.exports = i(n("21bf"), n("38ba"));
      })(0, function (t) {
        return (
          (function (e) {
            var n = t,
              i = n.lib,
              r = i.CipherParams,
              a = n.enc,
              o = a.Hex,
              s = n.format;
            s.Hex = {
              stringify: function (t) {
                return t.ciphertext.toString(o);
              },
              parse: function (t) {
                var e = o.parse(t);
                return r.create({ ciphertext: e });
              },
            };
          })(),
          t.format.Hex
        );
      });
    },
    "6f19": function (t, e, n) {
      var i = n("9112"),
        r = n("0d26"),
        a = n("b980"),
        o = Error.captureStackTrace;
      t.exports = function (t, e, n, s) {
        a && (o ? o(t, e) : i(t, "stack", r(n, s)));
      };
    },
    7156: function (t, e, n) {
      var i = n("1626"),
        r = n("861d"),
        a = n("d2bb");
      t.exports = function (t, e, n) {
        var o, s;
        return (
          a &&
            i((o = e.constructor)) &&
            o !== n &&
            r((s = o.prototype)) &&
            s !== n.prototype &&
            a(t, s),
          t
        );
      };
    },
    7234: function (t, e) {
      t.exports = function (t) {
        return null === t || void 0 === t;
      };
    },
    7282: function (t, e, n) {
      var i = n("e330"),
        r = n("59ed");
      t.exports = function (t, e, n) {
        try {
          return i(r(Object.getOwnPropertyDescriptor(t, e)[n]));
        } catch (a) {}
      };
    },
    "72fe": function (t, e, n) {
      (function (e, i) {
        t.exports = i(n("21bf"));
      })(0, function (t) {
        return (
          (function (e) {
            var n = t,
              i = n.lib,
              r = i.WordArray,
              a = i.Hasher,
              o = n.algo,
              s = [];
            (function () {
              for (var t = 0; t < 64; t++)
                s[t] = (4294967296 * e.abs(e.sin(t + 1))) | 0;
            })();
            var c = (o.MD5 = a.extend({
              _doReset: function () {
                this._hash = new r.init([
                  1732584193, 4023233417, 2562383102, 271733878,
                ]);
              },
              _doProcessBlock: function (t, e) {
                for (var n = 0; n < 16; n++) {
                  var i = e + n,
                    r = t[i];
                  t[i] =
                    (16711935 & ((r << 8) | (r >>> 24))) |
                    (4278255360 & ((r << 24) | (r >>> 8)));
                }
                var a = this._hash.words,
                  o = t[e + 0],
                  c = t[e + 1],
                  p = t[e + 2],
                  f = t[e + 3],
                  m = t[e + 4],
                  g = t[e + 5],
                  v = t[e + 6],
                  y = t[e + 7],
                  x = t[e + 8],
                  _ = t[e + 9],
                  b = t[e + 10],
                  w = t[e + 11],
                  M = t[e + 12],
                  S = t[e + 13],
                  E = t[e + 14],
                  T = t[e + 15],
                  A = a[0],
                  C = a[1],
                  R = a[2],
                  L = a[3];
                (A = l(A, C, R, L, o, 7, s[0])),
                  (L = l(L, A, C, R, c, 12, s[1])),
                  (R = l(R, L, A, C, p, 17, s[2])),
                  (C = l(C, R, L, A, f, 22, s[3])),
                  (A = l(A, C, R, L, m, 7, s[4])),
                  (L = l(L, A, C, R, g, 12, s[5])),
                  (R = l(R, L, A, C, v, 17, s[6])),
                  (C = l(C, R, L, A, y, 22, s[7])),
                  (A = l(A, C, R, L, x, 7, s[8])),
                  (L = l(L, A, C, R, _, 12, s[9])),
                  (R = l(R, L, A, C, b, 17, s[10])),
                  (C = l(C, R, L, A, w, 22, s[11])),
                  (A = l(A, C, R, L, M, 7, s[12])),
                  (L = l(L, A, C, R, S, 12, s[13])),
                  (R = l(R, L, A, C, E, 17, s[14])),
                  (C = l(C, R, L, A, T, 22, s[15])),
                  (A = h(A, C, R, L, c, 5, s[16])),
                  (L = h(L, A, C, R, v, 9, s[17])),
                  (R = h(R, L, A, C, w, 14, s[18])),
                  (C = h(C, R, L, A, o, 20, s[19])),
                  (A = h(A, C, R, L, g, 5, s[20])),
                  (L = h(L, A, C, R, b, 9, s[21])),
                  (R = h(R, L, A, C, T, 14, s[22])),
                  (C = h(C, R, L, A, m, 20, s[23])),
                  (A = h(A, C, R, L, _, 5, s[24])),
                  (L = h(L, A, C, R, E, 9, s[25])),
                  (R = h(R, L, A, C, f, 14, s[26])),
                  (C = h(C, R, L, A, x, 20, s[27])),
                  (A = h(A, C, R, L, S, 5, s[28])),
                  (L = h(L, A, C, R, p, 9, s[29])),
                  (R = h(R, L, A, C, y, 14, s[30])),
                  (C = h(C, R, L, A, M, 20, s[31])),
                  (A = u(A, C, R, L, g, 4, s[32])),
                  (L = u(L, A, C, R, x, 11, s[33])),
                  (R = u(R, L, A, C, w, 16, s[34])),
                  (C = u(C, R, L, A, E, 23, s[35])),
                  (A = u(A, C, R, L, c, 4, s[36])),
                  (L = u(L, A, C, R, m, 11, s[37])),
                  (R = u(R, L, A, C, y, 16, s[38])),
                  (C = u(C, R, L, A, b, 23, s[39])),
                  (A = u(A, C, R, L, S, 4, s[40])),
                  (L = u(L, A, C, R, o, 11, s[41])),
                  (R = u(R, L, A, C, f, 16, s[42])),
                  (C = u(C, R, L, A, v, 23, s[43])),
                  (A = u(A, C, R, L, _, 4, s[44])),
                  (L = u(L, A, C, R, M, 11, s[45])),
                  (R = u(R, L, A, C, T, 16, s[46])),
                  (C = u(C, R, L, A, p, 23, s[47])),
                  (A = d(A, C, R, L, o, 6, s[48])),
                  (L = d(L, A, C, R, y, 10, s[49])),
                  (R = d(R, L, A, C, E, 15, s[50])),
                  (C = d(C, R, L, A, g, 21, s[51])),
                  (A = d(A, C, R, L, M, 6, s[52])),
                  (L = d(L, A, C, R, f, 10, s[53])),
                  (R = d(R, L, A, C, b, 15, s[54])),
                  (C = d(C, R, L, A, c, 21, s[55])),
                  (A = d(A, C, R, L, x, 6, s[56])),
                  (L = d(L, A, C, R, T, 10, s[57])),
                  (R = d(R, L, A, C, v, 15, s[58])),
                  (C = d(C, R, L, A, S, 21, s[59])),
                  (A = d(A, C, R, L, m, 6, s[60])),
                  (L = d(L, A, C, R, w, 10, s[61])),
                  (R = d(R, L, A, C, p, 15, s[62])),
                  (C = d(C, R, L, A, _, 21, s[63])),
                  (a[0] = (a[0] + A) | 0),
                  (a[1] = (a[1] + C) | 0),
                  (a[2] = (a[2] + R) | 0),
                  (a[3] = (a[3] + L) | 0);
              },
              _doFinalize: function () {
                var t = this._data,
                  n = t.words,
                  i = 8 * this._nDataBytes,
                  r = 8 * t.sigBytes;
                n[r >>> 5] |= 128 << (24 - (r % 32));
                var a = e.floor(i / 4294967296),
                  o = i;
                (n[15 + (((r + 64) >>> 9) << 4)] =
                  (16711935 & ((a << 8) | (a >>> 24))) |
                  (4278255360 & ((a << 24) | (a >>> 8)))),
                  (n[14 + (((r + 64) >>> 9) << 4)] =
                    (16711935 & ((o << 8) | (o >>> 24))) |
                    (4278255360 & ((o << 24) | (o >>> 8)))),
                  (t.sigBytes = 4 * (n.length + 1)),
                  this._process();
                for (var s = this._hash, c = s.words, l = 0; l < 4; l++) {
                  var h = c[l];
                  c[l] =
                    (16711935 & ((h << 8) | (h >>> 24))) |
                    (4278255360 & ((h << 24) | (h >>> 8)));
                }
                return s;
              },
              clone: function () {
                var t = a.clone.call(this);
                return (t._hash = this._hash.clone()), t;
              },
            }));
            function l(t, e, n, i, r, a, o) {
              var s = t + ((e & n) | (~e & i)) + r + o;
              return ((s << a) | (s >>> (32 - a))) + e;
            }
            function h(t, e, n, i, r, a, o) {
              var s = t + ((e & i) | (n & ~i)) + r + o;
              return ((s << a) | (s >>> (32 - a))) + e;
            }
            function u(t, e, n, i, r, a, o) {
              var s = t + (e ^ n ^ i) + r + o;
              return ((s << a) | (s >>> (32 - a))) + e;
            }
            function d(t, e, n, i, r, a, o) {
              var s = t + (n ^ (e | ~i)) + r + o;
              return ((s << a) | (s >>> (32 - a))) + e;
            }
            (n.MD5 = a._createHelper(c)), (n.HmacMD5 = a._createHmacHelper(c));
          })(Math),
          t.MD5
        );
      });
    },
    7418: function (t, e) {
      e.f = Object.getOwnPropertySymbols;
    },
    7839: function (t, e) {
      t.exports = [
        "constructor",
        "hasOwnProperty",
        "isPrototypeOf",
        "propertyIsEnumerable",
        "toLocaleString",
        "toString",
        "valueOf",
      ];
    },
    "7a77": function (t, e, n) {
      "use strict";
      function i(t) {
        this.message = t;
      }
      (i.prototype.toString = function () {
        return "Cancel" + (this.message ? ": " + this.message : "");
      }),
        (i.prototype.__CANCEL__ = !0),
        (t.exports = i);
    },
    "7aac": function (t, e, n) {
      "use strict";
      var i = n("c532");
      t.exports = i.isStandardBrowserEnv()
        ? (function () {
            return {
              write: function (t, e, n, r, a, o) {
                var s = [];
                s.push(t + "=" + encodeURIComponent(e)),
                  i.isNumber(n) &&
                    s.push("expires=" + new Date(n).toGMTString()),
                  i.isString(r) && s.push("path=" + r),
                  i.isString(a) && s.push("domain=" + a),
                  !0 === o && s.push("secure"),
                  (document.cookie = s.join("; "));
              },
              read: function (t) {
                var e = document.cookie.match(
                  new RegExp("(^|;\\s*)(" + t + ")=([^;]*)")
                );
                return e ? decodeURIComponent(e[3]) : null;
              },
              remove: function (t) {
                this.write(t, "", Date.now() - 864e5);
              },
            };
          })()
        : (function () {
            return {
              write: function () {},
              read: function () {
                return null;
              },
              remove: function () {},
            };
          })();
    },
    "7b0b": function (t, e, n) {
      var i = n("1d80"),
        r = Object;
      t.exports = function (t) {
        return r(i(t));
      };
    },
    "7bbc": function (t, e, n) {
      (function (e, i, r) {
        t.exports = i(n("21bf"), n("df2f"), n("5980"));
      })(0, function (t) {
        return (
          (function () {
            var e = t,
              n = e.lib,
              i = n.Base,
              r = n.WordArray,
              a = e.algo,
              o = a.SHA1,
              s = a.HMAC,
              c = (a.PBKDF2 = i.extend({
                cfg: i.extend({ keySize: 4, hasher: o, iterations: 1 }),
                init: function (t) {
                  this.cfg = this.cfg.extend(t);
                },
                compute: function (t, e) {
                  var n = this.cfg,
                    i = s.create(n.hasher, t),
                    a = r.create(),
                    o = r.create([1]),
                    c = a.words,
                    l = o.words,
                    h = n.keySize,
                    u = n.iterations;
                  while (c.length < h) {
                    var d = i.update(e).finalize(o);
                    i.reset();
                    for (
                      var p = d.words, f = p.length, m = d, g = 1;
                      g < u;
                      g++
                    ) {
                      (m = i.finalize(m)), i.reset();
                      for (var v = m.words, y = 0; y < f; y++) p[y] ^= v[y];
                    }
                    a.concat(d), l[0]++;
                  }
                  return (a.sigBytes = 4 * h), a;
                },
              }));
            e.PBKDF2 = function (t, e, n) {
              return c.create(n).compute(t, e);
            };
          })(),
          t.PBKDF2
        );
      });
    },
    "81bf": function (t, e, n) {
      (function (e, i, r) {
        t.exports = i(n("21bf"), n("38ba"));
      })(0, function (t) {
        return (
          (t.mode.ECB = (function () {
            var e = t.lib.BlockCipherMode.extend();
            return (
              (e.Encryptor = e.extend({
                processBlock: function (t, e) {
                  this._cipher.encryptBlock(t, e);
                },
              })),
              (e.Decryptor = e.extend({
                processBlock: function (t, e) {
                  this._cipher.decryptBlock(t, e);
                },
              })),
              e
            );
          })()),
          t.mode.ECB
        );
      });
    },
    "825a": function (t, e, n) {
      var i = n("861d"),
        r = String,
        a = TypeError;
      t.exports = function (t) {
        if (i(t)) return t;
        throw a(r(t) + " is not an object");
      };
    },
    "83ab": function (t, e, n) {
      var i = n("d039");
      t.exports = !i(function () {
        return (
          7 !=
          Object.defineProperty({}, 1, {
            get: function () {
              return 7;
            },
          })[1]
        );
      });
    },
    "83b9": function (t, e, n) {
      "use strict";
      var i = n("d925"),
        r = n("e683");
      t.exports = function (t, e) {
        return t && !i(e) ? r(t, e) : e;
      };
    },
    "848b": function (t, e, n) {
      "use strict";
      var i = n("4a0c"),
        r = {};
      ["object", "boolean", "number", "function", "string", "symbol"].forEach(
        function (t, e) {
          r[t] = function (n) {
            return typeof n === t || "a" + (e < 1 ? "n " : " ") + t;
          };
        }
      );
      var a = {},
        o = i.version.split(".");
      function s(t, e) {
        for (
          var n = e ? e.split(".") : o, i = t.split("."), r = 0;
          r < 3;
          r++
        ) {
          if (n[r] > i[r]) return !0;
          if (n[r] < i[r]) return !1;
        }
        return !1;
      }
      function c(t, e, n) {
        if ("object" !== typeof t)
          throw new TypeError("options must be an object");
        var i = Object.keys(t),
          r = i.length;
        while (r-- > 0) {
          var a = i[r],
            o = e[a];
          if (o) {
            var s = t[a],
              c = void 0 === s || o(s, a, t);
            if (!0 !== c) throw new TypeError("option " + a + " must be " + c);
          } else if (!0 !== n) throw Error("Unknown option " + a);
        }
      }
      (r.transitional = function (t, e, n) {
        var r = e && s(e);
        function o(t, e) {
          return (
            "[Axios v" +
            i.version +
            "] Transitional option '" +
            t +
            "'" +
            e +
            (n ? ". " + n : "")
          );
        }
        return function (n, i, s) {
          if (!1 === t) throw new Error(o(i, " has been removed in " + e));
          return (
            r &&
              !a[i] &&
              ((a[i] = !0),
              console.warn(
                o(
                  i,
                  " has been deprecated since v" +
                    e +
                    " and will be removed in the near future"
                )
              )),
            !t || t(n, i, s)
          );
        };
      }),
        (t.exports = { isOlderVersion: s, assertOptions: c, validators: r });
    },
    "861d": function (t, e, n) {
      var i = n("1626"),
        r = n("8ea1"),
        a = r.all;
      t.exports = r.IS_HTMLDDA
        ? function (t) {
            return "object" == typeof t ? null !== t : i(t) || t === a;
          }
        : function (t) {
            return "object" == typeof t ? null !== t : i(t);
          };
    },
    8925: function (t, e, n) {
      var i = n("e330"),
        r = n("1626"),
        a = n("c6cd"),
        o = i(Function.toString);
      r(a.inspectSource) ||
        (a.inspectSource = function (t) {
          return o(t);
        }),
        (t.exports = a.inspectSource);
    },
    "8a05": function (t, e, n) {
      "use strict";
      var i =
        (this && this.__extends) ||
        (function () {
          var t =
            Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array &&
              function (t, e) {
                t.__proto__ = e;
              }) ||
            function (t, e) {
              for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n]);
            };
          return function (e, n) {
            function i() {
              this.constructor = e;
            }
            t(e, n),
              (e.prototype =
                null === n
                  ? Object.create(n)
                  : ((i.prototype = n.prototype), new i()));
          };
        })();
      Object.defineProperty(e, "__esModule", { value: !0 });
      var r = n("2ea7"),
        a = {
          NONE: -1,
          ROTATE: 0,
          DOLLY: 1,
          PAN: 2,
          TOUCH_ROTATE: 3,
          TOUCH_DOLLY: 4,
          TOUCH_PAN: 5,
        },
        o = { type: "change" },
        s = { type: "start" },
        c = { type: "end" },
        l = 1e-6,
        h = (function (t) {
          function e(e, n, i) {
            var o = t.call(this) || this;
            return (
              (o.object = e),
              (o.domElement = void 0 !== n ? n : document),
              (o.window = void 0 !== i ? i : window),
              (o.enabled = !0),
              (o.target = new r.Vector3()),
              (o.minDistance = 0),
              (o.maxDistance = 1 / 0),
              (o.minZoom = 0),
              (o.maxZoom = 1 / 0),
              (o.minPolarAngle = 0),
              (o.maxPolarAngle = Math.PI),
              (o.minAzimuthAngle = -1 / 0),
              (o.maxAzimuthAngle = 1 / 0),
              (o.enableDamping = !1),
              (o.dampingFactor = 0.25),
              (o.enableZoom = !0),
              (o.zoomSpeed = 1),
              (o.enableRotate = !0),
              (o.rotateSpeed = 1),
              (o.enablePan = !0),
              (o.keyPanSpeed = 7),
              (o.autoRotate = !1),
              (o.autoRotateSpeed = 2),
              (o.enableKeys = !0),
              (o.keys = { LEFT: 37, UP: 38, RIGHT: 39, BOTTOM: 40 }),
              (o.mouseButtons = {
                ORBIT: r.MOUSE.LEFT,
                ZOOM: r.MOUSE.MIDDLE,
                PAN: r.MOUSE.RIGHT,
              }),
              (o.target0 = o.target.clone()),
              (o.position0 = o.object.position.clone()),
              (o.zoom0 = o.object.zoom),
              (o.updateOffset = new r.Vector3()),
              (o.updateQuat = new r.Quaternion().setFromUnitVectors(
                e.up,
                new r.Vector3(0, 1, 0)
              )),
              (o.updateQuatInverse = o.updateQuat.clone().inverse()),
              (o.updateLastPosition = new r.Vector3()),
              (o.updateLastQuaternion = new r.Quaternion()),
              (o.state = a.NONE),
              (o.scale = 1),
              (o.spherical = new r.Spherical()),
              (o.sphericalDelta = new r.Spherical()),
              (o.panOffset = new r.Vector3()),
              (o.zoomChanged = !1),
              (o.rotateStart = new r.Vector2()),
              (o.rotateEnd = new r.Vector2()),
              (o.rotateDelta = new r.Vector2()),
              (o.panStart = new r.Vector2()),
              (o.panEnd = new r.Vector2()),
              (o.panDelta = new r.Vector2()),
              (o.dollyStart = new r.Vector2()),
              (o.dollyEnd = new r.Vector2()),
              (o.dollyDelta = new r.Vector2()),
              (o.panLeftV = new r.Vector3()),
              (o.panUpV = new r.Vector3()),
              (o.panInternalOffset = new r.Vector3()),
              (o.onMouseDown = function (t) {
                if (!1 !== o.enabled) {
                  if ((t.preventDefault(), t.button === o.mouseButtons.ORBIT)) {
                    if (!1 === o.enableRotate) return;
                    o.rotateStart.set(t.clientX, t.clientY),
                      (o.state = a.ROTATE);
                  } else if (t.button === o.mouseButtons.ZOOM) {
                    if (!1 === o.enableZoom) return;
                    o.dollyStart.set(t.clientX, t.clientY), (o.state = a.DOLLY);
                  } else if (t.button === o.mouseButtons.PAN) {
                    if (!1 === o.enablePan) return;
                    o.panStart.set(t.clientX, t.clientY), (o.state = a.PAN);
                  }
                  o.state !== a.NONE &&
                    (document.addEventListener("mousemove", o.onMouseMove, !1),
                    document.addEventListener("mouseup", o.onMouseUp, !1),
                    o.dispatchEvent(s));
                }
              }),
              (o.onMouseMove = function (t) {
                if (!1 !== o.enabled)
                  if ((t.preventDefault(), o.state === a.ROTATE)) {
                    if (!1 === o.enableRotate) return;
                    o.rotateEnd.set(t.clientX, t.clientY),
                      o.rotateDelta.subVectors(o.rotateEnd, o.rotateStart);
                    var e =
                      o.domElement === document
                        ? o.domElement.body
                        : o.domElement;
                    o.rotateLeft(
                      ((2 * Math.PI * o.rotateDelta.x) / e.clientWidth) *
                        o.rotateSpeed
                    ),
                      o.rotateUp(
                        ((2 * Math.PI * o.rotateDelta.y) / e.clientHeight) *
                          o.rotateSpeed
                      ),
                      o.rotateStart.copy(o.rotateEnd),
                      o.update();
                  } else if (o.state === a.DOLLY) {
                    if (!1 === o.enableZoom) return;
                    o.dollyEnd.set(t.clientX, t.clientY),
                      o.dollyDelta.subVectors(o.dollyEnd, o.dollyStart),
                      o.dollyDelta.y > 0
                        ? o.dollyIn(o.getZoomScale())
                        : o.dollyDelta.y < 0 && o.dollyOut(o.getZoomScale()),
                      o.dollyStart.copy(o.dollyEnd),
                      o.update();
                  } else if (o.state === a.PAN) {
                    if (!1 === o.enablePan) return;
                    o.panEnd.set(t.clientX, t.clientY),
                      o.panDelta.subVectors(o.panEnd, o.panStart),
                      o.pan(o.panDelta.x, o.panDelta.y),
                      o.panStart.copy(o.panEnd),
                      o.update();
                  }
              }),
              (o.onMouseUp = function (t) {
                !1 !== o.enabled &&
                  (document.removeEventListener("mousemove", o.onMouseMove, !1),
                  document.removeEventListener("mouseup", o.onMouseUp, !1),
                  o.dispatchEvent(c),
                  (o.state = a.NONE));
              }),
              (o.onMouseWheel = function (t) {
                !1 === o.enabled ||
                  !1 === o.enableZoom ||
                  (o.state !== a.NONE && o.state !== a.ROTATE) ||
                  (t.preventDefault(),
                  t.stopPropagation(),
                  t.deltaY < 0
                    ? o.dollyOut(o.getZoomScale())
                    : t.deltaY > 0 && o.dollyIn(o.getZoomScale()),
                  o.update(),
                  o.dispatchEvent(s),
                  o.dispatchEvent(c));
              }),
              (o.onKeyDown = function (t) {
                if (
                  !1 !== o.enabled &&
                  !1 !== o.enableKeys &&
                  !1 !== o.enablePan
                )
                  switch (t.keyCode) {
                    case o.keys.UP:
                      o.pan(0, o.keyPanSpeed), o.update();
                      break;
                    case o.keys.BOTTOM:
                      o.pan(0, -o.keyPanSpeed), o.update();
                      break;
                    case o.keys.LEFT:
                      o.pan(o.keyPanSpeed, 0), o.update();
                      break;
                    case o.keys.RIGHT:
                      o.pan(-o.keyPanSpeed, 0), o.update();
                      break;
                  }
              }),
              (o.onTouchStart = function (t) {
                if (!1 !== o.enabled) {
                  switch (t.touches.length) {
                    case 1:
                      if (!1 === o.enableRotate) return;
                      o.rotateStart.set(t.touches[0].pageX, t.touches[0].pageY),
                        (o.state = a.TOUCH_ROTATE);
                      break;
                    case 2:
                      if (!1 === o.enableZoom) return;
                      var e = t.touches[0].pageX - t.touches[1].pageX,
                        n = t.touches[0].pageY - t.touches[1].pageY,
                        i = Math.sqrt(e * e + n * n);
                      o.dollyStart.set(0, i), (o.state = a.TOUCH_DOLLY);
                      break;
                    case 3:
                      if (!1 === o.enablePan) return;
                      o.panStart.set(t.touches[0].pageX, t.touches[0].pageY),
                        (o.state = a.TOUCH_PAN);
                      break;
                    default:
                      o.state = a.NONE;
                  }
                  o.state !== a.NONE && o.dispatchEvent(s);
                }
              }),
              (o.onTouchMove = function (t) {
                if (!1 !== o.enabled)
                  switch (
                    (t.preventDefault(), t.stopPropagation(), t.touches.length)
                  ) {
                    case 1:
                      if (!1 === o.enableRotate) return;
                      if (o.state !== a.TOUCH_ROTATE) return;
                      o.rotateEnd.set(t.touches[0].pageX, t.touches[0].pageY),
                        o.rotateDelta.subVectors(o.rotateEnd, o.rotateStart);
                      var e =
                        o.domElement === document
                          ? o.domElement.body
                          : o.domElement;
                      o.rotateLeft(
                        ((2 * Math.PI * o.rotateDelta.x) / e.clientWidth) *
                          o.rotateSpeed
                      ),
                        o.rotateUp(
                          ((2 * Math.PI * o.rotateDelta.y) / e.clientHeight) *
                            o.rotateSpeed
                        ),
                        o.rotateStart.copy(o.rotateEnd),
                        o.update();
                      break;
                    case 2:
                      if (!1 === o.enableZoom) return;
                      if (o.state !== a.TOUCH_DOLLY) return;
                      var n = t.touches[0].pageX - t.touches[1].pageX,
                        i = t.touches[0].pageY - t.touches[1].pageY,
                        r = Math.sqrt(n * n + i * i);
                      o.dollyEnd.set(0, r),
                        o.dollyDelta.subVectors(o.dollyEnd, o.dollyStart),
                        o.dollyDelta.y > 0
                          ? o.dollyOut(o.getZoomScale())
                          : o.dollyDelta.y < 0 && o.dollyIn(o.getZoomScale()),
                        o.dollyStart.copy(o.dollyEnd),
                        o.update();
                      break;
                    case 3:
                      if (!1 === o.enablePan) return;
                      if (o.state !== a.TOUCH_PAN) return;
                      o.panEnd.set(t.touches[0].pageX, t.touches[0].pageY),
                        o.panDelta.subVectors(o.panEnd, o.panStart),
                        o.pan(o.panDelta.x, o.panDelta.y),
                        o.panStart.copy(o.panEnd),
                        o.update();
                      break;
                    default:
                      o.state = a.NONE;
                  }
              }),
              (o.onTouchEnd = function (t) {
                !1 !== o.enabled && (o.dispatchEvent(c), (o.state = a.NONE));
              }),
              (o.onContextMenu = function (t) {
                t.preventDefault();
              }),
              o.domElement.addEventListener("contextmenu", o.onContextMenu, !1),
              o.domElement.addEventListener("mousedown", o.onMouseDown, !1),
              o.domElement.addEventListener("wheel", o.onMouseWheel, !1),
              o.domElement.addEventListener("touchstart", o.onTouchStart, !1),
              o.domElement.addEventListener("touchend", o.onTouchEnd, !1),
              o.domElement.addEventListener("touchmove", o.onTouchMove, !1),
              o.window.addEventListener("keydown", o.onKeyDown, !1),
              o.update(),
              o
            );
          }
          return (
            i(e, t),
            (e.prototype.update = function () {
              var t = this.object.position;
              return (
                this.updateOffset.copy(t).sub(this.target),
                this.updateOffset.applyQuaternion(this.updateQuat),
                this.spherical.setFromVector3(this.updateOffset),
                this.autoRotate &&
                  this.state === a.NONE &&
                  this.rotateLeft(this.getAutoRotationAngle()),
                (this.spherical.theta += this.sphericalDelta.theta),
                (this.spherical.phi += this.sphericalDelta.phi),
                (this.spherical.theta = Math.max(
                  this.minAzimuthAngle,
                  Math.min(this.maxAzimuthAngle, this.spherical.theta)
                )),
                (this.spherical.phi = Math.max(
                  this.minPolarAngle,
                  Math.min(this.maxPolarAngle, this.spherical.phi)
                )),
                this.spherical.makeSafe(),
                (this.spherical.radius *= this.scale),
                (this.spherical.radius = Math.max(
                  this.minDistance,
                  Math.min(this.maxDistance, this.spherical.radius)
                )),
                this.target.add(this.panOffset),
                this.updateOffset.setFromSpherical(this.spherical),
                this.updateOffset.applyQuaternion(this.updateQuatInverse),
                t.copy(this.target).add(this.updateOffset),
                this.object.lookAt(this.target),
                !0 === this.enableDamping
                  ? ((this.sphericalDelta.theta *= 1 - this.dampingFactor),
                    (this.sphericalDelta.phi *= 1 - this.dampingFactor))
                  : this.sphericalDelta.set(0, 0, 0),
                (this.scale = 1),
                this.panOffset.set(0, 0, 0),
                !!(
                  this.zoomChanged ||
                  this.updateLastPosition.distanceToSquared(
                    this.object.position
                  ) > l ||
                  8 *
                    (1 -
                      this.updateLastQuaternion.dot(this.object.quaternion)) >
                    l
                ) &&
                  (this.dispatchEvent(o),
                  this.updateLastPosition.copy(this.object.position),
                  this.updateLastQuaternion.copy(this.object.quaternion),
                  (this.zoomChanged = !1),
                  !0)
              );
            }),
            (e.prototype.panLeft = function (t, e) {
              this.panLeftV.setFromMatrixColumn(e, 0),
                this.panLeftV.multiplyScalar(-t),
                this.panOffset.add(this.panLeftV);
            }),
            (e.prototype.panUp = function (t, e) {
              this.panUpV.setFromMatrixColumn(e, 1),
                this.panUpV.multiplyScalar(t),
                this.panOffset.add(this.panUpV);
            }),
            (e.prototype.pan = function (t, e) {
              var n =
                this.domElement === document
                  ? this.domElement.body
                  : this.domElement;
              if (this._checkPerspectiveCamera(this.object)) {
                var i = this.object.position;
                this.panInternalOffset.copy(i).sub(this.target);
                var r = this.panInternalOffset.length();
                (r *= Math.tan(((this.object.fov / 2) * Math.PI) / 180)),
                  this.panLeft(
                    (2 * t * r) / n.clientHeight,
                    this.object.matrix
                  ),
                  this.panUp((2 * e * r) / n.clientHeight, this.object.matrix);
              } else
                this._checkOrthographicCamera(this.object)
                  ? (this.panLeft(
                      (t * (this.object.right - this.object.left)) /
                        this.object.zoom /
                        n.clientWidth,
                      this.object.matrix
                    ),
                    this.panUp(
                      (e * (this.object.top - this.object.bottom)) /
                        this.object.zoom /
                        n.clientHeight,
                      this.object.matrix
                    ))
                  : (console.warn(
                      "WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."
                    ),
                    (this.enablePan = !1));
            }),
            (e.prototype.dollyIn = function (t) {
              this._checkPerspectiveCamera(this.object)
                ? (this.scale /= t)
                : this._checkOrthographicCamera(this.object)
                ? ((this.object.zoom = Math.max(
                    this.minZoom,
                    Math.min(this.maxZoom, this.object.zoom * t)
                  )),
                  this.object.updateProjectionMatrix(),
                  (this.zoomChanged = !0))
                : (console.warn(
                    "WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."
                  ),
                  (this.enableZoom = !1));
            }),
            (e.prototype.dollyOut = function (t) {
              this._checkPerspectiveCamera(this.object)
                ? (this.scale *= t)
                : this._checkOrthographicCamera(this.object)
                ? ((this.object.zoom = Math.max(
                    this.minZoom,
                    Math.min(this.maxZoom, this.object.zoom / t)
                  )),
                  this.object.updateProjectionMatrix(),
                  (this.zoomChanged = !0))
                : (console.warn(
                    "WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."
                  ),
                  (this.enableZoom = !1));
            }),
            (e.prototype.getAutoRotationAngle = function () {
              return ((2 * Math.PI) / 60 / 60) * this.autoRotateSpeed;
            }),
            (e.prototype.getZoomScale = function () {
              return Math.pow(0.95, this.zoomSpeed);
            }),
            (e.prototype.rotateLeft = function (t) {
              this.sphericalDelta.theta -= t;
            }),
            (e.prototype.rotateUp = function (t) {
              this.sphericalDelta.phi -= t;
            }),
            (e.prototype.getPolarAngle = function () {
              return this.spherical.phi;
            }),
            (e.prototype.getAzimuthalAngle = function () {
              return this.spherical.theta;
            }),
            (e.prototype.dispose = function () {
              this.domElement.removeEventListener(
                "contextmenu",
                this.onContextMenu,
                !1
              ),
                this.domElement.removeEventListener(
                  "mousedown",
                  this.onMouseDown,
                  !1
                ),
                this.domElement.removeEventListener(
                  "wheel",
                  this.onMouseWheel,
                  !1
                ),
                this.domElement.removeEventListener(
                  "touchstart",
                  this.onTouchStart,
                  !1
                ),
                this.domElement.removeEventListener(
                  "touchend",
                  this.onTouchEnd,
                  !1
                ),
                this.domElement.removeEventListener(
                  "touchmove",
                  this.onTouchMove,
                  !1
                ),
                document.removeEventListener("mousemove", this.onMouseMove, !1),
                document.removeEventListener("mouseup", this.onMouseUp, !1),
                this.window.removeEventListener("keydown", this.onKeyDown, !1);
            }),
            (e.prototype.reset = function () {
              this.target.copy(this.target0),
                this.object.position.copy(this.position0),
                (this.object.zoom = this.zoom0),
                this.object.updateProjectionMatrix(),
                this.dispatchEvent(o),
                this.update(),
                (this.state = a.NONE);
            }),
            (e.prototype.saveState = function () {
              this.target0.copy(this.target),
                this.position0.copy(this.object.position),
                (this._checkOrthographicCamera(this.object) ||
                  this._checkPerspectiveCamera(this.object)) &&
                  (this.zoom0 = this.object.zoom);
            }),
            Object.defineProperty(e.prototype, "center", {
              get: function () {
                return (
                  console.warn(
                    "THREE.OrbitControls: .center has been renamed to .target"
                  ),
                  this.target
                );
              },
              enumerable: !0,
              configurable: !0,
            }),
            Object.defineProperty(e.prototype, "noZoom", {
              get: function () {
                return (
                  console.warn(
                    "THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead."
                  ),
                  !this.enableZoom
                );
              },
              set: function (t) {
                console.warn(
                  "THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead."
                ),
                  (this.enableZoom = !t);
              },
              enumerable: !0,
              configurable: !0,
            }),
            (e.prototype._checkPerspectiveCamera = function (t) {
              return t.isPerspectiveCamera;
            }),
            (e.prototype._checkOrthographicCamera = function (t) {
              return t.isOrthographicCamera;
            }),
            e
          );
        })(r.EventDispatcher);
      e.OrbitControls = h;
    },
    "8bbf": function (e, n) {
      e.exports = t;
    },
    "8cef": function (t, e, n) {
      (function (e, i, r) {
        t.exports = i(n("21bf"), n("38ba"));
      })(0, function (t) {
        return (
          (t.pad.Iso97971 = {
            pad: function (e, n) {
              e.concat(t.lib.WordArray.create([2147483648], 1)),
                t.pad.ZeroPadding.pad(e, n);
            },
            unpad: function (e) {
              t.pad.ZeroPadding.unpad(e), e.sigBytes--;
            },
          }),
          t.pad.Iso97971
        );
      });
    },
    "8df4": function (t, e, n) {
      "use strict";
      var i = n("7a77");
      function r(t) {
        if ("function" !== typeof t)
          throw new TypeError("executor must be a function.");
        var e;
        this.promise = new Promise(function (t) {
          e = t;
        });
        var n = this;
        t(function (t) {
          n.reason || ((n.reason = new i(t)), e(n.reason));
        });
      }
      (r.prototype.throwIfRequested = function () {
        if (this.reason) throw this.reason;
      }),
        (r.source = function () {
          var t,
            e = new r(function (e) {
              t = e;
            });
          return { token: e, cancel: t };
        }),
        (t.exports = r);
    },
    "8ea1": function (t, e) {
      var n = "object" == typeof document && document.all,
        i = "undefined" == typeof n && void 0 !== n;
      t.exports = { all: n, IS_HTMLDDA: i };
    },
    "90e3": function (t, e, n) {
      var i = n("e330"),
        r = 0,
        a = Math.random(),
        o = i((1).toString);
      t.exports = function (t) {
        return "Symbol(" + (void 0 === t ? "" : t) + ")_" + o(++r + a, 36);
      };
    },
    9112: function (t, e, n) {
      var i = n("83ab"),
        r = n("9bf2"),
        a = n("5c6c");
      t.exports = i
        ? function (t, e, n) {
            return r.f(t, e, a(1, n));
          }
        : function (t, e, n) {
            return (t[e] = n), t;
          };
    },
    "94ca": function (t, e, n) {
      var i = n("d039"),
        r = n("1626"),
        a = /#|\.prototype\./,
        o = function (t, e) {
          var n = c[s(t)];
          return n == h || (n != l && (r(e) ? i(e) : !!e));
        },
        s = (o.normalize = function (t) {
          return String(t).replace(a, ".").toLowerCase();
        }),
        c = (o.data = {}),
        l = (o.NATIVE = "N"),
        h = (o.POLYFILL = "P");
      t.exports = o;
    },
    "94f8": function (t, e, n) {
      (function (e, i) {
        t.exports = i(n("21bf"));
      })(0, function (t) {
        return (
          (function (e) {
            var n = t,
              i = n.lib,
              r = i.WordArray,
              a = i.Hasher,
              o = n.algo,
              s = [],
              c = [];
            (function () {
              function t(t) {
                for (var n = e.sqrt(t), i = 2; i <= n; i++)
                  if (!(t % i)) return !1;
                return !0;
              }
              function n(t) {
                return (4294967296 * (t - (0 | t))) | 0;
              }
              var i = 2,
                r = 0;
              while (r < 64)
                t(i) &&
                  (r < 8 && (s[r] = n(e.pow(i, 0.5))),
                  (c[r] = n(e.pow(i, 1 / 3))),
                  r++),
                  i++;
            })();
            var l = [],
              h = (o.SHA256 = a.extend({
                _doReset: function () {
                  this._hash = new r.init(s.slice(0));
                },
                _doProcessBlock: function (t, e) {
                  for (
                    var n = this._hash.words,
                      i = n[0],
                      r = n[1],
                      a = n[2],
                      o = n[3],
                      s = n[4],
                      h = n[5],
                      u = n[6],
                      d = n[7],
                      p = 0;
                    p < 64;
                    p++
                  ) {
                    if (p < 16) l[p] = 0 | t[e + p];
                    else {
                      var f = l[p - 15],
                        m =
                          ((f << 25) | (f >>> 7)) ^
                          ((f << 14) | (f >>> 18)) ^
                          (f >>> 3),
                        g = l[p - 2],
                        v =
                          ((g << 15) | (g >>> 17)) ^
                          ((g << 13) | (g >>> 19)) ^
                          (g >>> 10);
                      l[p] = m + l[p - 7] + v + l[p - 16];
                    }
                    var y = (s & h) ^ (~s & u),
                      x = (i & r) ^ (i & a) ^ (r & a),
                      _ =
                        ((i << 30) | (i >>> 2)) ^
                        ((i << 19) | (i >>> 13)) ^
                        ((i << 10) | (i >>> 22)),
                      b =
                        ((s << 26) | (s >>> 6)) ^
                        ((s << 21) | (s >>> 11)) ^
                        ((s << 7) | (s >>> 25)),
                      w = d + b + y + c[p] + l[p],
                      M = _ + x;
                    (d = u),
                      (u = h),
                      (h = s),
                      (s = (o + w) | 0),
                      (o = a),
                      (a = r),
                      (r = i),
                      (i = (w + M) | 0);
                  }
                  (n[0] = (n[0] + i) | 0),
                    (n[1] = (n[1] + r) | 0),
                    (n[2] = (n[2] + a) | 0),
                    (n[3] = (n[3] + o) | 0),
                    (n[4] = (n[4] + s) | 0),
                    (n[5] = (n[5] + h) | 0),
                    (n[6] = (n[6] + u) | 0),
                    (n[7] = (n[7] + d) | 0);
                },
                _doFinalize: function () {
                  var t = this._data,
                    n = t.words,
                    i = 8 * this._nDataBytes,
                    r = 8 * t.sigBytes;
                  return (
                    (n[r >>> 5] |= 128 << (24 - (r % 32))),
                    (n[14 + (((r + 64) >>> 9) << 4)] = e.floor(i / 4294967296)),
                    (n[15 + (((r + 64) >>> 9) << 4)] = i),
                    (t.sigBytes = 4 * n.length),
                    this._process(),
                    this._hash
                  );
                },
                clone: function () {
                  var t = a.clone.call(this);
                  return (t._hash = this._hash.clone()), t;
                },
              }));
            (n.SHA256 = a._createHelper(h)),
              (n.HmacSHA256 = a._createHmacHelper(h));
          })(Math),
          t.SHA256
        );
      });
    },
    "9bf2": function (t, e, n) {
      var i = n("83ab"),
        r = n("0cfb"),
        a = n("aed9"),
        o = n("825a"),
        s = n("a04b"),
        c = TypeError,
        l = Object.defineProperty,
        h = Object.getOwnPropertyDescriptor,
        u = "enumerable",
        d = "configurable",
        p = "writable";
      e.f = i
        ? a
          ? function (t, e, n) {
              if (
                (o(t),
                (e = s(e)),
                o(n),
                "function" === typeof t &&
                  "prototype" === e &&
                  "value" in n &&
                  p in n &&
                  !n[p])
              ) {
                var i = h(t, e);
                i &&
                  i[p] &&
                  ((t[e] = n.value),
                  (n = {
                    configurable: d in n ? n[d] : i[d],
                    enumerable: u in n ? n[u] : i[u],
                    writable: !1,
                  }));
              }
              return l(t, e, n);
            }
          : l
        : function (t, e, n) {
            if ((o(t), (e = s(e)), o(n), r))
              try {
                return l(t, e, n);
              } catch (i) {}
            if ("get" in n || "set" in n) throw c("Accessors not supported");
            return "value" in n && (t[e] = n.value), t;
          };
    },
    a04b: function (t, e, n) {
      var i = n("c04e"),
        r = n("d9b5");
      t.exports = function (t) {
        var e = i(t, "string");
        return r(e) ? e : e + "";
      };
    },
    a11b: function (t, e, n) {
      (function (e, i, r) {
        t.exports = i(n("21bf"), n("38ba"));
      })(0, function (t) {
        return (
          (t.pad.Iso10126 = {
            pad: function (e, n) {
              var i = 4 * n,
                r = i - (e.sigBytes % i);
              e.concat(t.lib.WordArray.random(r - 1)).concat(
                t.lib.WordArray.create([r << 24], 1)
              );
            },
            unpad: function (t) {
              var e = 255 & t.words[(t.sigBytes - 1) >>> 2];
              t.sigBytes -= e;
            },
          }),
          t.pad.Iso10126
        );
      });
    },
    a40e: function (t, e, n) {
      (function (e, i, r) {
        t.exports = i(n("21bf"), n("1132"), n("72fe"), n("2b79"), n("38ba"));
      })(0, function (t) {
        return (
          (function () {
            var e = t,
              n = e.lib,
              i = n.WordArray,
              r = n.BlockCipher,
              a = e.algo,
              o = [
                57, 49, 41, 33, 25, 17, 9, 1, 58, 50, 42, 34, 26, 18, 10, 2, 59,
                51, 43, 35, 27, 19, 11, 3, 60, 52, 44, 36, 63, 55, 47, 39, 31,
                23, 15, 7, 62, 54, 46, 38, 30, 22, 14, 6, 61, 53, 45, 37, 29,
                21, 13, 5, 28, 20, 12, 4,
              ],
              s = [
                14, 17, 11, 24, 1, 5, 3, 28, 15, 6, 21, 10, 23, 19, 12, 4, 26,
                8, 16, 7, 27, 20, 13, 2, 41, 52, 31, 37, 47, 55, 30, 40, 51, 45,
                33, 48, 44, 49, 39, 56, 34, 53, 46, 42, 50, 36, 29, 32,
              ],
              c = [1, 2, 4, 6, 8, 10, 12, 14, 15, 17, 19, 21, 23, 25, 27, 28],
              l = [
                {
                  0: 8421888,
                  268435456: 32768,
                  536870912: 8421378,
                  805306368: 2,
                  1073741824: 512,
                  1342177280: 8421890,
                  1610612736: 8389122,
                  1879048192: 8388608,
                  2147483648: 514,
                  2415919104: 8389120,
                  2684354560: 33280,
                  2952790016: 8421376,
                  3221225472: 32770,
                  3489660928: 8388610,
                  3758096384: 0,
                  4026531840: 33282,
                  134217728: 0,
                  402653184: 8421890,
                  671088640: 33282,
                  939524096: 32768,
                  1207959552: 8421888,
                  1476395008: 512,
                  1744830464: 8421378,
                  2013265920: 2,
                  2281701376: 8389120,
                  2550136832: 33280,
                  2818572288: 8421376,
                  3087007744: 8389122,
                  3355443200: 8388610,
                  3623878656: 32770,
                  3892314112: 514,
                  4160749568: 8388608,
                  1: 32768,
                  268435457: 2,
                  536870913: 8421888,
                  805306369: 8388608,
                  1073741825: 8421378,
                  1342177281: 33280,
                  1610612737: 512,
                  1879048193: 8389122,
                  2147483649: 8421890,
                  2415919105: 8421376,
                  2684354561: 8388610,
                  2952790017: 33282,
                  3221225473: 514,
                  3489660929: 8389120,
                  3758096385: 32770,
                  4026531841: 0,
                  134217729: 8421890,
                  402653185: 8421376,
                  671088641: 8388608,
                  939524097: 512,
                  1207959553: 32768,
                  1476395009: 8388610,
                  1744830465: 2,
                  2013265921: 33282,
                  2281701377: 32770,
                  2550136833: 8389122,
                  2818572289: 514,
                  3087007745: 8421888,
                  3355443201: 8389120,
                  3623878657: 0,
                  3892314113: 33280,
                  4160749569: 8421378,
                },
                {
                  0: 1074282512,
                  16777216: 16384,
                  33554432: 524288,
                  50331648: 1074266128,
                  67108864: 1073741840,
                  83886080: 1074282496,
                  100663296: 1073758208,
                  117440512: 16,
                  134217728: 540672,
                  150994944: 1073758224,
                  167772160: 1073741824,
                  184549376: 540688,
                  201326592: 524304,
                  218103808: 0,
                  234881024: 16400,
                  251658240: 1074266112,
                  8388608: 1073758208,
                  25165824: 540688,
                  41943040: 16,
                  58720256: 1073758224,
                  75497472: 1074282512,
                  92274688: 1073741824,
                  109051904: 524288,
                  125829120: 1074266128,
                  142606336: 524304,
                  159383552: 0,
                  176160768: 16384,
                  192937984: 1074266112,
                  209715200: 1073741840,
                  226492416: 540672,
                  243269632: 1074282496,
                  260046848: 16400,
                  268435456: 0,
                  285212672: 1074266128,
                  301989888: 1073758224,
                  318767104: 1074282496,
                  335544320: 1074266112,
                  352321536: 16,
                  369098752: 540688,
                  385875968: 16384,
                  402653184: 16400,
                  419430400: 524288,
                  436207616: 524304,
                  452984832: 1073741840,
                  469762048: 540672,
                  486539264: 1073758208,
                  503316480: 1073741824,
                  520093696: 1074282512,
                  276824064: 540688,
                  293601280: 524288,
                  310378496: 1074266112,
                  327155712: 16384,
                  343932928: 1073758208,
                  360710144: 1074282512,
                  377487360: 16,
                  394264576: 1073741824,
                  411041792: 1074282496,
                  427819008: 1073741840,
                  444596224: 1073758224,
                  461373440: 524304,
                  478150656: 0,
                  494927872: 16400,
                  511705088: 1074266128,
                  528482304: 540672,
                },
                {
                  0: 260,
                  1048576: 0,
                  2097152: 67109120,
                  3145728: 65796,
                  4194304: 65540,
                  5242880: 67108868,
                  6291456: 67174660,
                  7340032: 67174400,
                  8388608: 67108864,
                  9437184: 67174656,
                  10485760: 65792,
                  11534336: 67174404,
                  12582912: 67109124,
                  13631488: 65536,
                  14680064: 4,
                  15728640: 256,
                  524288: 67174656,
                  1572864: 67174404,
                  2621440: 0,
                  3670016: 67109120,
                  4718592: 67108868,
                  5767168: 65536,
                  6815744: 65540,
                  7864320: 260,
                  8912896: 4,
                  9961472: 256,
                  11010048: 67174400,
                  12058624: 65796,
                  13107200: 65792,
                  14155776: 67109124,
                  15204352: 67174660,
                  16252928: 67108864,
                  16777216: 67174656,
                  17825792: 65540,
                  18874368: 65536,
                  19922944: 67109120,
                  20971520: 256,
                  22020096: 67174660,
                  23068672: 67108868,
                  24117248: 0,
                  25165824: 67109124,
                  26214400: 67108864,
                  27262976: 4,
                  28311552: 65792,
                  29360128: 67174400,
                  30408704: 260,
                  31457280: 65796,
                  32505856: 67174404,
                  17301504: 67108864,
                  18350080: 260,
                  19398656: 67174656,
                  20447232: 0,
                  21495808: 65540,
                  22544384: 67109120,
                  23592960: 256,
                  24641536: 67174404,
                  25690112: 65536,
                  26738688: 67174660,
                  27787264: 65796,
                  28835840: 67108868,
                  29884416: 67109124,
                  30932992: 67174400,
                  31981568: 4,
                  33030144: 65792,
                },
                {
                  0: 2151682048,
                  65536: 2147487808,
                  131072: 4198464,
                  196608: 2151677952,
                  262144: 0,
                  327680: 4198400,
                  393216: 2147483712,
                  458752: 4194368,
                  524288: 2147483648,
                  589824: 4194304,
                  655360: 64,
                  720896: 2147487744,
                  786432: 2151678016,
                  851968: 4160,
                  917504: 4096,
                  983040: 2151682112,
                  32768: 2147487808,
                  98304: 64,
                  163840: 2151678016,
                  229376: 2147487744,
                  294912: 4198400,
                  360448: 2151682112,
                  425984: 0,
                  491520: 2151677952,
                  557056: 4096,
                  622592: 2151682048,
                  688128: 4194304,
                  753664: 4160,
                  819200: 2147483648,
                  884736: 4194368,
                  950272: 4198464,
                  1015808: 2147483712,
                  1048576: 4194368,
                  1114112: 4198400,
                  1179648: 2147483712,
                  1245184: 0,
                  1310720: 4160,
                  1376256: 2151678016,
                  1441792: 2151682048,
                  1507328: 2147487808,
                  1572864: 2151682112,
                  1638400: 2147483648,
                  1703936: 2151677952,
                  1769472: 4198464,
                  1835008: 2147487744,
                  1900544: 4194304,
                  1966080: 64,
                  2031616: 4096,
                  1081344: 2151677952,
                  1146880: 2151682112,
                  1212416: 0,
                  1277952: 4198400,
                  1343488: 4194368,
                  1409024: 2147483648,
                  1474560: 2147487808,
                  1540096: 64,
                  1605632: 2147483712,
                  1671168: 4096,
                  1736704: 2147487744,
                  1802240: 2151678016,
                  1867776: 4160,
                  1933312: 2151682048,
                  1998848: 4194304,
                  2064384: 4198464,
                },
                {
                  0: 128,
                  4096: 17039360,
                  8192: 262144,
                  12288: 536870912,
                  16384: 537133184,
                  20480: 16777344,
                  24576: 553648256,
                  28672: 262272,
                  32768: 16777216,
                  36864: 537133056,
                  40960: 536871040,
                  45056: 553910400,
                  49152: 553910272,
                  53248: 0,
                  57344: 17039488,
                  61440: 553648128,
                  2048: 17039488,
                  6144: 553648256,
                  10240: 128,
                  14336: 17039360,
                  18432: 262144,
                  22528: 537133184,
                  26624: 553910272,
                  30720: 536870912,
                  34816: 537133056,
                  38912: 0,
                  43008: 553910400,
                  47104: 16777344,
                  51200: 536871040,
                  55296: 553648128,
                  59392: 16777216,
                  63488: 262272,
                  65536: 262144,
                  69632: 128,
                  73728: 536870912,
                  77824: 553648256,
                  81920: 16777344,
                  86016: 553910272,
                  90112: 537133184,
                  94208: 16777216,
                  98304: 553910400,
                  102400: 553648128,
                  106496: 17039360,
                  110592: 537133056,
                  114688: 262272,
                  118784: 536871040,
                  122880: 0,
                  126976: 17039488,
                  67584: 553648256,
                  71680: 16777216,
                  75776: 17039360,
                  79872: 537133184,
                  83968: 536870912,
                  88064: 17039488,
                  92160: 128,
                  96256: 553910272,
                  100352: 262272,
                  104448: 553910400,
                  108544: 0,
                  112640: 553648128,
                  116736: 16777344,
                  120832: 262144,
                  124928: 537133056,
                  129024: 536871040,
                },
                {
                  0: 268435464,
                  256: 8192,
                  512: 270532608,
                  768: 270540808,
                  1024: 268443648,
                  1280: 2097152,
                  1536: 2097160,
                  1792: 268435456,
                  2048: 0,
                  2304: 268443656,
                  2560: 2105344,
                  2816: 8,
                  3072: 270532616,
                  3328: 2105352,
                  3584: 8200,
                  3840: 270540800,
                  128: 270532608,
                  384: 270540808,
                  640: 8,
                  896: 2097152,
                  1152: 2105352,
                  1408: 268435464,
                  1664: 268443648,
                  1920: 8200,
                  2176: 2097160,
                  2432: 8192,
                  2688: 268443656,
                  2944: 270532616,
                  3200: 0,
                  3456: 270540800,
                  3712: 2105344,
                  3968: 268435456,
                  4096: 268443648,
                  4352: 270532616,
                  4608: 270540808,
                  4864: 8200,
                  5120: 2097152,
                  5376: 268435456,
                  5632: 268435464,
                  5888: 2105344,
                  6144: 2105352,
                  6400: 0,
                  6656: 8,
                  6912: 270532608,
                  7168: 8192,
                  7424: 268443656,
                  7680: 270540800,
                  7936: 2097160,
                  4224: 8,
                  4480: 2105344,
                  4736: 2097152,
                  4992: 268435464,
                  5248: 268443648,
                  5504: 8200,
                  5760: 270540808,
                  6016: 270532608,
                  6272: 270540800,
                  6528: 270532616,
                  6784: 8192,
                  7040: 2105352,
                  7296: 2097160,
                  7552: 0,
                  7808: 268435456,
                  8064: 268443656,
                },
                {
                  0: 1048576,
                  16: 33555457,
                  32: 1024,
                  48: 1049601,
                  64: 34604033,
                  80: 0,
                  96: 1,
                  112: 34603009,
                  128: 33555456,
                  144: 1048577,
                  160: 33554433,
                  176: 34604032,
                  192: 34603008,
                  208: 1025,
                  224: 1049600,
                  240: 33554432,
                  8: 34603009,
                  24: 0,
                  40: 33555457,
                  56: 34604032,
                  72: 1048576,
                  88: 33554433,
                  104: 33554432,
                  120: 1025,
                  136: 1049601,
                  152: 33555456,
                  168: 34603008,
                  184: 1048577,
                  200: 1024,
                  216: 34604033,
                  232: 1,
                  248: 1049600,
                  256: 33554432,
                  272: 1048576,
                  288: 33555457,
                  304: 34603009,
                  320: 1048577,
                  336: 33555456,
                  352: 34604032,
                  368: 1049601,
                  384: 1025,
                  400: 34604033,
                  416: 1049600,
                  432: 1,
                  448: 0,
                  464: 34603008,
                  480: 33554433,
                  496: 1024,
                  264: 1049600,
                  280: 33555457,
                  296: 34603009,
                  312: 1,
                  328: 33554432,
                  344: 1048576,
                  360: 1025,
                  376: 34604032,
                  392: 33554433,
                  408: 34603008,
                  424: 0,
                  440: 34604033,
                  456: 1049601,
                  472: 1024,
                  488: 33555456,
                  504: 1048577,
                },
                {
                  0: 134219808,
                  1: 131072,
                  2: 134217728,
                  3: 32,
                  4: 131104,
                  5: 134350880,
                  6: 134350848,
                  7: 2048,
                  8: 134348800,
                  9: 134219776,
                  10: 133120,
                  11: 134348832,
                  12: 2080,
                  13: 0,
                  14: 134217760,
                  15: 133152,
                  2147483648: 2048,
                  2147483649: 134350880,
                  2147483650: 134219808,
                  2147483651: 134217728,
                  2147483652: 134348800,
                  2147483653: 133120,
                  2147483654: 133152,
                  2147483655: 32,
                  2147483656: 134217760,
                  2147483657: 2080,
                  2147483658: 131104,
                  2147483659: 134350848,
                  2147483660: 0,
                  2147483661: 134348832,
                  2147483662: 134219776,
                  2147483663: 131072,
                  16: 133152,
                  17: 134350848,
                  18: 32,
                  19: 2048,
                  20: 134219776,
                  21: 134217760,
                  22: 134348832,
                  23: 131072,
                  24: 0,
                  25: 131104,
                  26: 134348800,
                  27: 134219808,
                  28: 134350880,
                  29: 133120,
                  30: 2080,
                  31: 134217728,
                  2147483664: 131072,
                  2147483665: 2048,
                  2147483666: 134348832,
                  2147483667: 133152,
                  2147483668: 32,
                  2147483669: 134348800,
                  2147483670: 134217728,
                  2147483671: 134219808,
                  2147483672: 134350880,
                  2147483673: 134217760,
                  2147483674: 134219776,
                  2147483675: 0,
                  2147483676: 133120,
                  2147483677: 2080,
                  2147483678: 131104,
                  2147483679: 134350848,
                },
              ],
              h = [
                4160749569, 528482304, 33030144, 2064384, 129024, 8064, 504,
                2147483679,
              ],
              u = (a.DES = r.extend({
                _doReset: function () {
                  for (
                    var t = this._key, e = t.words, n = [], i = 0;
                    i < 56;
                    i++
                  ) {
                    var r = o[i] - 1;
                    n[i] = (e[r >>> 5] >>> (31 - (r % 32))) & 1;
                  }
                  for (var a = (this._subKeys = []), l = 0; l < 16; l++) {
                    var h = (a[l] = []),
                      u = c[l];
                    for (i = 0; i < 24; i++)
                      (h[(i / 6) | 0] |=
                        n[(s[i] - 1 + u) % 28] << (31 - (i % 6))),
                        (h[4 + ((i / 6) | 0)] |=
                          n[28 + ((s[i + 24] - 1 + u) % 28)] << (31 - (i % 6)));
                    h[0] = (h[0] << 1) | (h[0] >>> 31);
                    for (i = 1; i < 7; i++) h[i] = h[i] >>> (4 * (i - 1) + 3);
                    h[7] = (h[7] << 5) | (h[7] >>> 27);
                  }
                  var d = (this._invSubKeys = []);
                  for (i = 0; i < 16; i++) d[i] = a[15 - i];
                },
                encryptBlock: function (t, e) {
                  this._doCryptBlock(t, e, this._subKeys);
                },
                decryptBlock: function (t, e) {
                  this._doCryptBlock(t, e, this._invSubKeys);
                },
                _doCryptBlock: function (t, e, n) {
                  (this._lBlock = t[e]),
                    (this._rBlock = t[e + 1]),
                    d.call(this, 4, 252645135),
                    d.call(this, 16, 65535),
                    p.call(this, 2, 858993459),
                    p.call(this, 8, 16711935),
                    d.call(this, 1, 1431655765);
                  for (var i = 0; i < 16; i++) {
                    for (
                      var r = n[i],
                        a = this._lBlock,
                        o = this._rBlock,
                        s = 0,
                        c = 0;
                      c < 8;
                      c++
                    )
                      s |= l[c][((o ^ r[c]) & h[c]) >>> 0];
                    (this._lBlock = o), (this._rBlock = a ^ s);
                  }
                  var u = this._lBlock;
                  (this._lBlock = this._rBlock),
                    (this._rBlock = u),
                    d.call(this, 1, 1431655765),
                    p.call(this, 8, 16711935),
                    p.call(this, 2, 858993459),
                    d.call(this, 16, 65535),
                    d.call(this, 4, 252645135),
                    (t[e] = this._lBlock),
                    (t[e + 1] = this._rBlock);
                },
                keySize: 2,
                ivSize: 2,
                blockSize: 2,
              }));
            function d(t, e) {
              var n = ((this._lBlock >>> t) ^ this._rBlock) & e;
              (this._rBlock ^= n), (this._lBlock ^= n << t);
            }
            function p(t, e) {
              var n = ((this._rBlock >>> t) ^ this._lBlock) & e;
              (this._lBlock ^= n), (this._rBlock ^= n << t);
            }
            e.DES = r._createHelper(u);
            var f = (a.TripleDES = r.extend({
              _doReset: function () {
                var t = this._key,
                  e = t.words;
                if (2 !== e.length && 4 !== e.length && e.length < 6)
                  throw new Error(
                    "Invalid key length - 3DES requires the key length to be 64, 128, 192 or >192."
                  );
                var n = e.slice(0, 2),
                  r = e.length < 4 ? e.slice(0, 2) : e.slice(2, 4),
                  a = e.length < 6 ? e.slice(0, 2) : e.slice(4, 6);
                (this._des1 = u.createEncryptor(i.create(n))),
                  (this._des2 = u.createEncryptor(i.create(r))),
                  (this._des3 = u.createEncryptor(i.create(a)));
              },
              encryptBlock: function (t, e) {
                this._des1.encryptBlock(t, e),
                  this._des2.decryptBlock(t, e),
                  this._des3.encryptBlock(t, e);
              },
              decryptBlock: function (t, e) {
                this._des3.decryptBlock(t, e),
                  this._des2.encryptBlock(t, e),
                  this._des1.decryptBlock(t, e);
              },
              keySize: 6,
              ivSize: 2,
              blockSize: 2,
            }));
            e.TripleDES = r._createHelper(f);
          })(),
          t.TripleDES
        );
      });
    },
    a817: function (t, e, n) {
      (function (e, i, r) {
        t.exports = i(n("21bf"), n("38ba"));
      })(0, function (t) {
        return (
          (t.pad.AnsiX923 = {
            pad: function (t, e) {
              var n = t.sigBytes,
                i = 4 * e,
                r = i - (n % i),
                a = n + r - 1;
              t.clamp(),
                (t.words[a >>> 2] |= r << (24 - (a % 4) * 8)),
                (t.sigBytes += r);
            },
            unpad: function (t) {
              var e = 255 & t.words[(t.sigBytes - 1) >>> 2];
              t.sigBytes -= e;
            },
          }),
          t.pad.Ansix923
        );
      });
    },
    a8ce: function (t, e, n) {
      (function (e, i) {
        t.exports = i(n("21bf"));
      })(0, function (t) {
        return (
          (function () {
            var e = t,
              n = e.lib,
              i = n.WordArray,
              r = e.enc;
            r.Utf16 = r.Utf16BE = {
              stringify: function (t) {
                for (
                  var e = t.words, n = t.sigBytes, i = [], r = 0;
                  r < n;
                  r += 2
                ) {
                  var a = (e[r >>> 2] >>> (16 - (r % 4) * 8)) & 65535;
                  i.push(String.fromCharCode(a));
                }
                return i.join("");
              },
              parse: function (t) {
                for (var e = t.length, n = [], r = 0; r < e; r++)
                  n[r >>> 1] |= t.charCodeAt(r) << (16 - (r % 2) * 16);
                return i.create(n, 2 * e);
              },
            };
            function a(t) {
              return ((t << 8) & 4278255360) | ((t >>> 8) & 16711935);
            }
            r.Utf16LE = {
              stringify: function (t) {
                for (
                  var e = t.words, n = t.sigBytes, i = [], r = 0;
                  r < n;
                  r += 2
                ) {
                  var o = a((e[r >>> 2] >>> (16 - (r % 4) * 8)) & 65535);
                  i.push(String.fromCharCode(o));
                }
                return i.join("");
              },
              parse: function (t) {
                for (var e = t.length, n = [], r = 0; r < e; r++)
                  n[r >>> 1] |= a(t.charCodeAt(r) << (16 - (r % 2) * 16));
                return i.create(n, 2 * e);
              },
            };
          })(),
          t.enc.Utf16
        );
      });
    },
    aaef: function (t, e, n) {
      (function (e, i, r) {
        t.exports = i(n("21bf"), n("38ba"));
      })(0, function (t) {
        /** @preserve
         * Counter block mode compatible with  Dr Brian Gladman fileenc.c
         * derived from CryptoJS.mode.CTR
         * Jan Hruby jhruby.web@gmail.com
         */
        return (
          (t.mode.CTRGladman = (function () {
            var e = t.lib.BlockCipherMode.extend();
            function n(t) {
              if (255 === ((t >> 24) & 255)) {
                var e = (t >> 16) & 255,
                  n = (t >> 8) & 255,
                  i = 255 & t;
                255 === e
                  ? ((e = 0),
                    255 === n ? ((n = 0), 255 === i ? (i = 0) : ++i) : ++n)
                  : ++e,
                  (t = 0),
                  (t += e << 16),
                  (t += n << 8),
                  (t += i);
              } else t += 1 << 24;
              return t;
            }
            function i(t) {
              return 0 === (t[0] = n(t[0])) && (t[1] = n(t[1])), t;
            }
            var r = (e.Encryptor = e.extend({
              processBlock: function (t, e) {
                var n = this._cipher,
                  r = n.blockSize,
                  a = this._iv,
                  o = this._counter;
                a && ((o = this._counter = a.slice(0)), (this._iv = void 0)),
                  i(o);
                var s = o.slice(0);
                n.encryptBlock(s, 0);
                for (var c = 0; c < r; c++) t[e + c] ^= s[c];
              },
            }));
            return (e.Decryptor = r), e;
          })()),
          t.mode.CTRGladman
        );
      });
    },
    ab36: function (t, e, n) {
      var i = n("861d"),
        r = n("9112");
      t.exports = function (t, e) {
        i(e) && "cause" in e && r(t, "cause", e.cause);
      };
    },
    aeb0: function (t, e, n) {
      var i = n("9bf2").f;
      t.exports = function (t, e, n) {
        n in t ||
          i(t, n, {
            configurable: !0,
            get: function () {
              return e[n];
            },
            set: function (t) {
              e[n] = t;
            },
          });
      };
    },
    aed9: function (t, e, n) {
      var i = n("83ab"),
        r = n("d039");
      t.exports =
        i &&
        r(function () {
          return (
            42 !=
            Object.defineProperty(function () {}, "prototype", {
              value: 42,
              writable: !1,
            }).prototype
          );
        });
    },
    b42e: function (t, e) {
      var n = Math.ceil,
        i = Math.floor;
      t.exports =
        Math.trunc ||
        function (t) {
          var e = +t;
          return (e > 0 ? i : n)(e);
        };
    },
    b50d: function (t, e, n) {
      "use strict";
      var i = n("c532"),
        r = n("467f"),
        a = n("7aac"),
        o = n("30b5"),
        s = n("83b9"),
        c = n("c345"),
        l = n("3934"),
        h = n("2d83");
      t.exports = function (t) {
        return new Promise(function (e, n) {
          var u = t.data,
            d = t.headers,
            p = t.responseType;
          i.isFormData(u) && delete d["Content-Type"];
          var f = new XMLHttpRequest();
          if (t.auth) {
            var m = t.auth.username || "",
              g = t.auth.password
                ? unescape(encodeURIComponent(t.auth.password))
                : "";
            d.Authorization = "Basic " + btoa(m + ":" + g);
          }
          var v = s(t.baseURL, t.url);
          function y() {
            if (f) {
              var i =
                  "getAllResponseHeaders" in f
                    ? c(f.getAllResponseHeaders())
                    : null,
                a =
                  p && "text" !== p && "json" !== p
                    ? f.response
                    : f.responseText,
                o = {
                  data: a,
                  status: f.status,
                  statusText: f.statusText,
                  headers: i,
                  config: t,
                  request: f,
                };
              r(e, n, o), (f = null);
            }
          }
          if (
            (f.open(
              t.method.toUpperCase(),
              o(v, t.params, t.paramsSerializer),
              !0
            ),
            (f.timeout = t.timeout),
            "onloadend" in f
              ? (f.onloadend = y)
              : (f.onreadystatechange = function () {
                  f &&
                    4 === f.readyState &&
                    (0 !== f.status ||
                      (f.responseURL &&
                        0 === f.responseURL.indexOf("file:"))) &&
                    setTimeout(y);
                }),
            (f.onabort = function () {
              f && (n(h("Request aborted", t, "ECONNABORTED", f)), (f = null));
            }),
            (f.onerror = function () {
              n(h("Network Error", t, null, f)), (f = null);
            }),
            (f.ontimeout = function () {
              var e = "timeout of " + t.timeout + "ms exceeded";
              t.timeoutErrorMessage && (e = t.timeoutErrorMessage),
                n(
                  h(
                    e,
                    t,
                    t.transitional && t.transitional.clarifyTimeoutError
                      ? "ETIMEDOUT"
                      : "ECONNABORTED",
                    f
                  )
                ),
                (f = null);
            }),
            i.isStandardBrowserEnv())
          ) {
            var x =
              (t.withCredentials || l(v)) && t.xsrfCookieName
                ? a.read(t.xsrfCookieName)
                : void 0;
            x && (d[t.xsrfHeaderName] = x);
          }
          "setRequestHeader" in f &&
            i.forEach(d, function (t, e) {
              "undefined" === typeof u && "content-type" === e.toLowerCase()
                ? delete d[e]
                : f.setRequestHeader(e, t);
            }),
            i.isUndefined(t.withCredentials) ||
              (f.withCredentials = !!t.withCredentials),
            p && "json" !== p && (f.responseType = t.responseType),
            "function" === typeof t.onDownloadProgress &&
              f.addEventListener("progress", t.onDownloadProgress),
            "function" === typeof t.onUploadProgress &&
              f.upload &&
              f.upload.addEventListener("progress", t.onUploadProgress),
            t.cancelToken &&
              t.cancelToken.promise.then(function (t) {
                f && (f.abort(), n(t), (f = null));
              }),
            u || (u = null),
            f.send(u);
        });
      };
    },
    b622: function (t, e, n) {
      var i = n("da84"),
        r = n("5692"),
        a = n("1a2d"),
        o = n("90e3"),
        s = n("04f8"),
        c = n("fdbf"),
        l = i.Symbol,
        h = r("wks"),
        u = c ? l["for"] || l : (l && l.withoutSetter) || o;
      t.exports = function (t) {
        return a(h, t) || (h[t] = s && a(l, t) ? l[t] : u("Symbol." + t)), h[t];
      };
    },
    b86b: function (t, e, n) {
      (function (e, i, r) {
        t.exports = i(n("21bf"), n("3252"), n("d6e6"));
      })(0, function (t) {
        return (
          (function () {
            var e = t,
              n = e.x64,
              i = n.Word,
              r = n.WordArray,
              a = e.algo,
              o = a.SHA512,
              s = (a.SHA384 = o.extend({
                _doReset: function () {
                  this._hash = new r.init([
                    new i.init(3418070365, 3238371032),
                    new i.init(1654270250, 914150663),
                    new i.init(2438529370, 812702999),
                    new i.init(355462360, 4144912697),
                    new i.init(1731405415, 4290775857),
                    new i.init(2394180231, 1750603025),
                    new i.init(3675008525, 1694076839),
                    new i.init(1203062813, 3204075428),
                  ]);
                },
                _doFinalize: function () {
                  var t = o._doFinalize.call(this);
                  return (t.sigBytes -= 16), t;
                },
              }));
            (e.SHA384 = o._createHelper(s)),
              (e.HmacSHA384 = o._createHmacHelper(s));
          })(),
          t.SHA384
        );
      });
    },
    b86c: function (t, e, n) {
      (function (e, i, r) {
        t.exports = i(n("21bf"), n("38ba"));
      })(0, function (t) {
        return (
          (t.pad.NoPadding = { pad: function () {}, unpad: function () {} }),
          t.pad.NoPadding
        );
      });
    },
    b980: function (t, e, n) {
      var i = n("d039"),
        r = n("5c6c");
      t.exports = !i(function () {
        var t = Error("a");
        return (
          !("stack" in t) ||
          (Object.defineProperty(t, "stack", r(1, 7)), 7 !== t.stack)
        );
      });
    },
    bc3a: function (t, e, n) {
      t.exports = n("cee4");
    },
    c04e: function (t, e, n) {
      var i = n("c65b"),
        r = n("861d"),
        a = n("d9b5"),
        o = n("dc4a"),
        s = n("485a"),
        c = n("b622"),
        l = TypeError,
        h = c("toPrimitive");
      t.exports = function (t, e) {
        if (!r(t) || a(t)) return t;
        var n,
          c = o(t, h);
        if (c) {
          if (
            (void 0 === e && (e = "default"), (n = i(c, t, e)), !r(n) || a(n))
          )
            return n;
          throw l("Can't convert object to primitive value");
        }
        return void 0 === e && (e = "number"), s(t, e);
      };
    },
    c198: function (t, e, n) {
      (function (e, i, r) {
        t.exports = i(n("21bf"), n("1132"), n("72fe"), n("2b79"), n("38ba"));
      })(0, function (t) {
        return (
          (function () {
            var e = t,
              n = e.lib,
              i = n.BlockCipher,
              r = e.algo,
              a = [],
              o = [],
              s = [],
              c = [],
              l = [],
              h = [],
              u = [],
              d = [],
              p = [],
              f = [];
            (function () {
              for (var t = [], e = 0; e < 256; e++)
                t[e] = e < 128 ? e << 1 : (e << 1) ^ 283;
              var n = 0,
                i = 0;
              for (e = 0; e < 256; e++) {
                var r = i ^ (i << 1) ^ (i << 2) ^ (i << 3) ^ (i << 4);
                (r = (r >>> 8) ^ (255 & r) ^ 99), (a[n] = r), (o[r] = n);
                var m = t[n],
                  g = t[m],
                  v = t[g],
                  y = (257 * t[r]) ^ (16843008 * r);
                (s[n] = (y << 24) | (y >>> 8)),
                  (c[n] = (y << 16) | (y >>> 16)),
                  (l[n] = (y << 8) | (y >>> 24)),
                  (h[n] = y);
                y = (16843009 * v) ^ (65537 * g) ^ (257 * m) ^ (16843008 * n);
                (u[r] = (y << 24) | (y >>> 8)),
                  (d[r] = (y << 16) | (y >>> 16)),
                  (p[r] = (y << 8) | (y >>> 24)),
                  (f[r] = y),
                  n ? ((n = m ^ t[t[t[v ^ m]]]), (i ^= t[t[i]])) : (n = i = 1);
              }
            })();
            var m = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54],
              g = (r.AES = i.extend({
                _doReset: function () {
                  if (!this._nRounds || this._keyPriorReset !== this._key) {
                    for (
                      var t = (this._keyPriorReset = this._key),
                        e = t.words,
                        n = t.sigBytes / 4,
                        i = (this._nRounds = n + 6),
                        r = 4 * (i + 1),
                        o = (this._keySchedule = []),
                        s = 0;
                      s < r;
                      s++
                    )
                      s < n
                        ? (o[s] = e[s])
                        : ((h = o[s - 1]),
                          s % n
                            ? n > 6 &&
                              s % n == 4 &&
                              (h =
                                (a[h >>> 24] << 24) |
                                (a[(h >>> 16) & 255] << 16) |
                                (a[(h >>> 8) & 255] << 8) |
                                a[255 & h])
                            : ((h = (h << 8) | (h >>> 24)),
                              (h =
                                (a[h >>> 24] << 24) |
                                (a[(h >>> 16) & 255] << 16) |
                                (a[(h >>> 8) & 255] << 8) |
                                a[255 & h]),
                              (h ^= m[(s / n) | 0] << 24)),
                          (o[s] = o[s - n] ^ h));
                    for (
                      var c = (this._invKeySchedule = []), l = 0;
                      l < r;
                      l++
                    ) {
                      s = r - l;
                      if (l % 4) var h = o[s];
                      else h = o[s - 4];
                      c[l] =
                        l < 4 || s <= 4
                          ? h
                          : u[a[h >>> 24]] ^
                            d[a[(h >>> 16) & 255]] ^
                            p[a[(h >>> 8) & 255]] ^
                            f[a[255 & h]];
                    }
                  }
                },
                encryptBlock: function (t, e) {
                  this._doCryptBlock(t, e, this._keySchedule, s, c, l, h, a);
                },
                decryptBlock: function (t, e) {
                  var n = t[e + 1];
                  (t[e + 1] = t[e + 3]),
                    (t[e + 3] = n),
                    this._doCryptBlock(
                      t,
                      e,
                      this._invKeySchedule,
                      u,
                      d,
                      p,
                      f,
                      o
                    );
                  n = t[e + 1];
                  (t[e + 1] = t[e + 3]), (t[e + 3] = n);
                },
                _doCryptBlock: function (t, e, n, i, r, a, o, s) {
                  for (
                    var c = this._nRounds,
                      l = t[e] ^ n[0],
                      h = t[e + 1] ^ n[1],
                      u = t[e + 2] ^ n[2],
                      d = t[e + 3] ^ n[3],
                      p = 4,
                      f = 1;
                    f < c;
                    f++
                  ) {
                    var m =
                        i[l >>> 24] ^
                        r[(h >>> 16) & 255] ^
                        a[(u >>> 8) & 255] ^
                        o[255 & d] ^
                        n[p++],
                      g =
                        i[h >>> 24] ^
                        r[(u >>> 16) & 255] ^
                        a[(d >>> 8) & 255] ^
                        o[255 & l] ^
                        n[p++],
                      v =
                        i[u >>> 24] ^
                        r[(d >>> 16) & 255] ^
                        a[(l >>> 8) & 255] ^
                        o[255 & h] ^
                        n[p++],
                      y =
                        i[d >>> 24] ^
                        r[(l >>> 16) & 255] ^
                        a[(h >>> 8) & 255] ^
                        o[255 & u] ^
                        n[p++];
                    (l = m), (h = g), (u = v), (d = y);
                  }
                  (m =
                    ((s[l >>> 24] << 24) |
                      (s[(h >>> 16) & 255] << 16) |
                      (s[(u >>> 8) & 255] << 8) |
                      s[255 & d]) ^
                    n[p++]),
                    (g =
                      ((s[h >>> 24] << 24) |
                        (s[(u >>> 16) & 255] << 16) |
                        (s[(d >>> 8) & 255] << 8) |
                        s[255 & l]) ^
                      n[p++]),
                    (v =
                      ((s[u >>> 24] << 24) |
                        (s[(d >>> 16) & 255] << 16) |
                        (s[(l >>> 8) & 255] << 8) |
                        s[255 & h]) ^
                      n[p++]),
                    (y =
                      ((s[d >>> 24] << 24) |
                        (s[(l >>> 16) & 255] << 16) |
                        (s[(h >>> 8) & 255] << 8) |
                        s[255 & u]) ^
                      n[p++]);
                  (t[e] = m), (t[e + 1] = g), (t[e + 2] = v), (t[e + 3] = y);
                },
                keySize: 8,
              }));
            e.AES = i._createHelper(g);
          })(),
          t.AES
        );
      });
    },
    c1bc: function (t, e, n) {
      (function (e, i) {
        t.exports = i(n("21bf"));
      })(0, function (t) {
        return (
          (function () {
            var e = t,
              n = e.lib,
              i = n.WordArray,
              r = e.enc;
            r.Base64url = {
              stringify: function (t, e = !0) {
                var n = t.words,
                  i = t.sigBytes,
                  r = e ? this._safe_map : this._map;
                t.clamp();
                for (var a = [], o = 0; o < i; o += 3)
                  for (
                    var s = (n[o >>> 2] >>> (24 - (o % 4) * 8)) & 255,
                      c = (n[(o + 1) >>> 2] >>> (24 - ((o + 1) % 4) * 8)) & 255,
                      l = (n[(o + 2) >>> 2] >>> (24 - ((o + 2) % 4) * 8)) & 255,
                      h = (s << 16) | (c << 8) | l,
                      u = 0;
                    u < 4 && o + 0.75 * u < i;
                    u++
                  )
                    a.push(r.charAt((h >>> (6 * (3 - u))) & 63));
                var d = r.charAt(64);
                if (d) while (a.length % 4) a.push(d);
                return a.join("");
              },
              parse: function (t, e = !0) {
                var n = t.length,
                  i = e ? this._safe_map : this._map,
                  r = this._reverseMap;
                if (!r) {
                  r = this._reverseMap = [];
                  for (var o = 0; o < i.length; o++) r[i.charCodeAt(o)] = o;
                }
                var s = i.charAt(64);
                if (s) {
                  var c = t.indexOf(s);
                  -1 !== c && (n = c);
                }
                return a(t, n, r);
              },
              _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
              _safe_map:
                "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
            };
            function a(t, e, n) {
              for (var r = [], a = 0, o = 0; o < e; o++)
                if (o % 4) {
                  var s = n[t.charCodeAt(o - 1)] << ((o % 4) * 2),
                    c = n[t.charCodeAt(o)] >>> (6 - (o % 4) * 2),
                    l = s | c;
                  (r[a >>> 2] |= l << (24 - (a % 4) * 8)), a++;
                }
              return i.create(r, a);
            }
          })(),
          t.enc.Base64url
        );
      });
    },
    c345: function (t, e, n) {
      "use strict";
      var i = n("c532"),
        r = [
          "age",
          "authorization",
          "content-length",
          "content-type",
          "etag",
          "expires",
          "from",
          "host",
          "if-modified-since",
          "if-unmodified-since",
          "last-modified",
          "location",
          "max-forwards",
          "proxy-authorization",
          "referer",
          "retry-after",
          "user-agent",
        ];
      t.exports = function (t) {
        var e,
          n,
          a,
          o = {};
        return t
          ? (i.forEach(t.split("\n"), function (t) {
              if (
                ((a = t.indexOf(":")),
                (e = i.trim(t.substr(0, a)).toLowerCase()),
                (n = i.trim(t.substr(a + 1))),
                e)
              ) {
                if (o[e] && r.indexOf(e) >= 0) return;
                o[e] =
                  "set-cookie" === e
                    ? (o[e] ? o[e] : []).concat([n])
                    : o[e]
                    ? o[e] + ", " + n
                    : n;
              }
            }),
            o)
          : o;
      };
    },
    c3b6: function (t, e, n) {
      (function (e, i, r) {
        t.exports = i(n("21bf"), n("1132"), n("72fe"), n("2b79"), n("38ba"));
      })(0, function (t) {
        return (
          (function () {
            var e = t,
              n = e.lib,
              i = n.StreamCipher,
              r = e.algo,
              a = (r.RC4 = i.extend({
                _doReset: function () {
                  for (
                    var t = this._key,
                      e = t.words,
                      n = t.sigBytes,
                      i = (this._S = []),
                      r = 0;
                    r < 256;
                    r++
                  )
                    i[r] = r;
                  r = 0;
                  for (var a = 0; r < 256; r++) {
                    var o = r % n,
                      s = (e[o >>> 2] >>> (24 - (o % 4) * 8)) & 255;
                    a = (a + i[r] + s) % 256;
                    var c = i[r];
                    (i[r] = i[a]), (i[a] = c);
                  }
                  this._i = this._j = 0;
                },
                _doProcessBlock: function (t, e) {
                  t[e] ^= o.call(this);
                },
                keySize: 8,
                ivSize: 0,
              }));
            function o() {
              for (
                var t = this._S, e = this._i, n = this._j, i = 0, r = 0;
                r < 4;
                r++
              ) {
                (e = (e + 1) % 256), (n = (n + t[e]) % 256);
                var a = t[e];
                (t[e] = t[n]),
                  (t[n] = a),
                  (i |= t[(t[e] + t[n]) % 256] << (24 - 8 * r));
              }
              return (this._i = e), (this._j = n), i;
            }
            e.RC4 = i._createHelper(a);
            var s = (r.RC4Drop = a.extend({
              cfg: a.cfg.extend({ drop: 192 }),
              _doReset: function () {
                a._doReset.call(this);
                for (var t = this.cfg.drop; t > 0; t--) o.call(this);
              },
            }));
            e.RC4Drop = i._createHelper(s);
          })(),
          t.RC4
        );
      });
    },
    c401: function (t, e, n) {
      "use strict";
      var i = n("c532"),
        r = n("2444");
      t.exports = function (t, e, n) {
        var a = this || r;
        return (
          i.forEach(n, function (n) {
            t = n.call(a, t, e);
          }),
          t
        );
      };
    },
    c430: function (t, e) {
      t.exports = !1;
    },
    c532: function (t, e, n) {
      "use strict";
      var i = n("1d2b"),
        r = Object.prototype.toString;
      function a(t) {
        return "[object Array]" === r.call(t);
      }
      function o(t) {
        return "undefined" === typeof t;
      }
      function s(t) {
        return (
          null !== t &&
          !o(t) &&
          null !== t.constructor &&
          !o(t.constructor) &&
          "function" === typeof t.constructor.isBuffer &&
          t.constructor.isBuffer(t)
        );
      }
      function c(t) {
        return "[object ArrayBuffer]" === r.call(t);
      }
      function l(t) {
        return "undefined" !== typeof FormData && t instanceof FormData;
      }
      function h(t) {
        var e;
        return (
          (e =
            "undefined" !== typeof ArrayBuffer && ArrayBuffer.isView
              ? ArrayBuffer.isView(t)
              : t && t.buffer && t.buffer instanceof ArrayBuffer),
          e
        );
      }
      function u(t) {
        return "string" === typeof t;
      }
      function d(t) {
        return "number" === typeof t;
      }
      function p(t) {
        return null !== t && "object" === typeof t;
      }
      function f(t) {
        if ("[object Object]" !== r.call(t)) return !1;
        var e = Object.getPrototypeOf(t);
        return null === e || e === Object.prototype;
      }
      function m(t) {
        return "[object Date]" === r.call(t);
      }
      function g(t) {
        return "[object File]" === r.call(t);
      }
      function v(t) {
        return "[object Blob]" === r.call(t);
      }
      function y(t) {
        return "[object Function]" === r.call(t);
      }
      function x(t) {
        return p(t) && y(t.pipe);
      }
      function _(t) {
        return (
          "undefined" !== typeof URLSearchParams && t instanceof URLSearchParams
        );
      }
      function b(t) {
        return t.trim ? t.trim() : t.replace(/^\s+|\s+$/g, "");
      }
      function w() {
        return (
          ("undefined" === typeof navigator ||
            ("ReactNative" !== navigator.product &&
              "NativeScript" !== navigator.product &&
              "NS" !== navigator.product)) &&
          "undefined" !== typeof window &&
          "undefined" !== typeof document
        );
      }
      function M(t, e) {
        if (null !== t && "undefined" !== typeof t)
          if (("object" !== typeof t && (t = [t]), a(t)))
            for (var n = 0, i = t.length; n < i; n++) e.call(null, t[n], n, t);
          else
            for (var r in t)
              Object.prototype.hasOwnProperty.call(t, r) &&
                e.call(null, t[r], r, t);
      }
      function S() {
        var t = {};
        function e(e, n) {
          f(t[n]) && f(e)
            ? (t[n] = S(t[n], e))
            : f(e)
            ? (t[n] = S({}, e))
            : a(e)
            ? (t[n] = e.slice())
            : (t[n] = e);
        }
        for (var n = 0, i = arguments.length; n < i; n++) M(arguments[n], e);
        return t;
      }
      function E(t, e, n) {
        return (
          M(e, function (e, r) {
            t[r] = n && "function" === typeof e ? i(e, n) : e;
          }),
          t
        );
      }
      function T(t) {
        return 65279 === t.charCodeAt(0) && (t = t.slice(1)), t;
      }
      t.exports = {
        isArray: a,
        isArrayBuffer: c,
        isBuffer: s,
        isFormData: l,
        isArrayBufferView: h,
        isString: u,
        isNumber: d,
        isObject: p,
        isPlainObject: f,
        isUndefined: o,
        isDate: m,
        isFile: g,
        isBlob: v,
        isFunction: y,
        isStream: x,
        isURLSearchParams: _,
        isStandardBrowserEnv: w,
        forEach: M,
        merge: S,
        extend: E,
        trim: b,
        stripBOM: T,
      };
    },
    c65b: function (t, e, n) {
      var i = n("40d5"),
        r = Function.prototype.call;
      t.exports = i
        ? r.bind(r)
        : function () {
            return r.apply(r, arguments);
          };
    },
    c6b6: function (t, e, n) {
      var i = n("e330"),
        r = i({}.toString),
        a = i("".slice);
      t.exports = function (t) {
        return a(r(t), 8, -1);
      };
    },
    c6cd: function (t, e, n) {
      var i = n("da84"),
        r = n("6374"),
        a = "__core-js_shared__",
        o = i[a] || r(a, {});
      t.exports = o;
    },
    c8af: function (t, e, n) {
      "use strict";
      var i = n("c532");
      t.exports = function (t, e) {
        i.forEach(t, function (n, i) {
          i !== e &&
            i.toUpperCase() === e.toUpperCase() &&
            ((t[e] = n), delete t[i]);
        });
      };
    },
    c8ba: function (t, e) {
      var n;
      n = (function () {
        return this;
      })();
      try {
        n = n || new Function("return this")();
      } catch (i) {
        "object" === typeof window && (n = window);
      }
      t.exports = n;
    },
    ca84: function (t, e, n) {
      var i = n("e330"),
        r = n("1a2d"),
        a = n("fc6a"),
        o = n("4d64").indexOf,
        s = n("d012"),
        c = i([].push);
      t.exports = function (t, e) {
        var n,
          i = a(t),
          l = 0,
          h = [];
        for (n in i) !r(s, n) && r(i, n) && c(h, n);
        while (e.length > l) r(i, (n = e[l++])) && (~o(h, n) || c(h, n));
        return h;
      };
    },
    cb2d: function (t, e, n) {
      var i = n("1626"),
        r = n("9bf2"),
        a = n("13d2"),
        o = n("6374");
      t.exports = function (t, e, n, s) {
        s || (s = {});
        var c = s.enumerable,
          l = void 0 !== s.name ? s.name : e;
        if ((i(n) && a(n, l, s), s.global)) c ? (t[e] = n) : o(e, n);
        else {
          try {
            s.unsafe ? t[e] && (c = !0) : delete t[e];
          } catch (h) {}
          c
            ? (t[e] = n)
            : r.f(t, e, {
                value: n,
                enumerable: !1,
                configurable: !s.nonConfigurable,
                writable: !s.nonWritable,
              });
        }
        return t;
      };
    },
    cc12: function (t, e, n) {
      var i = n("da84"),
        r = n("861d"),
        a = i.document,
        o = r(a) && r(a.createElement);
      t.exports = function (t) {
        return o ? a.createElement(t) : {};
      };
    },
    cdce: function (t, e, n) {
      var i = n("da84"),
        r = n("1626"),
        a = i.WeakMap;
      t.exports = r(a) && /native code/.test(String(a));
    },
    cee4: function (t, e, n) {
      "use strict";
      var i = n("c532"),
        r = n("1d2b"),
        a = n("0a06"),
        o = n("4a7b"),
        s = n("2444");
      function c(t) {
        var e = new a(t),
          n = r(a.prototype.request, e);
        return i.extend(n, a.prototype, e), i.extend(n, e), n;
      }
      var l = c(s);
      (l.Axios = a),
        (l.create = function (t) {
          return c(o(l.defaults, t));
        }),
        (l.Cancel = n("7a77")),
        (l.CancelToken = n("8df4")),
        (l.isCancel = n("2e67")),
        (l.all = function (t) {
          return Promise.all(t);
        }),
        (l.spread = n("0df6")),
        (l.isAxiosError = n("5f02")),
        (t.exports = l),
        (t.exports.default = l);
    },
    d012: function (t, e) {
      t.exports = {};
    },
    d039: function (t, e) {
      t.exports = function (t) {
        try {
          return !!t();
        } catch (e) {
          return !0;
        }
      };
    },
    d066: function (t, e, n) {
      var i = n("da84"),
        r = n("1626"),
        a = function (t) {
          return r(t) ? t : void 0;
        };
      t.exports = function (t, e) {
        return arguments.length < 2 ? a(i[t]) : i[t] && i[t][e];
      };
    },
    d1e7: function (t, e, n) {
      "use strict";
      var i = {}.propertyIsEnumerable,
        r = Object.getOwnPropertyDescriptor,
        a = r && !i.call({ 1: 2 }, 1);
      e.f = a
        ? function (t) {
            var e = r(this, t);
            return !!e && e.enumerable;
          }
        : i;
    },
    d2bb: function (t, e, n) {
      var i = n("7282"),
        r = n("825a"),
        a = n("3bbe");
      t.exports =
        Object.setPrototypeOf ||
        ("__proto__" in {}
          ? (function () {
              var t,
                e = !1,
                n = {};
              try {
                (t = i(Object.prototype, "__proto__", "set")),
                  t(n, []),
                  (e = n instanceof Array);
              } catch (o) {}
              return function (n, i) {
                return r(n), a(i), e ? t(n, i) : (n.__proto__ = i), n;
              };
            })()
          : void 0);
    },
    d396: function (t, e, n) {
      "use strict";
      n("3316");
    },
    d6e6: function (t, e, n) {
      (function (e, i, r) {
        t.exports = i(n("21bf"), n("3252"));
      })(0, function (t) {
        return (
          (function () {
            var e = t,
              n = e.lib,
              i = n.Hasher,
              r = e.x64,
              a = r.Word,
              o = r.WordArray,
              s = e.algo;
            function c() {
              return a.create.apply(a, arguments);
            }
            var l = [
                c(1116352408, 3609767458),
                c(1899447441, 602891725),
                c(3049323471, 3964484399),
                c(3921009573, 2173295548),
                c(961987163, 4081628472),
                c(1508970993, 3053834265),
                c(2453635748, 2937671579),
                c(2870763221, 3664609560),
                c(3624381080, 2734883394),
                c(310598401, 1164996542),
                c(607225278, 1323610764),
                c(1426881987, 3590304994),
                c(1925078388, 4068182383),
                c(2162078206, 991336113),
                c(2614888103, 633803317),
                c(3248222580, 3479774868),
                c(3835390401, 2666613458),
                c(4022224774, 944711139),
                c(264347078, 2341262773),
                c(604807628, 2007800933),
                c(770255983, 1495990901),
                c(1249150122, 1856431235),
                c(1555081692, 3175218132),
                c(1996064986, 2198950837),
                c(2554220882, 3999719339),
                c(2821834349, 766784016),
                c(2952996808, 2566594879),
                c(3210313671, 3203337956),
                c(3336571891, 1034457026),
                c(3584528711, 2466948901),
                c(113926993, 3758326383),
                c(338241895, 168717936),
                c(666307205, 1188179964),
                c(773529912, 1546045734),
                c(1294757372, 1522805485),
                c(1396182291, 2643833823),
                c(1695183700, 2343527390),
                c(1986661051, 1014477480),
                c(2177026350, 1206759142),
                c(2456956037, 344077627),
                c(2730485921, 1290863460),
                c(2820302411, 3158454273),
                c(3259730800, 3505952657),
                c(3345764771, 106217008),
                c(3516065817, 3606008344),
                c(3600352804, 1432725776),
                c(4094571909, 1467031594),
                c(275423344, 851169720),
                c(430227734, 3100823752),
                c(506948616, 1363258195),
                c(659060556, 3750685593),
                c(883997877, 3785050280),
                c(958139571, 3318307427),
                c(1322822218, 3812723403),
                c(1537002063, 2003034995),
                c(1747873779, 3602036899),
                c(1955562222, 1575990012),
                c(2024104815, 1125592928),
                c(2227730452, 2716904306),
                c(2361852424, 442776044),
                c(2428436474, 593698344),
                c(2756734187, 3733110249),
                c(3204031479, 2999351573),
                c(3329325298, 3815920427),
                c(3391569614, 3928383900),
                c(3515267271, 566280711),
                c(3940187606, 3454069534),
                c(4118630271, 4000239992),
                c(116418474, 1914138554),
                c(174292421, 2731055270),
                c(289380356, 3203993006),
                c(460393269, 320620315),
                c(685471733, 587496836),
                c(852142971, 1086792851),
                c(1017036298, 365543100),
                c(1126000580, 2618297676),
                c(1288033470, 3409855158),
                c(1501505948, 4234509866),
                c(1607167915, 987167468),
                c(1816402316, 1246189591),
              ],
              h = [];
            (function () {
              for (var t = 0; t < 80; t++) h[t] = c();
            })();
            var u = (s.SHA512 = i.extend({
              _doReset: function () {
                this._hash = new o.init([
                  new a.init(1779033703, 4089235720),
                  new a.init(3144134277, 2227873595),
                  new a.init(1013904242, 4271175723),
                  new a.init(2773480762, 1595750129),
                  new a.init(1359893119, 2917565137),
                  new a.init(2600822924, 725511199),
                  new a.init(528734635, 4215389547),
                  new a.init(1541459225, 327033209),
                ]);
              },
              _doProcessBlock: function (t, e) {
                for (
                  var n = this._hash.words,
                    i = n[0],
                    r = n[1],
                    a = n[2],
                    o = n[3],
                    s = n[4],
                    c = n[5],
                    u = n[6],
                    d = n[7],
                    p = i.high,
                    f = i.low,
                    m = r.high,
                    g = r.low,
                    v = a.high,
                    y = a.low,
                    x = o.high,
                    _ = o.low,
                    b = s.high,
                    w = s.low,
                    M = c.high,
                    S = c.low,
                    E = u.high,
                    T = u.low,
                    A = d.high,
                    C = d.low,
                    R = p,
                    L = f,
                    P = m,
                    D = g,
                    I = v,
                    O = y,
                    N = x,
                    B = _,
                    z = b,
                    U = w,
                    F = M,
                    H = S,
                    k = E,
                    G = T,
                    V = A,
                    W = C,
                    j = 0;
                  j < 80;
                  j++
                ) {
                  var q,
                    X,
                    Y = h[j];
                  if (j < 16)
                    (X = Y.high = 0 | t[e + 2 * j]),
                      (q = Y.low = 0 | t[e + 2 * j + 1]);
                  else {
                    var J = h[j - 15],
                      Z = J.high,
                      K = J.low,
                      $ =
                        ((Z >>> 1) | (K << 31)) ^
                        ((Z >>> 8) | (K << 24)) ^
                        (Z >>> 7),
                      Q =
                        ((K >>> 1) | (Z << 31)) ^
                        ((K >>> 8) | (Z << 24)) ^
                        ((K >>> 7) | (Z << 25)),
                      tt = h[j - 2],
                      et = tt.high,
                      nt = tt.low,
                      it =
                        ((et >>> 19) | (nt << 13)) ^
                        ((et << 3) | (nt >>> 29)) ^
                        (et >>> 6),
                      rt =
                        ((nt >>> 19) | (et << 13)) ^
                        ((nt << 3) | (et >>> 29)) ^
                        ((nt >>> 6) | (et << 26)),
                      at = h[j - 7],
                      ot = at.high,
                      st = at.low,
                      ct = h[j - 16],
                      lt = ct.high,
                      ht = ct.low;
                    (q = Q + st),
                      (X = $ + ot + (q >>> 0 < Q >>> 0 ? 1 : 0)),
                      (q += rt),
                      (X = X + it + (q >>> 0 < rt >>> 0 ? 1 : 0)),
                      (q += ht),
                      (X = X + lt + (q >>> 0 < ht >>> 0 ? 1 : 0)),
                      (Y.high = X),
                      (Y.low = q);
                  }
                  var ut = (z & F) ^ (~z & k),
                    dt = (U & H) ^ (~U & G),
                    pt = (R & P) ^ (R & I) ^ (P & I),
                    ft = (L & D) ^ (L & O) ^ (D & O),
                    mt =
                      ((R >>> 28) | (L << 4)) ^
                      ((R << 30) | (L >>> 2)) ^
                      ((R << 25) | (L >>> 7)),
                    gt =
                      ((L >>> 28) | (R << 4)) ^
                      ((L << 30) | (R >>> 2)) ^
                      ((L << 25) | (R >>> 7)),
                    vt =
                      ((z >>> 14) | (U << 18)) ^
                      ((z >>> 18) | (U << 14)) ^
                      ((z << 23) | (U >>> 9)),
                    yt =
                      ((U >>> 14) | (z << 18)) ^
                      ((U >>> 18) | (z << 14)) ^
                      ((U << 23) | (z >>> 9)),
                    xt = l[j],
                    _t = xt.high,
                    bt = xt.low,
                    wt = W + yt,
                    Mt = V + vt + (wt >>> 0 < W >>> 0 ? 1 : 0),
                    St =
                      ((wt = wt + dt),
                      (Mt = Mt + ut + (wt >>> 0 < dt >>> 0 ? 1 : 0)),
                      (wt = wt + bt),
                      (Mt = Mt + _t + (wt >>> 0 < bt >>> 0 ? 1 : 0)),
                      (wt = wt + q),
                      (Mt = Mt + X + (wt >>> 0 < q >>> 0 ? 1 : 0)),
                      gt + ft),
                    Et = mt + pt + (St >>> 0 < gt >>> 0 ? 1 : 0);
                  (V = k),
                    (W = G),
                    (k = F),
                    (G = H),
                    (F = z),
                    (H = U),
                    (U = (B + wt) | 0),
                    (z = (N + Mt + (U >>> 0 < B >>> 0 ? 1 : 0)) | 0),
                    (N = I),
                    (B = O),
                    (I = P),
                    (O = D),
                    (P = R),
                    (D = L),
                    (L = (wt + St) | 0),
                    (R = (Mt + Et + (L >>> 0 < wt >>> 0 ? 1 : 0)) | 0);
                }
                (f = i.low = f + L),
                  (i.high = p + R + (f >>> 0 < L >>> 0 ? 1 : 0)),
                  (g = r.low = g + D),
                  (r.high = m + P + (g >>> 0 < D >>> 0 ? 1 : 0)),
                  (y = a.low = y + O),
                  (a.high = v + I + (y >>> 0 < O >>> 0 ? 1 : 0)),
                  (_ = o.low = _ + B),
                  (o.high = x + N + (_ >>> 0 < B >>> 0 ? 1 : 0)),
                  (w = s.low = w + U),
                  (s.high = b + z + (w >>> 0 < U >>> 0 ? 1 : 0)),
                  (S = c.low = S + H),
                  (c.high = M + F + (S >>> 0 < H >>> 0 ? 1 : 0)),
                  (T = u.low = T + G),
                  (u.high = E + k + (T >>> 0 < G >>> 0 ? 1 : 0)),
                  (C = d.low = C + W),
                  (d.high = A + V + (C >>> 0 < W >>> 0 ? 1 : 0));
              },
              _doFinalize: function () {
                var t = this._data,
                  e = t.words,
                  n = 8 * this._nDataBytes,
                  i = 8 * t.sigBytes;
                (e[i >>> 5] |= 128 << (24 - (i % 32))),
                  (e[30 + (((i + 128) >>> 10) << 5)] = Math.floor(
                    n / 4294967296
                  )),
                  (e[31 + (((i + 128) >>> 10) << 5)] = n),
                  (t.sigBytes = 4 * e.length),
                  this._process();
                var r = this._hash.toX32();
                return r;
              },
              clone: function () {
                var t = i.clone.call(this);
                return (t._hash = this._hash.clone()), t;
              },
              blockSize: 32,
            }));
            (e.SHA512 = i._createHelper(u)),
              (e.HmacSHA512 = i._createHmacHelper(u));
          })(),
          t.SHA512
        );
      });
    },
    d925: function (t, e, n) {
      "use strict";
      t.exports = function (t) {
        return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(t);
      };
    },
    d9b5: function (t, e, n) {
      var i = n("d066"),
        r = n("1626"),
        a = n("3a9b"),
        o = n("fdbf"),
        s = Object;
      t.exports = o
        ? function (t) {
            return "symbol" == typeof t;
          }
        : function (t) {
            var e = i("Symbol");
            return r(e) && a(e.prototype, s(t));
          };
    },
    d9e2: function (t, e, n) {
      var i = n("23e7"),
        r = n("da84"),
        a = n("2ba4"),
        o = n("e5cb"),
        s = "WebAssembly",
        c = r[s],
        l = 7 !== Error("e", { cause: 7 }).cause,
        h = function (t, e) {
          var n = {};
          (n[t] = o(t, e, l)),
            i({ global: !0, constructor: !0, arity: 1, forced: l }, n);
        },
        u = function (t, e) {
          if (c && c[t]) {
            var n = {};
            (n[t] = o(s + "." + t, e, l)),
              i(
                { target: s, stat: !0, constructor: !0, arity: 1, forced: l },
                n
              );
          }
        };
      h("Error", function (t) {
        return function (e) {
          return a(t, this, arguments);
        };
      }),
        h("EvalError", function (t) {
          return function (e) {
            return a(t, this, arguments);
          };
        }),
        h("RangeError", function (t) {
          return function (e) {
            return a(t, this, arguments);
          };
        }),
        h("ReferenceError", function (t) {
          return function (e) {
            return a(t, this, arguments);
          };
        }),
        h("SyntaxError", function (t) {
          return function (e) {
            return a(t, this, arguments);
          };
        }),
        h("TypeError", function (t) {
          return function (e) {
            return a(t, this, arguments);
          };
        }),
        h("URIError", function (t) {
          return function (e) {
            return a(t, this, arguments);
          };
        }),
        u("CompileError", function (t) {
          return function (e) {
            return a(t, this, arguments);
          };
        }),
        u("LinkError", function (t) {
          return function (e) {
            return a(t, this, arguments);
          };
        }),
        u("RuntimeError", function (t) {
          return function (e) {
            return a(t, this, arguments);
          };
        });
    },
    da84: function (t, e, n) {
      (function (e) {
        var n = function (t) {
          return t && t.Math == Math && t;
        };
        t.exports =
          n("object" == typeof globalThis && globalThis) ||
          n("object" == typeof window && window) ||
          n("object" == typeof self && self) ||
          n("object" == typeof e && e) ||
          (function () {
            return this;
          })() ||
          Function("return this")();
      }.call(this, n("c8ba")));
    },
    dc4a: function (t, e, n) {
      var i = n("59ed"),
        r = n("7234");
      t.exports = function (t, e) {
        var n = t[e];
        return r(n) ? void 0 : i(n);
      };
    },
    df2f: function (t, e, n) {
      (function (e, i) {
        t.exports = i(n("21bf"));
      })(0, function (t) {
        return (
          (function () {
            var e = t,
              n = e.lib,
              i = n.WordArray,
              r = n.Hasher,
              a = e.algo,
              o = [],
              s = (a.SHA1 = r.extend({
                _doReset: function () {
                  this._hash = new i.init([
                    1732584193, 4023233417, 2562383102, 271733878, 3285377520,
                  ]);
                },
                _doProcessBlock: function (t, e) {
                  for (
                    var n = this._hash.words,
                      i = n[0],
                      r = n[1],
                      a = n[2],
                      s = n[3],
                      c = n[4],
                      l = 0;
                    l < 80;
                    l++
                  ) {
                    if (l < 16) o[l] = 0 | t[e + l];
                    else {
                      var h = o[l - 3] ^ o[l - 8] ^ o[l - 14] ^ o[l - 16];
                      o[l] = (h << 1) | (h >>> 31);
                    }
                    var u = ((i << 5) | (i >>> 27)) + c + o[l];
                    (u +=
                      l < 20
                        ? 1518500249 + ((r & a) | (~r & s))
                        : l < 40
                        ? 1859775393 + (r ^ a ^ s)
                        : l < 60
                        ? ((r & a) | (r & s) | (a & s)) - 1894007588
                        : (r ^ a ^ s) - 899497514),
                      (c = s),
                      (s = a),
                      (a = (r << 30) | (r >>> 2)),
                      (r = i),
                      (i = u);
                  }
                  (n[0] = (n[0] + i) | 0),
                    (n[1] = (n[1] + r) | 0),
                    (n[2] = (n[2] + a) | 0),
                    (n[3] = (n[3] + s) | 0),
                    (n[4] = (n[4] + c) | 0);
                },
                _doFinalize: function () {
                  var t = this._data,
                    e = t.words,
                    n = 8 * this._nDataBytes,
                    i = 8 * t.sigBytes;
                  return (
                    (e[i >>> 5] |= 128 << (24 - (i % 32))),
                    (e[14 + (((i + 64) >>> 9) << 4)] = Math.floor(
                      n / 4294967296
                    )),
                    (e[15 + (((i + 64) >>> 9) << 4)] = n),
                    (t.sigBytes = 4 * e.length),
                    this._process(),
                    this._hash
                  );
                },
                clone: function () {
                  var t = r.clone.call(this);
                  return (t._hash = this._hash.clone()), t;
                },
              }));
            (e.SHA1 = r._createHelper(s)),
              (e.HmacSHA1 = r._createHmacHelper(s));
          })(),
          t.SHA1
        );
      });
    },
    df7c: function (t, e, n) {
      (function (t) {
        function n(t, e) {
          for (var n = 0, i = t.length - 1; i >= 0; i--) {
            var r = t[i];
            "." === r
              ? t.splice(i, 1)
              : ".." === r
              ? (t.splice(i, 1), n++)
              : n && (t.splice(i, 1), n--);
          }
          if (e) for (; n--; n) t.unshift("..");
          return t;
        }
        function i(t) {
          "string" !== typeof t && (t += "");
          var e,
            n = 0,
            i = -1,
            r = !0;
          for (e = t.length - 1; e >= 0; --e)
            if (47 === t.charCodeAt(e)) {
              if (!r) {
                n = e + 1;
                break;
              }
            } else -1 === i && ((r = !1), (i = e + 1));
          return -1 === i ? "" : t.slice(n, i);
        }
        function r(t, e) {
          if (t.filter) return t.filter(e);
          for (var n = [], i = 0; i < t.length; i++)
            e(t[i], i, t) && n.push(t[i]);
          return n;
        }
        (e.resolve = function () {
          for (
            var e = "", i = !1, a = arguments.length - 1;
            a >= -1 && !i;
            a--
          ) {
            var o = a >= 0 ? arguments[a] : t.cwd();
            if ("string" !== typeof o)
              throw new TypeError("Arguments to path.resolve must be strings");
            o && ((e = o + "/" + e), (i = "/" === o.charAt(0)));
          }
          return (
            (e = n(
              r(e.split("/"), function (t) {
                return !!t;
              }),
              !i
            ).join("/")),
            (i ? "/" : "") + e || "."
          );
        }),
          (e.normalize = function (t) {
            var i = e.isAbsolute(t),
              o = "/" === a(t, -1);
            return (
              (t = n(
                r(t.split("/"), function (t) {
                  return !!t;
                }),
                !i
              ).join("/")),
              t || i || (t = "."),
              t && o && (t += "/"),
              (i ? "/" : "") + t
            );
          }),
          (e.isAbsolute = function (t) {
            return "/" === t.charAt(0);
          }),
          (e.join = function () {
            var t = Array.prototype.slice.call(arguments, 0);
            return e.normalize(
              r(t, function (t, e) {
                if ("string" !== typeof t)
                  throw new TypeError("Arguments to path.join must be strings");
                return t;
              }).join("/")
            );
          }),
          (e.relative = function (t, n) {
            function i(t) {
              for (var e = 0; e < t.length; e++) if ("" !== t[e]) break;
              for (var n = t.length - 1; n >= 0; n--) if ("" !== t[n]) break;
              return e > n ? [] : t.slice(e, n - e + 1);
            }
            (t = e.resolve(t).substr(1)), (n = e.resolve(n).substr(1));
            for (
              var r = i(t.split("/")),
                a = i(n.split("/")),
                o = Math.min(r.length, a.length),
                s = o,
                c = 0;
              c < o;
              c++
            )
              if (r[c] !== a[c]) {
                s = c;
                break;
              }
            var l = [];
            for (c = s; c < r.length; c++) l.push("..");
            return (l = l.concat(a.slice(s))), l.join("/");
          }),
          (e.sep = "/"),
          (e.delimiter = ":"),
          (e.dirname = function (t) {
            if (("string" !== typeof t && (t += ""), 0 === t.length))
              return ".";
            for (
              var e = t.charCodeAt(0),
                n = 47 === e,
                i = -1,
                r = !0,
                a = t.length - 1;
              a >= 1;
              --a
            )
              if (((e = t.charCodeAt(a)), 47 === e)) {
                if (!r) {
                  i = a;
                  break;
                }
              } else r = !1;
            return -1 === i
              ? n
                ? "/"
                : "."
              : n && 1 === i
              ? "/"
              : t.slice(0, i);
          }),
          (e.basename = function (t, e) {
            var n = i(t);
            return (
              e &&
                n.substr(-1 * e.length) === e &&
                (n = n.substr(0, n.length - e.length)),
              n
            );
          }),
          (e.extname = function (t) {
            "string" !== typeof t && (t += "");
            for (
              var e = -1, n = 0, i = -1, r = !0, a = 0, o = t.length - 1;
              o >= 0;
              --o
            ) {
              var s = t.charCodeAt(o);
              if (47 !== s)
                -1 === i && ((r = !1), (i = o + 1)),
                  46 === s
                    ? -1 === e
                      ? (e = o)
                      : 1 !== a && (a = 1)
                    : -1 !== e && (a = -1);
              else if (!r) {
                n = o + 1;
                break;
              }
            }
            return -1 === e ||
              -1 === i ||
              0 === a ||
              (1 === a && e === i - 1 && e === n + 1)
              ? ""
              : t.slice(e, i);
          });
        var a =
          "b" === "ab".substr(-1)
            ? function (t, e, n) {
                return t.substr(e, n);
              }
            : function (t, e, n) {
                return e < 0 && (e = t.length + e), t.substr(e, n);
              };
      }.call(this, n("4362")));
    },
    e330: function (t, e, n) {
      var i = n("40d5"),
        r = Function.prototype,
        a = r.call,
        o = i && r.bind.bind(a, a);
      t.exports = i
        ? o
        : function (t) {
            return function () {
              return a.apply(t, arguments);
            };
          };
    },
    e391: function (t, e, n) {
      var i = n("577e");
      t.exports = function (t, e) {
        return void 0 === t ? (arguments.length < 2 ? "" : e) : i(t);
      };
    },
    e5cb: function (t, e, n) {
      "use strict";
      var i = n("d066"),
        r = n("1a2d"),
        a = n("9112"),
        o = n("3a9b"),
        s = n("d2bb"),
        c = n("e893"),
        l = n("aeb0"),
        h = n("7156"),
        u = n("e391"),
        d = n("ab36"),
        p = n("6f19"),
        f = n("83ab"),
        m = n("c430");
      t.exports = function (t, e, n, g) {
        var v = "stackTraceLimit",
          y = g ? 2 : 1,
          x = t.split("."),
          _ = x[x.length - 1],
          b = i.apply(null, x);
        if (b) {
          var w = b.prototype;
          if ((!m && r(w, "cause") && delete w.cause, !n)) return b;
          var M = i("Error"),
            S = e(function (t, e) {
              var n = u(g ? e : t, void 0),
                i = g ? new b(t) : new b();
              return (
                void 0 !== n && a(i, "message", n),
                p(i, S, i.stack, 2),
                this && o(w, this) && h(i, this, S),
                arguments.length > y && d(i, arguments[y]),
                i
              );
            });
          if (
            ((S.prototype = w),
            "Error" !== _
              ? s
                ? s(S, M)
                : c(S, M, { name: !0 })
              : f && v in b && (l(S, b, v), l(S, b, "prepareStackTrace")),
            c(S, b),
            !m)
          )
            try {
              w.name !== _ && a(w, "name", _), (w.constructor = S);
            } catch (E) {}
          return S;
        }
      };
    },
    e61b: function (t, e, n) {
      (function (e, i, r) {
        t.exports = i(n("21bf"), n("3252"));
      })(0, function (t) {
        return (
          (function (e) {
            var n = t,
              i = n.lib,
              r = i.WordArray,
              a = i.Hasher,
              o = n.x64,
              s = o.Word,
              c = n.algo,
              l = [],
              h = [],
              u = [];
            (function () {
              for (var t = 1, e = 0, n = 0; n < 24; n++) {
                l[t + 5 * e] = (((n + 1) * (n + 2)) / 2) % 64;
                var i = e % 5,
                  r = (2 * t + 3 * e) % 5;
                (t = i), (e = r);
              }
              for (t = 0; t < 5; t++)
                for (e = 0; e < 5; e++)
                  h[t + 5 * e] = e + ((2 * t + 3 * e) % 5) * 5;
              for (var a = 1, o = 0; o < 24; o++) {
                for (var c = 0, d = 0, p = 0; p < 7; p++) {
                  if (1 & a) {
                    var f = (1 << p) - 1;
                    f < 32 ? (d ^= 1 << f) : (c ^= 1 << (f - 32));
                  }
                  128 & a ? (a = (a << 1) ^ 113) : (a <<= 1);
                }
                u[o] = s.create(c, d);
              }
            })();
            var d = [];
            (function () {
              for (var t = 0; t < 25; t++) d[t] = s.create();
            })();
            var p = (c.SHA3 = a.extend({
              cfg: a.cfg.extend({ outputLength: 512 }),
              _doReset: function () {
                for (var t = (this._state = []), e = 0; e < 25; e++)
                  t[e] = new s.init();
                this.blockSize = (1600 - 2 * this.cfg.outputLength) / 32;
              },
              _doProcessBlock: function (t, e) {
                for (
                  var n = this._state, i = this.blockSize / 2, r = 0;
                  r < i;
                  r++
                ) {
                  var a = t[e + 2 * r],
                    o = t[e + 2 * r + 1];
                  (a =
                    (16711935 & ((a << 8) | (a >>> 24))) |
                    (4278255360 & ((a << 24) | (a >>> 8)))),
                    (o =
                      (16711935 & ((o << 8) | (o >>> 24))) |
                      (4278255360 & ((o << 24) | (o >>> 8))));
                  var s = n[r];
                  (s.high ^= o), (s.low ^= a);
                }
                for (var c = 0; c < 24; c++) {
                  for (var p = 0; p < 5; p++) {
                    for (var f = 0, m = 0, g = 0; g < 5; g++) {
                      s = n[p + 5 * g];
                      (f ^= s.high), (m ^= s.low);
                    }
                    var v = d[p];
                    (v.high = f), (v.low = m);
                  }
                  for (p = 0; p < 5; p++) {
                    var y = d[(p + 4) % 5],
                      x = d[(p + 1) % 5],
                      _ = x.high,
                      b = x.low;
                    for (
                      f = y.high ^ ((_ << 1) | (b >>> 31)),
                        m = y.low ^ ((b << 1) | (_ >>> 31)),
                        g = 0;
                      g < 5;
                      g++
                    ) {
                      s = n[p + 5 * g];
                      (s.high ^= f), (s.low ^= m);
                    }
                  }
                  for (var w = 1; w < 25; w++) {
                    s = n[w];
                    var M = s.high,
                      S = s.low,
                      E = l[w];
                    E < 32
                      ? ((f = (M << E) | (S >>> (32 - E))),
                        (m = (S << E) | (M >>> (32 - E))))
                      : ((f = (S << (E - 32)) | (M >>> (64 - E))),
                        (m = (M << (E - 32)) | (S >>> (64 - E))));
                    var T = d[h[w]];
                    (T.high = f), (T.low = m);
                  }
                  var A = d[0],
                    C = n[0];
                  (A.high = C.high), (A.low = C.low);
                  for (p = 0; p < 5; p++)
                    for (g = 0; g < 5; g++) {
                      (w = p + 5 * g), (s = n[w]);
                      var R = d[w],
                        L = d[((p + 1) % 5) + 5 * g],
                        P = d[((p + 2) % 5) + 5 * g];
                      (s.high = R.high ^ (~L.high & P.high)),
                        (s.low = R.low ^ (~L.low & P.low));
                    }
                  s = n[0];
                  var D = u[c];
                  (s.high ^= D.high), (s.low ^= D.low);
                }
              },
              _doFinalize: function () {
                var t = this._data,
                  n = t.words,
                  i = (this._nDataBytes, 8 * t.sigBytes),
                  a = 32 * this.blockSize;
                (n[i >>> 5] |= 1 << (24 - (i % 32))),
                  (n[((e.ceil((i + 1) / a) * a) >>> 5) - 1] |= 128),
                  (t.sigBytes = 4 * n.length),
                  this._process();
                for (
                  var o = this._state,
                    s = this.cfg.outputLength / 8,
                    c = s / 8,
                    l = [],
                    h = 0;
                  h < c;
                  h++
                ) {
                  var u = o[h],
                    d = u.high,
                    p = u.low;
                  (d =
                    (16711935 & ((d << 8) | (d >>> 24))) |
                    (4278255360 & ((d << 24) | (d >>> 8)))),
                    (p =
                      (16711935 & ((p << 8) | (p >>> 24))) |
                      (4278255360 & ((p << 24) | (p >>> 8)))),
                    l.push(p),
                    l.push(d);
                }
                return new r.init(l, s);
              },
              clone: function () {
                for (
                  var t = a.clone.call(this),
                    e = (t._state = this._state.slice(0)),
                    n = 0;
                  n < 25;
                  n++
                )
                  e[n] = e[n].clone();
                return t;
              },
            }));
            (n.SHA3 = a._createHelper(p)),
              (n.HmacSHA3 = a._createHmacHelper(p));
          })(Math),
          t.SHA3
        );
      });
    },
    e683: function (t, e, n) {
      "use strict";
      t.exports = function (t, e) {
        return e ? t.replace(/\/+$/, "") + "/" + e.replace(/^\/+/, "") : t;
      };
    },
    e893: function (t, e, n) {
      var i = n("1a2d"),
        r = n("56ef"),
        a = n("06cf"),
        o = n("9bf2");
      t.exports = function (t, e, n) {
        for (var s = r(e), c = o.f, l = a.f, h = 0; h < s.length; h++) {
          var u = s[h];
          i(t, u) || (n && i(n, u)) || c(t, u, l(e, u));
        }
      };
    },
    e8b5: function (t, e, n) {
      var i = n("c6b6");
      t.exports =
        Array.isArray ||
        function (t) {
          return "Array" == i(t);
        };
    },
    eb11: function (t, e, n) {
      var i,
        r = (function () {
          var t = String.fromCharCode,
            e =
              "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
            n =
              "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+-$",
            i = {};
          function r(t, e) {
            if (!i[t]) {
              i[t] = {};
              for (var n = 0; n < t.length; n++) i[t][t.charAt(n)] = n;
            }
            return i[t][e];
          }
          var a = {
            compressToBase64: function (t) {
              if (null == t) return "";
              var n = a._compress(t, 6, function (t) {
                return e.charAt(t);
              });
              switch (n.length % 4) {
                default:
                case 0:
                  return n;
                case 1:
                  return n + "===";
                case 2:
                  return n + "==";
                case 3:
                  return n + "=";
              }
            },
            decompressFromBase64: function (t) {
              return null == t
                ? ""
                : "" == t
                ? null
                : a._decompress(t.length, 32, function (n) {
                    return r(e, t.charAt(n));
                  });
            },
            compressToUTF16: function (e) {
              return null == e
                ? ""
                : a._compress(e, 15, function (e) {
                    return t(e + 32);
                  }) + " ";
            },
            decompressFromUTF16: function (t) {
              return null == t
                ? ""
                : "" == t
                ? null
                : a._decompress(t.length, 16384, function (e) {
                    return t.charCodeAt(e) - 32;
                  });
            },
            compressToUint8Array: function (t) {
              for (
                var e = a.compress(t),
                  n = new Uint8Array(2 * e.length),
                  i = 0,
                  r = e.length;
                i < r;
                i++
              ) {
                var o = e.charCodeAt(i);
                (n[2 * i] = o >>> 8), (n[2 * i + 1] = o % 256);
              }
              return n;
            },
            decompressFromUint8Array: function (e) {
              if (null === e || void 0 === e) return a.decompress(e);
              for (
                var n = new Array(e.length / 2), i = 0, r = n.length;
                i < r;
                i++
              )
                n[i] = 256 * e[2 * i] + e[2 * i + 1];
              var o = [];
              return (
                n.forEach(function (e) {
                  o.push(t(e));
                }),
                a.decompress(o.join(""))
              );
            },
            compressToEncodedURIComponent: function (t) {
              return null == t
                ? ""
                : a._compress(t, 6, function (t) {
                    return n.charAt(t);
                  });
            },
            decompressFromEncodedURIComponent: function (t) {
              return null == t
                ? ""
                : "" == t
                ? null
                : ((t = t.replace(/ /g, "+")),
                  a._decompress(t.length, 32, function (e) {
                    return r(n, t.charAt(e));
                  }));
            },
            compress: function (e) {
              return a._compress(e, 16, function (e) {
                return t(e);
              });
            },
            _compress: function (t, e, n) {
              if (null == t) return "";
              var i,
                r,
                a,
                o = {},
                s = {},
                c = "",
                l = "",
                h = "",
                u = 2,
                d = 3,
                p = 2,
                f = [],
                m = 0,
                g = 0;
              for (a = 0; a < t.length; a += 1)
                if (
                  ((c = t.charAt(a)),
                  Object.prototype.hasOwnProperty.call(o, c) ||
                    ((o[c] = d++), (s[c] = !0)),
                  (l = h + c),
                  Object.prototype.hasOwnProperty.call(o, l))
                )
                  h = l;
                else {
                  if (Object.prototype.hasOwnProperty.call(s, h)) {
                    if (h.charCodeAt(0) < 256) {
                      for (i = 0; i < p; i++)
                        (m <<= 1),
                          g == e - 1 ? ((g = 0), f.push(n(m)), (m = 0)) : g++;
                      for (r = h.charCodeAt(0), i = 0; i < 8; i++)
                        (m = (m << 1) | (1 & r)),
                          g == e - 1 ? ((g = 0), f.push(n(m)), (m = 0)) : g++,
                          (r >>= 1);
                    } else {
                      for (r = 1, i = 0; i < p; i++)
                        (m = (m << 1) | r),
                          g == e - 1 ? ((g = 0), f.push(n(m)), (m = 0)) : g++,
                          (r = 0);
                      for (r = h.charCodeAt(0), i = 0; i < 16; i++)
                        (m = (m << 1) | (1 & r)),
                          g == e - 1 ? ((g = 0), f.push(n(m)), (m = 0)) : g++,
                          (r >>= 1);
                    }
                    u--, 0 == u && ((u = Math.pow(2, p)), p++), delete s[h];
                  } else
                    for (r = o[h], i = 0; i < p; i++)
                      (m = (m << 1) | (1 & r)),
                        g == e - 1 ? ((g = 0), f.push(n(m)), (m = 0)) : g++,
                        (r >>= 1);
                  u--,
                    0 == u && ((u = Math.pow(2, p)), p++),
                    (o[l] = d++),
                    (h = String(c));
                }
              if ("" !== h) {
                if (Object.prototype.hasOwnProperty.call(s, h)) {
                  if (h.charCodeAt(0) < 256) {
                    for (i = 0; i < p; i++)
                      (m <<= 1),
                        g == e - 1 ? ((g = 0), f.push(n(m)), (m = 0)) : g++;
                    for (r = h.charCodeAt(0), i = 0; i < 8; i++)
                      (m = (m << 1) | (1 & r)),
                        g == e - 1 ? ((g = 0), f.push(n(m)), (m = 0)) : g++,
                        (r >>= 1);
                  } else {
                    for (r = 1, i = 0; i < p; i++)
                      (m = (m << 1) | r),
                        g == e - 1 ? ((g = 0), f.push(n(m)), (m = 0)) : g++,
                        (r = 0);
                    for (r = h.charCodeAt(0), i = 0; i < 16; i++)
                      (m = (m << 1) | (1 & r)),
                        g == e - 1 ? ((g = 0), f.push(n(m)), (m = 0)) : g++,
                        (r >>= 1);
                  }
                  u--, 0 == u && ((u = Math.pow(2, p)), p++), delete s[h];
                } else
                  for (r = o[h], i = 0; i < p; i++)
                    (m = (m << 1) | (1 & r)),
                      g == e - 1 ? ((g = 0), f.push(n(m)), (m = 0)) : g++,
                      (r >>= 1);
                u--, 0 == u && ((u = Math.pow(2, p)), p++);
              }
              for (r = 2, i = 0; i < p; i++)
                (m = (m << 1) | (1 & r)),
                  g == e - 1 ? ((g = 0), f.push(n(m)), (m = 0)) : g++,
                  (r >>= 1);
              while (1) {
                if (((m <<= 1), g == e - 1)) {
                  f.push(n(m));
                  break;
                }
                g++;
              }
              return f.join("");
            },
            decompress: function (t) {
              return null == t
                ? ""
                : "" == t
                ? null
                : a._decompress(t.length, 32768, function (e) {
                    return t.charCodeAt(e);
                  });
            },
            _decompress: function (e, n, i) {
              var r,
                a,
                o,
                s,
                c,
                l,
                h,
                u = [],
                d = 4,
                p = 4,
                f = 3,
                m = "",
                g = [],
                v = { val: i(0), position: n, index: 1 };
              for (r = 0; r < 3; r += 1) u[r] = r;
              (o = 0), (c = Math.pow(2, 2)), (l = 1);
              while (l != c)
                (s = v.val & v.position),
                  (v.position >>= 1),
                  0 == v.position && ((v.position = n), (v.val = i(v.index++))),
                  (o |= (s > 0 ? 1 : 0) * l),
                  (l <<= 1);
              switch (o) {
                case 0:
                  (o = 0), (c = Math.pow(2, 8)), (l = 1);
                  while (l != c)
                    (s = v.val & v.position),
                      (v.position >>= 1),
                      0 == v.position &&
                        ((v.position = n), (v.val = i(v.index++))),
                      (o |= (s > 0 ? 1 : 0) * l),
                      (l <<= 1);
                  h = t(o);
                  break;
                case 1:
                  (o = 0), (c = Math.pow(2, 16)), (l = 1);
                  while (l != c)
                    (s = v.val & v.position),
                      (v.position >>= 1),
                      0 == v.position &&
                        ((v.position = n), (v.val = i(v.index++))),
                      (o |= (s > 0 ? 1 : 0) * l),
                      (l <<= 1);
                  h = t(o);
                  break;
                case 2:
                  return "";
              }
              (u[3] = h), (a = h), g.push(h);
              while (1) {
                if (v.index > e) return "";
                (o = 0), (c = Math.pow(2, f)), (l = 1);
                while (l != c)
                  (s = v.val & v.position),
                    (v.position >>= 1),
                    0 == v.position &&
                      ((v.position = n), (v.val = i(v.index++))),
                    (o |= (s > 0 ? 1 : 0) * l),
                    (l <<= 1);
                switch ((h = o)) {
                  case 0:
                    (o = 0), (c = Math.pow(2, 8)), (l = 1);
                    while (l != c)
                      (s = v.val & v.position),
                        (v.position >>= 1),
                        0 == v.position &&
                          ((v.position = n), (v.val = i(v.index++))),
                        (o |= (s > 0 ? 1 : 0) * l),
                        (l <<= 1);
                    (u[p++] = t(o)), (h = p - 1), d--;
                    break;
                  case 1:
                    (o = 0), (c = Math.pow(2, 16)), (l = 1);
                    while (l != c)
                      (s = v.val & v.position),
                        (v.position >>= 1),
                        0 == v.position &&
                          ((v.position = n), (v.val = i(v.index++))),
                        (o |= (s > 0 ? 1 : 0) * l),
                        (l <<= 1);
                    (u[p++] = t(o)), (h = p - 1), d--;
                    break;
                  case 2:
                    return g.join("");
                }
                if ((0 == d && ((d = Math.pow(2, f)), f++), u[h])) m = u[h];
                else {
                  if (h !== p) return null;
                  m = a + a.charAt(0);
                }
                g.push(m),
                  (u[p++] = a + m.charAt(0)),
                  d--,
                  (a = m),
                  0 == d && ((d = Math.pow(2, f)), f++);
              }
            },
          };
          return a;
        })();
      (i = function () {
        return r;
      }.call(e, n, e, t)),
        void 0 === i || (t.exports = i);
    },
    f4ea: function (t, e, n) {
      (function (e, i, r) {
        t.exports = i(n("21bf"), n("38ba"));
      })(0, function (t) {
        return (
          (t.mode.CTR = (function () {
            var e = t.lib.BlockCipherMode.extend(),
              n = (e.Encryptor = e.extend({
                processBlock: function (t, e) {
                  var n = this._cipher,
                    i = n.blockSize,
                    r = this._iv,
                    a = this._counter;
                  r && ((a = this._counter = r.slice(0)), (this._iv = void 0));
                  var o = a.slice(0);
                  n.encryptBlock(o, 0), (a[i - 1] = (a[i - 1] + 1) | 0);
                  for (var s = 0; s < i; s++) t[e + s] ^= o[s];
                },
              }));
            return (e.Decryptor = n), e;
          })()),
          t.mode.CTR
        );
      });
    },
    f5df: function (t, e, n) {
      var i = n("00ee"),
        r = n("1626"),
        a = n("c6b6"),
        o = n("b622"),
        s = o("toStringTag"),
        c = Object,
        l =
          "Arguments" ==
          a(
            (function () {
              return arguments;
            })()
          ),
        h = function (t, e) {
          try {
            return t[e];
          } catch (n) {}
        };
      t.exports = i
        ? a
        : function (t) {
            var e, n, i;
            return void 0 === t
              ? "Undefined"
              : null === t
              ? "Null"
              : "string" == typeof (n = h((e = c(t)), s))
              ? n
              : l
              ? a(e)
              : "Object" == (i = a(e)) && r(e.callee)
              ? "Arguments"
              : i;
          };
    },
    f6b4: function (t, e, n) {
      "use strict";
      var i = n("c532");
      function r() {
        this.handlers = [];
      }
      (r.prototype.use = function (t, e, n) {
        return (
          this.handlers.push({
            fulfilled: t,
            rejected: e,
            synchronous: !!n && n.synchronous,
            runWhen: n ? n.runWhen : null,
          }),
          this.handlers.length - 1
        );
      }),
        (r.prototype.eject = function (t) {
          this.handlers[t] && (this.handlers[t] = null);
        }),
        (r.prototype.forEach = function (t) {
          i.forEach(this.handlers, function (e) {
            null !== e && t(e);
          });
        }),
        (t.exports = r);
    },
    f772: function (t, e, n) {
      var i = n("5692"),
        r = n("90e3"),
        a = i("keys");
      t.exports = function (t) {
        return a[t] || (a[t] = r(t));
      };
    },
    fb15: function (t, e, n) {
      "use strict";
      if ((n.r(e), "undefined" !== typeof window)) {
        var i = window.document.currentScript,
          r = i && i.src.match(/(.+\/)[^/]+\.js(\?.*)?$/);
        r && (n.p = r[1]);
      }
      var a = n("8bbf"),
        o = n.n(a),
        s = function () {
          var t = this,
            e = t._self._c;
          return e(
            "div",
            { staticClass: "mb-5 calculator" },
            [
              e("div", { staticClass: "row" }, [
                e(
                  "div",
                  {
                    staticClass:
                      "col-12 col-sm-12 col-md-5 col-lg-5 pt-2 order-1 order-sm-1",
                  },
                  [
                    t.config
                      ? [
                          t.showFarmTypes
                            ? [
                                e("div", { staticClass: "form-group" }, [
                                  e("label", [
                                    t._v(
                                      "Ð¢Ð¸Ð¿ ÑÐµÑÐ¼Ñ: " +
                                        t._s(t.farmTypeLocal.caption)
                                    ),
                                  ]),
                                  e(
                                    "ul",
                                    { staticClass: "nav nav-tabs" },
                                    t._l(
                                      t.config.farmTypes.filter((t) =>
                                        this.allowedFarmTypes.includes(t.id)
                                      ),
                                      function (n) {
                                        return e(
                                          "li",
                                          {
                                            key: "ft" + n.id,
                                            staticClass: "nav-item",
                                          },
                                          [
                                            e(
                                              "a",
                                              {
                                                class: {
                                                  "nav-link active":
                                                    t.farmTypeLocal.id === n.id,
                                                  "nav-link":
                                                    t.farmTypeLocal.id !== n.id,
                                                },
                                                on: {
                                                  click: function (e) {
                                                    return t.setFarmType(n);
                                                  },
                                                },
                                              },
                                              [
                                                e("img", {
                                                  staticStyle: {
                                                    width: "85px",
                                                    height: "25px",
                                                    "object-fit": "contain",
                                                    "max-width": "85px",
                                                  },
                                                  attrs: { src: n.iconUrl },
                                                }),
                                              ]
                                            ),
                                          ]
                                        );
                                      }
                                    ),
                                    0
                                  ),
                                ]),
                              ]
                            : t._e(),
                          e("div", { staticClass: "row" }, [
                            e("div", { staticClass: "col-12" }, [
                              e("div", { staticClass: "form-group" }, [
                                e("label", [
                                  t._v("ÐÑÐµÐ´Ð½Ð°ÑÑÑÐ¾ÐµÐ½Ð½Ð°Ñ ÐºÐ¾Ð½ÑÐ¸Ð³ÑÑÐ°ÑÐ¸Ñ"),
                                ]),
                                e(
                                  "div",
                                  {
                                    staticClass: "btn-group btn-group-sm",
                                    attrs: {
                                      role: "group",
                                      "aria-label": "Basic outlined example",
                                    },
                                  },
                                  t._l(
                                    t.config.predefinedConfigurations,
                                    function (n) {
                                      return e(
                                        "div",
                                        {
                                          key: "conf" + n.id,
                                          staticClass: "btn",
                                          class: {
                                            "btn-primary":
                                              t.currentConfigurationId === n.id,
                                            "btn-outline-primary":
                                              t.currentConfigurationId !== n.id,
                                          },
                                          on: {
                                            click: function (e) {
                                              return t.setPredefinedConfiguration(
                                                n
                                              );
                                            },
                                          },
                                        },
                                        [t._v(" " + t._s(n.caption) + " ")]
                                      );
                                    }
                                  ),
                                  0
                                ),
                              ]),
                            ]),
                          ]),
                          5 != t.farmTypeLocal.id
                            ? e("div", { staticClass: "row" }, [
                                e("div", { staticClass: "col-12" }, [
                                  e("div", { staticClass: "form-group" }, [
                                    e("label", [t._v("ÐÐ±ÑÐµÑÐµÑÐºÐ°")]),
                                    e(
                                      "div",
                                      { staticClass: "btn-group btn-group-sm" },
                                      t._l(
                                        t.config.farmTypes.find(
                                          (e) => e.id == t.farmTypeLocal.id
                                        ).lathing,
                                        function (n) {
                                          return e(
                                            "div",
                                            {
                                              key: "lathingType" + n.id,
                                              staticClass: "btn",
                                              class: {
                                                "btn-primary":
                                                  t.lathingType.id === n.id,
                                                "btn-outline-primary":
                                                  t.lathingType.id !== n.id,
                                              },
                                              on: {
                                                click: function (e) {
                                                  return t.setLathingType(n);
                                                },
                                              },
                                            },
                                            [t._v(" " + t._s(n.caption) + " ")]
                                          );
                                        }
                                      ),
                                      0
                                    ),
                                  ]),
                                ]),
                              ])
                            : t._e(),
                          e("div", { staticClass: "row" }, [
                            e("div", { staticClass: "col-12 col-lg-6" }, [
                              e("div", { staticClass: "form-group" }, [
                                e(
                                  "label",
                                  { attrs: { for: "formControlRange" } },
                                  [t._v("Ð¨Ð¸ÑÐ¸Ð½Ð° Ð½Ð°Ð²ÐµÑÐ°, Ð¼")]
                                ),
                                e("input", {
                                  directives: [
                                    {
                                      name: "model",
                                      rawName: "v-model.number",
                                      value: t.width,
                                      expression: "width",
                                      modifiers: { number: !0 },
                                    },
                                  ],
                                  staticClass: "form-control",
                                  attrs: {
                                    type: "number",
                                    step: t.config.widthStep,
                                    min: t.config.minWidth,
                                    max: t.config.maxWidth,
                                  },
                                  domProps: { value: t.width },
                                  on: {
                                    change: function (e) {
                                      return t.render();
                                    },
                                    input: function (e) {
                                      e.target.composing ||
                                        (t.width = t._n(e.target.value));
                                    },
                                    blur: function (e) {
                                      return t.$forceUpdate();
                                    },
                                  },
                                }),
                                e("input", {
                                  directives: [
                                    {
                                      name: "model",
                                      rawName: "v-model",
                                      value: t.width,
                                      expression: "width",
                                    },
                                  ],
                                  staticClass:
                                    "form-control-range sticky-range custom-range",
                                  attrs: {
                                    type: "range",
                                    step: t.config.widthStep,
                                    id: "formControlRange",
                                    min: t.config.minWidth,
                                    max: t.config.maxWidth,
                                  },
                                  domProps: { value: t.width },
                                  on: {
                                    change: function (e) {
                                      return t.render();
                                    },
                                    __r: function (e) {
                                      t.width = e.target.value;
                                    },
                                  },
                                }),
                              ]),
                            ]),
                            e("div", { staticClass: "col-12 col-lg-6" }, [
                              e("div", { staticClass: "form-group" }, [
                                e(
                                  "label",
                                  { attrs: { for: "formControlRange" } },
                                  [t._v("ÐÐ»Ð¸Ð½Ð° Ð½Ð°Ð²ÐµÑÐ°, Ð¼ ")]
                                ),
                                e("input", {
                                  directives: [
                                    {
                                      name: "model",
                                      rawName: "v-model.number",
                                      value: t.height,
                                      expression: "height",
                                      modifiers: { number: !0 },
                                    },
                                  ],
                                  staticClass: "form-control",
                                  attrs: {
                                    type: "number",
                                    step: t.config.heightStep,
                                    min: t.config.minHeight,
                                    max: t.config.maxHeight,
                                  },
                                  domProps: { value: t.height },
                                  on: {
                                    change: function (e) {
                                      return t.render();
                                    },
                                    input: function (e) {
                                      e.target.composing ||
                                        (t.height = t._n(e.target.value));
                                    },
                                    blur: function (e) {
                                      return t.$forceUpdate();
                                    },
                                  },
                                }),
                                e("input", {
                                  directives: [
                                    {
                                      name: "model",
                                      rawName: "v-model",
                                      value: t.height,
                                      expression: "height",
                                    },
                                  ],
                                  staticClass:
                                    "form-control-range sticky-range custom-range",
                                  attrs: {
                                    type: "range",
                                    id: "formControlRange",
                                    step: t.config.heightStep,
                                    min: t.config.minHeight,
                                    max: t.config.maxHeight,
                                  },
                                  domProps: { value: t.height },
                                  on: {
                                    change: function (e) {
                                      return t.render();
                                    },
                                    __r: function (e) {
                                      t.height = e.target.value;
                                    },
                                  },
                                }),
                              ]),
                            ]),
                            e("div", { staticClass: "col-12 col-lg-6" }, [
                              e("div", { staticClass: "form-group" }, [
                                e(
                                  "label",
                                  { attrs: { for: "formControlRange" } },
                                  [t._v("ÐÑÑÐ¾ÑÐ° ÑÑÐ¾Ð»Ð±Ð¾Ð², Ð¼ ")]
                                ),
                                e("input", {
                                  directives: [
                                    {
                                      name: "model",
                                      rawName: "v-model.number",
                                      value: t.pillarHeight,
                                      expression: "pillarHeight",
                                      modifiers: { number: !0 },
                                    },
                                  ],
                                  staticClass: "form-control",
                                  attrs: {
                                    type: "number",
                                    step: t.config.pillarHeightStep,
                                    min: t.config.pillarMinHeight,
                                    max: t.config.pillarMaxHeight,
                                  },
                                  domProps: { value: t.pillarHeight },
                                  on: {
                                    change: function (e) {
                                      return t.render();
                                    },
                                    input: function (e) {
                                      e.target.composing ||
                                        (t.pillarHeight = t._n(e.target.value));
                                    },
                                    blur: function (e) {
                                      return t.$forceUpdate();
                                    },
                                  },
                                }),
                                e("input", {
                                  directives: [
                                    {
                                      name: "model",
                                      rawName: "v-model",
                                      value: t.pillarHeight,
                                      expression: "pillarHeight",
                                    },
                                  ],
                                  staticClass:
                                    "form-control-range sticky-range custom-range",
                                  attrs: {
                                    type: "range",
                                    id: "formControlRange",
                                    step: t.config.pillarHeightStep,
                                    min: t.config.pillarMinHeight,
                                    max: t.config.pillarMaxHeight,
                                  },
                                  domProps: { value: t.pillarHeight },
                                  on: {
                                    change: function (e) {
                                      return t.render();
                                    },
                                    __r: function (e) {
                                      t.pillarHeight = e.target.value;
                                    },
                                  },
                                }),
                              ]),
                            ]),
                            2 == t.farmTypeLocal.id ||
                            3 == t.farmTypeLocal.id ||
                            4 == t.farmTypeLocal.id ||
                            5 == t.farmTypeLocal.id ||
                            6 == t.farmTypeLocal.id ||
                            7 == t.farmTypeLocal.id
                              ? e("div", { staticClass: "col-12 col-lg-6" }, [
                                  e("div", { staticClass: "form-group" }, [
                                    e(
                                      "label",
                                      { attrs: { for: "formControlRange" } },
                                      [
                                        t._v("ÐÑÑÐ¾ÑÐ° ÑÐºÐ°ÑÐ°, Ð¼., "),
                                        e("span", [
                                          t._v(
                                            "(" + t._s(t.slopeDegree) + "Â°)"
                                          ),
                                        ]),
                                      ]
                                    ),
                                    e("input", {
                                      directives: [
                                        {
                                          name: "model",
                                          rawName: "v-model.number",
                                          value: t.slopeHeight,
                                          expression: "slopeHeight",
                                          modifiers: { number: !0 },
                                        },
                                      ],
                                      staticClass: "form-control",
                                      attrs: {
                                        type: "number",
                                        step: t.config.slopeHeightStep,
                                        min: t.config.slopeHeightMin,
                                        max: t.config.slopeHeightMax,
                                      },
                                      domProps: { value: t.slopeHeight },
                                      on: {
                                        change: function (e) {
                                          return t.render();
                                        },
                                        input: function (e) {
                                          e.target.composing ||
                                            (t.slopeHeight = t._n(
                                              e.target.value
                                            ));
                                        },
                                        blur: function (e) {
                                          return t.$forceUpdate();
                                        },
                                      },
                                    }),
                                    e("input", {
                                      directives: [
                                        {
                                          name: "model",
                                          rawName: "v-model",
                                          value: t.slopeHeight,
                                          expression: "slopeHeight",
                                        },
                                      ],
                                      staticClass:
                                        "form-control-range sticky-range custom-range",
                                      attrs: {
                                        type: "range",
                                        id: "formControlRange",
                                        step: t.config.slopeHeightStep,
                                        min: t.config.slopeHeightMin,
                                        max: t.config.slopeHeightMax,
                                      },
                                      domProps: { value: t.slopeHeight },
                                      on: {
                                        change: function (e) {
                                          return t.render();
                                        },
                                        __r: function (e) {
                                          t.slopeHeight = e.target.value;
                                        },
                                      },
                                    }),
                                  ]),
                                ])
                              : t._e(),
                            4 == t.farmTypeLocal.id
                              ? e("div", { staticClass: "col-12 col-lg-6" }, [
                                  e("div", { staticClass: "form-group" }, [
                                    e(
                                      "label",
                                      { attrs: { for: "formControlRange2" } },
                                      [t._v("ÐÑÑÐ¾ÑÐ° ÑÐµÑÐ¼Ñ ÑÐ½Ð¸Ð·Ñ, Ð¼.")]
                                    ),
                                    e("input", {
                                      directives: [
                                        {
                                          name: "model",
                                          rawName: "v-model.number",
                                          value: t.slopeHeight2,
                                          expression: "slopeHeight2",
                                          modifiers: { number: !0 },
                                        },
                                      ],
                                      staticClass: "form-control",
                                      attrs: {
                                        type: "number",
                                        step: t.config.slopeHeightStep,
                                        min: t.config.slopeHeightMin,
                                        max: t.config.slopeHeightMax,
                                      },
                                      domProps: { value: t.slopeHeight2 },
                                      on: {
                                        change: function (e) {
                                          return t.render();
                                        },
                                        input: function (e) {
                                          e.target.composing ||
                                            (t.slopeHeight2 = t._n(
                                              e.target.value
                                            ));
                                        },
                                        blur: function (e) {
                                          return t.$forceUpdate();
                                        },
                                      },
                                    }),
                                    e("input", {
                                      directives: [
                                        {
                                          name: "model",
                                          rawName: "v-model",
                                          value: t.slopeHeight2,
                                          expression: "slopeHeight2",
                                        },
                                      ],
                                      staticClass:
                                        "form-control-range sticky-range custom-range",
                                      attrs: {
                                        type: "range",
                                        id: "formControlRange2",
                                        step: t.config.slopeHeightStep,
                                        min: t.config.slopeHeightMin,
                                        max: t.config.slopeHeightMax,
                                      },
                                      domProps: { value: t.slopeHeight2 },
                                      on: {
                                        change: function (e) {
                                          return t.render();
                                        },
                                        __r: function (e) {
                                          t.slopeHeight2 = e.target.value;
                                        },
                                      },
                                    }),
                                  ]),
                                ])
                              : t._e(),
                          ]),
                          6 == t.farmTypeLocal.id
                            ? [
                                e("div", { staticClass: "row" }, [
                                  e("div", { staticClass: "col-12 col-lg-6" }, [
                                    e("div", { staticClass: "form-group" }, [
                                      e("div", { staticClass: "form-check" }, [
                                        e("input", {
                                          directives: [
                                            {
                                              name: "model",
                                              rawName: "v-model",
                                              value: t.useRoofShift,
                                              expression: "useRoofShift",
                                            },
                                          ],
                                          staticClass: "form-check-input",
                                          attrs: {
                                            type: "checkbox",
                                            id: "roofShiftCheckbox",
                                          },
                                          domProps: {
                                            checked: Array.isArray(
                                              t.useRoofShift
                                            )
                                              ? t._i(t.useRoofShift, null) > -1
                                              : t.useRoofShift,
                                          },
                                          on: {
                                            change: [
                                              function (e) {
                                                var n = t.useRoofShift,
                                                  i = e.target,
                                                  r = !!i.checked;
                                                if (Array.isArray(n)) {
                                                  var a = null,
                                                    o = t._i(n, a);
                                                  i.checked
                                                    ? o < 0 &&
                                                      (t.useRoofShift =
                                                        n.concat([a]))
                                                    : o > -1 &&
                                                      (t.useRoofShift = n
                                                        .slice(0, o)
                                                        .concat(
                                                          n.slice(o + 1)
                                                        ));
                                                } else t.useRoofShift = r;
                                              },
                                              function (e) {
                                                return t.roofShiftChanged();
                                              },
                                            ],
                                          },
                                        }),
                                        e(
                                          "label",
                                          {
                                            staticClass: "form-check-label",
                                            attrs: { for: "roofShiftCheckbox" },
                                          },
                                          [t._v(" Ð¡Ð¼ÐµÑÐµÐ½Ð¸Ðµ ÐºÐ¾Ð½ÑÐºÐ° ")]
                                        ),
                                      ]),
                                    ]),
                                  ]),
                                ]),
                                t.useRoofShift
                                  ? e("div", { staticClass: "row" }, [
                                      e(
                                        "div",
                                        { staticClass: "col-12 col-lg-6" },
                                        [
                                          e(
                                            "div",
                                            { staticClass: "form-group" },
                                            [
                                              e(
                                                "label",
                                                {
                                                  attrs: {
                                                    for: "formControlRange",
                                                  },
                                                },
                                                [t._v("Ð¡Ð¼ÐµÑÐµÐ½Ð¸Ðµ ÐºÐ¾Ð½ÑÐºÐ° ÑÐ»ÐµÐ²Ð° ")]
                                              ),
                                              e("input", {
                                                directives: [
                                                  {
                                                    name: "model",
                                                    rawName: "v-model.number",
                                                    value: t.roofShift,
                                                    expression: "roofShift",
                                                    modifiers: { number: !0 },
                                                  },
                                                ],
                                                staticClass: "form-control",
                                                attrs: {
                                                  type: "number",
                                                  step: 0.01,
                                                  min: (this.width / 4).toFixed(
                                                    2
                                                  ),
                                                  max: this.width / 2,
                                                },
                                                domProps: {
                                                  value: t.roofShift,
                                                },
                                                on: {
                                                  change: function (e) {
                                                    return t.render();
                                                  },
                                                  input: function (e) {
                                                    e.target.composing ||
                                                      (t.roofShift = t._n(
                                                        e.target.value
                                                      ));
                                                  },
                                                  blur: function (e) {
                                                    return t.$forceUpdate();
                                                  },
                                                },
                                              }),
                                              e("input", {
                                                directives: [
                                                  {
                                                    name: "model",
                                                    rawName: "v-model.number",
                                                    value: t.roofShift,
                                                    expression: "roofShift",
                                                    modifiers: { number: !0 },
                                                  },
                                                ],
                                                staticClass:
                                                  "form-control-range sticky-range custom-range",
                                                attrs: {
                                                  type: "range",
                                                  step: 0.01,
                                                  id: "roofShiftRange",
                                                  min: (this.width / 4).toFixed(
                                                    2
                                                  ),
                                                  max: this.width / 2,
                                                },
                                                domProps: {
                                                  value: t.roofShift,
                                                },
                                                on: {
                                                  change: function (e) {
                                                    return t.render();
                                                  },
                                                  __r: function (e) {
                                                    t.roofShift = t._n(
                                                      e.target.value
                                                    );
                                                  },
                                                  blur: function (e) {
                                                    return t.$forceUpdate();
                                                  },
                                                },
                                              }),
                                            ]
                                          ),
                                        ]
                                      ),
                                    ])
                                  : t._e(),
                              ]
                            : t._e(),
                          e("div", { staticClass: "row" }, [
                            e("div", { staticClass: "col-12 col-md-12" }, [
                              e("div", { staticClass: "form-group" }, [
                                e("label", [t._v("Ð Ð°Ð·Ð¼ÐµÑ ÑÑÐ¾Ð»Ð±Ð¾Ð² ")]),
                                e("div", { staticClass: "dropdown" }, [
                                  e(
                                    "button",
                                    {
                                      staticClass:
                                        "btn btn-default dropdown-toggle",
                                      attrs: {
                                        type: "button",
                                        "data-toggle": "dropdown",
                                        "aria-haspopup": "true",
                                        "aria-expanded": "false",
                                      },
                                    },
                                    [
                                      e(
                                        "span",
                                        { staticClass: "text-item__caption" },
                                        [t._v(t._s(t.pillarSize.caption))]
                                      ),
                                    ]
                                  ),
                                  e(
                                    "div",
                                    {
                                      staticClass: "dropdown-menu",
                                      attrs: {
                                        "aria-labelledby": "dropdownMenuButton",
                                      },
                                    },
                                    [
                                      t._l(t.config.pillarSizes, function (n) {
                                        return [
                                          e(
                                            "div",
                                            {
                                              key: "psgroup" + n.id,
                                              staticClass:
                                                "dropdown-item pl-2 group disabled",
                                            },
                                            [t._v(" " + t._s(n.caption) + " ")]
                                          ),
                                          t._l(n.sizes, function (n) {
                                            return e(
                                              "a",
                                              {
                                                key: "ps" + n.id,
                                                staticClass: "dropdown-item",
                                                on: {
                                                  click: function (e) {
                                                    return t.setPillarSize(n);
                                                  },
                                                },
                                              },
                                              [
                                                e(
                                                  "span",
                                                  {
                                                    staticClass:
                                                      "text-item__caption",
                                                  },
                                                  [t._v(t._s(n.caption))]
                                                ),
                                              ]
                                            );
                                          }),
                                        ];
                                      }),
                                    ],
                                    2
                                  ),
                                ]),
                              ]),
                            ]),
                          ]),
                          e("div", { staticClass: "row" }, [
                            e("div", { staticClass: "col-12 col-md-12" }, [
                              e("div", { staticClass: "form-group" }, [
                                e("label", [t._v("ÐÐ°ÑÐµÑÐ¸Ð°Ð» ÐºÑÐ¾Ð²Ð»Ð¸:")]),
                                e("div", { staticClass: "dropdown" }, [
                                  e(
                                    "button",
                                    {
                                      staticClass:
                                        "btn btn-default dropdown-toggle",
                                      attrs: {
                                        type: "button",
                                        "data-toggle": "dropdown",
                                        "aria-haspopup": "true",
                                        "aria-expanded": "false",
                                      },
                                    },
                                    [
                                      e(
                                        "span",
                                        { staticClass: "text-item__caption" },
                                        [t._v(t._s(t.roofTypeLocal.caption))]
                                      ),
                                    ]
                                  ),
                                  e(
                                    "div",
                                    {
                                      staticClass: "dropdown-menu",
                                      attrs: {
                                        "aria-labelledby": "dropdownMenuButton",
                                      },
                                    },
                                    t._l(
                                      t.config.roofTypes.filter((e) =>
                                        t.farmTypeLocal.roofTypes.includes(e.id)
                                      ),
                                      function (n) {
                                        return e(
                                          "a",
                                          {
                                            key: "rt" + n.id,
                                            staticClass: "dropdown-item",
                                            on: {
                                              click: function (e) {
                                                return t.setRoofType(n);
                                              },
                                            },
                                          },
                                          [
                                            e(
                                              "span",
                                              {
                                                staticClass:
                                                  "text-item__caption",
                                              },
                                              [t._v(t._s(n.caption))]
                                            ),
                                          ]
                                        );
                                      }
                                    ),
                                    0
                                  ),
                                ]),
                              ]),
                            ]),
                            t.roofSubTypeLocal
                              ? e("div", { staticClass: "col-12 col-md-12" }, [
                                  e("div", { staticClass: "form-group" }, [
                                    e("label", [t._v("ÐÐ°ÑÐ°Ð¼ÐµÑÑÑ:")]),
                                    e("div", { staticClass: "dropdown" }, [
                                      e(
                                        "button",
                                        {
                                          staticClass:
                                            "btn btn-default dropdown-toggle",
                                          attrs: {
                                            type: "button",
                                            "data-toggle": "dropdown",
                                            "aria-haspopup": "true",
                                            "aria-expanded": "false",
                                          },
                                        },
                                        [
                                          e(
                                            "span",
                                            {
                                              staticClass: "text-item__caption",
                                            },
                                            [
                                              t._v(
                                                t._s(t.roofSubTypeLocal.caption)
                                              ),
                                            ]
                                          ),
                                        ]
                                      ),
                                      e(
                                        "div",
                                        {
                                          staticClass: "dropdown-menu",
                                          attrs: {
                                            "aria-labelledby":
                                              "dropdownMenuButton",
                                          },
                                        },
                                        t._l(
                                          t.config.roofTypes.find(
                                            (e) => e.id == t.roofTypeLocal.id
                                          ).types,
                                          function (n) {
                                            return e(
                                              "a",
                                              {
                                                key: "rst" + n.id,
                                                staticClass: "dropdown-item",
                                                on: {
                                                  click: function (e) {
                                                    return t.setRoofSubType(n);
                                                  },
                                                },
                                              },
                                              [
                                                e(
                                                  "span",
                                                  {
                                                    staticClass:
                                                      "text-item__caption",
                                                  },
                                                  [t._v(t._s(n.caption))]
                                                ),
                                              ]
                                            );
                                          }
                                        ),
                                        0
                                      ),
                                    ]),
                                  ]),
                                ])
                              : t._e(),
                          ]),
                          e("div", { staticClass: "form-group" }, [
                            e("label", [t._v("Ð¦Ð²ÐµÑ ÐºÑÐ¾Ð²ÐµÐ»ÑÐ½Ð¾Ð³Ð¾ Ð¿Ð¾ÐºÑÑÑÐ¸Ñ")]),
                            e("div", { staticClass: "dropdown" }, [
                              e(
                                "button",
                                {
                                  staticClass:
                                    "btn btn-default dropdown-toggle",
                                  attrs: {
                                    type: "button",
                                    id: "dropdownMenuButton",
                                    "data-toggle": "dropdown",
                                    "aria-haspopup": "true",
                                    "aria-expanded": "false",
                                  },
                                },
                                [
                                  e("span", {
                                    staticClass: "color-item__color",
                                    style: {
                                      "background-color": t.roofColor.color,
                                    },
                                  }),
                                  e(
                                    "span",
                                    { staticClass: "color-item__caption" },
                                    [t._v(t._s(t.roofColor.caption))]
                                  ),
                                ]
                              ),
                              e(
                                "div",
                                {
                                  staticClass: "dropdown-menu",
                                  attrs: {
                                    "aria-labelledby": "dropdownMenuButton",
                                  },
                                },
                                t._l(t.config.roofColors, function (n) {
                                  return e(
                                    "a",
                                    {
                                      key: "rc" + n.id,
                                      staticClass: "dropdown-item",
                                      on: {
                                        click: function (e) {
                                          return t.setRoofColor(n);
                                        },
                                      },
                                    },
                                    [
                                      e("span", {
                                        staticClass: "color-item__color",
                                        style: { "background-color": n.color },
                                      }),
                                      e(
                                        "span",
                                        { staticClass: "color-item__caption" },
                                        [t._v(t._s(n.caption))]
                                      ),
                                    ]
                                  );
                                }),
                                0
                              ),
                            ]),
                          ]),
                          e("div", { staticClass: "row" }, [
                            e("div", { staticClass: "col-12 col-sm-12" }, [
                              e("div", { staticClass: "form-group" }, [
                                e("label", [t._v("Ð¦Ð²ÐµÑ Ð¼ÐµÑÐ°Ð»Ð»Ð¾ÐºÐ¾Ð½ÑÑÑÑÐºÑÐ¸Ð¸")]),
                                e("div", { staticClass: "dropdown" }, [
                                  e(
                                    "button",
                                    {
                                      staticClass:
                                        "btn btn-default dropdown-toggle",
                                      attrs: {
                                        type: "button",
                                        id: "dropdownMenuButton",
                                        "data-toggle": "dropdown",
                                        "aria-haspopup": "true",
                                        "aria-expanded": "false",
                                      },
                                    },
                                    [
                                      e("span", {
                                        staticClass: "color-item__color",
                                        style: {
                                          "background-color":
                                            t.frameColor.color,
                                        },
                                      }),
                                      e(
                                        "span",
                                        { staticClass: "color-item__caption" },
                                        [t._v(t._s(t.frameColor.caption))]
                                      ),
                                    ]
                                  ),
                                  e(
                                    "div",
                                    {
                                      staticClass: "dropdown-menu",
                                      attrs: {
                                        "aria-labelledby": "dropdownMenuButton",
                                      },
                                    },
                                    t._l(t.config.frameColors, function (n) {
                                      return e(
                                        "a",
                                        {
                                          key: "frc" + n.id,
                                          staticClass: "dropdown-item",
                                          on: {
                                            click: function (e) {
                                              return t.setframeColor(n);
                                            },
                                          },
                                        },
                                        [
                                          e("span", {
                                            staticClass: "color-item__color",
                                            style: {
                                              "background-color": n.color,
                                            },
                                          }),
                                          e(
                                            "span",
                                            {
                                              staticClass:
                                                "color-item__caption",
                                            },
                                            [t._v(t._s(n.caption))]
                                          ),
                                        ]
                                      );
                                    }),
                                    0
                                  ),
                                ]),
                              ]),
                            ]),
                          ]),
                          e("div", { staticClass: "row" }, [
                            e("div", { staticClass: "col-12 col-sm-12" }, [
                              e("label", [t._v("ÐÑÐ°ÑÐºÐ°")]),
                              e("div", { staticClass: "dropdown" }, [
                                e(
                                  "button",
                                  {
                                    staticClass:
                                      "btn btn-default dropdown-toggle",
                                    attrs: {
                                      type: "button",
                                      "data-toggle": "dropdown",
                                      "aria-haspopup": "true",
                                      "aria-expanded": "false",
                                    },
                                  },
                                  [
                                    e(
                                      "span",
                                      { staticClass: "text-item__caption" },
                                      [t._v(t._s(t.paintingType.caption))]
                                    ),
                                  ]
                                ),
                                e(
                                  "div",
                                  {
                                    staticClass: "dropdown-menu",
                                    attrs: {
                                      "aria-labelledby": "dropdownMenuButton",
                                    },
                                  },
                                  t._l(t.config.paintingTypes, function (n) {
                                    return e(
                                      "a",
                                      {
                                        key: "pt" + n.id,
                                        staticClass: "dropdown-item",
                                        on: {
                                          click: function (e) {
                                            return t.setPaintingType(n);
                                          },
                                        },
                                      },
                                      [
                                        e(
                                          "span",
                                          { staticClass: "text-item__caption" },
                                          [t._v(t._s(n.caption))]
                                        ),
                                      ]
                                    );
                                  }),
                                  0
                                ),
                              ]),
                            ]),
                          ]),
                          e("div", { staticClass: "row" }, [
                            e("div", { staticClass: "col-12 col-lg-12" }, [
                              e("div", { staticClass: "form-group" }, [
                                e("label", [t._v("ÐÐ¾Ð½ÑÐ°Ð¶")]),
                                e("div", { staticClass: "dropdown" }, [
                                  e(
                                    "button",
                                    {
                                      staticClass:
                                        "btn btn-default dropdown-toggle",
                                      attrs: {
                                        type: "button",
                                        id: "dropdownMenuButton",
                                        "data-toggle": "dropdown",
                                        "aria-haspopup": "true",
                                        "aria-expanded": "false",
                                      },
                                    },
                                    [
                                      e(
                                        "span",
                                        { staticClass: "color-item__caption" },
                                        [t._v(t._s(t.installationType.caption))]
                                      ),
                                    ]
                                  ),
                                  e(
                                    "div",
                                    {
                                      staticClass: "dropdown-menu",
                                      attrs: {
                                        "aria-labelledby": "dropdownMenuButton",
                                      },
                                    },
                                    t._l(
                                      t.config.installationTypes,
                                      function (n) {
                                        return e(
                                          "div",
                                          {
                                            key: "it" + n.id,
                                            staticClass: "dropdown-item",
                                            on: {
                                              click: function (e) {
                                                return t.setInstallationType(
                                                  e,
                                                  n
                                                );
                                              },
                                            },
                                          },
                                          [
                                            e(
                                              "span",
                                              {
                                                staticClass:
                                                  "color-item__caption",
                                              },
                                              [t._v(t._s(n.caption))]
                                            ),
                                          ]
                                        );
                                      }
                                    ),
                                    0
                                  ),
                                ]),
                              ]),
                            ]),
                          ]),
                          2 == t.installationType.id
                            ? e("div", { staticClass: "row" }, [
                                e("div", { staticClass: "col-12" }, [
                                  e("div", { staticClass: "form-group" }, [
                                    e(
                                      "label",
                                      { attrs: { for: "concreateDepthRange" } },
                                      [t._v("ÐÐ»ÑÐ±Ð¸Ð½Ð° Ð±ÐµÑÐ¾Ð½Ð¸ÑÐ¾Ð²Ð°Ð½Ð¸Ñ, Ð¼ ")]
                                    ),
                                    e("input", {
                                      directives: [
                                        {
                                          name: "model",
                                          rawName: "v-model.number",
                                          value: t.concreteDepth,
                                          expression: "concreteDepth",
                                          modifiers: { number: !0 },
                                        },
                                      ],
                                      staticClass: "form-control",
                                      attrs: {
                                        type: "number",
                                        step: t.config.concreteDepthStep,
                                        min: t.config.concreteMinDepth,
                                        max: t.config.concreteMaxDepth,
                                      },
                                      domProps: { value: t.concreteDepth },
                                      on: {
                                        change: function (e) {
                                          return t.render();
                                        },
                                        input: function (e) {
                                          e.target.composing ||
                                            (t.concreteDepth = t._n(
                                              e.target.value
                                            ));
                                        },
                                        blur: function (e) {
                                          return t.$forceUpdate();
                                        },
                                      },
                                    }),
                                    e("input", {
                                      directives: [
                                        {
                                          name: "model",
                                          rawName: "v-model",
                                          value: t.concreteDepth,
                                          expression: "concreteDepth",
                                        },
                                      ],
                                      staticClass:
                                        "form-control-range sticky-range custom-range",
                                      attrs: {
                                        type: "range",
                                        id: "concreateDepthRange",
                                        step: t.config.concreteDepthStep,
                                        min: t.config.concreteMinDepth,
                                        max: t.config.concreteMaxDepth,
                                      },
                                      domProps: { value: t.concreteDepth },
                                      on: {
                                        change: function (e) {
                                          return t.render();
                                        },
                                        __r: function (e) {
                                          t.concreteDepth = e.target.value;
                                        },
                                      },
                                    }),
                                  ]),
                                ]),
                              ])
                            : t._e(),
                          e("div", { staticClass: "row" }, [
                            e("div", { staticClass: "col-12 col-lg-6" }, [
                              e("div", { staticClass: "form-group" }, [
                                e("div", { staticClass: "form-check" }, [
                                  e("input", {
                                    directives: [
                                      {
                                        name: "model",
                                        rawName: "v-model",
                                        value: t.useDelivery,
                                        expression: "useDelivery",
                                      },
                                    ],
                                    staticClass: "form-check-input",
                                    attrs: {
                                      type: "checkbox",
                                      id: "deliveryCheckbox",
                                    },
                                    domProps: {
                                      checked: Array.isArray(t.useDelivery)
                                        ? t._i(t.useDelivery, null) > -1
                                        : t.useDelivery,
                                    },
                                    on: {
                                      change: [
                                        function (e) {
                                          var n = t.useDelivery,
                                            i = e.target,
                                            r = !!i.checked;
                                          if (Array.isArray(n)) {
                                            var a = null,
                                              o = t._i(n, a);
                                            i.checked
                                              ? o < 0 &&
                                                (t.useDelivery = n.concat([a]))
                                              : o > -1 &&
                                                (t.useDelivery = n
                                                  .slice(0, o)
                                                  .concat(n.slice(o + 1)));
                                          } else t.useDelivery = r;
                                        },
                                        function (e) {
                                          return t.render();
                                        },
                                      ],
                                    },
                                  }),
                                  e(
                                    "label",
                                    {
                                      staticClass: "form-check-label",
                                      attrs: { for: "deliveryCheckbox" },
                                    },
                                    [t._v(" ÐÐ¾ÑÑÐ°Ð²ÐºÐ° ")]
                                  ),
                                ]),
                              ]),
                            ]),
                          ]),
                          t.useDelivery
                            ? e("div", { staticClass: "row" }, [
                                e("div", { staticClass: "col-12 col-lg-6" }, [
                                  e("div", { staticClass: "form-group" }, [
                                    e(
                                      "label",
                                      { attrs: { for: "formControlRange" } },
                                      [t._v("Ð Ð°ÑÑÑÐ¾ÑÐ½Ð¸Ðµ Ð¾Ñ ÐÐÐÐ, ÐºÐ¼ ")]
                                    ),
                                    e("input", {
                                      directives: [
                                        {
                                          name: "model",
                                          rawName: "v-model.number",
                                          value: t.distance,
                                          expression: "distance",
                                          modifiers: { number: !0 },
                                        },
                                      ],
                                      staticClass: "form-control",
                                      attrs: {
                                        type: "number",
                                        step: t.config.distanceStep,
                                        min: t.config.distanceMin,
                                        max: t.config.distanceMax,
                                      },
                                      domProps: { value: t.distance },
                                      on: {
                                        change: function (e) {
                                          return t.render();
                                        },
                                        input: function (e) {
                                          e.target.composing ||
                                            (t.distance = t._n(e.target.value));
                                        },
                                        blur: function (e) {
                                          return t.$forceUpdate();
                                        },
                                      },
                                    }),
                                    e("input", {
                                      directives: [
                                        {
                                          name: "model",
                                          rawName: "v-model",
                                          value: t.distance,
                                          expression: "distance",
                                        },
                                      ],
                                      staticClass:
                                        "form-control-range sticky-range custom-range",
                                      attrs: {
                                        type: "range",
                                        step: t.config.distanceStep,
                                        id: "formControlRange",
                                        min: t.config.distanceMin,
                                        max: t.config.distanceMax,
                                      },
                                      domProps: { value: t.distance },
                                      on: {
                                        change: function (e) {
                                          return t.render();
                                        },
                                        __r: function (e) {
                                          t.distance = e.target.value;
                                        },
                                      },
                                    }),
                                  ]),
                                ]),
                              ])
                            : t._e(),
                          e("div", { class: { dropup: t.extraParamsOpened } }, [
                            e(
                              "div",
                              {
                                staticClass: "h3 dropdown-toggle",
                                attrs: {
                                  type: "button",
                                  "data-toggle": "collapse",
                                  "data-target": "#extraParams",
                                  "aria-expanded": "false",
                                  "aria-controls": "extraParams",
                                },
                                on: {
                                  click: function (e) {
                                    t.extraParamsOpened = !t.extraParamsOpened;
                                  },
                                },
                              },
                              [t._v(" ÐÐ¾Ð¿Ð¾Ð»Ð½Ð¸ÑÐµÐ»ÑÐ½ÑÐµ Ð¿Ð°ÑÐ°Ð¼ÐµÑÑÑ ")]
                            ),
                          ]),
                          e(
                            "div",
                            {
                              staticClass: "collapse",
                              attrs: { id: "extraParams" },
                            },
                            [
                              e("div", { staticClass: "h3" }, [t._v("Ð¤ÐµÑÐ¼Ñ")]),
                              e(
                                "div",
                                { staticClass: "row" },
                                [
                                  5 != t.farmTypeLocal.id
                                    ? [
                                        e(
                                          "div",
                                          { staticClass: "col-12 col-lg-6" },
                                          [
                                            e(
                                              "div",
                                              { staticClass: "form-group" },
                                              [
                                                e("label", [
                                                  t._v("Ð¢Ð¾Ð»ÑÐ¸Ð½Ð° ÑÐ°Ð¼Ñ "),
                                                ]),
                                                e(
                                                  "div",
                                                  { staticClass: "dropdown" },
                                                  [
                                                    e(
                                                      "button",
                                                      {
                                                        staticClass:
                                                          "btn btn-default dropdown-toggle",
                                                        attrs: {
                                                          type: "button",
                                                          "data-toggle":
                                                            "dropdown",
                                                          "aria-haspopup":
                                                            "true",
                                                          "aria-expanded":
                                                            "false",
                                                        },
                                                      },
                                                      [
                                                        e(
                                                          "span",
                                                          {
                                                            staticClass:
                                                              "text-item__caption",
                                                          },
                                                          [
                                                            t._v(
                                                              t._s(
                                                                t.frameSize
                                                                  .shortCaption
                                                              )
                                                            ),
                                                          ]
                                                        ),
                                                      ]
                                                    ),
                                                    e(
                                                      "div",
                                                      {
                                                        staticClass:
                                                          "dropdown-menu",
                                                        attrs: {
                                                          "aria-labelledby":
                                                            "dropdownMenuButton",
                                                        },
                                                      },
                                                      [
                                                        t._l(
                                                          t.config.farmSizes,
                                                          function (n) {
                                                            return [
                                                              e(
                                                                "div",
                                                                {
                                                                  key:
                                                                    "farmSizeGroup" +
                                                                    n.id,
                                                                  staticClass:
                                                                    "dropdown-item pl-2 group disabled",
                                                                },
                                                                [
                                                                  t._v(
                                                                    " " +
                                                                      t._s(
                                                                        n.caption
                                                                      ) +
                                                                      " "
                                                                  ),
                                                                ]
                                                              ),
                                                              t._l(
                                                                n.sizes,
                                                                function (n) {
                                                                  return e(
                                                                    "a",
                                                                    {
                                                                      key:
                                                                        "farmSizeGroupSize" +
                                                                        n.id,
                                                                      staticClass:
                                                                        "dropdown-item",
                                                                      on: {
                                                                        click:
                                                                          function (
                                                                            e
                                                                          ) {
                                                                            return t.setFrameSize(
                                                                              n
                                                                            );
                                                                          },
                                                                      },
                                                                    },
                                                                    [
                                                                      e(
                                                                        "span",
                                                                        {
                                                                          staticClass:
                                                                            "text-item__caption",
                                                                        },
                                                                        [
                                                                          t._v(
                                                                            t._s(
                                                                              n.shortCaption
                                                                            )
                                                                          ),
                                                                        ]
                                                                      ),
                                                                    ]
                                                                  );
                                                                }
                                                              ),
                                                            ];
                                                          }
                                                        ),
                                                      ],
                                                      2
                                                    ),
                                                  ]
                                                ),
                                              ]
                                            ),
                                          ]
                                        ),
                                        e(
                                          "div",
                                          { staticClass: "col-12 col-lg-6" },
                                          [
                                            e(
                                              "div",
                                              { staticClass: "form-group" },
                                              [
                                                e("label", [
                                                  t._v("Ð¢Ð¾Ð»ÑÐ¸Ð½Ð° ÑÐµÐ±ÐµÑ "),
                                                ]),
                                                e(
                                                  "div",
                                                  { staticClass: "dropdown" },
                                                  [
                                                    e(
                                                      "button",
                                                      {
                                                        staticClass:
                                                          "btn btn-default dropdown-toggle",
                                                        attrs: {
                                                          type: "button",
                                                          "data-toggle":
                                                            "dropdown",
                                                          "aria-haspopup":
                                                            "true",
                                                          "aria-expanded":
                                                            "false",
                                                        },
                                                      },
                                                      [
                                                        e(
                                                          "span",
                                                          {
                                                            staticClass:
                                                              "text-item__caption",
                                                          },
                                                          [
                                                            t._v(
                                                              t._s(
                                                                t.ribSize
                                                                  .shortCaption
                                                              )
                                                            ),
                                                          ]
                                                        ),
                                                      ]
                                                    ),
                                                    e(
                                                      "div",
                                                      {
                                                        staticClass:
                                                          "dropdown-menu",
                                                        attrs: {
                                                          "aria-labelledby":
                                                            "dropdownMenuButton",
                                                        },
                                                      },
                                                      [
                                                        t._l(
                                                          t.config.farmSizes,
                                                          function (n) {
                                                            return [
                                                              e(
                                                                "div",
                                                                {
                                                                  key:
                                                                    "rg" + n.id,
                                                                  staticClass:
                                                                    "dropdown-item pl-2 group disabled",
                                                                },
                                                                [
                                                                  t._v(
                                                                    " " +
                                                                      t._s(
                                                                        n.caption
                                                                      ) +
                                                                      " "
                                                                  ),
                                                                ]
                                                              ),
                                                              t._l(
                                                                n.sizes,
                                                                function (n) {
                                                                  return e(
                                                                    "a",
                                                                    {
                                                                      key:
                                                                        "rzgr" +
                                                                        n.id,
                                                                      staticClass:
                                                                        "dropdown-item",
                                                                      on: {
                                                                        click:
                                                                          function (
                                                                            e
                                                                          ) {
                                                                            return t.setRibSize(
                                                                              n
                                                                            );
                                                                          },
                                                                      },
                                                                    },
                                                                    [
                                                                      e(
                                                                        "span",
                                                                        {
                                                                          staticClass:
                                                                            "text-item__caption",
                                                                        },
                                                                        [
                                                                          t._v(
                                                                            t._s(
                                                                              n.shortCaption
                                                                            )
                                                                          ),
                                                                        ]
                                                                      ),
                                                                    ]
                                                                  );
                                                                }
                                                              ),
                                                            ];
                                                          }
                                                        ),
                                                      ],
                                                      2
                                                    ),
                                                  ]
                                                ),
                                              ]
                                            ),
                                          ]
                                        ),
                                      ]
                                    : t._e(),
                                  5 == t.farmTypeLocal.id
                                    ? [
                                        e(
                                          "div",
                                          { staticClass: "col-12 col-lg-6" },
                                          [
                                            e(
                                              "div",
                                              { staticClass: "form-group" },
                                              [
                                                e("label", [
                                                  t._v(" Ð Ð°Ð·Ð¼ÐµÑ ÑÐ²ÐµÐ»Ð»ÐµÑÐ° "),
                                                ]),
                                                e(
                                                  "div",
                                                  { staticClass: "dropdown" },
                                                  [
                                                    e(
                                                      "button",
                                                      {
                                                        staticClass:
                                                          "btn btn-default dropdown-toggle",
                                                        attrs: {
                                                          type: "button",
                                                          "data-toggle":
                                                            "dropdown",
                                                          "aria-haspopup":
                                                            "true",
                                                          "aria-expanded":
                                                            "false",
                                                        },
                                                      },
                                                      [
                                                        e(
                                                          "span",
                                                          {
                                                            staticClass:
                                                              "text-item__caption",
                                                          },
                                                          [
                                                            t._v(
                                                              t._s(
                                                                t.channelSize
                                                                  .caption
                                                              )
                                                            ),
                                                          ]
                                                        ),
                                                      ]
                                                    ),
                                                    e(
                                                      "div",
                                                      {
                                                        staticClass:
                                                          "dropdown-menu",
                                                        attrs: {
                                                          "aria-labelledby":
                                                            "dropdownMenuButton",
                                                        },
                                                      },
                                                      [
                                                        t._l(
                                                          t.config.channelSizes,
                                                          function (n) {
                                                            return [
                                                              e(
                                                                "a",
                                                                {
                                                                  key:
                                                                    "channelSize" +
                                                                    n.id,
                                                                  staticClass:
                                                                    "dropdown-item",
                                                                  on: {
                                                                    click:
                                                                      function (
                                                                        e
                                                                      ) {
                                                                        return t.setChannelSize(
                                                                          n
                                                                        );
                                                                      },
                                                                  },
                                                                },
                                                                [
                                                                  e(
                                                                    "span",
                                                                    {
                                                                      staticClass:
                                                                        "text-item__caption",
                                                                    },
                                                                    [
                                                                      t._v(
                                                                        t._s(
                                                                          n.caption
                                                                        )
                                                                      ),
                                                                    ]
                                                                  ),
                                                                ]
                                                              ),
                                                            ];
                                                          }
                                                        ),
                                                      ],
                                                      2
                                                    ),
                                                  ]
                                                ),
                                              ]
                                            ),
                                          ]
                                        ),
                                      ]
                                    : t._e(),
                                  e("div", { staticClass: "col-12 col-lg-6" }, [
                                    e("div", { staticClass: "form-group" }, [
                                      e("label", [t._v("Ð¢Ð¾Ð»ÑÐ¸Ð½Ð° Ð»Ð°Ð³Ð¾Ð² ")]),
                                      e("div", { staticClass: "dropdown" }, [
                                        e(
                                          "button",
                                          {
                                            staticClass:
                                              "btn btn-default dropdown-toggle",
                                            attrs: {
                                              type: "button",
                                              "data-toggle": "dropdown",
                                              "aria-haspopup": "true",
                                              "aria-expanded": "false",
                                            },
                                          },
                                          [
                                            e(
                                              "span",
                                              {
                                                staticClass:
                                                  "text-item__caption",
                                              },
                                              [
                                                t._v(
                                                  t._s(t.tieSize.shortCaption)
                                                ),
                                              ]
                                            ),
                                          ]
                                        ),
                                        e(
                                          "div",
                                          {
                                            staticClass: "dropdown-menu",
                                            attrs: {
                                              "aria-labelledby":
                                                "dropdownMenuButton",
                                            },
                                          },
                                          [
                                            t._l(
                                              t.config.farmSizes,
                                              function (n) {
                                                return [
                                                  e(
                                                    "div",
                                                    {
                                                      key: "tg" + n.id,
                                                      staticClass:
                                                        "dropdown-item pl-2 group disabled",
                                                    },
                                                    [
                                                      t._v(
                                                        " " +
                                                          t._s(n.caption) +
                                                          " "
                                                      ),
                                                    ]
                                                  ),
                                                  t._l(n.sizes, function (n) {
                                                    return e(
                                                      "a",
                                                      {
                                                        key: "tzgr" + n.id,
                                                        staticClass:
                                                          "dropdown-item",
                                                        on: {
                                                          click: function (e) {
                                                            return t.setTieSize(
                                                              n
                                                            );
                                                          },
                                                        },
                                                      },
                                                      [
                                                        e(
                                                          "span",
                                                          {
                                                            staticClass:
                                                              "text-item__caption",
                                                          },
                                                          [
                                                            t._v(
                                                              t._s(
                                                                n.shortCaption
                                                              )
                                                            ),
                                                          ]
                                                        ),
                                                      ]
                                                    );
                                                  }),
                                                ];
                                              }
                                            ),
                                          ],
                                          2
                                        ),
                                      ]),
                                    ]),
                                  ]),
                                ],
                                2
                              ),
                              e("div", { staticClass: "row" }, [
                                [1, 8, 10].includes(t.farmTypeLocal.id)
                                  ? e(
                                      "div",
                                      { staticClass: "col-12 col-lg-6" },
                                      [
                                        e(
                                          "div",
                                          { staticClass: "form-group" },
                                          [
                                            e(
                                              "label",
                                              {
                                                attrs: {
                                                  for: "formControlRange",
                                                },
                                              },
                                              [t._v("ÐÑÐ³Ð½ÑÑÐ¾ÑÑÑ Ð°ÑÐºÐ¸ ")]
                                            ),
                                            e("input", {
                                              directives: [
                                                {
                                                  name: "model",
                                                  rawName: "v-model.number",
                                                  value: t.arcCurveRatio,
                                                  expression: "arcCurveRatio",
                                                  modifiers: { number: !0 },
                                                },
                                              ],
                                              staticClass: "form-control",
                                              attrs: {
                                                type: "number",
                                                step: t.config
                                                  .arcCurveRatioStep,
                                                min: t.config.arcCurveRatioMin,
                                                max: t.config.arcCurveRatioMax,
                                              },
                                              domProps: {
                                                value: t.arcCurveRatio,
                                              },
                                              on: {
                                                change: function (e) {
                                                  return t.render();
                                                },
                                                input: function (e) {
                                                  e.target.composing ||
                                                    (t.arcCurveRatio = t._n(
                                                      e.target.value
                                                    ));
                                                },
                                                blur: function (e) {
                                                  return t.$forceUpdate();
                                                },
                                              },
                                            }),
                                            e("input", {
                                              directives: [
                                                {
                                                  name: "model",
                                                  rawName: "v-model",
                                                  value: t.arcCurveRatio,
                                                  expression: "arcCurveRatio",
                                                },
                                              ],
                                              staticClass:
                                                "form-control-range sticky-range custom-range",
                                              attrs: {
                                                type: "range",
                                                id: "formControlRange",
                                                step: t.config
                                                  .arcCurveRatioStep,
                                                min: t.config.arcCurveRatioMin,
                                                max: t.config.arcCurveRatioMax,
                                              },
                                              domProps: {
                                                value: t.arcCurveRatio,
                                              },
                                              on: {
                                                change: function (e) {
                                                  return t.render();
                                                },
                                                __r: function (e) {
                                                  t.arcCurveRatio =
                                                    e.target.value;
                                                },
                                              },
                                            }),
                                          ]
                                        ),
                                      ]
                                    )
                                  : t._e(),
                                [1, 2, 3].includes(t.farmTypeLocal.id) &&
                                t.lathingType.id != t.LathingType.flat
                                  ? e(
                                      "div",
                                      { staticClass: "col-12 col-lg-6" },
                                      [
                                        e(
                                          "div",
                                          { staticClass: "form-group" },
                                          [
                                            e(
                                              "label",
                                              {
                                                attrs: {
                                                  for: "formControlRange",
                                                },
                                              },
                                              [t._v("ÐÑÑÐ¾ÑÐ° ÑÐµÑÐ¼Ñ, Ð¼Ð¼ ")]
                                            ),
                                            e("input", {
                                              directives: [
                                                {
                                                  name: "model",
                                                  rawName: "v-model.number",
                                                  value: t.farmWidth,
                                                  expression: "farmWidth",
                                                  modifiers: { number: !0 },
                                                },
                                              ],
                                              staticClass: "form-control",
                                              attrs: {
                                                type: "number",
                                                step: t.config.farmWidthStep,
                                                min: t.config.farmWidthMin,
                                                max: t.config.farmWidthMax,
                                              },
                                              domProps: { value: t.farmWidth },
                                              on: {
                                                change: function (e) {
                                                  return t.render();
                                                },
                                                input: function (e) {
                                                  e.target.composing ||
                                                    (t.farmWidth = t._n(
                                                      e.target.value
                                                    ));
                                                },
                                                blur: function (e) {
                                                  return t.$forceUpdate();
                                                },
                                              },
                                            }),
                                            e("input", {
                                              directives: [
                                                {
                                                  name: "model",
                                                  rawName: "v-model",
                                                  value: t.farmWidth,
                                                  expression: "farmWidth",
                                                },
                                              ],
                                              staticClass:
                                                "form-control-range sticky-range custom-range",
                                              attrs: {
                                                type: "range",
                                                id: "formControlRange",
                                                step: t.config.farmWidthStep,
                                                min: t.config.farmWidthMin,
                                                max: t.config.farmWidthMax,
                                              },
                                              domProps: { value: t.farmWidth },
                                              on: {
                                                change: function (e) {
                                                  return t.render();
                                                },
                                                __r: function (e) {
                                                  t.farmWidth = e.target.value;
                                                },
                                              },
                                            }),
                                          ]
                                        ),
                                      ]
                                    )
                                  : t._e(),
                                [1, 2, 3].includes(t.farmTypeLocal.id) &&
                                t.lathingType.id == t.LathingType.flat
                                  ? e(
                                      "div",
                                      { staticClass: "col-12 col-lg-6" },
                                      [
                                        e(
                                          "div",
                                          { staticClass: "form-group" },
                                          [
                                            e(
                                              "label",
                                              {
                                                attrs: {
                                                  for: "formControlRange",
                                                },
                                              },
                                              [t._v("Ð¢Ð¾Ð»ÑÐ¸Ð½Ð° ÑÐµÑÐ¼Ñ ÑÑ ")]
                                            ),
                                            e("input", {
                                              directives: [
                                                {
                                                  name: "model",
                                                  rawName: "v-model.number",
                                                  value: t.flatProfileCount,
                                                  expression:
                                                    "flatProfileCount",
                                                  modifiers: { number: !0 },
                                                },
                                              ],
                                              staticClass: "form-control",
                                              attrs: {
                                                type: "number",
                                                step: 1,
                                                min: 1,
                                                max: 3,
                                              },
                                              domProps: {
                                                value: t.flatProfileCount,
                                              },
                                              on: {
                                                change: function (e) {
                                                  return t.render();
                                                },
                                                input: function (e) {
                                                  e.target.composing ||
                                                    (t.flatProfileCount = t._n(
                                                      e.target.value
                                                    ));
                                                },
                                                blur: function (e) {
                                                  return t.$forceUpdate();
                                                },
                                              },
                                            }),
                                            e("input", {
                                              directives: [
                                                {
                                                  name: "model",
                                                  rawName: "v-model",
                                                  value: t.flatProfileCount,
                                                  expression:
                                                    "flatProfileCount",
                                                },
                                              ],
                                              staticClass:
                                                "form-control-range sticky-range custom-range",
                                              attrs: {
                                                type: "range",
                                                id: "formControlRange",
                                                step: 1,
                                                min: 1,
                                                max: 3,
                                              },
                                              domProps: {
                                                value: t.flatProfileCount,
                                              },
                                              on: {
                                                change: function (e) {
                                                  return t.render();
                                                },
                                                __r: function (e) {
                                                  t.flatProfileCount =
                                                    e.target.value;
                                                },
                                              },
                                            }),
                                          ]
                                        ),
                                      ]
                                    )
                                  : t._e(),
                                e("div", { staticClass: "col-12 col-lg-6" }, [
                                  e("div", { staticClass: "form-group" }, [
                                    e(
                                      "label",
                                      { attrs: { for: "farmMargin" } },
                                      [t._v("ÐÑÐ¿ÑÑÐºÐ¸ ÑÐµÑÐ¼Ñ, Ð¼Ð¼ ")]
                                    ),
                                    e("input", {
                                      directives: [
                                        {
                                          name: "model",
                                          rawName: "v-model.number",
                                          value: t.farmMargin,
                                          expression: "farmMargin",
                                          modifiers: { number: !0 },
                                        },
                                      ],
                                      staticClass: "form-control",
                                      attrs: {
                                        id: "farmMargin",
                                        type: "number",
                                        step: t.config.farmMarginStep,
                                        min: t.config.farmMarginMin,
                                        max: [6, 7].includes(t.farmTypeLocal.id)
                                          ? 1e3
                                          : t.farmWidth,
                                      },
                                      domProps: { value: t.farmMargin },
                                      on: {
                                        change: function (e) {
                                          return t.render();
                                        },
                                        input: function (e) {
                                          e.target.composing ||
                                            (t.farmMargin = t._n(
                                              e.target.value
                                            ));
                                        },
                                        blur: function (e) {
                                          return t.$forceUpdate();
                                        },
                                      },
                                    }),
                                    e("input", {
                                      directives: [
                                        {
                                          name: "model",
                                          rawName: "v-model",
                                          value: t.farmMargin,
                                          expression: "farmMargin",
                                        },
                                      ],
                                      staticClass:
                                        "form-control-range sticky-range custom-range",
                                      attrs: {
                                        type: "range",
                                        step: t.config.farmMarginStep,
                                        min: t.config.farmMarginMin,
                                        max: [6, 7].includes(t.farmTypeLocal.id)
                                          ? 1e3
                                          : t.farmWidth,
                                      },
                                      domProps: { value: t.farmMargin },
                                      on: {
                                        change: function (e) {
                                          return t.render();
                                        },
                                        __r: function (e) {
                                          t.farmMargin = e.target.value;
                                        },
                                      },
                                    }),
                                  ]),
                                ]),
                              ]),
                              e("div", { staticClass: "row" }, [
                                e("div", { staticClass: "col-12 col-lg-6" }, [
                                  e("div", { staticClass: "form-group" }, [
                                    e(
                                      "label",
                                      { attrs: { for: "farmMargin" } },
                                      [t._v("ÐÑÑÑÑÐ¿ ÑÐµÑÐ¼Ñ ÑÐ¿ÐµÑÐµÐ´Ð¸, Ð¼Ð¼ ")]
                                    ),
                                    e("input", {
                                      directives: [
                                        {
                                          name: "model",
                                          rawName: "v-model.number",
                                          value: t.farmMarginFrontWidth,
                                          expression: "farmMarginFrontWidth",
                                          modifiers: { number: !0 },
                                        },
                                      ],
                                      staticClass: "form-control",
                                      attrs: {
                                        id: "farmMargin",
                                        type: "number",
                                        step: t.config.farmMarginWidthStep,
                                        min: t.config.farmMarginWidthMin,
                                        max: t.config.farmMarginWidthMax,
                                      },
                                      domProps: {
                                        value: t.farmMarginFrontWidth,
                                      },
                                      on: {
                                        change: function (e) {
                                          return t.render();
                                        },
                                        input: function (e) {
                                          e.target.composing ||
                                            (t.farmMarginFrontWidth = t._n(
                                              e.target.value
                                            ));
                                        },
                                        blur: function (e) {
                                          return t.$forceUpdate();
                                        },
                                      },
                                    }),
                                    e("input", {
                                      directives: [
                                        {
                                          name: "model",
                                          rawName: "v-model",
                                          value: t.farmMarginFrontWidth,
                                          expression: "farmMarginFrontWidth",
                                        },
                                      ],
                                      staticClass:
                                        "form-control-range sticky-range custom-range",
                                      attrs: {
                                        type: "range",
                                        step: t.config.farmMarginWidthStep,
                                        min: t.config.farmMarginWidthMin,
                                        max: t.config.farmMarginWidthMax,
                                      },
                                      domProps: {
                                        value: t.farmMarginFrontWidth,
                                      },
                                      on: {
                                        change: function (e) {
                                          return t.render();
                                        },
                                        __r: function (e) {
                                          t.farmMarginFrontWidth =
                                            e.target.value;
                                        },
                                      },
                                    }),
                                  ]),
                                ]),
                                e("div", { staticClass: "col-12 col-lg-6" }, [
                                  e("div", { staticClass: "form-group" }, [
                                    e(
                                      "label",
                                      { attrs: { for: "farmMargin" } },
                                      [t._v("ÐÑÑÑÑÐ¿ ÑÐµÑÐ¼Ñ cÐ·Ð°Ð´Ð¸, Ð¼Ð¼ ")]
                                    ),
                                    e("input", {
                                      directives: [
                                        {
                                          name: "model",
                                          rawName: "v-model.number",
                                          value: t.farmMarginBackWidth,
                                          expression: "farmMarginBackWidth",
                                          modifiers: { number: !0 },
                                        },
                                      ],
                                      staticClass: "form-control",
                                      attrs: {
                                        id: "farmMargin",
                                        type: "number",
                                        step: t.config.farmMarginWidthStep,
                                        min: t.config.farmMarginWidthMin,
                                        max: t.config.farmMarginWidthMax,
                                      },
                                      domProps: {
                                        value: t.farmMarginBackWidth,
                                      },
                                      on: {
                                        change: function (e) {
                                          return t.render();
                                        },
                                        input: function (e) {
                                          e.target.composing ||
                                            (t.farmMarginBackWidth = t._n(
                                              e.target.value
                                            ));
                                        },
                                        blur: function (e) {
                                          return t.$forceUpdate();
                                        },
                                      },
                                    }),
                                    e("input", {
                                      directives: [
                                        {
                                          name: "model",
                                          rawName: "v-model",
                                          value: t.farmMarginBackWidth,
                                          expression: "farmMarginBackWidth",
                                        },
                                      ],
                                      staticClass:
                                        "form-control-range sticky-range custom-range",
                                      attrs: {
                                        type: "range",
                                        step: t.config.farmMarginWidthStep,
                                        min: t.config.farmMarginWidthMin,
                                        max: t.config.farmMarginWidthMax,
                                      },
                                      domProps: {
                                        value: t.farmMarginBackWidth,
                                      },
                                      on: {
                                        change: function (e) {
                                          return t.render();
                                        },
                                        __r: function (e) {
                                          t.farmMarginBackWidth =
                                            e.target.value;
                                        },
                                      },
                                    }),
                                  ]),
                                ]),
                              ]),
                              e("div", { staticClass: "row" }, [
                                e("div", { staticClass: "col-12 col-lg-6" }, [
                                  e("div", { staticClass: "form-group" }, [
                                    e(
                                      "label",
                                      { attrs: { for: "formControlRange" } },
                                      [t._v("Ð¨Ð°Ð³ Ð»Ð°Ð³Ð¾Ð², Ð¼Ð¼ ")]
                                    ),
                                    e("input", {
                                      directives: [
                                        {
                                          name: "model",
                                          rawName: "v-model.number",
                                          value: t.tieStepWidth,
                                          expression: "tieStepWidth",
                                          modifiers: { number: !0 },
                                        },
                                      ],
                                      staticClass: "form-control",
                                      attrs: {
                                        type: "number",
                                        step: t.config.tieStepWidthStep,
                                        min: t.config.tieStepWidthMin,
                                        max: t.config.tieStepWidthMax,
                                      },
                                      domProps: { value: t.tieStepWidth },
                                      on: {
                                        change: function (e) {
                                          return t.render();
                                        },
                                        input: function (e) {
                                          e.target.composing ||
                                            (t.tieStepWidth = t._n(
                                              e.target.value
                                            ));
                                        },
                                        blur: function (e) {
                                          return t.$forceUpdate();
                                        },
                                      },
                                    }),
                                    e("input", {
                                      directives: [
                                        {
                                          name: "model",
                                          rawName: "v-model",
                                          value: t.tieStepWidth,
                                          expression: "tieStepWidth",
                                        },
                                      ],
                                      staticClass:
                                        "form-control-range sticky-range custom-range",
                                      attrs: {
                                        type: "range",
                                        id: "formControlRange",
                                        step: t.config.tieStepWidthStep,
                                        min: t.config.tieStepWidthMin,
                                        max: t.config.tieStepWidthMax,
                                      },
                                      domProps: { value: t.tieStepWidth },
                                      on: {
                                        change: function (e) {
                                          return t.render();
                                        },
                                        __r: function (e) {
                                          t.tieStepWidth = e.target.value;
                                        },
                                      },
                                    }),
                                  ]),
                                ]),
                                t.lathingType != t.lathingType.flat &&
                                5 != t.farmTypeLocal.id
                                  ? e(
                                      "div",
                                      { staticClass: "col-12 col-lg-6" },
                                      [
                                        e(
                                          "div",
                                          { staticClass: "form-group" },
                                          [
                                            e(
                                              "label",
                                              {
                                                attrs: {
                                                  for: "formControlRange",
                                                },
                                              },
                                              [t._v("Ð¨Ð°Ð³ Ð¾Ð±ÑÐµÐ±ÑÐ¾Ð²ÐºÐ¸, Ð¼Ð¼ ")]
                                            ),
                                            e("input", {
                                              directives: [
                                                {
                                                  name: "model",
                                                  rawName: "v-model",
                                                  value: t.ribStepWidth,
                                                  expression: "ribStepWidth",
                                                },
                                              ],
                                              staticClass: "form-control",
                                              attrs: { type: "text" },
                                              domProps: {
                                                value: t.ribStepWidth,
                                              },
                                              on: {
                                                change: function (e) {
                                                  return t.render();
                                                },
                                                input: function (e) {
                                                  e.target.composing ||
                                                    (t.ribStepWidth =
                                                      e.target.value);
                                                },
                                              },
                                            }),
                                            e("input", {
                                              directives: [
                                                {
                                                  name: "model",
                                                  rawName: "v-model",
                                                  value: t.ribStepWidth,
                                                  expression: "ribStepWidth",
                                                },
                                              ],
                                              staticClass:
                                                "form-control-range sticky-range custom-range",
                                              attrs: {
                                                type: "range",
                                                step: t.config.ribStepWidthStep,
                                                id: "formControlRange",
                                                min: t.config.ribStepWidthMin,
                                                max: t.config.ribStepWidthMax,
                                              },
                                              domProps: {
                                                value: t.ribStepWidth,
                                              },
                                              on: {
                                                click: function (t) {
                                                  return t.target.blur();
                                                },
                                                change: function (e) {
                                                  return t.render();
                                                },
                                                __r: function (e) {
                                                  t.ribStepWidth =
                                                    e.target.value;
                                                },
                                              },
                                            }),
                                          ]
                                        ),
                                      ]
                                    )
                                  : t._e(),
                                e("div", { staticClass: "col-12 col-lg-6" }, [
                                  e("div", { staticClass: "form-group" }, [
                                    e(
                                      "label",
                                      { attrs: { for: "formControlRange" } },
                                      [t._v("Ð¨Ð°Ð³ ÑÐµÑÐ¼, Ð¼ ")]
                                    ),
                                    e("input", {
                                      directives: [
                                        {
                                          name: "model",
                                          rawName: "v-model.number",
                                          value: t.farmStepWidth,
                                          expression: "farmStepWidth",
                                          modifiers: { number: !0 },
                                        },
                                      ],
                                      staticClass: "form-control",
                                      attrs: {
                                        type: "number",
                                        step: t.config.farmStepWidthStep,
                                        min: t.config.farmStepWidthMin,
                                        max: t.config.farmStepWidthMax,
                                      },
                                      domProps: { value: t.farmStepWidth },
                                      on: {
                                        change: function (e) {
                                          return t.render();
                                        },
                                        input: function (e) {
                                          e.target.composing ||
                                            (t.farmStepWidth = t._n(
                                              e.target.value
                                            ));
                                        },
                                        blur: function (e) {
                                          return t.$forceUpdate();
                                        },
                                      },
                                    }),
                                    e("input", {
                                      directives: [
                                        {
                                          name: "model",
                                          rawName: "v-model",
                                          value: t.farmStepWidth,
                                          expression: "farmStepWidth",
                                        },
                                      ],
                                      staticClass:
                                        "form-control-range sticky-range custom-range",
                                      attrs: {
                                        type: "range",
                                        id: "formControlRange",
                                        step: t.config.farmStepWidthStep,
                                        min: t.config.farmStepWidthMin,
                                        max: t.config.farmStepWidthMax,
                                      },
                                      domProps: { value: t.farmStepWidth },
                                      on: {
                                        change: function (e) {
                                          return t.render();
                                        },
                                        __r: function (e) {
                                          t.farmStepWidth = e.target.value;
                                        },
                                      },
                                    }),
                                  ]),
                                ]),
                              ]),
                              t._m(0),
                              e("div", { staticClass: "row" }, [
                                e("div", { staticClass: "col-12 col-lg-12" }, [
                                  e("div", { staticClass: "form-group" }, [
                                    e("div", { staticClass: "form-check" }, [
                                      e("input", {
                                        directives: [
                                          {
                                            name: "model",
                                            rawName: "v-model",
                                            value: t.hasPillars,
                                            expression: "hasPillars",
                                          },
                                        ],
                                        staticClass: "form-check-input",
                                        attrs: {
                                          type: "checkbox",
                                          id: "hasPillarsCheckbox",
                                        },
                                        domProps: {
                                          checked: Array.isArray(t.hasPillars)
                                            ? t._i(t.hasPillars, null) > -1
                                            : t.hasPillars,
                                        },
                                        on: {
                                          change: [
                                            function (e) {
                                              var n = t.hasPillars,
                                                i = e.target,
                                                r = !!i.checked;
                                              if (Array.isArray(n)) {
                                                var a = null,
                                                  o = t._i(n, a);
                                                i.checked
                                                  ? o < 0 &&
                                                    (t.hasPillars = n.concat([
                                                      a,
                                                    ]))
                                                  : o > -1 &&
                                                    (t.hasPillars = n
                                                      .slice(0, o)
                                                      .concat(n.slice(o + 1)));
                                              } else t.hasPillars = r;
                                            },
                                            function (e) {
                                              return t.render();
                                            },
                                          ],
                                        },
                                      }),
                                      e(
                                        "label",
                                        {
                                          staticClass: "form-check-label",
                                          attrs: { for: "hasPillarsCheckbox" },
                                        },
                                        [t._v(" ÐÑÐ¿Ð¾Ð»ÑÐ·Ð¾Ð²Ð°ÑÑ ÑÑÐ¾Ð»Ð±Ñ ")]
                                      ),
                                    ]),
                                  ]),
                                ]),
                              ]),
                              t.hasPillars
                                ? [
                                    e("div", { staticClass: "row" }, [
                                      e(
                                        "div",
                                        { staticClass: "col-12 col-lg-6" },
                                        [
                                          e(
                                            "div",
                                            { staticClass: "form-group" },
                                            [
                                              e(
                                                "label",
                                                {
                                                  attrs: {
                                                    for: "formControlRange",
                                                  },
                                                },
                                                [t._v("Ð¨Ð°Ð³ ÑÑÐ¾Ð»Ð±Ð¾Ð², Ð¼ ")]
                                              ),
                                              e("input", {
                                                directives: [
                                                  {
                                                    name: "model",
                                                    rawName: "v-model.number",
                                                    value: t.pillarStepWidth,
                                                    expression:
                                                      "pillarStepWidth",
                                                    modifiers: { number: !0 },
                                                  },
                                                ],
                                                staticClass: "form-control",
                                                attrs: {
                                                  type: "number",
                                                  step: t.config
                                                    .pillarStepWidthStep,
                                                  min: t.config
                                                    .pillarStepWidthMin,
                                                  max: t.config
                                                    .pillarStepWidthMax,
                                                },
                                                domProps: {
                                                  value: t.pillarStepWidth,
                                                },
                                                on: {
                                                  change: function (e) {
                                                    return t.render();
                                                  },
                                                  input: function (e) {
                                                    e.target.composing ||
                                                      (t.pillarStepWidth = t._n(
                                                        e.target.value
                                                      ));
                                                  },
                                                  blur: function (e) {
                                                    return t.$forceUpdate();
                                                  },
                                                },
                                              }),
                                              e("input", {
                                                directives: [
                                                  {
                                                    name: "model",
                                                    rawName: "v-model",
                                                    value: t.pillarStepWidth,
                                                    expression:
                                                      "pillarStepWidth",
                                                  },
                                                ],
                                                staticClass:
                                                  "form-control-range sticky-range custom-range",
                                                attrs: {
                                                  type: "range",
                                                  id: "formControlRange",
                                                  step: t.config
                                                    .pillarStepWidthStep,
                                                  min: t.config
                                                    .pillarStepWidthMin,
                                                  max: t.config
                                                    .pillarStepWidthMax,
                                                },
                                                domProps: {
                                                  value: t.pillarStepWidth,
                                                },
                                                on: {
                                                  change: function (e) {
                                                    return t.render();
                                                  },
                                                  __r: function (e) {
                                                    t.pillarStepWidth =
                                                      e.target.value;
                                                  },
                                                },
                                              }),
                                            ]
                                          ),
                                        ]
                                      ),
                                    ]),
                                    e("div", { staticClass: "row" }, [
                                      e(
                                        "div",
                                        { staticClass: "col-12 col-lg-6" },
                                        [
                                          e(
                                            "div",
                                            { staticClass: "form-group" },
                                            [
                                              e(
                                                "label",
                                                {
                                                  attrs: {
                                                    for: "pillarsMarginFront",
                                                  },
                                                },
                                                [t._v("ÐÑÑÑÑÐ¿ ÑÐ¿ÐµÑÐµÐ´Ð¸ ")]
                                              ),
                                              e("input", {
                                                directives: [
                                                  {
                                                    name: "model",
                                                    rawName: "v-model.number",
                                                    value: t.pillarsMarginFront,
                                                    expression:
                                                      "pillarsMarginFront",
                                                    modifiers: { number: !0 },
                                                  },
                                                ],
                                                staticClass: "form-control",
                                                attrs: {
                                                  id: "pillarsMarginFront",
                                                  type: "number",
                                                  step: t.config
                                                    .pillarsMarginStep,
                                                  min: t.config
                                                    .pillarsMarginMin,
                                                  max: t.config
                                                    .pillarsMarginMax,
                                                },
                                                domProps: {
                                                  value: t.pillarsMarginFront,
                                                },
                                                on: {
                                                  change: function (e) {
                                                    return t.render();
                                                  },
                                                  input: function (e) {
                                                    e.target.composing ||
                                                      (t.pillarsMarginFront =
                                                        t._n(e.target.value));
                                                  },
                                                  blur: function (e) {
                                                    return t.$forceUpdate();
                                                  },
                                                },
                                              }),
                                              e("input", {
                                                directives: [
                                                  {
                                                    name: "model",
                                                    rawName: "v-model",
                                                    value: t.pillarsMarginFront,
                                                    expression:
                                                      "pillarsMarginFront",
                                                  },
                                                ],
                                                staticClass:
                                                  "form-control-range sticky-range custom-range",
                                                attrs: {
                                                  type: "range",
                                                  id: "pillarsMarginRange",
                                                  step: t.config
                                                    .pillarsMarginStep,
                                                  min: t.config
                                                    .pillarsMarginMin,
                                                  max: t.config
                                                    .pillarsMarginMax,
                                                },
                                                domProps: {
                                                  value: t.pillarsMarginFront,
                                                },
                                                on: {
                                                  change: function (e) {
                                                    return t.render();
                                                  },
                                                  __r: function (e) {
                                                    t.pillarsMarginFront =
                                                      e.target.value;
                                                  },
                                                },
                                              }),
                                            ]
                                          ),
                                        ]
                                      ),
                                      e(
                                        "div",
                                        { staticClass: "col-12 col-lg-6" },
                                        [
                                          e(
                                            "div",
                                            { staticClass: "form-group" },
                                            [
                                              e(
                                                "label",
                                                {
                                                  attrs: {
                                                    for: "pillarsMarginBack",
                                                  },
                                                },
                                                [t._v("ÐÑÑÑÑÐ¿ ÑÐ·Ð°Ð´Ð¸ ")]
                                              ),
                                              e("input", {
                                                directives: [
                                                  {
                                                    name: "model",
                                                    rawName: "v-model.number",
                                                    value: t.pillarsMarginBack,
                                                    expression:
                                                      "pillarsMarginBack",
                                                    modifiers: { number: !0 },
                                                  },
                                                ],
                                                staticClass: "form-control",
                                                attrs: {
                                                  id: "pillarsMarginBack",
                                                  type: "number",
                                                  step: t.config
                                                    .pillarsMarginStep,
                                                  min: t.config
                                                    .pillarsMarginMin,
                                                  max: t.config
                                                    .pillarsMarginMax,
                                                },
                                                domProps: {
                                                  value: t.pillarsMarginBack,
                                                },
                                                on: {
                                                  change: function (e) {
                                                    return t.render();
                                                  },
                                                  input: function (e) {
                                                    e.target.composing ||
                                                      (t.pillarsMarginBack =
                                                        t._n(e.target.value));
                                                  },
                                                  blur: function (e) {
                                                    return t.$forceUpdate();
                                                  },
                                                },
                                              }),
                                              e("input", {
                                                directives: [
                                                  {
                                                    name: "model",
                                                    rawName: "v-model",
                                                    value: t.pillarsMarginBack,
                                                    expression:
                                                      "pillarsMarginBack",
                                                  },
                                                ],
                                                staticClass:
                                                  "form-control-range sticky-range custom-range",
                                                attrs: {
                                                  type: "range",
                                                  id: "pillarArmingOffsetRange",
                                                  step: t.config
                                                    .pillarsMarginStep,
                                                  min: t.config
                                                    .pillarsMarginMin,
                                                  max: t.config
                                                    .pillarsMarginMax,
                                                },
                                                domProps: {
                                                  value: t.pillarsMarginBack,
                                                },
                                                on: {
                                                  change: function (e) {
                                                    return t.render();
                                                  },
                                                  __r: function (e) {
                                                    t.pillarsMarginBack =
                                                      e.target.value;
                                                  },
                                                },
                                              }),
                                            ]
                                          ),
                                        ]
                                      ),
                                    ]),
                                    e(
                                      "div",
                                      { staticClass: "row" },
                                      [
                                        e(
                                          "div",
                                          { staticClass: "col-12 col-lg-12" },
                                          [
                                            e("div", { staticClass: "h3" }, [
                                              t._v("ÐÑÐ¼Ð¸ÑÐ¾Ð²Ð°Ð½Ð¸Ðµ"),
                                            ]),
                                            e(
                                              "div",
                                              { staticClass: "form-group" },
                                              [
                                                e(
                                                  "div",
                                                  { staticClass: "form-check" },
                                                  [
                                                    e("input", {
                                                      directives: [
                                                        {
                                                          name: "model",
                                                          rawName: "v-model",
                                                          value:
                                                            t.usePillarArming,
                                                          expression:
                                                            "usePillarArming",
                                                        },
                                                      ],
                                                      staticClass:
                                                        "form-check-input",
                                                      attrs: {
                                                        type: "checkbox",
                                                        id: "usePillarArmingCheckbox",
                                                      },
                                                      domProps: {
                                                        checked: Array.isArray(
                                                          t.usePillarArming
                                                        )
                                                          ? t._i(
                                                              t.usePillarArming,
                                                              null
                                                            ) > -1
                                                          : t.usePillarArming,
                                                      },
                                                      on: {
                                                        change: [
                                                          function (e) {
                                                            var n =
                                                                t.usePillarArming,
                                                              i = e.target,
                                                              r = !!i.checked;
                                                            if (
                                                              Array.isArray(n)
                                                            ) {
                                                              var a = null,
                                                                o = t._i(n, a);
                                                              i.checked
                                                                ? o < 0 &&
                                                                  (t.usePillarArming =
                                                                    n.concat([
                                                                      a,
                                                                    ]))
                                                                : o > -1 &&
                                                                  (t.usePillarArming =
                                                                    n
                                                                      .slice(
                                                                        0,
                                                                        o
                                                                      )
                                                                      .concat(
                                                                        n.slice(
                                                                          o + 1
                                                                        )
                                                                      ));
                                                            } else
                                                              t.usePillarArming =
                                                                r;
                                                          },
                                                          function (e) {
                                                            return t.render();
                                                          },
                                                        ],
                                                      },
                                                    }),
                                                    e(
                                                      "label",
                                                      {
                                                        staticClass:
                                                          "form-check-label",
                                                        attrs: {
                                                          for: "usePillarArmingCheckbox",
                                                        },
                                                      },
                                                      [
                                                        t._v(
                                                          " ÐÑÐ¿Ð¾Ð»ÑÐ·Ð¾Ð²Ð°ÑÑ Ð°ÑÐ¼Ð¸ÑÐ¾Ð²Ð°Ð½Ð¸Ðµ ÑÑÐ¾Ð»Ð±Ð¾Ð² "
                                                        ),
                                                      ]
                                                    ),
                                                  ]
                                                ),
                                              ]
                                            ),
                                          ]
                                        ),
                                        t.usePillarArming
                                          ? [
                                              e(
                                                "div",
                                                {
                                                  staticClass:
                                                    "col-12 col-md-12",
                                                },
                                                [
                                                  e(
                                                    "div",
                                                    {
                                                      staticClass: "form-group",
                                                    },
                                                    [
                                                      e("label", [
                                                        t._v(
                                                          "ÐÑÐ¼Ð¸ÑÐ¾Ð²Ð°Ð½Ð¸Ðµ ÑÑÐ¾Ð»Ð±Ð¾Ð² "
                                                        ),
                                                      ]),
                                                      e(
                                                        "div",
                                                        {
                                                          staticClass:
                                                            "dropdown",
                                                        },
                                                        [
                                                          e(
                                                            "button",
                                                            {
                                                              staticClass:
                                                                "btn btn-default dropdown-toggle",
                                                              attrs: {
                                                                type: "button",
                                                                "data-toggle":
                                                                  "dropdown",
                                                                "aria-haspopup":
                                                                  "true",
                                                                "aria-expanded":
                                                                  "false",
                                                              },
                                                            },
                                                            [
                                                              e(
                                                                "span",
                                                                {
                                                                  staticClass:
                                                                    "text-item__caption",
                                                                },
                                                                [
                                                                  t._v(
                                                                    t._s(
                                                                      t
                                                                        .pillarArmingSize
                                                                        .caption
                                                                    )
                                                                  ),
                                                                ]
                                                              ),
                                                            ]
                                                          ),
                                                          e(
                                                            "div",
                                                            {
                                                              staticClass:
                                                                "dropdown-menu",
                                                              attrs: {
                                                                "aria-labelledby":
                                                                  "dropdownMenuButton",
                                                              },
                                                            },
                                                            [
                                                              t._l(
                                                                t.config
                                                                  .pillarArmingSizes,
                                                                function (n) {
                                                                  return [
                                                                    e(
                                                                      "div",
                                                                      {
                                                                        key:
                                                                          "pasgroup" +
                                                                          n.id,
                                                                        staticClass:
                                                                          "dropdown-item pl-2 group disabled",
                                                                      },
                                                                      [
                                                                        t._v(
                                                                          " " +
                                                                            t._s(
                                                                              n.caption
                                                                            ) +
                                                                            " "
                                                                        ),
                                                                      ]
                                                                    ),
                                                                    t._l(
                                                                      n.sizes,
                                                                      function (
                                                                        n
                                                                      ) {
                                                                        return e(
                                                                          "a",
                                                                          {
                                                                            key:
                                                                              "pas" +
                                                                              n.id,
                                                                            staticClass:
                                                                              "dropdown-item",
                                                                            on: {
                                                                              click:
                                                                                function (
                                                                                  e
                                                                                ) {
                                                                                  return t.setPillarArmingSize(
                                                                                    n
                                                                                  );
                                                                                },
                                                                            },
                                                                          },
                                                                          [
                                                                            e(
                                                                              "span",
                                                                              {
                                                                                staticClass:
                                                                                  "text-item__caption",
                                                                              },
                                                                              [
                                                                                t._v(
                                                                                  t._s(
                                                                                    n.caption
                                                                                  )
                                                                                ),
                                                                              ]
                                                                            ),
                                                                          ]
                                                                        );
                                                                      }
                                                                    ),
                                                                  ];
                                                                }
                                                              ),
                                                            ],
                                                            2
                                                          ),
                                                        ]
                                                      ),
                                                    ]
                                                  ),
                                                ]
                                              ),
                                              e(
                                                "div",
                                                {
                                                  staticClass:
                                                    "col-12 col-lg-6",
                                                },
                                                [
                                                  e(
                                                    "div",
                                                    {
                                                      staticClass: "form-group",
                                                    },
                                                    [
                                                      e(
                                                        "label",
                                                        {
                                                          attrs: {
                                                            for: "pillarArmingRowsRange",
                                                          },
                                                        },
                                                        [
                                                          t._v(
                                                            "Ð ÑÐ´Ð¾Ð² Ð°ÑÐ¼Ð¸ÑÐ¾Ð²Ð°Ð½Ð¸Ñ "
                                                          ),
                                                        ]
                                                      ),
                                                      e("input", {
                                                        directives: [
                                                          {
                                                            name: "model",
                                                            rawName:
                                                              "v-model.number",
                                                            value:
                                                              t.pillarArmingRows,
                                                            expression:
                                                              "pillarArmingRows",
                                                            modifiers: {
                                                              number: !0,
                                                            },
                                                          },
                                                        ],
                                                        staticClass:
                                                          "form-control",
                                                        attrs: {
                                                          type: "number",
                                                          step: t.config
                                                            .pillarArmingRowsStep,
                                                          min: t.config
                                                            .pillarArmingRowsMin,
                                                          max: t.config
                                                            .pillarArmingRowsMax,
                                                        },
                                                        domProps: {
                                                          value:
                                                            t.pillarArmingRows,
                                                        },
                                                        on: {
                                                          change: function (e) {
                                                            return t.render();
                                                          },
                                                          input: function (e) {
                                                            e.target
                                                              .composing ||
                                                              (t.pillarArmingRows =
                                                                t._n(
                                                                  e.target.value
                                                                ));
                                                          },
                                                          blur: function (e) {
                                                            return t.$forceUpdate();
                                                          },
                                                        },
                                                      }),
                                                      e("input", {
                                                        directives: [
                                                          {
                                                            name: "model",
                                                            rawName: "v-model",
                                                            value:
                                                              t.pillarArmingRows,
                                                            expression:
                                                              "pillarArmingRows",
                                                          },
                                                        ],
                                                        staticClass:
                                                          "form-control-range sticky-range custom-range",
                                                        attrs: {
                                                          type: "range",
                                                          id: "pillarArmingRowsRange",
                                                          step: t.config
                                                            .pillarArmingRowsStep,
                                                          min: t.config
                                                            .pillarArmingRowsMin,
                                                          max: t.config
                                                            .pillarArmingRowsMax,
                                                        },
                                                        domProps: {
                                                          value:
                                                            t.pillarArmingRows,
                                                        },
                                                        on: {
                                                          change: function (e) {
                                                            return t.render();
                                                          },
                                                          __r: function (e) {
                                                            t.pillarArmingRows =
                                                              e.target.value;
                                                          },
                                                        },
                                                      }),
                                                    ]
                                                  ),
                                                ]
                                              ),
                                              e(
                                                "div",
                                                {
                                                  staticClass:
                                                    "col-12 col-lg-6",
                                                },
                                                [
                                                  e(
                                                    "div",
                                                    {
                                                      staticClass: "form-group",
                                                    },
                                                    [
                                                      e(
                                                        "label",
                                                        {
                                                          attrs: {
                                                            for: "pillarArmingOffsetRange",
                                                          },
                                                        },
                                                        [t._v("ÐÑÑÑÑÐ¿ ÑÐ½Ð¸Ð·Ñ ")]
                                                      ),
                                                      e("input", {
                                                        directives: [
                                                          {
                                                            name: "model",
                                                            rawName:
                                                              "v-model.number",
                                                            value:
                                                              t.pillarArmingOffset,
                                                            expression:
                                                              "pillarArmingOffset",
                                                            modifiers: {
                                                              number: !0,
                                                            },
                                                          },
                                                        ],
                                                        staticClass:
                                                          "form-control",
                                                        attrs: {
                                                          type: "number",
                                                          step: t.config
                                                            .pillarArmingOffsetStep,
                                                          min: t.config
                                                            .pillarArmingOffsetMin,
                                                          max: t.pillarHeight,
                                                        },
                                                        domProps: {
                                                          value:
                                                            t.pillarArmingOffset,
                                                        },
                                                        on: {
                                                          change: function (e) {
                                                            return t.render();
                                                          },
                                                          input: function (e) {
                                                            e.target
                                                              .composing ||
                                                              (t.pillarArmingOffset =
                                                                t._n(
                                                                  e.target.value
                                                                ));
                                                          },
                                                          blur: function (e) {
                                                            return t.$forceUpdate();
                                                          },
                                                        },
                                                      }),
                                                      e("input", {
                                                        directives: [
                                                          {
                                                            name: "model",
                                                            rawName: "v-model",
                                                            value:
                                                              t.pillarArmingOffset,
                                                            expression:
                                                              "pillarArmingOffset",
                                                          },
                                                        ],
                                                        staticClass:
                                                          "form-control-range sticky-range custom-range",
                                                        attrs: {
                                                          type: "range",
                                                          id: "pillarArmingOffsetRange",
                                                          step: t.config
                                                            .pillarArmingOffsetStep,
                                                          min: t.config
                                                            .pillarArmingOffsetMin,
                                                          max: t.pillarHeight,
                                                        },
                                                        domProps: {
                                                          value:
                                                            t.pillarArmingOffset,
                                                        },
                                                        on: {
                                                          change: function (e) {
                                                            return t.render();
                                                          },
                                                          __r: function (e) {
                                                            t.pillarArmingOffset =
                                                              e.target.value;
                                                          },
                                                        },
                                                      }),
                                                    ]
                                                  ),
                                                ]
                                              ),
                                            ]
                                          : t._e(),
                                      ],
                                      2
                                    ),
                                    e("div", { staticClass: "row" }, [
                                      e(
                                        "div",
                                        { staticClass: "col-12 col-lg-6" },
                                        [
                                          e(
                                            "div",
                                            { staticClass: "form-group" },
                                            [
                                              e(
                                                "label",
                                                {
                                                  attrs: {
                                                    for: "pillarInnerRowsRange",
                                                  },
                                                },
                                                [
                                                  t._v(
                                                    "ÐÐ½ÑÑÑÐµÐ½Ð½Ð¸Ð¹ ÑÑÐ´ ÑÑÐ¾Ð»Ð±Ð¾Ð² "
                                                  ),
                                                ]
                                              ),
                                              e("input", {
                                                directives: [
                                                  {
                                                    name: "model",
                                                    rawName: "v-model.number",
                                                    value: t.pillarInnerRows,
                                                    expression:
                                                      "pillarInnerRows",
                                                    modifiers: { number: !0 },
                                                  },
                                                ],
                                                staticClass: "form-control",
                                                attrs: {
                                                  type: "number",
                                                  step: t.config
                                                    .pillarInnerRowsStep,
                                                  min: t.config
                                                    .pillarInnerRowsMin,
                                                  max: t.config
                                                    .pillarInnerRowsMax,
                                                },
                                                domProps: {
                                                  value: t.pillarInnerRows,
                                                },
                                                on: {
                                                  change: function (e) {
                                                    return t.render();
                                                  },
                                                  input: function (e) {
                                                    e.target.composing ||
                                                      (t.pillarInnerRows = t._n(
                                                        e.target.value
                                                      ));
                                                  },
                                                  blur: function (e) {
                                                    return t.$forceUpdate();
                                                  },
                                                },
                                              }),
                                              e("input", {
                                                directives: [
                                                  {
                                                    name: "model",
                                                    rawName: "v-model",
                                                    value: t.pillarInnerRows,
                                                    expression:
                                                      "pillarInnerRows",
                                                  },
                                                ],
                                                staticClass:
                                                  "form-control-range sticky-range custom-range",
                                                attrs: {
                                                  type: "range",
                                                  id: "pillarInnerRowsRange",
                                                  step: t.config
                                                    .pillarInnerRowsStep,
                                                  min: t.config
                                                    .pillarInnerRowsMin,
                                                  max: t.config
                                                    .pillarInnerRowsMax,
                                                },
                                                domProps: {
                                                  value: t.pillarInnerRows,
                                                },
                                                on: {
                                                  change: function (e) {
                                                    return t.render();
                                                  },
                                                  __r: function (e) {
                                                    t.pillarInnerRows =
                                                      e.target.value;
                                                  },
                                                },
                                              }),
                                            ]
                                          ),
                                        ]
                                      ),
                                    ]),
                                  ]
                                : t._e(),
                              e("div", { staticClass: "row" }, [
                                e("div", { staticClass: "col-12 col-lg-12" }, [
                                  e("div", { staticClass: "form-group" }, [
                                    e(
                                      "label",
                                      {
                                        attrs: { for: "pillarInnerRowsRange" },
                                      },
                                      [t._v("Ð¡Ð¼ÐµÐ½ ÐºÑÐ°Ð½Ð° ")]
                                    ),
                                    e("input", {
                                      directives: [
                                        {
                                          name: "model",
                                          rawName: "v-model.number",
                                          value: t.craneDays,
                                          expression: "craneDays",
                                          modifiers: { number: !0 },
                                        },
                                      ],
                                      staticClass: "form-control",
                                      attrs: {
                                        type: "number",
                                        step: "1",
                                        min: "0",
                                        max: "30",
                                      },
                                      domProps: { value: t.craneDays },
                                      on: {
                                        change: function (e) {
                                          return t.render();
                                        },
                                        input: function (e) {
                                          e.target.composing ||
                                            (t.craneDays = t._n(
                                              e.target.value
                                            ));
                                        },
                                        blur: function (e) {
                                          return t.$forceUpdate();
                                        },
                                      },
                                    }),
                                  ]),
                                ]),
                              ]),
                              e("div", { staticClass: "row" }, [
                                e("div", { staticClass: "col-12 col-lg-12" }, [
                                  e("div", { staticClass: "form-group" }, [
                                    e(
                                      "label",
                                      {
                                        attrs: { for: "pillarInnerRowsRange" },
                                      },
                                      [
                                        t._v(
                                          "ÐÐ¾Ð¿Ð¾Ð»Ð½Ð¸ÑÐµÐ»ÑÐ½Ð°Ñ Ð¾Ð¿Ð»Ð°ÑÐ° Ð·Ð° ÑÐ»Ð¾Ð¶Ð½Ð¾ÑÑÑ "
                                        ),
                                      ]
                                    ),
                                    e("input", {
                                      directives: [
                                        {
                                          name: "model",
                                          rawName: "v-model.number",
                                          value: t.complexityPrice,
                                          expression: "complexityPrice",
                                          modifiers: { number: !0 },
                                        },
                                      ],
                                      staticClass: "form-control",
                                      attrs: {
                                        type: "number",
                                        step: "1000",
                                        min: "0",
                                        max: "1000000",
                                      },
                                      domProps: { value: t.complexityPrice },
                                      on: {
                                        change: function (e) {
                                          return t.render();
                                        },
                                        input: function (e) {
                                          e.target.composing ||
                                            (t.complexityPrice = t._n(
                                              e.target.value
                                            ));
                                        },
                                        blur: function (e) {
                                          return t.$forceUpdate();
                                        },
                                      },
                                    }),
                                  ]),
                                ]),
                              ]),
                              e("div", { staticClass: "h3" }, [
                                t._v("ÐÐ¸Ð·ÑÐ°Ð»Ð¸Ð·Ð°ÑÐ¸Ñ ÑÐ°Ð·Ð¼ÐµÑÐ¾Ð²"),
                              ]),
                              e("div", { staticClass: "row" }, [
                                e("div", { staticClass: "col-12 col-lg-6" }, [
                                  e("div", { staticClass: "form-group" }, [
                                    e("div", { staticClass: "form-check" }, [
                                      e("input", {
                                        directives: [
                                          {
                                            name: "model",
                                            rawName: "v-model",
                                            value:
                                              t.sizingLayers.showCanopyBounds,
                                            expression:
                                              "sizingLayers.showCanopyBounds",
                                          },
                                        ],
                                        staticClass: "form-check-input",
                                        attrs: {
                                          type: "checkbox",
                                          id: "showCanopyBounds",
                                        },
                                        domProps: {
                                          checked: Array.isArray(
                                            t.sizingLayers.showCanopyBounds
                                          )
                                            ? t._i(
                                                t.sizingLayers.showCanopyBounds,
                                                null
                                              ) > -1
                                            : t.sizingLayers.showCanopyBounds,
                                        },
                                        on: {
                                          change: [
                                            function (e) {
                                              var n =
                                                  t.sizingLayers
                                                    .showCanopyBounds,
                                                i = e.target,
                                                r = !!i.checked;
                                              if (Array.isArray(n)) {
                                                var a = null,
                                                  o = t._i(n, a);
                                                i.checked
                                                  ? o < 0 &&
                                                    t.$set(
                                                      t.sizingLayers,
                                                      "showCanopyBounds",
                                                      n.concat([a])
                                                    )
                                                  : o > -1 &&
                                                    t.$set(
                                                      t.sizingLayers,
                                                      "showCanopyBounds",
                                                      n
                                                        .slice(0, o)
                                                        .concat(n.slice(o + 1))
                                                    );
                                              } else
                                                t.$set(
                                                  t.sizingLayers,
                                                  "showCanopyBounds",
                                                  r
                                                );
                                            },
                                            function (e) {
                                              return t.render();
                                            },
                                          ],
                                        },
                                      }),
                                      e(
                                        "label",
                                        {
                                          staticClass: "form-check-label light",
                                          attrs: { for: "showCanopyBounds" },
                                        },
                                        [t._v(" ÐÐ±ÑÐ¸Ðµ ÑÐ°Ð·Ð¼ÐµÑÑ Ð½Ð°Ð²ÐµÑÐ° ")]
                                      ),
                                    ]),
                                  ]),
                                  e("div", { staticClass: "form-group" }, [
                                    e("div", { staticClass: "form-check" }, [
                                      e("input", {
                                        directives: [
                                          {
                                            name: "model",
                                            rawName: "v-model",
                                            value:
                                              t.sizingLayers.showPillarSteps,
                                            expression:
                                              "sizingLayers.showPillarSteps",
                                          },
                                        ],
                                        staticClass: "form-check-input",
                                        attrs: {
                                          type: "checkbox",
                                          id: "showPillarSteps",
                                        },
                                        domProps: {
                                          checked: Array.isArray(
                                            t.sizingLayers.showPillarSteps
                                          )
                                            ? t._i(
                                                t.sizingLayers.showPillarSteps,
                                                null
                                              ) > -1
                                            : t.sizingLayers.showPillarSteps,
                                        },
                                        on: {
                                          change: [
                                            function (e) {
                                              var n =
                                                  t.sizingLayers
                                                    .showPillarSteps,
                                                i = e.target,
                                                r = !!i.checked;
                                              if (Array.isArray(n)) {
                                                var a = null,
                                                  o = t._i(n, a);
                                                i.checked
                                                  ? o < 0 &&
                                                    t.$set(
                                                      t.sizingLayers,
                                                      "showPillarSteps",
                                                      n.concat([a])
                                                    )
                                                  : o > -1 &&
                                                    t.$set(
                                                      t.sizingLayers,
                                                      "showPillarSteps",
                                                      n
                                                        .slice(0, o)
                                                        .concat(n.slice(o + 1))
                                                    );
                                              } else
                                                t.$set(
                                                  t.sizingLayers,
                                                  "showPillarSteps",
                                                  r
                                                );
                                            },
                                            function (e) {
                                              return t.render();
                                            },
                                          ],
                                        },
                                      }),
                                      e(
                                        "label",
                                        {
                                          staticClass: "form-check-label light",
                                          attrs: { for: "showPillarSteps" },
                                        },
                                        [t._v(" Ð¨Ð°Ð³ ÑÑÐ¾Ð»Ð±Ð¾Ð² ")]
                                      ),
                                    ]),
                                  ]),
                                  e("div", { staticClass: "form-group" }, [
                                    e("div", { staticClass: "form-check" }, [
                                      e("input", {
                                        directives: [
                                          {
                                            name: "model",
                                            rawName: "v-model",
                                            value:
                                              t.sizingLayers.showPillarHeights,
                                            expression:
                                              "sizingLayers.showPillarHeights",
                                          },
                                        ],
                                        staticClass: "form-check-input",
                                        attrs: {
                                          type: "checkbox",
                                          id: "showPillarHeights",
                                        },
                                        domProps: {
                                          checked: Array.isArray(
                                            t.sizingLayers.showPillarHeights
                                          )
                                            ? t._i(
                                                t.sizingLayers
                                                  .showPillarHeights,
                                                null
                                              ) > -1
                                            : t.sizingLayers.showPillarHeights,
                                        },
                                        on: {
                                          change: [
                                            function (e) {
                                              var n =
                                                  t.sizingLayers
                                                    .showPillarHeights,
                                                i = e.target,
                                                r = !!i.checked;
                                              if (Array.isArray(n)) {
                                                var a = null,
                                                  o = t._i(n, a);
                                                i.checked
                                                  ? o < 0 &&
                                                    t.$set(
                                                      t.sizingLayers,
                                                      "showPillarHeights",
                                                      n.concat([a])
                                                    )
                                                  : o > -1 &&
                                                    t.$set(
                                                      t.sizingLayers,
                                                      "showPillarHeights",
                                                      n
                                                        .slice(0, o)
                                                        .concat(n.slice(o + 1))
                                                    );
                                              } else
                                                t.$set(
                                                  t.sizingLayers,
                                                  "showPillarHeights",
                                                  r
                                                );
                                            },
                                            function (e) {
                                              return t.render();
                                            },
                                          ],
                                        },
                                      }),
                                      e(
                                        "label",
                                        {
                                          staticClass: "form-check-label light",
                                          attrs: { for: "showPillarHeights" },
                                        },
                                        [t._v(" ÐÑÑÐ¾ÑÐ° ÑÑÐ¾Ð»Ð±Ð¾Ð² ")]
                                      ),
                                    ]),
                                  ]),
                                  e("div", { staticClass: "form-group" }, [
                                    e("div", { staticClass: "form-check" }, [
                                      e("input", {
                                        directives: [
                                          {
                                            name: "model",
                                            rawName: "v-model",
                                            value: t.sizingLayers.showFarmSteps,
                                            expression:
                                              "sizingLayers.showFarmSteps",
                                          },
                                        ],
                                        staticClass: "form-check-input",
                                        attrs: {
                                          type: "checkbox",
                                          id: "showFarmSteps",
                                        },
                                        domProps: {
                                          checked: Array.isArray(
                                            t.sizingLayers.showFarmSteps
                                          )
                                            ? t._i(
                                                t.sizingLayers.showFarmSteps,
                                                null
                                              ) > -1
                                            : t.sizingLayers.showFarmSteps,
                                        },
                                        on: {
                                          change: [
                                            function (e) {
                                              var n =
                                                  t.sizingLayers.showFarmSteps,
                                                i = e.target,
                                                r = !!i.checked;
                                              if (Array.isArray(n)) {
                                                var a = null,
                                                  o = t._i(n, a);
                                                i.checked
                                                  ? o < 0 &&
                                                    t.$set(
                                                      t.sizingLayers,
                                                      "showFarmSteps",
                                                      n.concat([a])
                                                    )
                                                  : o > -1 &&
                                                    t.$set(
                                                      t.sizingLayers,
                                                      "showFarmSteps",
                                                      n
                                                        .slice(0, o)
                                                        .concat(n.slice(o + 1))
                                                    );
                                              } else
                                                t.$set(
                                                  t.sizingLayers,
                                                  "showFarmSteps",
                                                  r
                                                );
                                            },
                                            function (e) {
                                              return t.render();
                                            },
                                          ],
                                        },
                                      }),
                                      e(
                                        "label",
                                        {
                                          staticClass: "form-check-label light",
                                          attrs: { for: "showFarmSteps" },
                                        },
                                        [t._v(" Ð¨Ð°Ð³ ÑÐµÑÐ¼ ")]
                                      ),
                                    ]),
                                  ]),
                                ]),
                              ]),
                            ],
                            2
                          ),
                        ]
                      : t._e(),
                  ],
                  2
                ),
                e(
                  "div",
                  {
                    staticClass:
                      "col-12 col-sm-8 col-md-7 col-lg-7 order-2 order-sm-2",
                  },
                  [
                    e(
                      "div",
                      {
                        staticClass: "canvas-wrapper",
                        class: { "full-screen": t.fullScreenMode },
                      },
                      [
                        e("div", { staticClass: "toolbar" }, [
                          e(
                            "div",
                            {
                              staticClass: "toolbar-btn",
                              on: {
                                click: function (e) {
                                  return t.setFullScreenMode(!t.fullScreenMode);
                                },
                              },
                            },
                            [
                              t.fullScreenMode
                                ? e("img", {
                                    attrs: {
                                      src: "/content/icons/exit-full-screen.svg",
                                    },
                                  })
                                : e("img", {
                                    attrs: {
                                      src: "/content/icons/full-screen.svg",
                                    },
                                  }),
                            ]
                          ),
                          e(
                            "div",
                            {
                              staticClass: "toolbar-btn",
                              on: {
                                click: function (e) {
                                  return t.saveAsImage();
                                },
                              },
                            },
                            [
                              e("img", {
                                attrs: { src: "/content/icons/download.svg" },
                              }),
                            ]
                          ),
                        ]),
                        e("div", {
                          ref: "canvas",
                          staticClass: "canvas",
                          class: { loading: t.loading },
                          attrs: { id: "canvas" },
                        }),
                        t.groupReady && !t.loading
                          ? e(
                              "button",
                              {
                                staticClass: "btn btn-primary load-group-btn",
                                on: {
                                  click: function (e) {
                                    return t.loadGroup();
                                  },
                                },
                              },
                              [t._v(" ÐÐ¾ÐºÐ°Ð·Ð°ÑÑ 3D Ð¼Ð¾Ð´ÐµÐ»Ñ ")]
                            )
                          : t._e(),
                      ]
                    ),
                    e("div", { staticClass: "row mb-2 mt-2" }, [
                      e("div", { staticClass: "col-12 col-lg-6" }, [
                        e("div", [
                          e(
                            "button",
                            {
                              staticClass: "btn btn-secondary btn-lg mb-1",
                              attrs: {
                                "data-toggle": "modal",
                                "data-backdrop": "false",
                                "data-target": "#orderModal",
                              },
                              on: {
                                click: function (e) {
                                  t.orderComplete = !1;
                                },
                              },
                            },
                            [t._v(" ÐÐ°ÐºÐ°Ð·Ð°ÑÑ Ð½Ð°Ð²ÐµÑ ")]
                          ),
                        ]),
                        e("div", [
                          e(
                            "button",
                            {
                              staticClass: "btn btn-primary btn-lg mb-1",
                              attrs: {
                                "data-toggle1": "modal",
                                "data-backdrop": "false",
                                disabled: t.sendingCalculation,
                                "data-target": "#calculationModal",
                              },
                              on: {
                                click: function (e) {
                                  return t.trySaveCalculation();
                                },
                              },
                            },
                            [t._v(" Ð¡Ð¾ÑÑÐ°Ð½Ð¸ÑÑ ÑÐ°ÑÑÐµÑ ")]
                          ),
                        ]),
                      ]),
                      t._m(1),
                    ]),
                    t.calculation
                      ? e("div", { staticClass: "results1" }, [
                          e("div", { staticClass: "row" }, [
                            e("div", { staticClass: "col-12" }, [
                              e(
                                "div",
                                {
                                  class: {
                                    invisible:
                                      t.calculation.calculatedPrice <= 0,
                                  },
                                },
                                [
                                  e("div", { staticClass: "row" }, [
                                    t._m(2),
                                    e(
                                      "div",
                                      {
                                        staticClass:
                                          "col-12 col-sm-6 text-left text-sm-left h2 mb-1",
                                      },
                                      [
                                        t._v(
                                          " " +
                                            t._s(
                                              new Intl.NumberFormat(
                                                "ru-RU"
                                              ).format(
                                                t.calculation.finalPrice.toFixed(
                                                  0
                                                )
                                              )
                                            ) +
                                            " ÑÑÐ±. "
                                        ),
                                      ]
                                    ),
                                  ]),
                                ]
                              ),
                            ]),
                          ]),
                          e("div", { staticClass: "row" }, [
                            e("div", { staticClass: "col-12 col-xl-12" }, [
                              e(
                                "table",
                                { staticClass: "table mb-2" },
                                [
                                  e("tbody", [
                                    e("tr", [
                                      t._m(3),
                                      e(
                                        "td",
                                        {
                                          staticClass: "text-right text-nowrap",
                                        },
                                        [
                                          e("span", { staticClass: "number" }, [
                                            t._v(
                                              " " +
                                                t._s(
                                                  (t.width * t.height).toFixed(
                                                    2
                                                  )
                                                ) +
                                                " Ð¼ "
                                            ),
                                            e("sup", [t._v("2")]),
                                          ]),
                                        ]
                                      ),
                                    ]),
                                  ]),
                                  t._l(t.calculation.groups, function (n) {
                                    return e("tbody", { key: n.id }, [
                                      e("tr", [
                                        e("td", [t._v(t._s(n.caption) + ":")]),
                                        e(
                                          "td",
                                          {
                                            staticClass:
                                              "text-right text-nowrap",
                                          },
                                          [
                                            t._v(
                                              " " +
                                                t._s(
                                                  new Intl.NumberFormat(
                                                    "ru-RU"
                                                  ).format(
                                                    (
                                                      n.sum - n.discountSum
                                                    ).toFixed(0)
                                                  )
                                                ) +
                                                " ÑÑÐ±. "
                                            ),
                                          ]
                                        ),
                                      ]),
                                    ]);
                                  }),
                                  e("tbody", [
                                    e("tr", { staticClass: "sum" }, [
                                      t._m(4),
                                      e(
                                        "td",
                                        {
                                          staticClass: "text-right text-nowrap",
                                        },
                                        [
                                          e("b", [
                                            t._v(
                                              t._s(
                                                new Intl.NumberFormat(
                                                  "ru-RU"
                                                ).format(
                                                  t.calculation.calculatedPrice.toFixed(
                                                    0
                                                  )
                                                )
                                              ) + " ÑÑÐ±."
                                            ),
                                          ]),
                                        ]
                                      ),
                                    ]),
                                    t.calculation.calculatedDiscount > 0
                                      ? e("tr", { staticClass: "sum" }, [
                                          t._m(5),
                                          e(
                                            "td",
                                            {
                                              staticClass:
                                                "text-right text-nowrap",
                                            },
                                            [
                                              e("b", { staticClass: "red" }, [
                                                t._v(
                                                  "-" +
                                                    t._s(
                                                      new Intl.NumberFormat(
                                                        "ru-RU"
                                                      ).format(
                                                        t.calculation.calculatedDiscount.toFixed(
                                                          0
                                                        )
                                                      )
                                                    ) +
                                                    " ÑÑÐ±."
                                                ),
                                              ]),
                                            ]
                                          ),
                                        ])
                                      : t._e(),
                                    e("tr", { staticClass: "sum" }, [
                                      t._m(6),
                                      e(
                                        "td",
                                        {
                                          staticClass: "text-right text-nowrap",
                                        },
                                        [
                                          e("b", [
                                            t._v(
                                              t._s(
                                                new Intl.NumberFormat(
                                                  "ru-RU"
                                                ).format(
                                                  t.calculation.finalPrice.toFixed(
                                                    0
                                                  )
                                                )
                                              ) + " ÑÑÐ±."
                                            ),
                                          ]),
                                        ]
                                      ),
                                    ]),
                                    t.area
                                      ? e("tr", { staticClass: "sum" }, [
                                          e("td", [
                                            t._v("Ð¡ÑÐ¾Ð¸Ð¼Ð¾ÑÑÑ 1 ÐºÐ².Ð¼. Ð½Ð°Ð²ÐµÑÐ°:"),
                                          ]),
                                          e(
                                            "td",
                                            {
                                              staticClass:
                                                "text-right text-nowrap",
                                            },
                                            [
                                              t._v(
                                                " " +
                                                  t._s(
                                                    new Intl.NumberFormat(
                                                      "ru-RU"
                                                    ).format(
                                                      (
                                                        t.calculation
                                                          .finalPrice / t.area
                                                      ).toFixed(0)
                                                    )
                                                  ) +
                                                  " ÑÑÐ±. "
                                              ),
                                            ]
                                          ),
                                        ])
                                      : t._e(),
                                  ]),
                                ],
                                2
                              ),
                            ]),
                          ]),
                        ])
                      : t._e(),
                    e("h2", [t._v("Ð ÐµÐ¹ÑÐ¸Ð½Ð³Ð¸ Ð¸ Ð¾ÑÐ·ÑÐ²Ñ")]),
                    t._m(7),
                    e(
                      "div",
                      {
                        staticClass: "modal fade",
                        attrs: {
                          id: "orderModal",
                          tabindex: "-1",
                          "aria-labelledby": "modalLabel",
                          "aria-hidden": "true",
                        },
                      },
                      [
                        e("div", { staticClass: "modal-dialog align-center" }, [
                          e("div", { staticClass: "modal-content" }, [
                            t._m(8),
                            e(
                              "div",
                              { staticClass: "modal-body" },
                              [
                                t.orderComplete
                                  ? [
                                      e("p", [
                                        t._v(
                                          " ÐÐ°ÑÐ° Ð·Ð°ÑÐ²ÐºÐ° Ð¾ÑÐ¿ÑÐ°Ð²Ð»ÐµÐ½Ð°! ÐÑ ÑÐ²ÑÐ¶ÐµÐ¼ÑÑ Ñ ÐÐ°Ð¼Ð¸ Ð² Ð±Ð»Ð¸Ð¶Ð°Ð¹ÑÐµÐµ Ð²ÑÐµÐ¼Ñ! "
                                        ),
                                      ]),
                                    ]
                                  : [
                                      e("div", { staticClass: "form-group" }, [
                                        e("label", { attrs: { for: "name" } }, [
                                          t._v("ÐÐ¼Ñ"),
                                        ]),
                                        e("input", {
                                          directives: [
                                            {
                                              name: "model",
                                              rawName: "v-model",
                                              value: t.order.userName,
                                              expression: "order.userName",
                                            },
                                          ],
                                          staticClass: "form-control",
                                          attrs: { id: "name", type: "text" },
                                          domProps: { value: t.order.userName },
                                          on: {
                                            input: function (e) {
                                              e.target.composing ||
                                                t.$set(
                                                  t.order,
                                                  "userName",
                                                  e.target.value
                                                );
                                            },
                                          },
                                        }),
                                      ]),
                                      e("div", { staticClass: "form-group" }, [
                                        e(
                                          "label",
                                          { attrs: { for: "phone" } },
                                          [t._v("Ð¢ÐµÐ»ÐµÑÐ¾Ð½")]
                                        ),
                                        e("input", {
                                          directives: [
                                            {
                                              name: "calcphone",
                                              rawName: "v-calcphone",
                                            },
                                            {
                                              name: "model",
                                              rawName: "v-model",
                                              value: t.order.phone,
                                              expression: "order.phone",
                                            },
                                          ],
                                          staticClass: "form-control",
                                          attrs: { id: "phone", type: "text" },
                                          domProps: { value: t.order.phone },
                                          on: {
                                            input: function (e) {
                                              e.target.composing ||
                                                t.$set(
                                                  t.order,
                                                  "phone",
                                                  e.target.value
                                                );
                                            },
                                          },
                                        }),
                                      ]),
                                      e("div", { staticClass: "form-group" }, [
                                        e(
                                          "label",
                                          { attrs: { for: "comment" } },
                                          [t._v("ÐÐ¾Ð¼Ð¼ÐµÐ½ÑÐ°ÑÐ¸Ð¹")]
                                        ),
                                        e("textarea", {
                                          directives: [
                                            {
                                              name: "model",
                                              rawName: "v-model",
                                              value: t.order.comment,
                                              expression: "order.comment",
                                            },
                                          ],
                                          staticClass: "form-control",
                                          attrs: {
                                            id: "comment",
                                            type: "text",
                                            rows: "3",
                                          },
                                          domProps: { value: t.order.comment },
                                          on: {
                                            input: function (e) {
                                              e.target.composing ||
                                                t.$set(
                                                  t.order,
                                                  "comment",
                                                  e.target.value
                                                );
                                            },
                                          },
                                        }),
                                      ]),
                                      t.hasError
                                        ? e(
                                            "div",
                                            {
                                              staticClass: "alert alert-danger",
                                            },
                                            [t._v(" " + t._s(t.error) + " ")]
                                          )
                                        : t._e(),
                                    ],
                              ],
                              2
                            ),
                            e(
                              "div",
                              { staticClass: "modal-footer" },
                              [
                                t.orderComplete
                                  ? [
                                      e(
                                        "button",
                                        {
                                          staticClass: "btn btn-primary",
                                          attrs: {
                                            type: "button",
                                            "data-dismiss": "modal",
                                          },
                                        },
                                        [t._v(" OK ")]
                                      ),
                                    ]
                                  : [
                                      e(
                                        "button",
                                        {
                                          staticClass:
                                            "btn btn-secondary btn-lg",
                                          attrs: {
                                            type: "button",
                                            disabled: !t.canSendOrder,
                                          },
                                          on: {
                                            click: function (e) {
                                              return t.sendOrder();
                                            },
                                          },
                                        },
                                        [
                                          t.sendingOrder
                                            ? [t._v(" ÐÑÐ¿ÑÐ°Ð²Ð»ÑÐµÐ¼ Ð·Ð°ÑÐ²ÐºÑ ... ")]
                                            : [t._v(" ÐÑÐ¿ÑÐ°Ð²Ð¸ÑÑ Ð·Ð°ÑÐ²ÐºÑ ")],
                                        ],
                                        2
                                      ),
                                    ],
                              ],
                              2
                            ),
                          ]),
                        ]),
                      ]
                    ),
                    e(
                      "div",
                      {
                        staticClass: "modal fade",
                        staticStyle: { "z-index": "10000" },
                        attrs: {
                          id: "calculationModal",
                          tabindex: "-1",
                          "data-backdrop": "false",
                          "aria-labelledby": "modalLabel",
                          "aria-hidden": "true",
                        },
                      },
                      [
                        e("div", { staticClass: "modal-dialog align-center" }, [
                          e("div", { staticClass: "modal-content" }, [
                            e("div", { staticClass: "modal-header" }, [
                              e(
                                "div",
                                {
                                  staticClass: "modal-title",
                                  attrs: { id: "modalLabel" },
                                },
                                [t._v("Ð¡Ð¾ÑÑÐ°Ð½Ð¸ÑÑ ÑÐ°ÑÑÐµÑ")]
                              ),
                              e(
                                "button",
                                {
                                  staticClass: "close",
                                  attrs: {
                                    type: "button",
                                    "data-dismiss": "modal",
                                    "aria-label": "Close",
                                  },
                                  on: {
                                    click: function (e) {
                                      return t.ym(
                                        67222159,
                                        "reachGoal",
                                        "calcCancel"
                                      );
                                    },
                                  },
                                },
                                [
                                  e(
                                    "span",
                                    { attrs: { "aria-hidden": "true" } },
                                    [t._v("Ã")]
                                  ),
                                ]
                              ),
                            ]),
                            e(
                              "div",
                              { staticClass: "modal-body" },
                              [
                                t.calculationComplete
                                  ? [
                                      e("p", [
                                        t._v(" ÐÐ°ÑÐ° ÑÑÑÐ»ÐºÐ° Ð½Ð° ÑÐ°ÑÑÐµÑ:"),
                                        e("br"),
                                        e(
                                          "a",
                                          {
                                            attrs: {
                                              href:
                                                "https://mosnavesi.ru/calc/?key=" +
                                                t.clientCalculation
                                                  .calculationKey,
                                            },
                                          },
                                          [
                                            t._v(
                                              "https://mosnavesi.ru/calc/?key=" +
                                                t._s(
                                                  t.clientCalculation
                                                    .calculationKey
                                                )
                                            ),
                                          ]
                                        ),
                                      ]),
                                    ]
                                  : [
                                      e("div", { staticClass: "row" }, [
                                        e(
                                          "div",
                                          { staticClass: "col-12 col-sm-6" },
                                          [
                                            e(
                                              "div",
                                              { staticClass: "form-group" },
                                              [
                                                e(
                                                  "label",
                                                  { attrs: { for: "name" } },
                                                  [t._v("ÐÐ¼Ñ")]
                                                ),
                                                e("input", {
                                                  directives: [
                                                    {
                                                      name: "model",
                                                      rawName: "v-model",
                                                      value:
                                                        t.clientCalculation
                                                          .userName,
                                                      expression:
                                                        "clientCalculation.userName",
                                                    },
                                                  ],
                                                  staticClass: "form-control",
                                                  attrs: {
                                                    id: "name",
                                                    type: "text",
                                                  },
                                                  domProps: {
                                                    value:
                                                      t.clientCalculation
                                                        .userName,
                                                  },
                                                  on: {
                                                    input: function (e) {
                                                      e.target.composing ||
                                                        t.$set(
                                                          t.clientCalculation,
                                                          "userName",
                                                          e.target.value
                                                        );
                                                    },
                                                  },
                                                }),
                                              ]
                                            ),
                                          ]
                                        ),
                                        e(
                                          "div",
                                          { staticClass: "col-12 col-sm-6" },
                                          [
                                            e(
                                              "div",
                                              { staticClass: "form-group" },
                                              [
                                                e(
                                                  "label",
                                                  { attrs: { for: "phone" } },
                                                  [t._v("Ð¢ÐµÐ»ÐµÑÐ¾Ð½ (whatsapp)")]
                                                ),
                                                e("input", {
                                                  directives: [
                                                    {
                                                      name: "calcphone",
                                                      rawName: "v-calcphone",
                                                    },
                                                    {
                                                      name: "model",
                                                      rawName: "v-model",
                                                      value:
                                                        t.clientCalculation
                                                          .phone,
                                                      expression:
                                                        "clientCalculation.phone",
                                                    },
                                                  ],
                                                  staticClass: "form-control",
                                                  attrs: {
                                                    id: "phone",
                                                    type: "text",
                                                  },
                                                  domProps: {
                                                    value:
                                                      t.clientCalculation.phone,
                                                  },
                                                  on: {
                                                    input: function (e) {
                                                      e.target.composing ||
                                                        t.$set(
                                                          t.clientCalculation,
                                                          "phone",
                                                          e.target.value
                                                        );
                                                    },
                                                  },
                                                }),
                                              ]
                                            ),
                                          ]
                                        ),
                                        e(
                                          "div",
                                          { staticClass: "col-12 col-sm-12" },
                                          [
                                            e(
                                              "div",
                                              { staticClass: "form-group" },
                                              [
                                                e(
                                                  "label",
                                                  { attrs: { for: "phone" } },
                                                  [t._v("Email")]
                                                ),
                                                e("input", {
                                                  directives: [
                                                    {
                                                      name: "model",
                                                      rawName: "v-model",
                                                      value:
                                                        t.clientCalculation
                                                          .email,
                                                      expression:
                                                        "clientCalculation.email",
                                                    },
                                                  ],
                                                  staticClass: "form-control",
                                                  attrs: {
                                                    id: "phone",
                                                    type: "text",
                                                  },
                                                  domProps: {
                                                    value:
                                                      t.clientCalculation.email,
                                                  },
                                                  on: {
                                                    input: function (e) {
                                                      e.target.composing ||
                                                        t.$set(
                                                          t.clientCalculation,
                                                          "email",
                                                          e.target.value
                                                        );
                                                    },
                                                  },
                                                }),
                                              ]
                                            ),
                                          ]
                                        ),
                                      ]),
                                      e("div", { staticClass: "form-group" }, [
                                        e(
                                          "div",
                                          { staticClass: "form-check" },
                                          [
                                            e("input", {
                                              directives: [
                                                {
                                                  name: "model",
                                                  rawName: "v-model",
                                                  value:
                                                    t.clientCalculation
                                                      .needsConsultation,
                                                  expression:
                                                    "clientCalculation.needsConsultation",
                                                },
                                              ],
                                              staticClass: "form-check-input",
                                              attrs: {
                                                type: "checkbox",
                                                id: "flexCheckDefault",
                                              },
                                              domProps: {
                                                checked: Array.isArray(
                                                  t.clientCalculation
                                                    .needsConsultation
                                                )
                                                  ? t._i(
                                                      t.clientCalculation
                                                        .needsConsultation,
                                                      null
                                                    ) > -1
                                                  : t.clientCalculation
                                                      .needsConsultation,
                                              },
                                              on: {
                                                change: function (e) {
                                                  var n =
                                                      t.clientCalculation
                                                        .needsConsultation,
                                                    i = e.target,
                                                    r = !!i.checked;
                                                  if (Array.isArray(n)) {
                                                    var a = null,
                                                      o = t._i(n, a);
                                                    i.checked
                                                      ? o < 0 &&
                                                        t.$set(
                                                          t.clientCalculation,
                                                          "needsConsultation",
                                                          n.concat([a])
                                                        )
                                                      : o > -1 &&
                                                        t.$set(
                                                          t.clientCalculation,
                                                          "needsConsultation",
                                                          n
                                                            .slice(0, o)
                                                            .concat(
                                                              n.slice(o + 1)
                                                            )
                                                        );
                                                  } else
                                                    t.$set(
                                                      t.clientCalculation,
                                                      "needsConsultation",
                                                      r
                                                    );
                                                },
                                              },
                                            }),
                                            e(
                                              "label",
                                              {
                                                staticClass: "form-check-label",
                                                attrs: {
                                                  for: "flexCheckDefault",
                                                },
                                              },
                                              [
                                                t._v(
                                                  " ÐÑÐ¶Ð½Ð° ÐºÐ¾Ð½ÑÑÐ»ÑÑÐ°ÑÐ¸Ñ ÑÐ¿ÐµÑÐ¸Ð°Ð»Ð¸ÑÑÐ° "
                                                ),
                                              ]
                                            ),
                                          ]
                                        ),
                                      ]),
                                      e("div", { staticClass: "form-group" }, [
                                        e(
                                          "label",
                                          { attrs: { for: "region" } },
                                          [t._v("Ð ÐµÐ³Ð¸Ð¾Ð½")]
                                        ),
                                        e("div", { staticClass: "row" }, [
                                          e(
                                            "div",
                                            { staticClass: "col-12 col-sm-6" },
                                            [
                                              e(
                                                "div",
                                                { staticClass: "form-check" },
                                                [
                                                  e("input", {
                                                    directives: [
                                                      {
                                                        name: "model",
                                                        rawName: "v-model",
                                                        value:
                                                          t.clientCalculation
                                                            .defaultRegion,
                                                        expression:
                                                          "clientCalculation.defaultRegion",
                                                      },
                                                    ],
                                                    staticClass:
                                                      "form-check-input",
                                                    attrs: {
                                                      type: "radio",
                                                      name: "flexRadioDefault",
                                                      id: "flexRadioDefault1",
                                                      value: "0",
                                                      checked: "",
                                                    },
                                                    domProps: {
                                                      checked: t._q(
                                                        t.clientCalculation
                                                          .defaultRegion,
                                                        "0"
                                                      ),
                                                    },
                                                    on: {
                                                      change: function (e) {
                                                        return t.$set(
                                                          t.clientCalculation,
                                                          "defaultRegion",
                                                          "0"
                                                        );
                                                      },
                                                    },
                                                  }),
                                                  e(
                                                    "label",
                                                    {
                                                      staticClass:
                                                        "form-check-label",
                                                      attrs: {
                                                        for: "flexRadioDefault1",
                                                      },
                                                    },
                                                    [t._v(" ÐÐ¾ÑÐºÐ²Ð° Ð¸ Ð¾Ð±Ð»Ð°ÑÑÑ ")]
                                                  ),
                                                ]
                                              ),
                                            ]
                                          ),
                                          e(
                                            "div",
                                            { staticClass: "col-12 col-sm-6" },
                                            [
                                              e(
                                                "div",
                                                { staticClass: "form-check" },
                                                [
                                                  e("input", {
                                                    directives: [
                                                      {
                                                        name: "model",
                                                        rawName: "v-model",
                                                        value:
                                                          t.clientCalculation
                                                            .defaultRegion,
                                                        expression:
                                                          "clientCalculation.defaultRegion",
                                                      },
                                                    ],
                                                    staticClass:
                                                      "form-check-input",
                                                    attrs: {
                                                      type: "radio",
                                                      name: "flexRadioDefault",
                                                      value: "1",
                                                      id: "flexRadioDefault2",
                                                    },
                                                    domProps: {
                                                      checked: t._q(
                                                        t.clientCalculation
                                                          .defaultRegion,
                                                        "1"
                                                      ),
                                                    },
                                                    on: {
                                                      change: function (e) {
                                                        return t.$set(
                                                          t.clientCalculation,
                                                          "defaultRegion",
                                                          "1"
                                                        );
                                                      },
                                                    },
                                                  }),
                                                  e(
                                                    "label",
                                                    {
                                                      staticClass:
                                                        "form-check-label",
                                                      attrs: {
                                                        for: "flexRadioDefault2",
                                                      },
                                                    },
                                                    [t._v(" ÐÑÑÐ³Ð¾Ð¹ ÑÐµÐ³Ð¸Ð¾Ð½ ")]
                                                  ),
                                                ]
                                              ),
                                            ]
                                          ),
                                        ]),
                                      ]),
                                      e(
                                        "div",
                                        {
                                          staticClass: "form-group",
                                          class: {
                                            "d-none":
                                              "1" !=
                                              t.clientCalculation.defaultRegion,
                                          },
                                        },
                                        [
                                          e("input", {
                                            directives: [
                                              {
                                                name: "model",
                                                rawName: "v-model",
                                                value:
                                                  t.clientCalculation
                                                    .regionName,
                                                expression:
                                                  "clientCalculation.regionName",
                                              },
                                            ],
                                            staticClass: "form-control",
                                            attrs: {
                                              id: "regionName",
                                              type: "text",
                                              placeholder:
                                                "ÑÐºÐ°Ð¶Ð¸ÑÐµ ÑÐ²Ð¾Ð¹ ÑÐµÐ³Ð¸Ð¾Ð½",
                                            },
                                            domProps: {
                                              value:
                                                t.clientCalculation.regionName,
                                            },
                                            on: {
                                              input: function (e) {
                                                e.target.composing ||
                                                  t.$set(
                                                    t.clientCalculation,
                                                    "regionName",
                                                    e.target.value
                                                  );
                                              },
                                            },
                                          }),
                                        ]
                                      ),
                                      e("div", { staticClass: "form-group" }, [
                                        e(
                                          "label",
                                          { attrs: { for: "comment" } },
                                          [t._v("ÐÐ¾Ð¼Ð¼ÐµÐ½ÑÐ°ÑÐ¸Ð¹")]
                                        ),
                                        e("textarea", {
                                          directives: [
                                            {
                                              name: "model",
                                              rawName: "v-model",
                                              value:
                                                t.clientCalculation.comment,
                                              expression:
                                                "clientCalculation.comment",
                                            },
                                          ],
                                          staticClass: "form-control",
                                          attrs: {
                                            id: "comment",
                                            type: "text",
                                            rows: "3",
                                          },
                                          domProps: {
                                            value: t.clientCalculation.comment,
                                          },
                                          on: {
                                            input: function (e) {
                                              e.target.composing ||
                                                t.$set(
                                                  t.clientCalculation,
                                                  "comment",
                                                  e.target.value
                                                );
                                            },
                                          },
                                        }),
                                      ]),
                                      t.hasError
                                        ? e(
                                            "div",
                                            {
                                              staticClass: "alert alert-danger",
                                            },
                                            [t._v(" " + t._s(t.error) + " ")]
                                          )
                                        : t._e(),
                                    ],
                              ],
                              2
                            ),
                            e(
                              "div",
                              { staticClass: "modal-footer" },
                              [
                                t.calculationComplete
                                  ? [
                                      e(
                                        "button",
                                        {
                                          staticClass: "btn btn-primary",
                                          attrs: {
                                            type: "button",
                                            "data-dismiss": "modal",
                                          },
                                        },
                                        [t._v(" OK ")]
                                      ),
                                    ]
                                  : [
                                      e(
                                        "button",
                                        {
                                          staticClass:
                                            "btn btn-secondary btn-lg",
                                          attrs: {
                                            type: "button",
                                            disabled: !t.canSendCalculation,
                                          },
                                          on: {
                                            click: function (e) {
                                              return t.sendCalculation();
                                            },
                                          },
                                        },
                                        [
                                          t.sendingCalculation
                                            ? [t._v(" ÐÑÐ¿ÑÐ°Ð²Ð»ÑÐµÐ¼ ÑÑÑÐ»ÐºÑ ... ")]
                                            : [t._v(" ÐÑÐ¿ÑÐ°Ð²Ð¸ÑÑ ÑÑÑÐ»ÐºÑ ")],
                                        ],
                                        2
                                      ),
                                    ],
                              ],
                              2
                            ),
                          ]),
                        ]),
                      ]
                    ),
                  ]
                ),
              ]),
              t.fullMode
                ? e("div", { staticClass: "row mt-3" }, [t._m(9)])
                : t._e(),
              t.fullMode && t.specification
                ? [
                    e("h2", { staticClass: "mt-2" }, [
                      t._v("Ð¡Ð¿ÐµÑÐ¸ÑÐ¸ÐºÐ°ÑÐ¸Ñ Ð½Ð°Ð²ÐµÑÐ°"),
                    ]),
                    e(
                      "table",
                      { staticClass: "table" },
                      [
                        t._m(10),
                        t._l(t.specification, function (n, i) {
                          return [
                            e("thead", { key: "header" + i }, [
                              e("tr", [
                                e("th", [t._v(t._s(i + 1) + ".")]),
                                e("th", { attrs: { colspan: "2" } }, [
                                  t._v(t._s(n.caption)),
                                ]),
                              ]),
                            ]),
                            e(
                              "tbody",
                              { key: "body" + i },
                              t._l(n.items, function (n, r) {
                                return e("tr", { key: r }, [
                                  e("td", [
                                    t._v(t._s(i + 1) + "." + t._s(r + 1)),
                                  ]),
                                  e("td", [t._v(t._s(n.caption))]),
                                  e("td", [
                                    t._v(
                                      t._s(n.value) + " " + t._s(n.unitName)
                                    ),
                                  ]),
                                ]);
                              }),
                              0
                            ),
                          ];
                        }),
                      ],
                      2
                    ),
                  ]
                : t._e(),
              t.fullMode && t.calculation
                ? [
                    e("h2", { staticClass: "mt-2" }, [
                      t._v("Ð¡Ð¼ÐµÑÐ° ÑÐ°ÑÑÐµÑÐ° Ð½Ð°Ð²ÐµÑÐ°"),
                    ]),
                    e("div", { staticClass: "table-responsive" }, [
                      e(
                        "table",
                        { staticClass: "table" },
                        [
                          t._l(t.calculation.groups, function (n, i) {
                            return e(
                              "tbody",
                              { key: n.id },
                              [
                                e("tr", [
                                  e("th", { attrs: { colspan: "4" } }, [
                                    t._v(t._s(i + 1) + ". " + t._s(n.caption)),
                                  ]),
                                ]),
                                t._l(n.items, function (n, r) {
                                  return e("tr", { key: n.id }, [
                                    e("td", [
                                      t._v(t._s(i + 1) + "." + t._s(r + 1)),
                                    ]),
                                    e("td", [t._v(t._s(n.caption))]),
                                    e("td", [
                                      t._v(
                                        " " +
                                          t._s(
                                            new Intl.NumberFormat(
                                              "ru-RU"
                                            ).format(n.value.toFixed(2))
                                          ) +
                                          " " +
                                          t._s(n.unitName) +
                                          " "
                                      ),
                                    ]),
                                    e(
                                      "td",
                                      { staticClass: "text-right text-nowrap" },
                                      [
                                        t._v(
                                          " " +
                                            t._s(
                                              n.sum > 0
                                                ? new Intl.NumberFormat(
                                                    "ru-RU"
                                                  ).format(n.sum.toFixed(0)) +
                                                    " ÑÑÐ±."
                                                : "Ð±ÐµÑÐ¿Ð»Ð°ÑÐ½Ð¾"
                                            ) +
                                            " "
                                        ),
                                      ]
                                    ),
                                  ]);
                                }),
                                n.discountSum > 0
                                  ? e("tr", [
                                      e("td"),
                                      e("td", { attrs: { colspan: "2" } }, [
                                        e("b", { staticClass: "red" }, [
                                          t._v(t._s(n.caption) + " ÑÐºÐ¸Ð´ÐºÐ°"),
                                        ]),
                                      ]),
                                      e(
                                        "td",
                                        {
                                          staticClass: "text-right text-nowrap",
                                        },
                                        [
                                          e("b", { staticClass: "red" }, [
                                            t._v(
                                              "- " +
                                                t._s(
                                                  new Intl.NumberFormat(
                                                    "ru-RU"
                                                  ).format(
                                                    n.discountSum.toFixed(0)
                                                  )
                                                ) +
                                                " ÑÑÐ±. "
                                            ),
                                          ]),
                                        ]
                                      ),
                                    ])
                                  : t._e(),
                                e("tr", [
                                  e("td", { attrs: { colspan: "3" } }, [
                                    e("b", [t._v(t._s(n.caption) + " Ð¸ÑÐ¾Ð³Ð¾:")]),
                                  ]),
                                  e(
                                    "td",
                                    { staticClass: "text-right text-nowrap" },
                                    [
                                      e("b", [
                                        t._v(
                                          " " +
                                            t._s(
                                              new Intl.NumberFormat(
                                                "ru-RU"
                                              ).format(
                                                (n.sum - n.discountSum).toFixed(
                                                  0
                                                )
                                              )
                                            ) +
                                            " ÑÑÐ±. "
                                        ),
                                      ]),
                                    ]
                                  ),
                                ]),
                              ],
                              2
                            );
                          }),
                          e("tbody", [
                            e("tr", { staticClass: "sum" }, [
                              t._m(11),
                              e(
                                "td",
                                { staticClass: "text-right text-nowrap" },
                                [
                                  e("b", [
                                    t._v(
                                      t._s(
                                        new Intl.NumberFormat("ru-RU").format(
                                          t.calculation.calculatedPrice.toFixed(
                                            0
                                          )
                                        )
                                      ) + " ÑÑÐ±."
                                    ),
                                  ]),
                                ]
                              ),
                            ]),
                            t.calculation.calculatedDiscount > 0
                              ? e("tr", { staticClass: "sum" }, [
                                  t._m(12),
                                  e(
                                    "td",
                                    { staticClass: "text-right text-nowrap" },
                                    [
                                      e("b", { staticClass: "red" }, [
                                        t._v(
                                          "-" +
                                            t._s(
                                              new Intl.NumberFormat(
                                                "ru-RU"
                                              ).format(
                                                t.calculation.calculatedDiscount.toFixed(
                                                  0
                                                )
                                              )
                                            ) +
                                            " ÑÑÐ±."
                                        ),
                                      ]),
                                    ]
                                  ),
                                ])
                              : t._e(),
                            e("tr", { staticClass: "sum" }, [
                              t._m(13),
                              e(
                                "td",
                                { staticClass: "text-right text-nowrap" },
                                [
                                  e("b", [
                                    t._v(
                                      t._s(
                                        new Intl.NumberFormat("ru-RU").format(
                                          t.calculation.finalPrice.toFixed(0)
                                        )
                                      ) + " ÑÑÐ±."
                                    ),
                                  ]),
                                ]
                              ),
                            ]),
                          ]),
                        ],
                        2
                      ),
                    ]),
                  ]
                : t._e(),
            ],
            2
          );
        },
        c = [
          function () {
            var t = this,
              e = t._self._c;
            return e("div", { staticClass: "row" }, [
              e("div", { staticClass: "col-12 col-lg-12" }, [
                e("div", { staticClass: "h3" }, [t._v("Ð¡ÑÐ¾Ð»Ð±Ñ")]),
              ]),
            ]);
          },
          function () {
            var t = this,
              e = t._self._c;
            return e("div", { staticClass: "col-12 col-lg-6" }, [
              e("p", { staticClass: "b" }, [
                t._v(" ÐÑÐ¾ÐºÐ¾Ð½ÑÑÐ»ÑÑÐ¸ÑÑÐ¹ÑÐµÑÑ Ñ Ð½Ð°Ð¼Ð¸:"),
                e("br"),
                e("span", { staticClass: "phone" }, [
                  e("a", { attrs: { href: "tel:+74951516801" } }, [
                    t._v("+7 (495) 151-68-01"),
                  ]),
                  e(
                    "a",
                    {
                      staticClass: "whatsapp ga-event",
                      attrs: {
                        href: "https://wa.me/74951516801",
                        target: "_blank",
                      },
                    },
                    [
                      e("img", {
                        attrs: {
                          src: "/content/images/icons/whatsapp-icon.svg",
                        },
                      }),
                    ]
                  ),
                ]),
              ]),
              e("p", { staticClass: "b" }, [
                t._v(" ÐÑÐµÐ´Ð»Ð¾Ð¶ÐµÐ½Ð¸Ñ Ð¿Ð¾ ÑÐ»ÑÑÑÐµÐ½Ð¸Ñ ÐºÐ°Ð»ÑÐºÑÐ»ÑÑÐ¾ÑÐ° (ÑÐ°Ð·ÑÐ°Ð±Ð¾ÑÑÐ¸Ðº):"),
                e("br"),
                e("span", { staticClass: "email" }, [
                  e("a", { attrs: { href: "tel:+79161970739" } }, [
                    t._v("+7 (916) 197-07-39"),
                  ]),
                  e(
                    "a",
                    {
                      staticClass: "whatsapp ga-event",
                      attrs: {
                        href: "https://wa.me/79161970739",
                        target: "_blank",
                      },
                    },
                    [
                      e("img", {
                        attrs: {
                          src: "/content/images/icons/whatsapp-icon.svg",
                        },
                      }),
                    ]
                  ),
                ]),
              ]),
            ]);
          },
          function () {
            var t = this,
              e = t._self._c;
            return e(
              "div",
              { staticClass: "col-12 col-sm-6 text-left text-sm-right" },
              [e("h2", { staticClass: "mb-0" }, [t._v("Ð¡ÑÐ¾Ð¸Ð¼Ð¾ÑÑÑ Ð½Ð°Ð²ÐµÑÐ°:")])]
            );
          },
          function () {
            var t = this,
              e = t._self._c;
            return e("td", [
              e("span", { staticClass: "caption" }, [t._v("ÐÐ»Ð¾ÑÐ°Ð´Ñ: ")]),
            ]);
          },
          function () {
            var t = this,
              e = t._self._c;
            return e("td", [e("b", [t._v("Ð¡ÑÐ¾Ð¸Ð¼Ð¾ÑÑÑ Ð½Ð°Ð²ÐµÑÐ°:")])]);
          },
          function () {
            var t = this,
              e = t._self._c;
            return e("td", [
              e("b", { staticClass: "red" }, [t._v("ÐÐ±ÑÐ°Ñ ÑÐºÐ¸Ð´ÐºÐ°:")]),
            ]);
          },
          function () {
            var t = this,
              e = t._self._c;
            return e("td", [
              e("b", [t._v("ÐÑÐ¾Ð³Ð¾ ÑÑÐ¾Ð¸Ð¼Ð¾ÑÑÑ Ð½Ð°Ð²ÐµÑÐ° (Ð¿Ð¾Ð´ ÐºÐ»ÑÑ):")]),
            ]);
          },
          function () {
            var t = this,
              e = t._self._c;
            return e("div", { staticClass: "row" }, [
              e(
                "div",
                { staticClass: "col-12 col-sm-6 col-md-3 text-center mb-3" },
                [
                  e("div", { staticClass: "h2" }, [t._v("5 / 5")]),
                  e("div", { staticClass: "item-rating h2" }, [
                    e("div", { staticClass: "item-rating-stars" }, [
                      e("span", { staticClass: "rating-star selected" }),
                      e("span", { staticClass: "rating-star selected" }),
                      e("span", {
                        staticClass: "fas fa-star fa-fw rating-star selected",
                      }),
                      e("span", { staticClass: "rating-star selected" }),
                      e("span", { staticClass: "rating-star selected" }),
                    ]),
                  ]),
                  e(
                    "a",
                    {
                      attrs: {
                        target: "_blank",
                        href: "https://uslugi.yandex.ru/profile/Mosnavesy-777393",
                      },
                    },
                    [
                      e("img", {
                        attrs: {
                          src: "/Content/icons/yandex.png",
                          alt: "ÐÑÐ·ÑÐ²Ñ Ð¯Ð½Ð´ÐµÐºÑ",
                        },
                      }),
                    ]
                  ),
                ]
              ),
              e(
                "div",
                { staticClass: "col-12 col-sm-6 col-md-4 text-center mb-3" },
                [
                  e("div", { staticClass: "h2" }, [t._v("5 / 5")]),
                  e("div", { staticClass: "item-rating h2" }, [
                    e("div", { staticClass: "item-rating-stars" }, [
                      e("span", { staticClass: "rating-star selected" }),
                      e("span", { staticClass: "rating-star selected" }),
                      e("span", {
                        staticClass: "fas fa-star fa-fw rating-star selected",
                      }),
                      e("span", { staticClass: "rating-star selected" }),
                      e("span", { staticClass: "rating-star selected" }),
                    ]),
                  ]),
                  e(
                    "a",
                    {
                      attrs: {
                        target: "_blank",
                        href: "https://www.google.com/search?q=%D0%BC%D0%BE%D1%81%D0%BD%D0%B0%D0%B2%D0%B5%D1%81%D1%8B&oq=%D0%BC%D0%BE%D1%81&aqs=chrome.0.69i59l2j69i57j69i61l3j69i65l2.2663j0j4&sourceid=chrome&ie=UTF-8#lrd=0x414ab7beb46444b1:0x367a7d9b168bcf52,1,,,",
                      },
                    },
                    [
                      e("img", {
                        staticClass: "pt-1",
                        attrs: {
                          src: "/Content/icons/go.png",
                          alt: "ÐÑÐ·ÑÐ²Ñ Google",
                        },
                      }),
                    ]
                  ),
                ]
              ),
              e(
                "div",
                { staticClass: "col-12 col-sm-6 col-md-4 text-center mb-3" },
                [
                  e("div", { staticClass: "h2" }, [t._v("5 / 5")]),
                  e("div", { staticClass: "item-rating h2" }, [
                    e("div", { staticClass: "item-rating-stars" }, [
                      e("span", { staticClass: "rating-star selected" }),
                      e("span", { staticClass: "rating-star selected" }),
                      e("span", {
                        staticClass: "fas fa-star fa-fw rating-star selected",
                      }),
                      e("span", { staticClass: "rating-star selected" }),
                      e("span", { staticClass: "rating-star selected" }),
                    ]),
                  ]),
                  e(
                    "a",
                    {
                      attrs: {
                        target: "_blank",
                        href: "https://www.avito.ru/user/beb7f90d2fb478a4b18cc138ed6c7094/profile",
                      },
                    },
                    [
                      e("img", {
                        staticClass: "pt-1",
                        staticStyle: { width: "170px" },
                        attrs: {
                          src: "/Content/icons/avito.svg",
                          alt: "ÐÑÐ·ÑÐ²Ñ ÐÐ²Ð¸ÑÐ¾",
                        },
                      }),
                    ]
                  ),
                ]
              ),
            ]);
          },
          function () {
            var t = this,
              e = t._self._c;
            return e("div", { staticClass: "modal-header" }, [
              e(
                "div",
                { staticClass: "modal-title", attrs: { id: "modalLabel" } },
                [t._v("ÐÐ°ÐºÐ°Ð·Ð°ÑÑ Ð½Ð°Ð²ÐµÑ")]
              ),
              e(
                "button",
                {
                  staticClass: "close",
                  attrs: {
                    type: "button",
                    "data-dismiss": "modal",
                    "aria-label": "Close",
                  },
                },
                [e("span", { attrs: { "aria-hidden": "true" } }, [t._v("Ã")])]
              ),
            ]);
          },
          function () {
            var t = this,
              e = t._self._c;
            return e("div", { staticClass: "col-12" }, [
              e("h2", [t._v("ÐÐ¾ÑÐµÐ¼Ñ Ð½Ð°ÑÐµ Ð¿ÑÐµÐ´Ð»Ð¾Ð¶ÐµÐ½Ð¸Ðµ Ð»ÑÑÑÐµ?")]),
              e("ul", { staticClass: "advantage-list" }, [
                e("li", [
                  e("div", { staticClass: "advantage" }, [
                    t._v("ÐÐ¾Ð¼ÐµÐ½ÑÐ°Ð»ÑÐ½Ð°Ñ Ð²Ð¸Ð·ÑÐ°Ð»Ð¸Ð·Ð°ÑÐ¸Ñ"),
                  ]),
                  e("div", { staticClass: "description" }, [
                    t._v(
                      " ÐÑ ÑÐ¾ÑÐ½Ð¾ Ð¿Ð¾Ð½Ð¸Ð¼Ð°ÐµÑÐµ ÐºÐ°Ðº Ð±ÑÐ´ÐµÑ Ð²ÑÐ³Ð»ÑÐ´ÐµÑÑ ÐÐ°Ñ Ð½Ð°Ð²ÐµÑ. ÐÑ Ð¿ÑÐµÐ´Ð¾ÑÑÐ°Ð²Ð»ÑÐµÐ¼ "
                    ),
                    e("b", [t._v("3D Ð¼Ð¾Ð´ÐµÐ»Ñ")]),
                    t._v(" ÐºÐ¾Ð½ÑÑÑÑÐºÑÐ¸Ð¸ Ð¾Ð½Ð»Ð°Ð¹Ð½. "),
                  ]),
                ]),
                e("li", [
                  e("div", { staticClass: "advantage" }, [
                    t._v("ÐÑÑÐ¾ÐºÐ°Ñ Ð¿ÑÐ¾ÑÐ½Ð¾ÑÑÑ ÐºÐ¾Ð½ÑÑÑÑÐºÑÐ¸Ð¸"),
                  ]),
                  e("div", { staticClass: "description" }, [
                    t._v(" ÐÐ¾Ð½ÑÑÑÑÐºÑÐ¸Ñ Ð½Ð°Ð²ÐµÑÐ° Ð²ÑÐ´ÐµÑÐ¶Ð¸Ñ "),
                    e("b", [t._v("Ð±Ð¾Ð»ÐµÐµ 240ÐºÐ³/Ð¼2")]),
                    t._v(
                      ". Ð­ÑÐ¾ Ð²ÑÑÐ¾ÐºÐ¸Ð¹ Ð·Ð°Ð¿Ð°Ñ Ð¿ÑÐ¾ÑÐ½Ð¾ÑÑÐ¸. ÐÑ Ð½Ðµ ÑÐºÐ¾Ð½Ð¾Ð¼Ð¸Ð¼ Ð½Ð° Ð¼ÐµÑÐ°Ð»Ð»Ðµ, Ð³Ð°ÑÐ°Ð½ÑÐ¸Ñ Ð½Ð° ÐºÐ¾Ð½ÑÑÑÑÐºÑÐ¸Ñ "
                    ),
                    e("b", [t._v("Ð¾Ñ 5 Ð»ÐµÑ")]),
                  ]),
                ]),
                e("li", [
                  e("div", { staticClass: "advantage" }, [
                    t._v("ÐÐ¸ÐºÐ°ÐºÐ¸Ñ Ð¸Ð³Ñ Ñ ÑÐ¾Ð»ÑÐ¸Ð½Ð¾Ð¹ Ð¼ÐµÑÐ°Ð»Ð»Ð°"),
                  ]),
                  e("div", { staticClass: "description" }, [
                    t._v(" ÐÐµÑÑ Ð¼ÐµÑÐ°Ð»Ð» ÑÐµÑÑÐ¸ÑÐ¸ÑÐ¸ÑÐ¾Ð²Ð°Ð½ Ð¸ Ð¾ÑÐ²ÐµÑÐ°ÐµÑ "),
                    e("b", [t._v("ÑÑÐµÐ±Ð¾Ð²Ð°Ð½Ð¸ÑÐ¼ ÐÐÐ¡Ð¢")]),
                    t._v(", ÑÐ¾Ð»ÑÐ¸Ð½Ñ Ð¼ÐµÑÐ°Ð»Ð»Ð° Ð·Ð°Ð¼ÐµÑÑÐµÐ¼ Ð¿ÑÐ¸ Ð·Ð°ÐºÐ°Ð·ÑÐ¸ÐºÐµ "),
                  ]),
                ]),
                e("li", [
                  e("div", { staticClass: "advantage" }, [
                    t._v("ÐÐ¾Ð»Ð¸ÐºÐ°ÑÐ±Ð¾Ð½Ð°Ñ Ð¿Ð¾Ð²ÑÑÐµÐ½Ð½Ð¾Ð¹ Ð¿ÑÐ¾ÑÐ½Ð¾ÑÑÐ¸"),
                  ]),
                  e("div", { staticClass: "description" }, [
                    t._v(
                      " ÐÑ Ð¸ÑÐ¿Ð¾Ð»ÑÐ·ÑÐµÐ¼ Ð¿Ð¾Ð»Ð¸ÐºÐ°ÑÐ±Ð¾Ð½Ð°Ñ Ð¿Ð¾Ð²ÑÑÐµÐ½Ð½Ð¾Ð¹ Ð¿ÑÐ¾ÑÐ½Ð¾ÑÑÐ¸ Ð¿Ð»Ð¾ÑÐ½Ð¾ÑÑÑÑ "
                    ),
                    e("b", [t._v("Ð¾Ñ 1.1 ÐºÐ³/Ð¼2")]),
                    t._v(". ÐÐ¾ Ð½ÐµÐ¼Ñ Ð¼Ð¾Ð¶Ð½Ð¾ ÑÐ¾Ð´Ð¸ÑÑ, ÐµÐ³Ð¾ Ð½Ðµ Ð¿ÑÐ¾Ð±ÑÐµÑ Ð³ÑÐ°Ð´ "),
                  ]),
                ]),
                e("li", [
                  e("div", { staticClass: "advantage" }, [
                    t._v(" ÐÐ°ÑÐ¸ÑÐ° Ð¾Ñ Ð²Ð¾Ð·Ð´ÐµÐ¹ÑÑÐ²Ð¸Ñ ÑÐ»ÑÑÑÐ°ÑÐ¸Ð¾Ð»ÐµÑÐ¾Ð²ÑÑ Ð»ÑÑÐµÐ¹ "),
                  ]),
                  e("div", { staticClass: "description" }, [
                    t._v(
                      " ÐÐ¾Ð»Ð¸ÐºÐ°ÑÐ±Ð¾Ð½Ð°Ñ Ð·Ð°ÑÐ¸ÑÐµÐ½ Ð¾Ñ Ð²Ð¾Ð·Ð´ÐµÐ¹ÑÑÐ²Ð¸Ñ ÑÐ»ÑÑÑÐ°ÑÐ¸Ð¾Ð»ÐµÑÐ¾Ð²ÑÑ Ð»ÑÑÐµÐ¹, Ð³Ð°ÑÐ°Ð½ÑÐ¸Ñ Ð¿ÑÐ¾Ð¸Ð·Ð²Ð¾Ð´Ð¸ÑÐµÐ»Ñ "
                    ),
                    e("b", [t._v("Ð¾Ñ 15 Ð»ÐµÑ")]),
                  ]),
                ]),
                e("li", [
                  e("div", { staticClass: "advantage" }, [
                    t._v("ÐÐ°ÑÐµÑÑÐ²ÐµÐ½Ð½Ð°Ñ ÐºÑÐ°ÑÐºÐ°"),
                  ]),
                  e("div", { staticClass: "description" }, [
                    t._v(" ÐÑ Ð¸ÑÐ¿Ð¾Ð»ÑÐ·ÑÐµÐ¼ ÐºÐ°ÑÐµÑÑÐ²ÐµÐ½Ð½ÑÑ ÐºÑÐ°ÑÐºÑ "),
                    e("b", [t._v("SLAVEN")]),
                    t._v(" (Ð Ð¾ÑÑÐ¸Ñ) Ð»Ð¸Ð±Ð¾ "),
                    e("b", [t._v("HAMMERITE")]),
                    t._v(" (ÐÐ¸Ð´ÐµÑÐ»Ð°Ð½Ð´Ñ) "),
                  ]),
                ]),
                e("li", [
                  e("div", { staticClass: "advantage" }, [
                    t._v("ÐÑÐ¾Ð·ÑÐ°ÑÐ½Ð°Ñ ÑÐ¼ÐµÑÐ°"),
                  ]),
                  e("div", { staticClass: "description" }, [
                    t._v(
                      " ÐÑ Ð¿Ð¾ÐºÐ°Ð·ÑÐ²Ð°ÐµÐ¼ Ð´ÐµÑÐ°Ð»ÑÐ½ÑÑ ÑÐ¼ÐµÑÑ Ð¿ÑÐ¾Ð¸Ð·Ð²Ð¾Ð´ÑÑÐ²Ð° Ð½Ð°Ð²ÐµÑÐ° Ð´Ð¾ Ð¿Ð¾ÑÐ»ÐµÐ´Ð½ÐµÐ³Ð¾ ÑÑÑÑÐ¿Ð° "
                    ),
                  ]),
                ]),
                e("li", [
                  e("div", { staticClass: "advantage" }, [
                    t._v("ÐÐ¿ÑÐ¾Ð²ÑÐµ ÑÐµÐ½Ñ Ð½Ð° Ð¼Ð°ÑÐµÑÐ¸Ð°Ð»Ñ"),
                  ]),
                  e("div", { staticClass: "description" }, [
                    t._v(" Ð¦ÐµÐ½Ñ Ð½Ð° Ð¼ÐµÑÐ°Ð»Ð» Ð¸ Ð¿Ð¾Ð»Ð¸ÐºÐ°ÑÐ±Ð¾Ð½Ð°Ñ "),
                    e("b", [t._v("Ð¾Ð¿ÑÐ¾Ð²ÑÐµ")]),
                    t._v(
                      ", ÐÑ Ð¼Ð¾Ð¶ÐµÑÐµ Ð¿ÑÐ¾Ð²ÐµÑÐ¸ÑÑ ÑÑÐ¾Ð¸Ð¼Ð¾ÑÑÑ Ð¼ÐµÑÐ°Ð»Ð»Ð° Ð² ÐºÑÑÐ¿Ð½ÑÑ ÑÐµÑÐµÐ²ÑÑ ÑÑÑÐ¾Ð¸ÑÐµÐ»ÑÐ½ÑÑ Ð¼Ð°Ð³Ð°Ð·Ð¸Ð½Ð°Ñ Ð¸ ÑÑÐ°Ð²Ð½Ð¸ÑÑ Ñ Ð½Ð°ÑÐµÐ¹ "
                    ),
                  ]),
                ]),
                e("li", [
                  e("div", { staticClass: "advantage" }, [
                    t._v("ÐÐ¿ÐµÑÐ°ÑÐ¸Ð²Ð½ÑÐµ ÑÑÐ¾ÐºÐ¸ Ð¸Ð·Ð³Ð¾ÑÐ¾Ð²Ð»ÐµÐ½Ð¸Ñ"),
                  ]),
                  e("div", { staticClass: "description" }, [
                    t._v(" ÐÐ·Ð³Ð¾ÑÐ°Ð²Ð»Ð¸Ð²Ð°ÐµÐ¼ Ð½Ð°Ð²ÐµÑ Ð² ÐºÑÐ°ÑÑÐ°Ð¹ÑÐ¸Ðµ ÑÑÐ¾ÐºÐ¸, Ð² ÑÑÐµÐ´Ð½ÐµÐ¼ "),
                    e("b", [t._v("7 Ð´Ð½ÐµÐ¹")]),
                  ]),
                ]),
                e("li", [
                  e("div", { staticClass: "advantage" }, [
                    t._v("ÐÐ¾Ð½ÑÐ°Ð¶ Ð½Ð°Ð²ÐµÑÐ° Ð·Ð° 1 Ð´ÐµÐ½Ñ"),
                  ]),
                  e("div", { staticClass: "description" }, [
                    t._v(" Ð ÑÑÐµÐ´Ð½ÐµÐ¼ Ð½Ð° Ð¼Ð¾Ð½ÑÐ°Ð¶ Ð½Ð°Ð²ÐµÑÐ° Ñ Ð½Ð°Ñ ÑÑÐ¾Ð´Ð¸Ñ "),
                    e("b", [t._v("1 Ð´ÐµÐ½Ñ")]),
                  ]),
                ]),
                e("li", [
                  e("div", { staticClass: "advantage" }, [
                    t._v(" ÐÐµÑÐµÑÑÐ¸ÑÐ°ÐµÐ¼ Ð»ÑÐ±ÑÑ ÐºÐ¾Ð½ÑÑÑÑÐºÑÐ¸Ñ ÐºÐ¾Ð½ÐºÑÑÐµÐ½ÑÐ¾Ð² "),
                  ]),
                  e("div", { staticClass: "description" }, [
                    t._v(
                      " ÐÑ Ð¼Ð¾Ð¶ÐµÐ¼ Ð¿ÐµÑÐµÑÑÐ¸ÑÐ°ÑÑ Ð»ÑÐ±ÑÑ ÐºÐ¾Ð½ÑÑÑÑÐºÑÐ¸Ñ ÐºÐ¾Ð½ÐºÑÑÐµÐ½ÑÐ¾Ð² Ð¸ Ð¿Ð¾ÐºÐ°Ð·Ð°ÑÑ, ÐºÐ°ÐºÐ¾Ð²Ð° ÑÐµÐ°Ð»ÑÐ½Ð°Ñ ÑÑÐ¾Ð¸Ð¼Ð¾ÑÑÑ Ð½Ð°Ð²ÐµÑÐ°, Ð´ÐµÑÐ°Ð»ÑÐ½Ð¾ ÑÐ°Ð·Ð»Ð¾Ð¶Ð¸Ð² ÑÐ¼ÐµÑÑ. ÐÐ°Ðº Ð¿ÑÐ°Ð²Ð¸Ð»Ð¾, "
                    ),
                    e("b", [
                      t._v(
                        "Ð½Ð°ÑÐ° ÐºÐ¾Ð½ÑÑÑÑÐºÑÐ¸Ñ Ð¸Ð¼ÐµÐµÑ Ð±Ð¾Ð»ÑÑÐµ ÑÐµÑÐ¼, ÑÑÐ¾Ð»Ð±Ð¾Ð², Ð»Ð°Ð³Ð¾Ð² Ð¸ Ð¿Ð¾ÑÑÐ¾Ð¼Ñ Ð¿ÑÐ¾ÑÐ½ÐµÐµ"
                      ),
                    ]),
                    t._v(". ÐÑ Ð½Ðµ ÑÐºÐ¾Ð½Ð¾Ð¼Ð¸Ð¼ Ð½Ð° Ð½Ð°Ð´ÐµÐ¶Ð½Ð¾ÑÑÐ¸. "),
                  ]),
                ]),
                e("li", [
                  e("div", { staticClass: "advantage" }, [
                    t._v("ÐÐ°ÑÐ°Ð½ÑÐ¸Ñ Ð½Ð¸Ð·ÐºÐ¾Ð¹ ÑÐµÐ½Ñ"),
                  ]),
                  e("div", { staticClass: "description" }, [
                    t._v(
                      " ÐÑÐ»Ð¸ ÐÑ Ð½Ð°Ð¹Ð´ÐµÑÐµ ÑÐµÐ½Ñ Ñ ÐºÐ¾Ð½ÐºÑÑÐµÐ½ÑÐ¾Ð² Ð´ÐµÑÐµÐ²Ð»Ðµ ÑÐµÐ¼ Ð½Ð°ÑÑ, Ð¿ÑÐ¸ Ð·Ð°Ð´Ð°Ð½Ð½ÑÑ Ð¿Ð°ÑÐ°Ð¼ÐµÑÑÐ°Ñ ÐºÐ¾Ð½ÑÑÑÑÐºÑÐ¸Ð¸, Ð·Ð²Ð¾Ð½Ð¸ÑÐµ Ð¼Ñ ÑÐ´ÐµÐ»Ð°ÐµÐ¼ Ð¿Ð¾ ÑÐµÐ½Ðµ ÐºÐ¾Ð½ÐºÑÑÐµÐ½ÑÐ¾Ð² "
                    ),
                  ]),
                ]),
              ]),
              e("p", { staticClass: "h2" }, [
                t._v(" ÐÐ°ÐºÐ°Ð¶Ð¸ÑÐµ Ð½Ð°Ð²ÐµÑ Ð¿Ð¾ ÑÐµÐ»ÐµÑÐ¾Ð½Ñ:"),
                e("br"),
                e("span", { staticClass: "phone" }, [
                  e("a", { attrs: { href: "tel:+74951516801" } }, [
                    t._v("+7(495)151-68-01"),
                  ]),
                ]),
              ]),
            ]);
          },
          function () {
            var t = this,
              e = t._self._c;
            return e("thead", [
              e("tr", [
                e("th", [t._v("â")]),
                e("th", [t._v("ÐÐ°Ð¸Ð¼ÐµÐ½Ð¾Ð²Ð°Ð½Ð¸Ðµ")]),
                e("th", [t._v("ÐÐ½Ð°ÑÐµÐ½Ð¸Ðµ")]),
              ]),
            ]);
          },
          function () {
            var t = this,
              e = t._self._c;
            return e("td", { attrs: { colspan: "3" } }, [
              e("b", [t._v("Ð¡ÑÐ¾Ð¸Ð¼Ð¾ÑÑÑ Ð½Ð°Ð²ÐµÑÐ°:")]),
            ]);
          },
          function () {
            var t = this,
              e = t._self._c;
            return e("td", { attrs: { colspan: "3" } }, [
              e("b", { staticClass: "red" }, [t._v("ÐÐ±ÑÐ°Ñ ÑÐºÐ¸Ð´ÐºÐ°:")]),
            ]);
          },
          function () {
            var t = this,
              e = t._self._c;
            return e("td", { attrs: { colspan: "3" } }, [
              e("b", [t._v("ÐÑÐ¾Ð³Ð¾ ÑÑÐ¾Ð¸Ð¼Ð¾ÑÑÑ Ð½Ð°Ð²ÐµÑÐ° (Ð¿Ð¾Ð´ ÐºÐ»ÑÑ):")]),
            ]);
          },
        ];
      n("14d9"), n("d9e2");
      /**
       * @license
       * Copyright 2010-2022 Three.js Authors
       * SPDX-License-Identifier: MIT
       */
      const l = "137",
        h = 0,
        u = 1,
        d = 2,
        p = 1,
        f = 2,
        m = 3,
        g = 0,
        v = 1,
        y = 2,
        x = 1,
        _ = 0,
        b = 1,
        w = 2,
        M = 3,
        S = 4,
        E = 5,
        T = 100,
        A = 101,
        C = 102,
        R = 103,
        L = 104,
        P = 200,
        D = 201,
        I = 202,
        O = 203,
        N = 204,
        B = 205,
        z = 206,
        U = 207,
        F = 208,
        H = 209,
        k = 210,
        G = 0,
        V = 1,
        W = 2,
        j = 3,
        q = 4,
        X = 5,
        Y = 6,
        J = 7,
        Z = 0,
        K = 1,
        Q = 2,
        tt = 0,
        et = 1,
        nt = 2,
        it = 3,
        rt = 4,
        at = 5,
        ot = 300,
        st = 301,
        ct = 302,
        lt = 303,
        ht = 304,
        ut = 306,
        dt = 307,
        pt = 1e3,
        ft = 1001,
        mt = 1002,
        gt = 1003,
        vt = 1004,
        yt = 1005,
        xt = 1006,
        _t = 1007,
        bt = 1008,
        wt = 1009,
        Mt = 1010,
        St = 1011,
        Et = 1012,
        Tt = 1013,
        At = 1014,
        Ct = 1015,
        Rt = 1016,
        Lt = 1017,
        Pt = 1018,
        Dt = 1020,
        It = 1021,
        Ot = 1022,
        Nt = 1023,
        Bt = 1024,
        zt = 1025,
        Ut = 1026,
        Ft = 1027,
        Ht = 1028,
        kt = 1029,
        Gt = 1030,
        Vt = 1031,
        Wt = 1033,
        jt = 33776,
        qt = 33777,
        Xt = 33778,
        Yt = 33779,
        Jt = 35840,
        Zt = 35841,
        Kt = 35842,
        $t = 35843,
        Qt = 36196,
        te = 37492,
        ee = 37496,
        ne = 37808,
        ie = 37809,
        re = 37810,
        ae = 37811,
        oe = 37812,
        se = 37813,
        ce = 37814,
        le = 37815,
        he = 37816,
        ue = 37817,
        de = 37818,
        pe = 37819,
        fe = 37820,
        me = 37821,
        ge = 36492,
        ve = 2200,
        ye = 2201,
        xe = 2202,
        _e = 2300,
        be = 2301,
        we = 2302,
        Me = 2400,
        Se = 2401,
        Ee = 2402,
        Te = 2500,
        Ae = 2501,
        Ce = 0,
        Re = 3e3,
        Le = 3001,
        Pe = 3200,
        De = 3201,
        Ie = 0,
        Oe = 1,
        Ne = 7680,
        Be = 519,
        ze = 35044,
        Ue = 35048,
        Fe = "300 es",
        He = 1035;
      class ke {
        addEventListener(t, e) {
          void 0 === this._listeners && (this._listeners = {});
          const n = this._listeners;
          void 0 === n[t] && (n[t] = []),
            -1 === n[t].indexOf(e) && n[t].push(e);
        }
        hasEventListener(t, e) {
          if (void 0 === this._listeners) return !1;
          const n = this._listeners;
          return void 0 !== n[t] && -1 !== n[t].indexOf(e);
        }
        removeEventListener(t, e) {
          if (void 0 === this._listeners) return;
          const n = this._listeners,
            i = n[t];
          if (void 0 !== i) {
            const t = i.indexOf(e);
            -1 !== t && i.splice(t, 1);
          }
        }
        dispatchEvent(t) {
          if (void 0 === this._listeners) return;
          const e = this._listeners,
            n = e[t.type];
          if (void 0 !== n) {
            t.target = this;
            const e = n.slice(0);
            for (let n = 0, i = e.length; n < i; n++) e[n].call(this, t);
            t.target = null;
          }
        }
      }
      const Ge = [];
      for (let $ = 0; $ < 256; $++)
        Ge[$] = ($ < 16 ? "0" : "") + $.toString(16);
      const Ve = Math.PI / 180,
        We = 180 / Math.PI;
      function je() {
        const t = (4294967295 * Math.random()) | 0,
          e = (4294967295 * Math.random()) | 0,
          n = (4294967295 * Math.random()) | 0,
          i = (4294967295 * Math.random()) | 0,
          r =
            Ge[255 & t] +
            Ge[(t >> 8) & 255] +
            Ge[(t >> 16) & 255] +
            Ge[(t >> 24) & 255] +
            "-" +
            Ge[255 & e] +
            Ge[(e >> 8) & 255] +
            "-" +
            Ge[((e >> 16) & 15) | 64] +
            Ge[(e >> 24) & 255] +
            "-" +
            Ge[(63 & n) | 128] +
            Ge[(n >> 8) & 255] +
            "-" +
            Ge[(n >> 16) & 255] +
            Ge[(n >> 24) & 255] +
            Ge[255 & i] +
            Ge[(i >> 8) & 255] +
            Ge[(i >> 16) & 255] +
            Ge[(i >> 24) & 255];
        return r.toUpperCase();
      }
      function qe(t, e, n) {
        return Math.max(e, Math.min(n, t));
      }
      function Xe(t, e) {
        return ((t % e) + e) % e;
      }
      function Ye(t, e, n) {
        return (1 - n) * t + n * e;
      }
      function Je(t) {
        return 0 === (t & (t - 1)) && 0 !== t;
      }
      function Ze(t) {
        return Math.pow(2, Math.ceil(Math.log(t) / Math.LN2));
      }
      function Ke(t) {
        return Math.pow(2, Math.floor(Math.log(t) / Math.LN2));
      }
      class $e {
        constructor(t = 0, e = 0) {
          (this.x = t), (this.y = e);
        }
        get width() {
          return this.x;
        }
        set width(t) {
          this.x = t;
        }
        get height() {
          return this.y;
        }
        set height(t) {
          this.y = t;
        }
        set(t, e) {
          return (this.x = t), (this.y = e), this;
        }
        setScalar(t) {
          return (this.x = t), (this.y = t), this;
        }
        setX(t) {
          return (this.x = t), this;
        }
        setY(t) {
          return (this.y = t), this;
        }
        setComponent(t, e) {
          switch (t) {
            case 0:
              this.x = e;
              break;
            case 1:
              this.y = e;
              break;
            default:
              throw new Error("index is out of range: " + t);
          }
          return this;
        }
        getComponent(t) {
          switch (t) {
            case 0:
              return this.x;
            case 1:
              return this.y;
            default:
              throw new Error("index is out of range: " + t);
          }
        }
        clone() {
          return new this.constructor(this.x, this.y);
        }
        copy(t) {
          return (this.x = t.x), (this.y = t.y), this;
        }
        add(t, e) {
          return void 0 !== e
            ? (console.warn(
                "THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."
              ),
              this.addVectors(t, e))
            : ((this.x += t.x), (this.y += t.y), this);
        }
        addScalar(t) {
          return (this.x += t), (this.y += t), this;
        }
        addVectors(t, e) {
          return (this.x = t.x + e.x), (this.y = t.y + e.y), this;
        }
        addScaledVector(t, e) {
          return (this.x += t.x * e), (this.y += t.y * e), this;
        }
        sub(t, e) {
          return void 0 !== e
            ? (console.warn(
                "THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."
              ),
              this.subVectors(t, e))
            : ((this.x -= t.x), (this.y -= t.y), this);
        }
        subScalar(t) {
          return (this.x -= t), (this.y -= t), this;
        }
        subVectors(t, e) {
          return (this.x = t.x - e.x), (this.y = t.y - e.y), this;
        }
        multiply(t) {
          return (this.x *= t.x), (this.y *= t.y), this;
        }
        multiplyScalar(t) {
          return (this.x *= t), (this.y *= t), this;
        }
        divide(t) {
          return (this.x /= t.x), (this.y /= t.y), this;
        }
        divideScalar(t) {
          return this.multiplyScalar(1 / t);
        }
        applyMatrix3(t) {
          const e = this.x,
            n = this.y,
            i = t.elements;
          return (
            (this.x = i[0] * e + i[3] * n + i[6]),
            (this.y = i[1] * e + i[4] * n + i[7]),
            this
          );
        }
        min(t) {
          return (
            (this.x = Math.min(this.x, t.x)),
            (this.y = Math.min(this.y, t.y)),
            this
          );
        }
        max(t) {
          return (
            (this.x = Math.max(this.x, t.x)),
            (this.y = Math.max(this.y, t.y)),
            this
          );
        }
        clamp(t, e) {
          return (
            (this.x = Math.max(t.x, Math.min(e.x, this.x))),
            (this.y = Math.max(t.y, Math.min(e.y, this.y))),
            this
          );
        }
        clampScalar(t, e) {
          return (
            (this.x = Math.max(t, Math.min(e, this.x))),
            (this.y = Math.max(t, Math.min(e, this.y))),
            this
          );
        }
        clampLength(t, e) {
          const n = this.length();
          return this.divideScalar(n || 1).multiplyScalar(
            Math.max(t, Math.min(e, n))
          );
        }
        floor() {
          return (
            (this.x = Math.floor(this.x)), (this.y = Math.floor(this.y)), this
          );
        }
        ceil() {
          return (
            (this.x = Math.ceil(this.x)), (this.y = Math.ceil(this.y)), this
          );
        }
        round() {
          return (
            (this.x = Math.round(this.x)), (this.y = Math.round(this.y)), this
          );
        }
        roundToZero() {
          return (
            (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
            (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
            this
          );
        }
        negate() {
          return (this.x = -this.x), (this.y = -this.y), this;
        }
        dot(t) {
          return this.x * t.x + this.y * t.y;
        }
        cross(t) {
          return this.x * t.y - this.y * t.x;
        }
        lengthSq() {
          return this.x * this.x + this.y * this.y;
        }
        length() {
          return Math.sqrt(this.x * this.x + this.y * this.y);
        }
        manhattanLength() {
          return Math.abs(this.x) + Math.abs(this.y);
        }
        normalize() {
          return this.divideScalar(this.length() || 1);
        }
        angle() {
          const t = Math.atan2(-this.y, -this.x) + Math.PI;
          return t;
        }
        distanceTo(t) {
          return Math.sqrt(this.distanceToSquared(t));
        }
        distanceToSquared(t) {
          const e = this.x - t.x,
            n = this.y - t.y;
          return e * e + n * n;
        }
        manhattanDistanceTo(t) {
          return Math.abs(this.x - t.x) + Math.abs(this.y - t.y);
        }
        setLength(t) {
          return this.normalize().multiplyScalar(t);
        }
        lerp(t, e) {
          return (
            (this.x += (t.x - this.x) * e), (this.y += (t.y - this.y) * e), this
          );
        }
        lerpVectors(t, e, n) {
          return (
            (this.x = t.x + (e.x - t.x) * n),
            (this.y = t.y + (e.y - t.y) * n),
            this
          );
        }
        equals(t) {
          return t.x === this.x && t.y === this.y;
        }
        fromArray(t, e = 0) {
          return (this.x = t[e]), (this.y = t[e + 1]), this;
        }
        toArray(t = [], e = 0) {
          return (t[e] = this.x), (t[e + 1] = this.y), t;
        }
        fromBufferAttribute(t, e, n) {
          return (
            void 0 !== n &&
              console.warn(
                "THREE.Vector2: offset has been removed from .fromBufferAttribute()."
              ),
            (this.x = t.getX(e)),
            (this.y = t.getY(e)),
            this
          );
        }
        rotateAround(t, e) {
          const n = Math.cos(e),
            i = Math.sin(e),
            r = this.x - t.x,
            a = this.y - t.y;
          return (
            (this.x = r * n - a * i + t.x), (this.y = r * i + a * n + t.y), this
          );
        }
        random() {
          return (this.x = Math.random()), (this.y = Math.random()), this;
        }
        *[Symbol.iterator]() {
          yield this.x, yield this.y;
        }
      }
      $e.prototype.isVector2 = !0;
      class Qe {
        constructor() {
          (this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
            arguments.length > 0 &&
              console.error(
                "THREE.Matrix3: the constructor no longer reads arguments. use .set() instead."
              );
        }
        set(t, e, n, i, r, a, o, s, c) {
          const l = this.elements;
          return (
            (l[0] = t),
            (l[1] = i),
            (l[2] = o),
            (l[3] = e),
            (l[4] = r),
            (l[5] = s),
            (l[6] = n),
            (l[7] = a),
            (l[8] = c),
            this
          );
        }
        identity() {
          return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
        }
        copy(t) {
          const e = this.elements,
            n = t.elements;
          return (
            (e[0] = n[0]),
            (e[1] = n[1]),
            (e[2] = n[2]),
            (e[3] = n[3]),
            (e[4] = n[4]),
            (e[5] = n[5]),
            (e[6] = n[6]),
            (e[7] = n[7]),
            (e[8] = n[8]),
            this
          );
        }
        extractBasis(t, e, n) {
          return (
            t.setFromMatrix3Column(this, 0),
            e.setFromMatrix3Column(this, 1),
            n.setFromMatrix3Column(this, 2),
            this
          );
        }
        setFromMatrix4(t) {
          const e = t.elements;
          return (
            this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]),
            this
          );
        }
        multiply(t) {
          return this.multiplyMatrices(this, t);
        }
        premultiply(t) {
          return this.multiplyMatrices(t, this);
        }
        multiplyMatrices(t, e) {
          const n = t.elements,
            i = e.elements,
            r = this.elements,
            a = n[0],
            o = n[3],
            s = n[6],
            c = n[1],
            l = n[4],
            h = n[7],
            u = n[2],
            d = n[5],
            p = n[8],
            f = i[0],
            m = i[3],
            g = i[6],
            v = i[1],
            y = i[4],
            x = i[7],
            _ = i[2],
            b = i[5],
            w = i[8];
          return (
            (r[0] = a * f + o * v + s * _),
            (r[3] = a * m + o * y + s * b),
            (r[6] = a * g + o * x + s * w),
            (r[1] = c * f + l * v + h * _),
            (r[4] = c * m + l * y + h * b),
            (r[7] = c * g + l * x + h * w),
            (r[2] = u * f + d * v + p * _),
            (r[5] = u * m + d * y + p * b),
            (r[8] = u * g + d * x + p * w),
            this
          );
        }
        multiplyScalar(t) {
          const e = this.elements;
          return (
            (e[0] *= t),
            (e[3] *= t),
            (e[6] *= t),
            (e[1] *= t),
            (e[4] *= t),
            (e[7] *= t),
            (e[2] *= t),
            (e[5] *= t),
            (e[8] *= t),
            this
          );
        }
        determinant() {
          const t = this.elements,
            e = t[0],
            n = t[1],
            i = t[2],
            r = t[3],
            a = t[4],
            o = t[5],
            s = t[6],
            c = t[7],
            l = t[8];
          return (
            e * a * l -
            e * o * c -
            n * r * l +
            n * o * s +
            i * r * c -
            i * a * s
          );
        }
        invert() {
          const t = this.elements,
            e = t[0],
            n = t[1],
            i = t[2],
            r = t[3],
            a = t[4],
            o = t[5],
            s = t[6],
            c = t[7],
            l = t[8],
            h = l * a - o * c,
            u = o * s - l * r,
            d = c * r - a * s,
            p = e * h + n * u + i * d;
          if (0 === p) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
          const f = 1 / p;
          return (
            (t[0] = h * f),
            (t[1] = (i * c - l * n) * f),
            (t[2] = (o * n - i * a) * f),
            (t[3] = u * f),
            (t[4] = (l * e - i * s) * f),
            (t[5] = (i * r - o * e) * f),
            (t[6] = d * f),
            (t[7] = (n * s - c * e) * f),
            (t[8] = (a * e - n * r) * f),
            this
          );
        }
        transpose() {
          let t;
          const e = this.elements;
          return (
            (t = e[1]),
            (e[1] = e[3]),
            (e[3] = t),
            (t = e[2]),
            (e[2] = e[6]),
            (e[6] = t),
            (t = e[5]),
            (e[5] = e[7]),
            (e[7] = t),
            this
          );
        }
        getNormalMatrix(t) {
          return this.setFromMatrix4(t).invert().transpose();
        }
        transposeIntoArray(t) {
          const e = this.elements;
          return (
            (t[0] = e[0]),
            (t[1] = e[3]),
            (t[2] = e[6]),
            (t[3] = e[1]),
            (t[4] = e[4]),
            (t[5] = e[7]),
            (t[6] = e[2]),
            (t[7] = e[5]),
            (t[8] = e[8]),
            this
          );
        }
        setUvTransform(t, e, n, i, r, a, o) {
          const s = Math.cos(r),
            c = Math.sin(r);
          return (
            this.set(
              n * s,
              n * c,
              -n * (s * a + c * o) + a + t,
              -i * c,
              i * s,
              -i * (-c * a + s * o) + o + e,
              0,
              0,
              1
            ),
            this
          );
        }
        scale(t, e) {
          const n = this.elements;
          return (
            (n[0] *= t),
            (n[3] *= t),
            (n[6] *= t),
            (n[1] *= e),
            (n[4] *= e),
            (n[7] *= e),
            this
          );
        }
        rotate(t) {
          const e = Math.cos(t),
            n = Math.sin(t),
            i = this.elements,
            r = i[0],
            a = i[3],
            o = i[6],
            s = i[1],
            c = i[4],
            l = i[7];
          return (
            (i[0] = e * r + n * s),
            (i[3] = e * a + n * c),
            (i[6] = e * o + n * l),
            (i[1] = -n * r + e * s),
            (i[4] = -n * a + e * c),
            (i[7] = -n * o + e * l),
            this
          );
        }
        translate(t, e) {
          const n = this.elements;
          return (
            (n[0] += t * n[2]),
            (n[3] += t * n[5]),
            (n[6] += t * n[8]),
            (n[1] += e * n[2]),
            (n[4] += e * n[5]),
            (n[7] += e * n[8]),
            this
          );
        }
        equals(t) {
          const e = this.elements,
            n = t.elements;
          for (let i = 0; i < 9; i++) if (e[i] !== n[i]) return !1;
          return !0;
        }
        fromArray(t, e = 0) {
          for (let n = 0; n < 9; n++) this.elements[n] = t[n + e];
          return this;
        }
        toArray(t = [], e = 0) {
          const n = this.elements;
          return (
            (t[e] = n[0]),
            (t[e + 1] = n[1]),
            (t[e + 2] = n[2]),
            (t[e + 3] = n[3]),
            (t[e + 4] = n[4]),
            (t[e + 5] = n[5]),
            (t[e + 6] = n[6]),
            (t[e + 7] = n[7]),
            (t[e + 8] = n[8]),
            t
          );
        }
        clone() {
          return new this.constructor().fromArray(this.elements);
        }
      }
      function tn(t) {
        for (let e = t.length - 1; e >= 0; --e) if (t[e] > 65535) return !0;
        return !1;
      }
      Qe.prototype.isMatrix3 = !0;
      const en = {
        Int8Array: Int8Array,
        Uint8Array: Uint8Array,
        Uint8ClampedArray: Uint8ClampedArray,
        Int16Array: Int16Array,
        Uint16Array: Uint16Array,
        Int32Array: Int32Array,
        Uint32Array: Uint32Array,
        Float32Array: Float32Array,
        Float64Array: Float64Array,
      };
      function nn(t, e) {
        return new en[t](e);
      }
      function rn(t) {
        return document.createElementNS("http://www.w3.org/1999/xhtml", t);
      }
      const an = {
          aliceblue: 15792383,
          antiquewhite: 16444375,
          aqua: 65535,
          aquamarine: 8388564,
          azure: 15794175,
          beige: 16119260,
          bisque: 16770244,
          black: 0,
          blanchedalmond: 16772045,
          blue: 255,
          blueviolet: 9055202,
          brown: 10824234,
          burlywood: 14596231,
          cadetblue: 6266528,
          chartreuse: 8388352,
          chocolate: 13789470,
          coral: 16744272,
          cornflowerblue: 6591981,
          cornsilk: 16775388,
          crimson: 14423100,
          cyan: 65535,
          darkblue: 139,
          darkcyan: 35723,
          darkgoldenrod: 12092939,
          darkgray: 11119017,
          darkgreen: 25600,
          darkgrey: 11119017,
          darkkhaki: 12433259,
          darkmagenta: 9109643,
          darkolivegreen: 5597999,
          darkorange: 16747520,
          darkorchid: 10040012,
          darkred: 9109504,
          darksalmon: 15308410,
          darkseagreen: 9419919,
          darkslateblue: 4734347,
          darkslategray: 3100495,
          darkslategrey: 3100495,
          darkturquoise: 52945,
          darkviolet: 9699539,
          deeppink: 16716947,
          deepskyblue: 49151,
          dimgray: 6908265,
          dimgrey: 6908265,
          dodgerblue: 2003199,
          firebrick: 11674146,
          floralwhite: 16775920,
          forestgreen: 2263842,
          fuchsia: 16711935,
          gainsboro: 14474460,
          ghostwhite: 16316671,
          gold: 16766720,
          goldenrod: 14329120,
          gray: 8421504,
          green: 32768,
          greenyellow: 11403055,
          grey: 8421504,
          honeydew: 15794160,
          hotpink: 16738740,
          indianred: 13458524,
          indigo: 4915330,
          ivory: 16777200,
          khaki: 15787660,
          lavender: 15132410,
          lavenderblush: 16773365,
          lawngreen: 8190976,
          lemonchiffon: 16775885,
          lightblue: 11393254,
          lightcoral: 15761536,
          lightcyan: 14745599,
          lightgoldenrodyellow: 16448210,
          lightgray: 13882323,
          lightgreen: 9498256,
          lightgrey: 13882323,
          lightpink: 16758465,
          lightsalmon: 16752762,
          lightseagreen: 2142890,
          lightskyblue: 8900346,
          lightslategray: 7833753,
          lightslategrey: 7833753,
          lightsteelblue: 11584734,
          lightyellow: 16777184,
          lime: 65280,
          limegreen: 3329330,
          linen: 16445670,
          magenta: 16711935,
          maroon: 8388608,
          mediumaquamarine: 6737322,
          mediumblue: 205,
          mediumorchid: 12211667,
          mediumpurple: 9662683,
          mediumseagreen: 3978097,
          mediumslateblue: 8087790,
          mediumspringgreen: 64154,
          mediumturquoise: 4772300,
          mediumvioletred: 13047173,
          midnightblue: 1644912,
          mintcream: 16121850,
          mistyrose: 16770273,
          moccasin: 16770229,
          navajowhite: 16768685,
          navy: 128,
          oldlace: 16643558,
          olive: 8421376,
          olivedrab: 7048739,
          orange: 16753920,
          orangered: 16729344,
          orchid: 14315734,
          palegoldenrod: 15657130,
          palegreen: 10025880,
          paleturquoise: 11529966,
          palevioletred: 14381203,
          papayawhip: 16773077,
          peachpuff: 16767673,
          peru: 13468991,
          pink: 16761035,
          plum: 14524637,
          powderblue: 11591910,
          purple: 8388736,
          rebeccapurple: 6697881,
          red: 16711680,
          rosybrown: 12357519,
          royalblue: 4286945,
          saddlebrown: 9127187,
          salmon: 16416882,
          sandybrown: 16032864,
          seagreen: 3050327,
          seashell: 16774638,
          sienna: 10506797,
          silver: 12632256,
          skyblue: 8900331,
          slateblue: 6970061,
          slategray: 7372944,
          slategrey: 7372944,
          snow: 16775930,
          springgreen: 65407,
          steelblue: 4620980,
          tan: 13808780,
          teal: 32896,
          thistle: 14204888,
          tomato: 16737095,
          turquoise: 4251856,
          violet: 15631086,
          wheat: 16113331,
          white: 16777215,
          whitesmoke: 16119285,
          yellow: 16776960,
          yellowgreen: 10145074,
        },
        on = { h: 0, s: 0, l: 0 },
        sn = { h: 0, s: 0, l: 0 };
      function cn(t, e, n) {
        return (
          n < 0 && (n += 1),
          n > 1 && (n -= 1),
          n < 1 / 6
            ? t + 6 * (e - t) * n
            : n < 0.5
            ? e
            : n < 2 / 3
            ? t + 6 * (e - t) * (2 / 3 - n)
            : t
        );
      }
      function ln(t) {
        return t < 0.04045
          ? 0.0773993808 * t
          : Math.pow(0.9478672986 * t + 0.0521327014, 2.4);
      }
      function hn(t) {
        return t < 0.0031308 ? 12.92 * t : 1.055 * Math.pow(t, 0.41666) - 0.055;
      }
      class un {
        constructor(t, e, n) {
          return void 0 === e && void 0 === n
            ? this.set(t)
            : this.setRGB(t, e, n);
        }
        set(t) {
          return (
            t && t.isColor
              ? this.copy(t)
              : "number" === typeof t
              ? this.setHex(t)
              : "string" === typeof t && this.setStyle(t),
            this
          );
        }
        setScalar(t) {
          return (this.r = t), (this.g = t), (this.b = t), this;
        }
        setHex(t) {
          return (
            (t = Math.floor(t)),
            (this.r = ((t >> 16) & 255) / 255),
            (this.g = ((t >> 8) & 255) / 255),
            (this.b = (255 & t) / 255),
            this
          );
        }
        setRGB(t, e, n) {
          return (this.r = t), (this.g = e), (this.b = n), this;
        }
        setHSL(t, e, n) {
          if (((t = Xe(t, 1)), (e = qe(e, 0, 1)), (n = qe(n, 0, 1)), 0 === e))
            this.r = this.g = this.b = n;
          else {
            const i = n <= 0.5 ? n * (1 + e) : n + e - n * e,
              r = 2 * n - i;
            (this.r = cn(r, i, t + 1 / 3)),
              (this.g = cn(r, i, t)),
              (this.b = cn(r, i, t - 1 / 3));
          }
          return this;
        }
        setStyle(t) {
          function e(e) {
            void 0 !== e &&
              parseFloat(e) < 1 &&
              console.warn(
                "THREE.Color: Alpha component of " + t + " will be ignored."
              );
          }
          let n;
          if ((n = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(t))) {
            let t;
            const i = n[1],
              r = n[2];
            switch (i) {
              case "rgb":
              case "rgba":
                if (
                  (t =
                    /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                      r
                    ))
                )
                  return (
                    (this.r = Math.min(255, parseInt(t[1], 10)) / 255),
                    (this.g = Math.min(255, parseInt(t[2], 10)) / 255),
                    (this.b = Math.min(255, parseInt(t[3], 10)) / 255),
                    e(t[4]),
                    this
                  );
                if (
                  (t =
                    /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                      r
                    ))
                )
                  return (
                    (this.r = Math.min(100, parseInt(t[1], 10)) / 100),
                    (this.g = Math.min(100, parseInt(t[2], 10)) / 100),
                    (this.b = Math.min(100, parseInt(t[3], 10)) / 100),
                    e(t[4]),
                    this
                  );
                break;
              case "hsl":
              case "hsla":
                if (
                  (t =
                    /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                      r
                    ))
                ) {
                  const n = parseFloat(t[1]) / 360,
                    i = parseInt(t[2], 10) / 100,
                    r = parseInt(t[3], 10) / 100;
                  return e(t[4]), this.setHSL(n, i, r);
                }
                break;
            }
          } else if ((n = /^\#([A-Fa-f\d]+)$/.exec(t))) {
            const t = n[1],
              e = t.length;
            if (3 === e)
              return (
                (this.r = parseInt(t.charAt(0) + t.charAt(0), 16) / 255),
                (this.g = parseInt(t.charAt(1) + t.charAt(1), 16) / 255),
                (this.b = parseInt(t.charAt(2) + t.charAt(2), 16) / 255),
                this
              );
            if (6 === e)
              return (
                (this.r = parseInt(t.charAt(0) + t.charAt(1), 16) / 255),
                (this.g = parseInt(t.charAt(2) + t.charAt(3), 16) / 255),
                (this.b = parseInt(t.charAt(4) + t.charAt(5), 16) / 255),
                this
              );
          }
          return t && t.length > 0 ? this.setColorName(t) : this;
        }
        setColorName(t) {
          const e = an[t.toLowerCase()];
          return (
            void 0 !== e
              ? this.setHex(e)
              : console.warn("THREE.Color: Unknown color " + t),
            this
          );
        }
        clone() {
          return new this.constructor(this.r, this.g, this.b);
        }
        copy(t) {
          return (this.r = t.r), (this.g = t.g), (this.b = t.b), this;
        }
        copySRGBToLinear(t) {
          return (
            (this.r = ln(t.r)), (this.g = ln(t.g)), (this.b = ln(t.b)), this
          );
        }
        copyLinearToSRGB(t) {
          return (
            (this.r = hn(t.r)), (this.g = hn(t.g)), (this.b = hn(t.b)), this
          );
        }
        convertSRGBToLinear() {
          return this.copySRGBToLinear(this), this;
        }
        convertLinearToSRGB() {
          return this.copyLinearToSRGB(this), this;
        }
        getHex() {
          return (
            ((255 * this.r) << 16) ^
            ((255 * this.g) << 8) ^
            ((255 * this.b) << 0)
          );
        }
        getHexString() {
          return ("000000" + this.getHex().toString(16)).slice(-6);
        }
        getHSL(t) {
          const e = this.r,
            n = this.g,
            i = this.b,
            r = Math.max(e, n, i),
            a = Math.min(e, n, i);
          let o, s;
          const c = (a + r) / 2;
          if (a === r) (o = 0), (s = 0);
          else {
            const t = r - a;
            switch (((s = c <= 0.5 ? t / (r + a) : t / (2 - r - a)), r)) {
              case e:
                o = (n - i) / t + (n < i ? 6 : 0);
                break;
              case n:
                o = (i - e) / t + 2;
                break;
              case i:
                o = (e - n) / t + 4;
                break;
            }
            o /= 6;
          }
          return (t.h = o), (t.s = s), (t.l = c), t;
        }
        getStyle() {
          return (
            "rgb(" +
            ((255 * this.r) | 0) +
            "," +
            ((255 * this.g) | 0) +
            "," +
            ((255 * this.b) | 0) +
            ")"
          );
        }
        offsetHSL(t, e, n) {
          return (
            this.getHSL(on),
            (on.h += t),
            (on.s += e),
            (on.l += n),
            this.setHSL(on.h, on.s, on.l),
            this
          );
        }
        add(t) {
          return (this.r += t.r), (this.g += t.g), (this.b += t.b), this;
        }
        addColors(t, e) {
          return (
            (this.r = t.r + e.r),
            (this.g = t.g + e.g),
            (this.b = t.b + e.b),
            this
          );
        }
        addScalar(t) {
          return (this.r += t), (this.g += t), (this.b += t), this;
        }
        sub(t) {
          return (
            (this.r = Math.max(0, this.r - t.r)),
            (this.g = Math.max(0, this.g - t.g)),
            (this.b = Math.max(0, this.b - t.b)),
            this
          );
        }
        multiply(t) {
          return (this.r *= t.r), (this.g *= t.g), (this.b *= t.b), this;
        }
        multiplyScalar(t) {
          return (this.r *= t), (this.g *= t), (this.b *= t), this;
        }
        lerp(t, e) {
          return (
            (this.r += (t.r - this.r) * e),
            (this.g += (t.g - this.g) * e),
            (this.b += (t.b - this.b) * e),
            this
          );
        }
        lerpColors(t, e, n) {
          return (
            (this.r = t.r + (e.r - t.r) * n),
            (this.g = t.g + (e.g - t.g) * n),
            (this.b = t.b + (e.b - t.b) * n),
            this
          );
        }
        lerpHSL(t, e) {
          this.getHSL(on), t.getHSL(sn);
          const n = Ye(on.h, sn.h, e),
            i = Ye(on.s, sn.s, e),
            r = Ye(on.l, sn.l, e);
          return this.setHSL(n, i, r), this;
        }
        equals(t) {
          return t.r === this.r && t.g === this.g && t.b === this.b;
        }
        fromArray(t, e = 0) {
          return (
            (this.r = t[e]), (this.g = t[e + 1]), (this.b = t[e + 2]), this
          );
        }
        toArray(t = [], e = 0) {
          return (t[e] = this.r), (t[e + 1] = this.g), (t[e + 2] = this.b), t;
        }
        fromBufferAttribute(t, e) {
          return (
            (this.r = t.getX(e)),
            (this.g = t.getY(e)),
            (this.b = t.getZ(e)),
            !0 === t.normalized &&
              ((this.r /= 255), (this.g /= 255), (this.b /= 255)),
            this
          );
        }
        toJSON() {
          return this.getHex();
        }
      }
      let dn;
      (un.NAMES = an),
        (un.prototype.isColor = !0),
        (un.prototype.r = 1),
        (un.prototype.g = 1),
        (un.prototype.b = 1);
      class pn {
        static getDataURL(t) {
          if (/^data:/i.test(t.src)) return t.src;
          if ("undefined" == typeof HTMLCanvasElement) return t.src;
          let e;
          if (t instanceof HTMLCanvasElement) e = t;
          else {
            void 0 === dn && (dn = rn("canvas")),
              (dn.width = t.width),
              (dn.height = t.height);
            const n = dn.getContext("2d");
            t instanceof ImageData
              ? n.putImageData(t, 0, 0)
              : n.drawImage(t, 0, 0, t.width, t.height),
              (e = dn);
          }
          return e.width > 2048 || e.height > 2048
            ? (console.warn(
                "THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",
                t
              ),
              e.toDataURL("image/jpeg", 0.6))
            : e.toDataURL("image/png");
        }
        static sRGBToLinear(t) {
          if (
            ("undefined" !== typeof HTMLImageElement &&
              t instanceof HTMLImageElement) ||
            ("undefined" !== typeof HTMLCanvasElement &&
              t instanceof HTMLCanvasElement) ||
            ("undefined" !== typeof ImageBitmap && t instanceof ImageBitmap)
          ) {
            const e = rn("canvas");
            (e.width = t.width), (e.height = t.height);
            const n = e.getContext("2d");
            n.drawImage(t, 0, 0, t.width, t.height);
            const i = n.getImageData(0, 0, t.width, t.height),
              r = i.data;
            for (let t = 0; t < r.length; t++) r[t] = 255 * ln(r[t] / 255);
            return n.putImageData(i, 0, 0), e;
          }
          if (t.data) {
            const e = t.data.slice(0);
            for (let t = 0; t < e.length; t++)
              e instanceof Uint8Array || e instanceof Uint8ClampedArray
                ? (e[t] = Math.floor(255 * ln(e[t] / 255)))
                : (e[t] = ln(e[t]));
            return { data: e, width: t.width, height: t.height };
          }
          return (
            console.warn(
              "THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."
            ),
            t
          );
        }
      }
      let fn = 0;
      class mn extends ke {
        constructor(
          t = mn.DEFAULT_IMAGE,
          e = mn.DEFAULT_MAPPING,
          n = ft,
          i = ft,
          r = xt,
          a = bt,
          o = Nt,
          s = wt,
          c = 1,
          l = Re
        ) {
          super(),
            Object.defineProperty(this, "id", { value: fn++ }),
            (this.uuid = je()),
            (this.name = ""),
            (this.image = t),
            (this.mipmaps = []),
            (this.mapping = e),
            (this.wrapS = n),
            (this.wrapT = i),
            (this.magFilter = r),
            (this.minFilter = a),
            (this.anisotropy = c),
            (this.format = o),
            (this.internalFormat = null),
            (this.type = s),
            (this.offset = new $e(0, 0)),
            (this.repeat = new $e(1, 1)),
            (this.center = new $e(0, 0)),
            (this.rotation = 0),
            (this.matrixAutoUpdate = !0),
            (this.matrix = new Qe()),
            (this.generateMipmaps = !0),
            (this.premultiplyAlpha = !1),
            (this.flipY = !0),
            (this.unpackAlignment = 4),
            (this.encoding = l),
            (this.userData = {}),
            (this.version = 0),
            (this.onUpdate = null),
            (this.isRenderTargetTexture = !1),
            (this.needsPMREMUpdate = !1);
        }
        updateMatrix() {
          this.matrix.setUvTransform(
            this.offset.x,
            this.offset.y,
            this.repeat.x,
            this.repeat.y,
            this.rotation,
            this.center.x,
            this.center.y
          );
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(t) {
          return (
            (this.name = t.name),
            (this.image = t.image),
            (this.mipmaps = t.mipmaps.slice(0)),
            (this.mapping = t.mapping),
            (this.wrapS = t.wrapS),
            (this.wrapT = t.wrapT),
            (this.magFilter = t.magFilter),
            (this.minFilter = t.minFilter),
            (this.anisotropy = t.anisotropy),
            (this.format = t.format),
            (this.internalFormat = t.internalFormat),
            (this.type = t.type),
            this.offset.copy(t.offset),
            this.repeat.copy(t.repeat),
            this.center.copy(t.center),
            (this.rotation = t.rotation),
            (this.matrixAutoUpdate = t.matrixAutoUpdate),
            this.matrix.copy(t.matrix),
            (this.generateMipmaps = t.generateMipmaps),
            (this.premultiplyAlpha = t.premultiplyAlpha),
            (this.flipY = t.flipY),
            (this.unpackAlignment = t.unpackAlignment),
            (this.encoding = t.encoding),
            (this.userData = JSON.parse(JSON.stringify(t.userData))),
            this
          );
        }
        toJSON(t) {
          const e = void 0 === t || "string" === typeof t;
          if (!e && void 0 !== t.textures[this.uuid])
            return t.textures[this.uuid];
          const n = {
            metadata: {
              version: 4.5,
              type: "Texture",
              generator: "Texture.toJSON",
            },
            uuid: this.uuid,
            name: this.name,
            mapping: this.mapping,
            repeat: [this.repeat.x, this.repeat.y],
            offset: [this.offset.x, this.offset.y],
            center: [this.center.x, this.center.y],
            rotation: this.rotation,
            wrap: [this.wrapS, this.wrapT],
            format: this.format,
            type: this.type,
            encoding: this.encoding,
            minFilter: this.minFilter,
            magFilter: this.magFilter,
            anisotropy: this.anisotropy,
            flipY: this.flipY,
            premultiplyAlpha: this.premultiplyAlpha,
            unpackAlignment: this.unpackAlignment,
          };
          if (void 0 !== this.image) {
            const i = this.image;
            if (
              (void 0 === i.uuid && (i.uuid = je()),
              !e && void 0 === t.images[i.uuid])
            ) {
              let e;
              if (Array.isArray(i)) {
                e = [];
                for (let t = 0, n = i.length; t < n; t++)
                  i[t].isDataTexture
                    ? e.push(gn(i[t].image))
                    : e.push(gn(i[t]));
              } else e = gn(i);
              t.images[i.uuid] = { uuid: i.uuid, url: e };
            }
            n.image = i.uuid;
          }
          return (
            "{}" !== JSON.stringify(this.userData) &&
              (n.userData = this.userData),
            e || (t.textures[this.uuid] = n),
            n
          );
        }
        dispose() {
          this.dispatchEvent({ type: "dispose" });
        }
        transformUv(t) {
          if (this.mapping !== ot) return t;
          if ((t.applyMatrix3(this.matrix), t.x < 0 || t.x > 1))
            switch (this.wrapS) {
              case pt:
                t.x = t.x - Math.floor(t.x);
                break;
              case ft:
                t.x = t.x < 0 ? 0 : 1;
                break;
              case mt:
                1 === Math.abs(Math.floor(t.x) % 2)
                  ? (t.x = Math.ceil(t.x) - t.x)
                  : (t.x = t.x - Math.floor(t.x));
                break;
            }
          if (t.y < 0 || t.y > 1)
            switch (this.wrapT) {
              case pt:
                t.y = t.y - Math.floor(t.y);
                break;
              case ft:
                t.y = t.y < 0 ? 0 : 1;
                break;
              case mt:
                1 === Math.abs(Math.floor(t.y) % 2)
                  ? (t.y = Math.ceil(t.y) - t.y)
                  : (t.y = t.y - Math.floor(t.y));
                break;
            }
          return this.flipY && (t.y = 1 - t.y), t;
        }
        set needsUpdate(t) {
          !0 === t && this.version++;
        }
      }
      function gn(t) {
        return ("undefined" !== typeof HTMLImageElement &&
          t instanceof HTMLImageElement) ||
          ("undefined" !== typeof HTMLCanvasElement &&
            t instanceof HTMLCanvasElement) ||
          ("undefined" !== typeof ImageBitmap && t instanceof ImageBitmap)
          ? pn.getDataURL(t)
          : t.data
          ? {
              data: Array.prototype.slice.call(t.data),
              width: t.width,
              height: t.height,
              type: t.data.constructor.name,
            }
          : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
      }
      (mn.DEFAULT_IMAGE = void 0),
        (mn.DEFAULT_MAPPING = ot),
        (mn.prototype.isTexture = !0);
      class vn {
        constructor(t = 0, e = 0, n = 0, i = 1) {
          (this.x = t), (this.y = e), (this.z = n), (this.w = i);
        }
        get width() {
          return this.z;
        }
        set width(t) {
          this.z = t;
        }
        get height() {
          return this.w;
        }
        set height(t) {
          this.w = t;
        }
        set(t, e, n, i) {
          return (this.x = t), (this.y = e), (this.z = n), (this.w = i), this;
        }
        setScalar(t) {
          return (this.x = t), (this.y = t), (this.z = t), (this.w = t), this;
        }
        setX(t) {
          return (this.x = t), this;
        }
        setY(t) {
          return (this.y = t), this;
        }
        setZ(t) {
          return (this.z = t), this;
        }
        setW(t) {
          return (this.w = t), this;
        }
        setComponent(t, e) {
          switch (t) {
            case 0:
              this.x = e;
              break;
            case 1:
              this.y = e;
              break;
            case 2:
              this.z = e;
              break;
            case 3:
              this.w = e;
              break;
            default:
              throw new Error("index is out of range: " + t);
          }
          return this;
        }
        getComponent(t) {
          switch (t) {
            case 0:
              return this.x;
            case 1:
              return this.y;
            case 2:
              return this.z;
            case 3:
              return this.w;
            default:
              throw new Error("index is out of range: " + t);
          }
        }
        clone() {
          return new this.constructor(this.x, this.y, this.z, this.w);
        }
        copy(t) {
          return (
            (this.x = t.x),
            (this.y = t.y),
            (this.z = t.z),
            (this.w = void 0 !== t.w ? t.w : 1),
            this
          );
        }
        add(t, e) {
          return void 0 !== e
            ? (console.warn(
                "THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."
              ),
              this.addVectors(t, e))
            : ((this.x += t.x),
              (this.y += t.y),
              (this.z += t.z),
              (this.w += t.w),
              this);
        }
        addScalar(t) {
          return (
            (this.x += t), (this.y += t), (this.z += t), (this.w += t), this
          );
        }
        addVectors(t, e) {
          return (
            (this.x = t.x + e.x),
            (this.y = t.y + e.y),
            (this.z = t.z + e.z),
            (this.w = t.w + e.w),
            this
          );
        }
        addScaledVector(t, e) {
          return (
            (this.x += t.x * e),
            (this.y += t.y * e),
            (this.z += t.z * e),
            (this.w += t.w * e),
            this
          );
        }
        sub(t, e) {
          return void 0 !== e
            ? (console.warn(
                "THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."
              ),
              this.subVectors(t, e))
            : ((this.x -= t.x),
              (this.y -= t.y),
              (this.z -= t.z),
              (this.w -= t.w),
              this);
        }
        subScalar(t) {
          return (
            (this.x -= t), (this.y -= t), (this.z -= t), (this.w -= t), this
          );
        }
        subVectors(t, e) {
          return (
            (this.x = t.x - e.x),
            (this.y = t.y - e.y),
            (this.z = t.z - e.z),
            (this.w = t.w - e.w),
            this
          );
        }
        multiply(t) {
          return (
            (this.x *= t.x),
            (this.y *= t.y),
            (this.z *= t.z),
            (this.w *= t.w),
            this
          );
        }
        multiplyScalar(t) {
          return (
            (this.x *= t), (this.y *= t), (this.z *= t), (this.w *= t), this
          );
        }
        applyMatrix4(t) {
          const e = this.x,
            n = this.y,
            i = this.z,
            r = this.w,
            a = t.elements;
          return (
            (this.x = a[0] * e + a[4] * n + a[8] * i + a[12] * r),
            (this.y = a[1] * e + a[5] * n + a[9] * i + a[13] * r),
            (this.z = a[2] * e + a[6] * n + a[10] * i + a[14] * r),
            (this.w = a[3] * e + a[7] * n + a[11] * i + a[15] * r),
            this
          );
        }
        divideScalar(t) {
          return this.multiplyScalar(1 / t);
        }
        setAxisAngleFromQuaternion(t) {
          this.w = 2 * Math.acos(t.w);
          const e = Math.sqrt(1 - t.w * t.w);
          return (
            e < 1e-4
              ? ((this.x = 1), (this.y = 0), (this.z = 0))
              : ((this.x = t.x / e), (this.y = t.y / e), (this.z = t.z / e)),
            this
          );
        }
        setAxisAngleFromRotationMatrix(t) {
          let e, n, i, r;
          const a = 0.01,
            o = 0.1,
            s = t.elements,
            c = s[0],
            l = s[4],
            h = s[8],
            u = s[1],
            d = s[5],
            p = s[9],
            f = s[2],
            m = s[6],
            g = s[10];
          if (
            Math.abs(l - u) < a &&
            Math.abs(h - f) < a &&
            Math.abs(p - m) < a
          ) {
            if (
              Math.abs(l + u) < o &&
              Math.abs(h + f) < o &&
              Math.abs(p + m) < o &&
              Math.abs(c + d + g - 3) < o
            )
              return this.set(1, 0, 0, 0), this;
            e = Math.PI;
            const t = (c + 1) / 2,
              s = (d + 1) / 2,
              v = (g + 1) / 2,
              y = (l + u) / 4,
              x = (h + f) / 4,
              _ = (p + m) / 4;
            return (
              t > s && t > v
                ? t < a
                  ? ((n = 0), (i = 0.707106781), (r = 0.707106781))
                  : ((n = Math.sqrt(t)), (i = y / n), (r = x / n))
                : s > v
                ? s < a
                  ? ((n = 0.707106781), (i = 0), (r = 0.707106781))
                  : ((i = Math.sqrt(s)), (n = y / i), (r = _ / i))
                : v < a
                ? ((n = 0.707106781), (i = 0.707106781), (r = 0))
                : ((r = Math.sqrt(v)), (n = x / r), (i = _ / r)),
              this.set(n, i, r, e),
              this
            );
          }
          let v = Math.sqrt(
            (m - p) * (m - p) + (h - f) * (h - f) + (u - l) * (u - l)
          );
          return (
            Math.abs(v) < 0.001 && (v = 1),
            (this.x = (m - p) / v),
            (this.y = (h - f) / v),
            (this.z = (u - l) / v),
            (this.w = Math.acos((c + d + g - 1) / 2)),
            this
          );
        }
        min(t) {
          return (
            (this.x = Math.min(this.x, t.x)),
            (this.y = Math.min(this.y, t.y)),
            (this.z = Math.min(this.z, t.z)),
            (this.w = Math.min(this.w, t.w)),
            this
          );
        }
        max(t) {
          return (
            (this.x = Math.max(this.x, t.x)),
            (this.y = Math.max(this.y, t.y)),
            (this.z = Math.max(this.z, t.z)),
            (this.w = Math.max(this.w, t.w)),
            this
          );
        }
        clamp(t, e) {
          return (
            (this.x = Math.max(t.x, Math.min(e.x, this.x))),
            (this.y = Math.max(t.y, Math.min(e.y, this.y))),
            (this.z = Math.max(t.z, Math.min(e.z, this.z))),
            (this.w = Math.max(t.w, Math.min(e.w, this.w))),
            this
          );
        }
        clampScalar(t, e) {
          return (
            (this.x = Math.max(t, Math.min(e, this.x))),
            (this.y = Math.max(t, Math.min(e, this.y))),
            (this.z = Math.max(t, Math.min(e, this.z))),
            (this.w = Math.max(t, Math.min(e, this.w))),
            this
          );
        }
        clampLength(t, e) {
          const n = this.length();
          return this.divideScalar(n || 1).multiplyScalar(
            Math.max(t, Math.min(e, n))
          );
        }
        floor() {
          return (
            (this.x = Math.floor(this.x)),
            (this.y = Math.floor(this.y)),
            (this.z = Math.floor(this.z)),
            (this.w = Math.floor(this.w)),
            this
          );
        }
        ceil() {
          return (
            (this.x = Math.ceil(this.x)),
            (this.y = Math.ceil(this.y)),
            (this.z = Math.ceil(this.z)),
            (this.w = Math.ceil(this.w)),
            this
          );
        }
        round() {
          return (
            (this.x = Math.round(this.x)),
            (this.y = Math.round(this.y)),
            (this.z = Math.round(this.z)),
            (this.w = Math.round(this.w)),
            this
          );
        }
        roundToZero() {
          return (
            (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
            (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
            (this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)),
            (this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w)),
            this
          );
        }
        negate() {
          return (
            (this.x = -this.x),
            (this.y = -this.y),
            (this.z = -this.z),
            (this.w = -this.w),
            this
          );
        }
        dot(t) {
          return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w;
        }
        lengthSq() {
          return (
            this.x * this.x +
            this.y * this.y +
            this.z * this.z +
            this.w * this.w
          );
        }
        length() {
          return Math.sqrt(
            this.x * this.x +
              this.y * this.y +
              this.z * this.z +
              this.w * this.w
          );
        }
        manhattanLength() {
          return (
            Math.abs(this.x) +
            Math.abs(this.y) +
            Math.abs(this.z) +
            Math.abs(this.w)
          );
        }
        normalize() {
          return this.divideScalar(this.length() || 1);
        }
        setLength(t) {
          return this.normalize().multiplyScalar(t);
        }
        lerp(t, e) {
          return (
            (this.x += (t.x - this.x) * e),
            (this.y += (t.y - this.y) * e),
            (this.z += (t.z - this.z) * e),
            (this.w += (t.w - this.w) * e),
            this
          );
        }
        lerpVectors(t, e, n) {
          return (
            (this.x = t.x + (e.x - t.x) * n),
            (this.y = t.y + (e.y - t.y) * n),
            (this.z = t.z + (e.z - t.z) * n),
            (this.w = t.w + (e.w - t.w) * n),
            this
          );
        }
        equals(t) {
          return (
            t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w
          );
        }
        fromArray(t, e = 0) {
          return (
            (this.x = t[e]),
            (this.y = t[e + 1]),
            (this.z = t[e + 2]),
            (this.w = t[e + 3]),
            this
          );
        }
        toArray(t = [], e = 0) {
          return (
            (t[e] = this.x),
            (t[e + 1] = this.y),
            (t[e + 2] = this.z),
            (t[e + 3] = this.w),
            t
          );
        }
        fromBufferAttribute(t, e, n) {
          return (
            void 0 !== n &&
              console.warn(
                "THREE.Vector4: offset has been removed from .fromBufferAttribute()."
              ),
            (this.x = t.getX(e)),
            (this.y = t.getY(e)),
            (this.z = t.getZ(e)),
            (this.w = t.getW(e)),
            this
          );
        }
        random() {
          return (
            (this.x = Math.random()),
            (this.y = Math.random()),
            (this.z = Math.random()),
            (this.w = Math.random()),
            this
          );
        }
        *[Symbol.iterator]() {
          yield this.x, yield this.y, yield this.z, yield this.w;
        }
      }
      vn.prototype.isVector4 = !0;
      class yn extends ke {
        constructor(t, e, n = {}) {
          super(),
            (this.width = t),
            (this.height = e),
            (this.depth = 1),
            (this.scissor = new vn(0, 0, t, e)),
            (this.scissorTest = !1),
            (this.viewport = new vn(0, 0, t, e)),
            (this.texture = new mn(
              void 0,
              n.mapping,
              n.wrapS,
              n.wrapT,
              n.magFilter,
              n.minFilter,
              n.format,
              n.type,
              n.anisotropy,
              n.encoding
            )),
            (this.texture.isRenderTargetTexture = !0),
            (this.texture.image = { width: t, height: e, depth: 1 }),
            (this.texture.generateMipmaps =
              void 0 !== n.generateMipmaps && n.generateMipmaps),
            (this.texture.internalFormat =
              void 0 !== n.internalFormat ? n.internalFormat : null),
            (this.texture.minFilter =
              void 0 !== n.minFilter ? n.minFilter : xt),
            (this.depthBuffer = void 0 === n.depthBuffer || n.depthBuffer),
            (this.stencilBuffer =
              void 0 !== n.stencilBuffer && n.stencilBuffer),
            (this.depthTexture =
              void 0 !== n.depthTexture ? n.depthTexture : null);
        }
        setTexture(t) {
          (t.image = {
            width: this.width,
            height: this.height,
            depth: this.depth,
          }),
            (this.texture = t);
        }
        setSize(t, e, n = 1) {
          (this.width === t && this.height === e && this.depth === n) ||
            ((this.width = t),
            (this.height = e),
            (this.depth = n),
            (this.texture.image.width = t),
            (this.texture.image.height = e),
            (this.texture.image.depth = n),
            this.dispose()),
            this.viewport.set(0, 0, t, e),
            this.scissor.set(0, 0, t, e);
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(t) {
          return (
            (this.width = t.width),
            (this.height = t.height),
            (this.depth = t.depth),
            this.viewport.copy(t.viewport),
            (this.texture = t.texture.clone()),
            (this.texture.image = Object.assign({}, t.texture.image)),
            (this.depthBuffer = t.depthBuffer),
            (this.stencilBuffer = t.stencilBuffer),
            (this.depthTexture = t.depthTexture),
            this
          );
        }
        dispose() {
          this.dispatchEvent({ type: "dispose" });
        }
      }
      yn.prototype.isWebGLRenderTarget = !0;
      class xn extends yn {
        constructor(t, e, n) {
          super(t, e);
          const i = this.texture;
          this.texture = [];
          for (let r = 0; r < n; r++) this.texture[r] = i.clone();
        }
        setSize(t, e, n = 1) {
          if (this.width !== t || this.height !== e || this.depth !== n) {
            (this.width = t), (this.height = e), (this.depth = n);
            for (let i = 0, r = this.texture.length; i < r; i++)
              (this.texture[i].image.width = t),
                (this.texture[i].image.height = e),
                (this.texture[i].image.depth = n);
            this.dispose();
          }
          return (
            this.viewport.set(0, 0, t, e), this.scissor.set(0, 0, t, e), this
          );
        }
        copy(t) {
          this.dispose(),
            (this.width = t.width),
            (this.height = t.height),
            (this.depth = t.depth),
            this.viewport.set(0, 0, this.width, this.height),
            this.scissor.set(0, 0, this.width, this.height),
            (this.depthBuffer = t.depthBuffer),
            (this.stencilBuffer = t.stencilBuffer),
            (this.depthTexture = t.depthTexture),
            (this.texture.length = 0);
          for (let e = 0, n = t.texture.length; e < n; e++)
            this.texture[e] = t.texture[e].clone();
          return this;
        }
      }
      xn.prototype.isWebGLMultipleRenderTargets = !0;
      class _n extends yn {
        constructor(t, e, n = {}) {
          super(t, e, n),
            (this.samples = 4),
            (this.ignoreDepthForMultisampleCopy =
              void 0 === n.ignoreDepth || n.ignoreDepth),
            (this.useRenderToTexture =
              void 0 !== n.useRenderToTexture && n.useRenderToTexture),
            (this.useRenderbuffer = !1 === this.useRenderToTexture);
        }
        copy(t) {
          return (
            super.copy.call(this, t),
            (this.samples = t.samples),
            (this.useRenderToTexture = t.useRenderToTexture),
            (this.useRenderbuffer = t.useRenderbuffer),
            this
          );
        }
      }
      _n.prototype.isWebGLMultisampleRenderTarget = !0;
      class bn {
        constructor(t = 0, e = 0, n = 0, i = 1) {
          (this._x = t), (this._y = e), (this._z = n), (this._w = i);
        }
        static slerp(t, e, n, i) {
          return (
            console.warn(
              "THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead."
            ),
            n.slerpQuaternions(t, e, i)
          );
        }
        static slerpFlat(t, e, n, i, r, a, o) {
          let s = n[i + 0],
            c = n[i + 1],
            l = n[i + 2],
            h = n[i + 3];
          const u = r[a + 0],
            d = r[a + 1],
            p = r[a + 2],
            f = r[a + 3];
          if (0 === o)
            return (
              (t[e + 0] = s),
              (t[e + 1] = c),
              (t[e + 2] = l),
              void (t[e + 3] = h)
            );
          if (1 === o)
            return (
              (t[e + 0] = u),
              (t[e + 1] = d),
              (t[e + 2] = p),
              void (t[e + 3] = f)
            );
          if (h !== f || s !== u || c !== d || l !== p) {
            let t = 1 - o;
            const e = s * u + c * d + l * p + h * f,
              n = e >= 0 ? 1 : -1,
              i = 1 - e * e;
            if (i > Number.EPSILON) {
              const r = Math.sqrt(i),
                a = Math.atan2(r, e * n);
              (t = Math.sin(t * a) / r), (o = Math.sin(o * a) / r);
            }
            const r = o * n;
            if (
              ((s = s * t + u * r),
              (c = c * t + d * r),
              (l = l * t + p * r),
              (h = h * t + f * r),
              t === 1 - o)
            ) {
              const t = 1 / Math.sqrt(s * s + c * c + l * l + h * h);
              (s *= t), (c *= t), (l *= t), (h *= t);
            }
          }
          (t[e] = s), (t[e + 1] = c), (t[e + 2] = l), (t[e + 3] = h);
        }
        static multiplyQuaternionsFlat(t, e, n, i, r, a) {
          const o = n[i],
            s = n[i + 1],
            c = n[i + 2],
            l = n[i + 3],
            h = r[a],
            u = r[a + 1],
            d = r[a + 2],
            p = r[a + 3];
          return (
            (t[e] = o * p + l * h + s * d - c * u),
            (t[e + 1] = s * p + l * u + c * h - o * d),
            (t[e + 2] = c * p + l * d + o * u - s * h),
            (t[e + 3] = l * p - o * h - s * u - c * d),
            t
          );
        }
        get x() {
          return this._x;
        }
        set x(t) {
          (this._x = t), this._onChangeCallback();
        }
        get y() {
          return this._y;
        }
        set y(t) {
          (this._y = t), this._onChangeCallback();
        }
        get z() {
          return this._z;
        }
        set z(t) {
          (this._z = t), this._onChangeCallback();
        }
        get w() {
          return this._w;
        }
        set w(t) {
          (this._w = t), this._onChangeCallback();
        }
        set(t, e, n, i) {
          return (
            (this._x = t),
            (this._y = e),
            (this._z = n),
            (this._w = i),
            this._onChangeCallback(),
            this
          );
        }
        clone() {
          return new this.constructor(this._x, this._y, this._z, this._w);
        }
        copy(t) {
          return (
            (this._x = t.x),
            (this._y = t.y),
            (this._z = t.z),
            (this._w = t.w),
            this._onChangeCallback(),
            this
          );
        }
        setFromEuler(t, e) {
          if (!t || !t.isEuler)
            throw new Error(
              "THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order."
            );
          const n = t._x,
            i = t._y,
            r = t._z,
            a = t._order,
            o = Math.cos,
            s = Math.sin,
            c = o(n / 2),
            l = o(i / 2),
            h = o(r / 2),
            u = s(n / 2),
            d = s(i / 2),
            p = s(r / 2);
          switch (a) {
            case "XYZ":
              (this._x = u * l * h + c * d * p),
                (this._y = c * d * h - u * l * p),
                (this._z = c * l * p + u * d * h),
                (this._w = c * l * h - u * d * p);
              break;
            case "YXZ":
              (this._x = u * l * h + c * d * p),
                (this._y = c * d * h - u * l * p),
                (this._z = c * l * p - u * d * h),
                (this._w = c * l * h + u * d * p);
              break;
            case "ZXY":
              (this._x = u * l * h - c * d * p),
                (this._y = c * d * h + u * l * p),
                (this._z = c * l * p + u * d * h),
                (this._w = c * l * h - u * d * p);
              break;
            case "ZYX":
              (this._x = u * l * h - c * d * p),
                (this._y = c * d * h + u * l * p),
                (this._z = c * l * p - u * d * h),
                (this._w = c * l * h + u * d * p);
              break;
            case "YZX":
              (this._x = u * l * h + c * d * p),
                (this._y = c * d * h + u * l * p),
                (this._z = c * l * p - u * d * h),
                (this._w = c * l * h - u * d * p);
              break;
            case "XZY":
              (this._x = u * l * h - c * d * p),
                (this._y = c * d * h - u * l * p),
                (this._z = c * l * p + u * d * h),
                (this._w = c * l * h + u * d * p);
              break;
            default:
              console.warn(
                "THREE.Quaternion: .setFromEuler() encountered an unknown order: " +
                  a
              );
          }
          return !1 !== e && this._onChangeCallback(), this;
        }
        setFromAxisAngle(t, e) {
          const n = e / 2,
            i = Math.sin(n);
          return (
            (this._x = t.x * i),
            (this._y = t.y * i),
            (this._z = t.z * i),
            (this._w = Math.cos(n)),
            this._onChangeCallback(),
            this
          );
        }
        setFromRotationMatrix(t) {
          const e = t.elements,
            n = e[0],
            i = e[4],
            r = e[8],
            a = e[1],
            o = e[5],
            s = e[9],
            c = e[2],
            l = e[6],
            h = e[10],
            u = n + o + h;
          if (u > 0) {
            const t = 0.5 / Math.sqrt(u + 1);
            (this._w = 0.25 / t),
              (this._x = (l - s) * t),
              (this._y = (r - c) * t),
              (this._z = (a - i) * t);
          } else if (n > o && n > h) {
            const t = 2 * Math.sqrt(1 + n - o - h);
            (this._w = (l - s) / t),
              (this._x = 0.25 * t),
              (this._y = (i + a) / t),
              (this._z = (r + c) / t);
          } else if (o > h) {
            const t = 2 * Math.sqrt(1 + o - n - h);
            (this._w = (r - c) / t),
              (this._x = (i + a) / t),
              (this._y = 0.25 * t),
              (this._z = (s + l) / t);
          } else {
            const t = 2 * Math.sqrt(1 + h - n - o);
            (this._w = (a - i) / t),
              (this._x = (r + c) / t),
              (this._y = (s + l) / t),
              (this._z = 0.25 * t);
          }
          return this._onChangeCallback(), this;
        }
        setFromUnitVectors(t, e) {
          let n = t.dot(e) + 1;
          return (
            n < Number.EPSILON
              ? ((n = 0),
                Math.abs(t.x) > Math.abs(t.z)
                  ? ((this._x = -t.y),
                    (this._y = t.x),
                    (this._z = 0),
                    (this._w = n))
                  : ((this._x = 0),
                    (this._y = -t.z),
                    (this._z = t.y),
                    (this._w = n)))
              : ((this._x = t.y * e.z - t.z * e.y),
                (this._y = t.z * e.x - t.x * e.z),
                (this._z = t.x * e.y - t.y * e.x),
                (this._w = n)),
            this.normalize()
          );
        }
        angleTo(t) {
          return 2 * Math.acos(Math.abs(qe(this.dot(t), -1, 1)));
        }
        rotateTowards(t, e) {
          const n = this.angleTo(t);
          if (0 === n) return this;
          const i = Math.min(1, e / n);
          return this.slerp(t, i), this;
        }
        identity() {
          return this.set(0, 0, 0, 1);
        }
        invert() {
          return this.conjugate();
        }
        conjugate() {
          return (
            (this._x *= -1),
            (this._y *= -1),
            (this._z *= -1),
            this._onChangeCallback(),
            this
          );
        }
        dot(t) {
          return (
            this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w
          );
        }
        lengthSq() {
          return (
            this._x * this._x +
            this._y * this._y +
            this._z * this._z +
            this._w * this._w
          );
        }
        length() {
          return Math.sqrt(
            this._x * this._x +
              this._y * this._y +
              this._z * this._z +
              this._w * this._w
          );
        }
        normalize() {
          let t = this.length();
          return (
            0 === t
              ? ((this._x = 0), (this._y = 0), (this._z = 0), (this._w = 1))
              : ((t = 1 / t),
                (this._x = this._x * t),
                (this._y = this._y * t),
                (this._z = this._z * t),
                (this._w = this._w * t)),
            this._onChangeCallback(),
            this
          );
        }
        multiply(t, e) {
          return void 0 !== e
            ? (console.warn(
                "THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."
              ),
              this.multiplyQuaternions(t, e))
            : this.multiplyQuaternions(this, t);
        }
        premultiply(t) {
          return this.multiplyQuaternions(t, this);
        }
        multiplyQuaternions(t, e) {
          const n = t._x,
            i = t._y,
            r = t._z,
            a = t._w,
            o = e._x,
            s = e._y,
            c = e._z,
            l = e._w;
          return (
            (this._x = n * l + a * o + i * c - r * s),
            (this._y = i * l + a * s + r * o - n * c),
            (this._z = r * l + a * c + n * s - i * o),
            (this._w = a * l - n * o - i * s - r * c),
            this._onChangeCallback(),
            this
          );
        }
        slerp(t, e) {
          if (0 === e) return this;
          if (1 === e) return this.copy(t);
          const n = this._x,
            i = this._y,
            r = this._z,
            a = this._w;
          let o = a * t._w + n * t._x + i * t._y + r * t._z;
          if (
            (o < 0
              ? ((this._w = -t._w),
                (this._x = -t._x),
                (this._y = -t._y),
                (this._z = -t._z),
                (o = -o))
              : this.copy(t),
            o >= 1)
          )
            return (
              (this._w = a), (this._x = n), (this._y = i), (this._z = r), this
            );
          const s = 1 - o * o;
          if (s <= Number.EPSILON) {
            const t = 1 - e;
            return (
              (this._w = t * a + e * this._w),
              (this._x = t * n + e * this._x),
              (this._y = t * i + e * this._y),
              (this._z = t * r + e * this._z),
              this.normalize(),
              this._onChangeCallback(),
              this
            );
          }
          const c = Math.sqrt(s),
            l = Math.atan2(c, o),
            h = Math.sin((1 - e) * l) / c,
            u = Math.sin(e * l) / c;
          return (
            (this._w = a * h + this._w * u),
            (this._x = n * h + this._x * u),
            (this._y = i * h + this._y * u),
            (this._z = r * h + this._z * u),
            this._onChangeCallback(),
            this
          );
        }
        slerpQuaternions(t, e, n) {
          return this.copy(t).slerp(e, n);
        }
        random() {
          const t = Math.random(),
            e = Math.sqrt(1 - t),
            n = Math.sqrt(t),
            i = 2 * Math.PI * Math.random(),
            r = 2 * Math.PI * Math.random();
          return this.set(
            e * Math.cos(i),
            n * Math.sin(r),
            n * Math.cos(r),
            e * Math.sin(i)
          );
        }
        equals(t) {
          return (
            t._x === this._x &&
            t._y === this._y &&
            t._z === this._z &&
            t._w === this._w
          );
        }
        fromArray(t, e = 0) {
          return (
            (this._x = t[e]),
            (this._y = t[e + 1]),
            (this._z = t[e + 2]),
            (this._w = t[e + 3]),
            this._onChangeCallback(),
            this
          );
        }
        toArray(t = [], e = 0) {
          return (
            (t[e] = this._x),
            (t[e + 1] = this._y),
            (t[e + 2] = this._z),
            (t[e + 3] = this._w),
            t
          );
        }
        fromBufferAttribute(t, e) {
          return (
            (this._x = t.getX(e)),
            (this._y = t.getY(e)),
            (this._z = t.getZ(e)),
            (this._w = t.getW(e)),
            this
          );
        }
        _onChange(t) {
          return (this._onChangeCallback = t), this;
        }
        _onChangeCallback() {}
      }
      bn.prototype.isQuaternion = !0;
      class wn {
        constructor(t = 0, e = 0, n = 0) {
          (this.x = t), (this.y = e), (this.z = n);
        }
        set(t, e, n) {
          return (
            void 0 === n && (n = this.z),
            (this.x = t),
            (this.y = e),
            (this.z = n),
            this
          );
        }
        setScalar(t) {
          return (this.x = t), (this.y = t), (this.z = t), this;
        }
        setX(t) {
          return (this.x = t), this;
        }
        setY(t) {
          return (this.y = t), this;
        }
        setZ(t) {
          return (this.z = t), this;
        }
        setComponent(t, e) {
          switch (t) {
            case 0:
              this.x = e;
              break;
            case 1:
              this.y = e;
              break;
            case 2:
              this.z = e;
              break;
            default:
              throw new Error("index is out of range: " + t);
          }
          return this;
        }
        getComponent(t) {
          switch (t) {
            case 0:
              return this.x;
            case 1:
              return this.y;
            case 2:
              return this.z;
            default:
              throw new Error("index is out of range: " + t);
          }
        }
        clone() {
          return new this.constructor(this.x, this.y, this.z);
        }
        copy(t) {
          return (this.x = t.x), (this.y = t.y), (this.z = t.z), this;
        }
        add(t, e) {
          return void 0 !== e
            ? (console.warn(
                "THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."
              ),
              this.addVectors(t, e))
            : ((this.x += t.x), (this.y += t.y), (this.z += t.z), this);
        }
        addScalar(t) {
          return (this.x += t), (this.y += t), (this.z += t), this;
        }
        addVectors(t, e) {
          return (
            (this.x = t.x + e.x),
            (this.y = t.y + e.y),
            (this.z = t.z + e.z),
            this
          );
        }
        addScaledVector(t, e) {
          return (
            (this.x += t.x * e), (this.y += t.y * e), (this.z += t.z * e), this
          );
        }
        sub(t, e) {
          return void 0 !== e
            ? (console.warn(
                "THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."
              ),
              this.subVectors(t, e))
            : ((this.x -= t.x), (this.y -= t.y), (this.z -= t.z), this);
        }
        subScalar(t) {
          return (this.x -= t), (this.y -= t), (this.z -= t), this;
        }
        subVectors(t, e) {
          return (
            (this.x = t.x - e.x),
            (this.y = t.y - e.y),
            (this.z = t.z - e.z),
            this
          );
        }
        multiply(t, e) {
          return void 0 !== e
            ? (console.warn(
                "THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."
              ),
              this.multiplyVectors(t, e))
            : ((this.x *= t.x), (this.y *= t.y), (this.z *= t.z), this);
        }
        multiplyScalar(t) {
          return (this.x *= t), (this.y *= t), (this.z *= t), this;
        }
        multiplyVectors(t, e) {
          return (
            (this.x = t.x * e.x),
            (this.y = t.y * e.y),
            (this.z = t.z * e.z),
            this
          );
        }
        applyEuler(t) {
          return (
            (t && t.isEuler) ||
              console.error(
                "THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."
              ),
            this.applyQuaternion(Sn.setFromEuler(t))
          );
        }
        applyAxisAngle(t, e) {
          return this.applyQuaternion(Sn.setFromAxisAngle(t, e));
        }
        applyMatrix3(t) {
          const e = this.x,
            n = this.y,
            i = this.z,
            r = t.elements;
          return (
            (this.x = r[0] * e + r[3] * n + r[6] * i),
            (this.y = r[1] * e + r[4] * n + r[7] * i),
            (this.z = r[2] * e + r[5] * n + r[8] * i),
            this
          );
        }
        applyNormalMatrix(t) {
          return this.applyMatrix3(t).normalize();
        }
        applyMatrix4(t) {
          const e = this.x,
            n = this.y,
            i = this.z,
            r = t.elements,
            a = 1 / (r[3] * e + r[7] * n + r[11] * i + r[15]);
          return (
            (this.x = (r[0] * e + r[4] * n + r[8] * i + r[12]) * a),
            (this.y = (r[1] * e + r[5] * n + r[9] * i + r[13]) * a),
            (this.z = (r[2] * e + r[6] * n + r[10] * i + r[14]) * a),
            this
          );
        }
        applyQuaternion(t) {
          const e = this.x,
            n = this.y,
            i = this.z,
            r = t.x,
            a = t.y,
            o = t.z,
            s = t.w,
            c = s * e + a * i - o * n,
            l = s * n + o * e - r * i,
            h = s * i + r * n - a * e,
            u = -r * e - a * n - o * i;
          return (
            (this.x = c * s + u * -r + l * -o - h * -a),
            (this.y = l * s + u * -a + h * -r - c * -o),
            (this.z = h * s + u * -o + c * -a - l * -r),
            this
          );
        }
        project(t) {
          return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(
            t.projectionMatrix
          );
        }
        unproject(t) {
          return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(
            t.matrixWorld
          );
        }
        transformDirection(t) {
          const e = this.x,
            n = this.y,
            i = this.z,
            r = t.elements;
          return (
            (this.x = r[0] * e + r[4] * n + r[8] * i),
            (this.y = r[1] * e + r[5] * n + r[9] * i),
            (this.z = r[2] * e + r[6] * n + r[10] * i),
            this.normalize()
          );
        }
        divide(t) {
          return (this.x /= t.x), (this.y /= t.y), (this.z /= t.z), this;
        }
        divideScalar(t) {
          return this.multiplyScalar(1 / t);
        }
        min(t) {
          return (
            (this.x = Math.min(this.x, t.x)),
            (this.y = Math.min(this.y, t.y)),
            (this.z = Math.min(this.z, t.z)),
            this
          );
        }
        max(t) {
          return (
            (this.x = Math.max(this.x, t.x)),
            (this.y = Math.max(this.y, t.y)),
            (this.z = Math.max(this.z, t.z)),
            this
          );
        }
        clamp(t, e) {
          return (
            (this.x = Math.max(t.x, Math.min(e.x, this.x))),
            (this.y = Math.max(t.y, Math.min(e.y, this.y))),
            (this.z = Math.max(t.z, Math.min(e.z, this.z))),
            this
          );
        }
        clampScalar(t, e) {
          return (
            (this.x = Math.max(t, Math.min(e, this.x))),
            (this.y = Math.max(t, Math.min(e, this.y))),
            (this.z = Math.max(t, Math.min(e, this.z))),
            this
          );
        }
        clampLength(t, e) {
          const n = this.length();
          return this.divideScalar(n || 1).multiplyScalar(
            Math.max(t, Math.min(e, n))
          );
        }
        floor() {
          return (
            (this.x = Math.floor(this.x)),
            (this.y = Math.floor(this.y)),
            (this.z = Math.floor(this.z)),
            this
          );
        }
        ceil() {
          return (
            (this.x = Math.ceil(this.x)),
            (this.y = Math.ceil(this.y)),
            (this.z = Math.ceil(this.z)),
            this
          );
        }
        round() {
          return (
            (this.x = Math.round(this.x)),
            (this.y = Math.round(this.y)),
            (this.z = Math.round(this.z)),
            this
          );
        }
        roundToZero() {
          return (
            (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
            (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
            (this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)),
            this
          );
        }
        negate() {
          return (
            (this.x = -this.x), (this.y = -this.y), (this.z = -this.z), this
          );
        }
        dot(t) {
          return this.x * t.x + this.y * t.y + this.z * t.z;
        }
        lengthSq() {
          return this.x * this.x + this.y * this.y + this.z * this.z;
        }
        length() {
          return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
        }
        manhattanLength() {
          return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
        }
        normalize() {
          return this.divideScalar(this.length() || 1);
        }
        setLength(t) {
          return this.normalize().multiplyScalar(t);
        }
        lerp(t, e) {
          return (
            (this.x += (t.x - this.x) * e),
            (this.y += (t.y - this.y) * e),
            (this.z += (t.z - this.z) * e),
            this
          );
        }
        lerpVectors(t, e, n) {
          return (
            (this.x = t.x + (e.x - t.x) * n),
            (this.y = t.y + (e.y - t.y) * n),
            (this.z = t.z + (e.z - t.z) * n),
            this
          );
        }
        cross(t, e) {
          return void 0 !== e
            ? (console.warn(
                "THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."
              ),
              this.crossVectors(t, e))
            : this.crossVectors(this, t);
        }
        crossVectors(t, e) {
          const n = t.x,
            i = t.y,
            r = t.z,
            a = e.x,
            o = e.y,
            s = e.z;
          return (
            (this.x = i * s - r * o),
            (this.y = r * a - n * s),
            (this.z = n * o - i * a),
            this
          );
        }
        projectOnVector(t) {
          const e = t.lengthSq();
          if (0 === e) return this.set(0, 0, 0);
          const n = t.dot(this) / e;
          return this.copy(t).multiplyScalar(n);
        }
        projectOnPlane(t) {
          return Mn.copy(this).projectOnVector(t), this.sub(Mn);
        }
        reflect(t) {
          return this.sub(Mn.copy(t).multiplyScalar(2 * this.dot(t)));
        }
        angleTo(t) {
          const e = Math.sqrt(this.lengthSq() * t.lengthSq());
          if (0 === e) return Math.PI / 2;
          const n = this.dot(t) / e;
          return Math.acos(qe(n, -1, 1));
        }
        distanceTo(t) {
          return Math.sqrt(this.distanceToSquared(t));
        }
        distanceToSquared(t) {
          const e = this.x - t.x,
            n = this.y - t.y,
            i = this.z - t.z;
          return e * e + n * n + i * i;
        }
        manhattanDistanceTo(t) {
          return (
            Math.abs(this.x - t.x) +
            Math.abs(this.y - t.y) +
            Math.abs(this.z - t.z)
          );
        }
        setFromSpherical(t) {
          return this.setFromSphericalCoords(t.radius, t.phi, t.theta);
        }
        setFromSphericalCoords(t, e, n) {
          const i = Math.sin(e) * t;
          return (
            (this.x = i * Math.sin(n)),
            (this.y = Math.cos(e) * t),
            (this.z = i * Math.cos(n)),
            this
          );
        }
        setFromCylindrical(t) {
          return this.setFromCylindricalCoords(t.radius, t.theta, t.y);
        }
        setFromCylindricalCoords(t, e, n) {
          return (
            (this.x = t * Math.sin(e)),
            (this.y = n),
            (this.z = t * Math.cos(e)),
            this
          );
        }
        setFromMatrixPosition(t) {
          const e = t.elements;
          return (this.x = e[12]), (this.y = e[13]), (this.z = e[14]), this;
        }
        setFromMatrixScale(t) {
          const e = this.setFromMatrixColumn(t, 0).length(),
            n = this.setFromMatrixColumn(t, 1).length(),
            i = this.setFromMatrixColumn(t, 2).length();
          return (this.x = e), (this.y = n), (this.z = i), this;
        }
        setFromMatrixColumn(t, e) {
          return this.fromArray(t.elements, 4 * e);
        }
        setFromMatrix3Column(t, e) {
          return this.fromArray(t.elements, 3 * e);
        }
        equals(t) {
          return t.x === this.x && t.y === this.y && t.z === this.z;
        }
        fromArray(t, e = 0) {
          return (
            (this.x = t[e]), (this.y = t[e + 1]), (this.z = t[e + 2]), this
          );
        }
        toArray(t = [], e = 0) {
          return (t[e] = this.x), (t[e + 1] = this.y), (t[e + 2] = this.z), t;
        }
        fromBufferAttribute(t, e, n) {
          return (
            void 0 !== n &&
              console.warn(
                "THREE.Vector3: offset has been removed from .fromBufferAttribute()."
              ),
            (this.x = t.getX(e)),
            (this.y = t.getY(e)),
            (this.z = t.getZ(e)),
            this
          );
        }
        random() {
          return (
            (this.x = Math.random()),
            (this.y = Math.random()),
            (this.z = Math.random()),
            this
          );
        }
        randomDirection() {
          const t = 2 * (Math.random() - 0.5),
            e = Math.random() * Math.PI * 2,
            n = Math.sqrt(1 - t ** 2);
          return (
            (this.x = n * Math.cos(e)),
            (this.y = n * Math.sin(e)),
            (this.z = t),
            this
          );
        }
        *[Symbol.iterator]() {
          yield this.x, yield this.y, yield this.z;
        }
      }
      wn.prototype.isVector3 = !0;
      const Mn = new wn(),
        Sn = new bn();
      class En {
        constructor(
          t = new wn(1 / 0, 1 / 0, 1 / 0),
          e = new wn(-1 / 0, -1 / 0, -1 / 0)
        ) {
          (this.min = t), (this.max = e);
        }
        set(t, e) {
          return this.min.copy(t), this.max.copy(e), this;
        }
        setFromArray(t) {
          let e = 1 / 0,
            n = 1 / 0,
            i = 1 / 0,
            r = -1 / 0,
            a = -1 / 0,
            o = -1 / 0;
          for (let s = 0, c = t.length; s < c; s += 3) {
            const c = t[s],
              l = t[s + 1],
              h = t[s + 2];
            c < e && (e = c),
              l < n && (n = l),
              h < i && (i = h),
              c > r && (r = c),
              l > a && (a = l),
              h > o && (o = h);
          }
          return this.min.set(e, n, i), this.max.set(r, a, o), this;
        }
        setFromBufferAttribute(t) {
          let e = 1 / 0,
            n = 1 / 0,
            i = 1 / 0,
            r = -1 / 0,
            a = -1 / 0,
            o = -1 / 0;
          for (let s = 0, c = t.count; s < c; s++) {
            const c = t.getX(s),
              l = t.getY(s),
              h = t.getZ(s);
            c < e && (e = c),
              l < n && (n = l),
              h < i && (i = h),
              c > r && (r = c),
              l > a && (a = l),
              h > o && (o = h);
          }
          return this.min.set(e, n, i), this.max.set(r, a, o), this;
        }
        setFromPoints(t) {
          this.makeEmpty();
          for (let e = 0, n = t.length; e < n; e++) this.expandByPoint(t[e]);
          return this;
        }
        setFromCenterAndSize(t, e) {
          const n = An.copy(e).multiplyScalar(0.5);
          return this.min.copy(t).sub(n), this.max.copy(t).add(n), this;
        }
        setFromObject(t, e = !1) {
          return this.makeEmpty(), this.expandByObject(t, e);
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(t) {
          return this.min.copy(t.min), this.max.copy(t.max), this;
        }
        makeEmpty() {
          return (
            (this.min.x = this.min.y = this.min.z = 1 / 0),
            (this.max.x = this.max.y = this.max.z = -1 / 0),
            this
          );
        }
        isEmpty() {
          return (
            this.max.x < this.min.x ||
            this.max.y < this.min.y ||
            this.max.z < this.min.z
          );
        }
        getCenter(t) {
          return this.isEmpty()
            ? t.set(0, 0, 0)
            : t.addVectors(this.min, this.max).multiplyScalar(0.5);
        }
        getSize(t) {
          return this.isEmpty()
            ? t.set(0, 0, 0)
            : t.subVectors(this.max, this.min);
        }
        expandByPoint(t) {
          return this.min.min(t), this.max.max(t), this;
        }
        expandByVector(t) {
          return this.min.sub(t), this.max.add(t), this;
        }
        expandByScalar(t) {
          return this.min.addScalar(-t), this.max.addScalar(t), this;
        }
        expandByObject(t, e = !1) {
          t.updateWorldMatrix(!1, !1);
          const n = t.geometry;
          if (void 0 !== n)
            if (
              e &&
              void 0 != n.attributes &&
              void 0 !== n.attributes.position
            ) {
              const e = n.attributes.position;
              for (let n = 0, i = e.count; n < i; n++)
                An.fromBufferAttribute(e, n).applyMatrix4(t.matrixWorld),
                  this.expandByPoint(An);
            } else
              null === n.boundingBox && n.computeBoundingBox(),
                Cn.copy(n.boundingBox),
                Cn.applyMatrix4(t.matrixWorld),
                this.union(Cn);
          const i = t.children;
          for (let r = 0, a = i.length; r < a; r++)
            this.expandByObject(i[r], e);
          return this;
        }
        containsPoint(t) {
          return !(
            t.x < this.min.x ||
            t.x > this.max.x ||
            t.y < this.min.y ||
            t.y > this.max.y ||
            t.z < this.min.z ||
            t.z > this.max.z
          );
        }
        containsBox(t) {
          return (
            this.min.x <= t.min.x &&
            t.max.x <= this.max.x &&
            this.min.y <= t.min.y &&
            t.max.y <= this.max.y &&
            this.min.z <= t.min.z &&
            t.max.z <= this.max.z
          );
        }
        getParameter(t, e) {
          return e.set(
            (t.x - this.min.x) / (this.max.x - this.min.x),
            (t.y - this.min.y) / (this.max.y - this.min.y),
            (t.z - this.min.z) / (this.max.z - this.min.z)
          );
        }
        intersectsBox(t) {
          return !(
            t.max.x < this.min.x ||
            t.min.x > this.max.x ||
            t.max.y < this.min.y ||
            t.min.y > this.max.y ||
            t.max.z < this.min.z ||
            t.min.z > this.max.z
          );
        }
        intersectsSphere(t) {
          return (
            this.clampPoint(t.center, An),
            An.distanceToSquared(t.center) <= t.radius * t.radius
          );
        }
        intersectsPlane(t) {
          let e, n;
          return (
            t.normal.x > 0
              ? ((e = t.normal.x * this.min.x), (n = t.normal.x * this.max.x))
              : ((e = t.normal.x * this.max.x), (n = t.normal.x * this.min.x)),
            t.normal.y > 0
              ? ((e += t.normal.y * this.min.y), (n += t.normal.y * this.max.y))
              : ((e += t.normal.y * this.max.y),
                (n += t.normal.y * this.min.y)),
            t.normal.z > 0
              ? ((e += t.normal.z * this.min.z), (n += t.normal.z * this.max.z))
              : ((e += t.normal.z * this.max.z),
                (n += t.normal.z * this.min.z)),
            e <= -t.constant && n >= -t.constant
          );
        }
        intersectsTriangle(t) {
          if (this.isEmpty()) return !1;
          this.getCenter(Nn),
            Bn.subVectors(this.max, Nn),
            Rn.subVectors(t.a, Nn),
            Ln.subVectors(t.b, Nn),
            Pn.subVectors(t.c, Nn),
            Dn.subVectors(Ln, Rn),
            In.subVectors(Pn, Ln),
            On.subVectors(Rn, Pn);
          let e = [
            0,
            -Dn.z,
            Dn.y,
            0,
            -In.z,
            In.y,
            0,
            -On.z,
            On.y,
            Dn.z,
            0,
            -Dn.x,
            In.z,
            0,
            -In.x,
            On.z,
            0,
            -On.x,
            -Dn.y,
            Dn.x,
            0,
            -In.y,
            In.x,
            0,
            -On.y,
            On.x,
            0,
          ];
          return (
            !!Fn(e, Rn, Ln, Pn, Bn) &&
            ((e = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
            !!Fn(e, Rn, Ln, Pn, Bn) &&
              (zn.crossVectors(Dn, In),
              (e = [zn.x, zn.y, zn.z]),
              Fn(e, Rn, Ln, Pn, Bn)))
          );
        }
        clampPoint(t, e) {
          return e.copy(t).clamp(this.min, this.max);
        }
        distanceToPoint(t) {
          const e = An.copy(t).clamp(this.min, this.max);
          return e.sub(t).length();
        }
        getBoundingSphere(t) {
          return (
            this.getCenter(t.center),
            (t.radius = 0.5 * this.getSize(An).length()),
            t
          );
        }
        intersect(t) {
          return (
            this.min.max(t.min),
            this.max.min(t.max),
            this.isEmpty() && this.makeEmpty(),
            this
          );
        }
        union(t) {
          return this.min.min(t.min), this.max.max(t.max), this;
        }
        applyMatrix4(t) {
          return (
            this.isEmpty() ||
              (Tn[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t),
              Tn[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t),
              Tn[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t),
              Tn[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t),
              Tn[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t),
              Tn[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t),
              Tn[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t),
              Tn[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t),
              this.setFromPoints(Tn)),
            this
          );
        }
        translate(t) {
          return this.min.add(t), this.max.add(t), this;
        }
        equals(t) {
          return t.min.equals(this.min) && t.max.equals(this.max);
        }
      }
      En.prototype.isBox3 = !0;
      const Tn = [
          new wn(),
          new wn(),
          new wn(),
          new wn(),
          new wn(),
          new wn(),
          new wn(),
          new wn(),
        ],
        An = new wn(),
        Cn = new En(),
        Rn = new wn(),
        Ln = new wn(),
        Pn = new wn(),
        Dn = new wn(),
        In = new wn(),
        On = new wn(),
        Nn = new wn(),
        Bn = new wn(),
        zn = new wn(),
        Un = new wn();
      function Fn(t, e, n, i, r) {
        for (let a = 0, o = t.length - 3; a <= o; a += 3) {
          Un.fromArray(t, a);
          const o =
              r.x * Math.abs(Un.x) +
              r.y * Math.abs(Un.y) +
              r.z * Math.abs(Un.z),
            s = e.dot(Un),
            c = n.dot(Un),
            l = i.dot(Un);
          if (Math.max(-Math.max(s, c, l), Math.min(s, c, l)) > o) return !1;
        }
        return !0;
      }
      const Hn = new En(),
        kn = new wn(),
        Gn = new wn(),
        Vn = new wn();
      class Wn {
        constructor(t = new wn(), e = -1) {
          (this.center = t), (this.radius = e);
        }
        set(t, e) {
          return this.center.copy(t), (this.radius = e), this;
        }
        setFromPoints(t, e) {
          const n = this.center;
          void 0 !== e ? n.copy(e) : Hn.setFromPoints(t).getCenter(n);
          let i = 0;
          for (let r = 0, a = t.length; r < a; r++)
            i = Math.max(i, n.distanceToSquared(t[r]));
          return (this.radius = Math.sqrt(i)), this;
        }
        copy(t) {
          return this.center.copy(t.center), (this.radius = t.radius), this;
        }
        isEmpty() {
          return this.radius < 0;
        }
        makeEmpty() {
          return this.center.set(0, 0, 0), (this.radius = -1), this;
        }
        containsPoint(t) {
          return t.distanceToSquared(this.center) <= this.radius * this.radius;
        }
        distanceToPoint(t) {
          return t.distanceTo(this.center) - this.radius;
        }
        intersectsSphere(t) {
          const e = this.radius + t.radius;
          return t.center.distanceToSquared(this.center) <= e * e;
        }
        intersectsBox(t) {
          return t.intersectsSphere(this);
        }
        intersectsPlane(t) {
          return Math.abs(t.distanceToPoint(this.center)) <= this.radius;
        }
        clampPoint(t, e) {
          const n = this.center.distanceToSquared(t);
          return (
            e.copy(t),
            n > this.radius * this.radius &&
              (e.sub(this.center).normalize(),
              e.multiplyScalar(this.radius).add(this.center)),
            e
          );
        }
        getBoundingBox(t) {
          return this.isEmpty()
            ? (t.makeEmpty(), t)
            : (t.set(this.center, this.center),
              t.expandByScalar(this.radius),
              t);
        }
        applyMatrix4(t) {
          return (
            this.center.applyMatrix4(t),
            (this.radius = this.radius * t.getMaxScaleOnAxis()),
            this
          );
        }
        translate(t) {
          return this.center.add(t), this;
        }
        expandByPoint(t) {
          Vn.subVectors(t, this.center);
          const e = Vn.lengthSq();
          if (e > this.radius * this.radius) {
            const t = Math.sqrt(e),
              n = 0.5 * (t - this.radius);
            this.center.add(Vn.multiplyScalar(n / t)), (this.radius += n);
          }
          return this;
        }
        union(t) {
          return (
            !0 === this.center.equals(t.center)
              ? Gn.set(0, 0, 1).multiplyScalar(t.radius)
              : Gn.subVectors(t.center, this.center)
                  .normalize()
                  .multiplyScalar(t.radius),
            this.expandByPoint(kn.copy(t.center).add(Gn)),
            this.expandByPoint(kn.copy(t.center).sub(Gn)),
            this
          );
        }
        equals(t) {
          return t.center.equals(this.center) && t.radius === this.radius;
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      const jn = new wn(),
        qn = new wn(),
        Xn = new wn(),
        Yn = new wn(),
        Jn = new wn(),
        Zn = new wn(),
        Kn = new wn();
      class $n {
        constructor(t = new wn(), e = new wn(0, 0, -1)) {
          (this.origin = t), (this.direction = e);
        }
        set(t, e) {
          return this.origin.copy(t), this.direction.copy(e), this;
        }
        copy(t) {
          return (
            this.origin.copy(t.origin), this.direction.copy(t.direction), this
          );
        }
        at(t, e) {
          return e.copy(this.direction).multiplyScalar(t).add(this.origin);
        }
        lookAt(t) {
          return this.direction.copy(t).sub(this.origin).normalize(), this;
        }
        recast(t) {
          return this.origin.copy(this.at(t, jn)), this;
        }
        closestPointToPoint(t, e) {
          e.subVectors(t, this.origin);
          const n = e.dot(this.direction);
          return n < 0
            ? e.copy(this.origin)
            : e.copy(this.direction).multiplyScalar(n).add(this.origin);
        }
        distanceToPoint(t) {
          return Math.sqrt(this.distanceSqToPoint(t));
        }
        distanceSqToPoint(t) {
          const e = jn.subVectors(t, this.origin).dot(this.direction);
          return e < 0
            ? this.origin.distanceToSquared(t)
            : (jn.copy(this.direction).multiplyScalar(e).add(this.origin),
              jn.distanceToSquared(t));
        }
        distanceSqToSegment(t, e, n, i) {
          qn.copy(t).add(e).multiplyScalar(0.5),
            Xn.copy(e).sub(t).normalize(),
            Yn.copy(this.origin).sub(qn);
          const r = 0.5 * t.distanceTo(e),
            a = -this.direction.dot(Xn),
            o = Yn.dot(this.direction),
            s = -Yn.dot(Xn),
            c = Yn.lengthSq(),
            l = Math.abs(1 - a * a);
          let h, u, d, p;
          if (l > 0)
            if (((h = a * s - o), (u = a * o - s), (p = r * l), h >= 0))
              if (u >= -p)
                if (u <= p) {
                  const t = 1 / l;
                  (h *= t),
                    (u *= t),
                    (d = h * (h + a * u + 2 * o) + u * (a * h + u + 2 * s) + c);
                } else
                  (u = r),
                    (h = Math.max(0, -(a * u + o))),
                    (d = -h * h + u * (u + 2 * s) + c);
              else
                (u = -r),
                  (h = Math.max(0, -(a * u + o))),
                  (d = -h * h + u * (u + 2 * s) + c);
            else
              u <= -p
                ? ((h = Math.max(0, -(-a * r + o))),
                  (u = h > 0 ? -r : Math.min(Math.max(-r, -s), r)),
                  (d = -h * h + u * (u + 2 * s) + c))
                : u <= p
                ? ((h = 0),
                  (u = Math.min(Math.max(-r, -s), r)),
                  (d = u * (u + 2 * s) + c))
                : ((h = Math.max(0, -(a * r + o))),
                  (u = h > 0 ? r : Math.min(Math.max(-r, -s), r)),
                  (d = -h * h + u * (u + 2 * s) + c));
          else
            (u = a > 0 ? -r : r),
              (h = Math.max(0, -(a * u + o))),
              (d = -h * h + u * (u + 2 * s) + c);
          return (
            n && n.copy(this.direction).multiplyScalar(h).add(this.origin),
            i && i.copy(Xn).multiplyScalar(u).add(qn),
            d
          );
        }
        intersectSphere(t, e) {
          jn.subVectors(t.center, this.origin);
          const n = jn.dot(this.direction),
            i = jn.dot(jn) - n * n,
            r = t.radius * t.radius;
          if (i > r) return null;
          const a = Math.sqrt(r - i),
            o = n - a,
            s = n + a;
          return o < 0 && s < 0 ? null : o < 0 ? this.at(s, e) : this.at(o, e);
        }
        intersectsSphere(t) {
          return this.distanceSqToPoint(t.center) <= t.radius * t.radius;
        }
        distanceToPlane(t) {
          const e = t.normal.dot(this.direction);
          if (0 === e) return 0 === t.distanceToPoint(this.origin) ? 0 : null;
          const n = -(this.origin.dot(t.normal) + t.constant) / e;
          return n >= 0 ? n : null;
        }
        intersectPlane(t, e) {
          const n = this.distanceToPlane(t);
          return null === n ? null : this.at(n, e);
        }
        intersectsPlane(t) {
          const e = t.distanceToPoint(this.origin);
          if (0 === e) return !0;
          const n = t.normal.dot(this.direction);
          return n * e < 0;
        }
        intersectBox(t, e) {
          let n, i, r, a, o, s;
          const c = 1 / this.direction.x,
            l = 1 / this.direction.y,
            h = 1 / this.direction.z,
            u = this.origin;
          return (
            c >= 0
              ? ((n = (t.min.x - u.x) * c), (i = (t.max.x - u.x) * c))
              : ((n = (t.max.x - u.x) * c), (i = (t.min.x - u.x) * c)),
            l >= 0
              ? ((r = (t.min.y - u.y) * l), (a = (t.max.y - u.y) * l))
              : ((r = (t.max.y - u.y) * l), (a = (t.min.y - u.y) * l)),
            n > a || r > i
              ? null
              : ((r > n || n !== n) && (n = r),
                (a < i || i !== i) && (i = a),
                h >= 0
                  ? ((o = (t.min.z - u.z) * h), (s = (t.max.z - u.z) * h))
                  : ((o = (t.max.z - u.z) * h), (s = (t.min.z - u.z) * h)),
                n > s || o > i
                  ? null
                  : ((o > n || n !== n) && (n = o),
                    (s < i || i !== i) && (i = s),
                    i < 0 ? null : this.at(n >= 0 ? n : i, e)))
          );
        }
        intersectsBox(t) {
          return null !== this.intersectBox(t, jn);
        }
        intersectTriangle(t, e, n, i, r) {
          Jn.subVectors(e, t), Zn.subVectors(n, t), Kn.crossVectors(Jn, Zn);
          let a,
            o = this.direction.dot(Kn);
          if (o > 0) {
            if (i) return null;
            a = 1;
          } else {
            if (!(o < 0)) return null;
            (a = -1), (o = -o);
          }
          Yn.subVectors(this.origin, t);
          const s = a * this.direction.dot(Zn.crossVectors(Yn, Zn));
          if (s < 0) return null;
          const c = a * this.direction.dot(Jn.cross(Yn));
          if (c < 0) return null;
          if (s + c > o) return null;
          const l = -a * Yn.dot(Kn);
          return l < 0 ? null : this.at(l / o, r);
        }
        applyMatrix4(t) {
          return (
            this.origin.applyMatrix4(t),
            this.direction.transformDirection(t),
            this
          );
        }
        equals(t) {
          return (
            t.origin.equals(this.origin) && t.direction.equals(this.direction)
          );
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      class Qn {
        constructor() {
          (this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]),
            arguments.length > 0 &&
              console.error(
                "THREE.Matrix4: the constructor no longer reads arguments. use .set() instead."
              );
        }
        set(t, e, n, i, r, a, o, s, c, l, h, u, d, p, f, m) {
          const g = this.elements;
          return (
            (g[0] = t),
            (g[4] = e),
            (g[8] = n),
            (g[12] = i),
            (g[1] = r),
            (g[5] = a),
            (g[9] = o),
            (g[13] = s),
            (g[2] = c),
            (g[6] = l),
            (g[10] = h),
            (g[14] = u),
            (g[3] = d),
            (g[7] = p),
            (g[11] = f),
            (g[15] = m),
            this
          );
        }
        identity() {
          return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
        }
        clone() {
          return new Qn().fromArray(this.elements);
        }
        copy(t) {
          const e = this.elements,
            n = t.elements;
          return (
            (e[0] = n[0]),
            (e[1] = n[1]),
            (e[2] = n[2]),
            (e[3] = n[3]),
            (e[4] = n[4]),
            (e[5] = n[5]),
            (e[6] = n[6]),
            (e[7] = n[7]),
            (e[8] = n[8]),
            (e[9] = n[9]),
            (e[10] = n[10]),
            (e[11] = n[11]),
            (e[12] = n[12]),
            (e[13] = n[13]),
            (e[14] = n[14]),
            (e[15] = n[15]),
            this
          );
        }
        copyPosition(t) {
          const e = this.elements,
            n = t.elements;
          return (e[12] = n[12]), (e[13] = n[13]), (e[14] = n[14]), this;
        }
        setFromMatrix3(t) {
          const e = t.elements;
          return (
            this.set(
              e[0],
              e[3],
              e[6],
              0,
              e[1],
              e[4],
              e[7],
              0,
              e[2],
              e[5],
              e[8],
              0,
              0,
              0,
              0,
              1
            ),
            this
          );
        }
        extractBasis(t, e, n) {
          return (
            t.setFromMatrixColumn(this, 0),
            e.setFromMatrixColumn(this, 1),
            n.setFromMatrixColumn(this, 2),
            this
          );
        }
        makeBasis(t, e, n) {
          return (
            this.set(
              t.x,
              e.x,
              n.x,
              0,
              t.y,
              e.y,
              n.y,
              0,
              t.z,
              e.z,
              n.z,
              0,
              0,
              0,
              0,
              1
            ),
            this
          );
        }
        extractRotation(t) {
          const e = this.elements,
            n = t.elements,
            i = 1 / ti.setFromMatrixColumn(t, 0).length(),
            r = 1 / ti.setFromMatrixColumn(t, 1).length(),
            a = 1 / ti.setFromMatrixColumn(t, 2).length();
          return (
            (e[0] = n[0] * i),
            (e[1] = n[1] * i),
            (e[2] = n[2] * i),
            (e[3] = 0),
            (e[4] = n[4] * r),
            (e[5] = n[5] * r),
            (e[6] = n[6] * r),
            (e[7] = 0),
            (e[8] = n[8] * a),
            (e[9] = n[9] * a),
            (e[10] = n[10] * a),
            (e[11] = 0),
            (e[12] = 0),
            (e[13] = 0),
            (e[14] = 0),
            (e[15] = 1),
            this
          );
        }
        makeRotationFromEuler(t) {
          (t && t.isEuler) ||
            console.error(
              "THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order."
            );
          const e = this.elements,
            n = t.x,
            i = t.y,
            r = t.z,
            a = Math.cos(n),
            o = Math.sin(n),
            s = Math.cos(i),
            c = Math.sin(i),
            l = Math.cos(r),
            h = Math.sin(r);
          if ("XYZ" === t.order) {
            const t = a * l,
              n = a * h,
              i = o * l,
              r = o * h;
            (e[0] = s * l),
              (e[4] = -s * h),
              (e[8] = c),
              (e[1] = n + i * c),
              (e[5] = t - r * c),
              (e[9] = -o * s),
              (e[2] = r - t * c),
              (e[6] = i + n * c),
              (e[10] = a * s);
          } else if ("YXZ" === t.order) {
            const t = s * l,
              n = s * h,
              i = c * l,
              r = c * h;
            (e[0] = t + r * o),
              (e[4] = i * o - n),
              (e[8] = a * c),
              (e[1] = a * h),
              (e[5] = a * l),
              (e[9] = -o),
              (e[2] = n * o - i),
              (e[6] = r + t * o),
              (e[10] = a * s);
          } else if ("ZXY" === t.order) {
            const t = s * l,
              n = s * h,
              i = c * l,
              r = c * h;
            (e[0] = t - r * o),
              (e[4] = -a * h),
              (e[8] = i + n * o),
              (e[1] = n + i * o),
              (e[5] = a * l),
              (e[9] = r - t * o),
              (e[2] = -a * c),
              (e[6] = o),
              (e[10] = a * s);
          } else if ("ZYX" === t.order) {
            const t = a * l,
              n = a * h,
              i = o * l,
              r = o * h;
            (e[0] = s * l),
              (e[4] = i * c - n),
              (e[8] = t * c + r),
              (e[1] = s * h),
              (e[5] = r * c + t),
              (e[9] = n * c - i),
              (e[2] = -c),
              (e[6] = o * s),
              (e[10] = a * s);
          } else if ("YZX" === t.order) {
            const t = a * s,
              n = a * c,
              i = o * s,
              r = o * c;
            (e[0] = s * l),
              (e[4] = r - t * h),
              (e[8] = i * h + n),
              (e[1] = h),
              (e[5] = a * l),
              (e[9] = -o * l),
              (e[2] = -c * l),
              (e[6] = n * h + i),
              (e[10] = t - r * h);
          } else if ("XZY" === t.order) {
            const t = a * s,
              n = a * c,
              i = o * s,
              r = o * c;
            (e[0] = s * l),
              (e[4] = -h),
              (e[8] = c * l),
              (e[1] = t * h + r),
              (e[5] = a * l),
              (e[9] = n * h - i),
              (e[2] = i * h - n),
              (e[6] = o * l),
              (e[10] = r * h + t);
          }
          return (
            (e[3] = 0),
            (e[7] = 0),
            (e[11] = 0),
            (e[12] = 0),
            (e[13] = 0),
            (e[14] = 0),
            (e[15] = 1),
            this
          );
        }
        makeRotationFromQuaternion(t) {
          return this.compose(ni, t, ii);
        }
        lookAt(t, e, n) {
          const i = this.elements;
          return (
            oi.subVectors(t, e),
            0 === oi.lengthSq() && (oi.z = 1),
            oi.normalize(),
            ri.crossVectors(n, oi),
            0 === ri.lengthSq() &&
              (1 === Math.abs(n.z) ? (oi.x += 1e-4) : (oi.z += 1e-4),
              oi.normalize(),
              ri.crossVectors(n, oi)),
            ri.normalize(),
            ai.crossVectors(oi, ri),
            (i[0] = ri.x),
            (i[4] = ai.x),
            (i[8] = oi.x),
            (i[1] = ri.y),
            (i[5] = ai.y),
            (i[9] = oi.y),
            (i[2] = ri.z),
            (i[6] = ai.z),
            (i[10] = oi.z),
            this
          );
        }
        multiply(t, e) {
          return void 0 !== e
            ? (console.warn(
                "THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."
              ),
              this.multiplyMatrices(t, e))
            : this.multiplyMatrices(this, t);
        }
        premultiply(t) {
          return this.multiplyMatrices(t, this);
        }
        multiplyMatrices(t, e) {
          const n = t.elements,
            i = e.elements,
            r = this.elements,
            a = n[0],
            o = n[4],
            s = n[8],
            c = n[12],
            l = n[1],
            h = n[5],
            u = n[9],
            d = n[13],
            p = n[2],
            f = n[6],
            m = n[10],
            g = n[14],
            v = n[3],
            y = n[7],
            x = n[11],
            _ = n[15],
            b = i[0],
            w = i[4],
            M = i[8],
            S = i[12],
            E = i[1],
            T = i[5],
            A = i[9],
            C = i[13],
            R = i[2],
            L = i[6],
            P = i[10],
            D = i[14],
            I = i[3],
            O = i[7],
            N = i[11],
            B = i[15];
          return (
            (r[0] = a * b + o * E + s * R + c * I),
            (r[4] = a * w + o * T + s * L + c * O),
            (r[8] = a * M + o * A + s * P + c * N),
            (r[12] = a * S + o * C + s * D + c * B),
            (r[1] = l * b + h * E + u * R + d * I),
            (r[5] = l * w + h * T + u * L + d * O),
            (r[9] = l * M + h * A + u * P + d * N),
            (r[13] = l * S + h * C + u * D + d * B),
            (r[2] = p * b + f * E + m * R + g * I),
            (r[6] = p * w + f * T + m * L + g * O),
            (r[10] = p * M + f * A + m * P + g * N),
            (r[14] = p * S + f * C + m * D + g * B),
            (r[3] = v * b + y * E + x * R + _ * I),
            (r[7] = v * w + y * T + x * L + _ * O),
            (r[11] = v * M + y * A + x * P + _ * N),
            (r[15] = v * S + y * C + x * D + _ * B),
            this
          );
        }
        multiplyScalar(t) {
          const e = this.elements;
          return (
            (e[0] *= t),
            (e[4] *= t),
            (e[8] *= t),
            (e[12] *= t),
            (e[1] *= t),
            (e[5] *= t),
            (e[9] *= t),
            (e[13] *= t),
            (e[2] *= t),
            (e[6] *= t),
            (e[10] *= t),
            (e[14] *= t),
            (e[3] *= t),
            (e[7] *= t),
            (e[11] *= t),
            (e[15] *= t),
            this
          );
        }
        determinant() {
          const t = this.elements,
            e = t[0],
            n = t[4],
            i = t[8],
            r = t[12],
            a = t[1],
            o = t[5],
            s = t[9],
            c = t[13],
            l = t[2],
            h = t[6],
            u = t[10],
            d = t[14],
            p = t[3],
            f = t[7],
            m = t[11],
            g = t[15];
          return (
            p *
              (+r * s * h -
                i * c * h -
                r * o * u +
                n * c * u +
                i * o * d -
                n * s * d) +
            f *
              (+e * s * d -
                e * c * u +
                r * a * u -
                i * a * d +
                i * c * l -
                r * s * l) +
            m *
              (+e * c * h -
                e * o * d -
                r * a * h +
                n * a * d +
                r * o * l -
                n * c * l) +
            g *
              (-i * o * l -
                e * s * h +
                e * o * u +
                i * a * h -
                n * a * u +
                n * s * l)
          );
        }
        transpose() {
          const t = this.elements;
          let e;
          return (
            (e = t[1]),
            (t[1] = t[4]),
            (t[4] = e),
            (e = t[2]),
            (t[2] = t[8]),
            (t[8] = e),
            (e = t[6]),
            (t[6] = t[9]),
            (t[9] = e),
            (e = t[3]),
            (t[3] = t[12]),
            (t[12] = e),
            (e = t[7]),
            (t[7] = t[13]),
            (t[13] = e),
            (e = t[11]),
            (t[11] = t[14]),
            (t[14] = e),
            this
          );
        }
        setPosition(t, e, n) {
          const i = this.elements;
          return (
            t.isVector3
              ? ((i[12] = t.x), (i[13] = t.y), (i[14] = t.z))
              : ((i[12] = t), (i[13] = e), (i[14] = n)),
            this
          );
        }
        invert() {
          const t = this.elements,
            e = t[0],
            n = t[1],
            i = t[2],
            r = t[3],
            a = t[4],
            o = t[5],
            s = t[6],
            c = t[7],
            l = t[8],
            h = t[9],
            u = t[10],
            d = t[11],
            p = t[12],
            f = t[13],
            m = t[14],
            g = t[15],
            v =
              h * m * c -
              f * u * c +
              f * s * d -
              o * m * d -
              h * s * g +
              o * u * g,
            y =
              p * u * c -
              l * m * c -
              p * s * d +
              a * m * d +
              l * s * g -
              a * u * g,
            x =
              l * f * c -
              p * h * c +
              p * o * d -
              a * f * d -
              l * o * g +
              a * h * g,
            _ =
              p * h * s -
              l * f * s -
              p * o * u +
              a * f * u +
              l * o * m -
              a * h * m,
            b = e * v + n * y + i * x + r * _;
          if (0 === b)
            return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
          const w = 1 / b;
          return (
            (t[0] = v * w),
            (t[1] =
              (f * u * r -
                h * m * r -
                f * i * d +
                n * m * d +
                h * i * g -
                n * u * g) *
              w),
            (t[2] =
              (o * m * r -
                f * s * r +
                f * i * c -
                n * m * c -
                o * i * g +
                n * s * g) *
              w),
            (t[3] =
              (h * s * r -
                o * u * r -
                h * i * c +
                n * u * c +
                o * i * d -
                n * s * d) *
              w),
            (t[4] = y * w),
            (t[5] =
              (l * m * r -
                p * u * r +
                p * i * d -
                e * m * d -
                l * i * g +
                e * u * g) *
              w),
            (t[6] =
              (p * s * r -
                a * m * r -
                p * i * c +
                e * m * c +
                a * i * g -
                e * s * g) *
              w),
            (t[7] =
              (a * u * r -
                l * s * r +
                l * i * c -
                e * u * c -
                a * i * d +
                e * s * d) *
              w),
            (t[8] = x * w),
            (t[9] =
              (p * h * r -
                l * f * r -
                p * n * d +
                e * f * d +
                l * n * g -
                e * h * g) *
              w),
            (t[10] =
              (a * f * r -
                p * o * r +
                p * n * c -
                e * f * c -
                a * n * g +
                e * o * g) *
              w),
            (t[11] =
              (l * o * r -
                a * h * r -
                l * n * c +
                e * h * c +
                a * n * d -
                e * o * d) *
              w),
            (t[12] = _ * w),
            (t[13] =
              (l * f * i -
                p * h * i +
                p * n * u -
                e * f * u -
                l * n * m +
                e * h * m) *
              w),
            (t[14] =
              (p * o * i -
                a * f * i -
                p * n * s +
                e * f * s +
                a * n * m -
                e * o * m) *
              w),
            (t[15] =
              (a * h * i -
                l * o * i +
                l * n * s -
                e * h * s -
                a * n * u +
                e * o * u) *
              w),
            this
          );
        }
        scale(t) {
          const e = this.elements,
            n = t.x,
            i = t.y,
            r = t.z;
          return (
            (e[0] *= n),
            (e[4] *= i),
            (e[8] *= r),
            (e[1] *= n),
            (e[5] *= i),
            (e[9] *= r),
            (e[2] *= n),
            (e[6] *= i),
            (e[10] *= r),
            (e[3] *= n),
            (e[7] *= i),
            (e[11] *= r),
            this
          );
        }
        getMaxScaleOnAxis() {
          const t = this.elements,
            e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2],
            n = t[4] * t[4] + t[5] * t[5] + t[6] * t[6],
            i = t[8] * t[8] + t[9] * t[9] + t[10] * t[10];
          return Math.sqrt(Math.max(e, n, i));
        }
        makeTranslation(t, e, n) {
          return this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, n, 0, 0, 0, 1), this;
        }
        makeRotationX(t) {
          const e = Math.cos(t),
            n = Math.sin(t);
          return (
            this.set(1, 0, 0, 0, 0, e, -n, 0, 0, n, e, 0, 0, 0, 0, 1), this
          );
        }
        makeRotationY(t) {
          const e = Math.cos(t),
            n = Math.sin(t);
          return (
            this.set(e, 0, n, 0, 0, 1, 0, 0, -n, 0, e, 0, 0, 0, 0, 1), this
          );
        }
        makeRotationZ(t) {
          const e = Math.cos(t),
            n = Math.sin(t);
          return (
            this.set(e, -n, 0, 0, n, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
          );
        }
        makeRotationAxis(t, e) {
          const n = Math.cos(e),
            i = Math.sin(e),
            r = 1 - n,
            a = t.x,
            o = t.y,
            s = t.z,
            c = r * a,
            l = r * o;
          return (
            this.set(
              c * a + n,
              c * o - i * s,
              c * s + i * o,
              0,
              c * o + i * s,
              l * o + n,
              l * s - i * a,
              0,
              c * s - i * o,
              l * s + i * a,
              r * s * s + n,
              0,
              0,
              0,
              0,
              1
            ),
            this
          );
        }
        makeScale(t, e, n) {
          return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this;
        }
        makeShear(t, e, n, i, r, a) {
          return this.set(1, n, r, 0, t, 1, a, 0, e, i, 1, 0, 0, 0, 0, 1), this;
        }
        compose(t, e, n) {
          const i = this.elements,
            r = e._x,
            a = e._y,
            o = e._z,
            s = e._w,
            c = r + r,
            l = a + a,
            h = o + o,
            u = r * c,
            d = r * l,
            p = r * h,
            f = a * l,
            m = a * h,
            g = o * h,
            v = s * c,
            y = s * l,
            x = s * h,
            _ = n.x,
            b = n.y,
            w = n.z;
          return (
            (i[0] = (1 - (f + g)) * _),
            (i[1] = (d + x) * _),
            (i[2] = (p - y) * _),
            (i[3] = 0),
            (i[4] = (d - x) * b),
            (i[5] = (1 - (u + g)) * b),
            (i[6] = (m + v) * b),
            (i[7] = 0),
            (i[8] = (p + y) * w),
            (i[9] = (m - v) * w),
            (i[10] = (1 - (u + f)) * w),
            (i[11] = 0),
            (i[12] = t.x),
            (i[13] = t.y),
            (i[14] = t.z),
            (i[15] = 1),
            this
          );
        }
        decompose(t, e, n) {
          const i = this.elements;
          let r = ti.set(i[0], i[1], i[2]).length();
          const a = ti.set(i[4], i[5], i[6]).length(),
            o = ti.set(i[8], i[9], i[10]).length(),
            s = this.determinant();
          s < 0 && (r = -r),
            (t.x = i[12]),
            (t.y = i[13]),
            (t.z = i[14]),
            ei.copy(this);
          const c = 1 / r,
            l = 1 / a,
            h = 1 / o;
          return (
            (ei.elements[0] *= c),
            (ei.elements[1] *= c),
            (ei.elements[2] *= c),
            (ei.elements[4] *= l),
            (ei.elements[5] *= l),
            (ei.elements[6] *= l),
            (ei.elements[8] *= h),
            (ei.elements[9] *= h),
            (ei.elements[10] *= h),
            e.setFromRotationMatrix(ei),
            (n.x = r),
            (n.y = a),
            (n.z = o),
            this
          );
        }
        makePerspective(t, e, n, i, r, a) {
          void 0 === a &&
            console.warn(
              "THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs."
            );
          const o = this.elements,
            s = (2 * r) / (e - t),
            c = (2 * r) / (n - i),
            l = (e + t) / (e - t),
            h = (n + i) / (n - i),
            u = -(a + r) / (a - r),
            d = (-2 * a * r) / (a - r);
          return (
            (o[0] = s),
            (o[4] = 0),
            (o[8] = l),
            (o[12] = 0),
            (o[1] = 0),
            (o[5] = c),
            (o[9] = h),
            (o[13] = 0),
            (o[2] = 0),
            (o[6] = 0),
            (o[10] = u),
            (o[14] = d),
            (o[3] = 0),
            (o[7] = 0),
            (o[11] = -1),
            (o[15] = 0),
            this
          );
        }
        makeOrthographic(t, e, n, i, r, a) {
          const o = this.elements,
            s = 1 / (e - t),
            c = 1 / (n - i),
            l = 1 / (a - r),
            h = (e + t) * s,
            u = (n + i) * c,
            d = (a + r) * l;
          return (
            (o[0] = 2 * s),
            (o[4] = 0),
            (o[8] = 0),
            (o[12] = -h),
            (o[1] = 0),
            (o[5] = 2 * c),
            (o[9] = 0),
            (o[13] = -u),
            (o[2] = 0),
            (o[6] = 0),
            (o[10] = -2 * l),
            (o[14] = -d),
            (o[3] = 0),
            (o[7] = 0),
            (o[11] = 0),
            (o[15] = 1),
            this
          );
        }
        equals(t) {
          const e = this.elements,
            n = t.elements;
          for (let i = 0; i < 16; i++) if (e[i] !== n[i]) return !1;
          return !0;
        }
        fromArray(t, e = 0) {
          for (let n = 0; n < 16; n++) this.elements[n] = t[n + e];
          return this;
        }
        toArray(t = [], e = 0) {
          const n = this.elements;
          return (
            (t[e] = n[0]),
            (t[e + 1] = n[1]),
            (t[e + 2] = n[2]),
            (t[e + 3] = n[3]),
            (t[e + 4] = n[4]),
            (t[e + 5] = n[5]),
            (t[e + 6] = n[6]),
            (t[e + 7] = n[7]),
            (t[e + 8] = n[8]),
            (t[e + 9] = n[9]),
            (t[e + 10] = n[10]),
            (t[e + 11] = n[11]),
            (t[e + 12] = n[12]),
            (t[e + 13] = n[13]),
            (t[e + 14] = n[14]),
            (t[e + 15] = n[15]),
            t
          );
        }
      }
      Qn.prototype.isMatrix4 = !0;
      const ti = new wn(),
        ei = new Qn(),
        ni = new wn(0, 0, 0),
        ii = new wn(1, 1, 1),
        ri = new wn(),
        ai = new wn(),
        oi = new wn(),
        si = new Qn(),
        ci = new bn();
      class li {
        constructor(t = 0, e = 0, n = 0, i = li.DefaultOrder) {
          (this._x = t), (this._y = e), (this._z = n), (this._order = i);
        }
        get x() {
          return this._x;
        }
        set x(t) {
          (this._x = t), this._onChangeCallback();
        }
        get y() {
          return this._y;
        }
        set y(t) {
          (this._y = t), this._onChangeCallback();
        }
        get z() {
          return this._z;
        }
        set z(t) {
          (this._z = t), this._onChangeCallback();
        }
        get order() {
          return this._order;
        }
        set order(t) {
          (this._order = t), this._onChangeCallback();
        }
        set(t, e, n, i = this._order) {
          return (
            (this._x = t),
            (this._y = e),
            (this._z = n),
            (this._order = i),
            this._onChangeCallback(),
            this
          );
        }
        clone() {
          return new this.constructor(this._x, this._y, this._z, this._order);
        }
        copy(t) {
          return (
            (this._x = t._x),
            (this._y = t._y),
            (this._z = t._z),
            (this._order = t._order),
            this._onChangeCallback(),
            this
          );
        }
        setFromRotationMatrix(t, e = this._order, n = !0) {
          const i = t.elements,
            r = i[0],
            a = i[4],
            o = i[8],
            s = i[1],
            c = i[5],
            l = i[9],
            h = i[2],
            u = i[6],
            d = i[10];
          switch (e) {
            case "XYZ":
              (this._y = Math.asin(qe(o, -1, 1))),
                Math.abs(o) < 0.9999999
                  ? ((this._x = Math.atan2(-l, d)),
                    (this._z = Math.atan2(-a, r)))
                  : ((this._x = Math.atan2(u, c)), (this._z = 0));
              break;
            case "YXZ":
              (this._x = Math.asin(-qe(l, -1, 1))),
                Math.abs(l) < 0.9999999
                  ? ((this._y = Math.atan2(o, d)), (this._z = Math.atan2(s, c)))
                  : ((this._y = Math.atan2(-h, r)), (this._z = 0));
              break;
            case "ZXY":
              (this._x = Math.asin(qe(u, -1, 1))),
                Math.abs(u) < 0.9999999
                  ? ((this._y = Math.atan2(-h, d)),
                    (this._z = Math.atan2(-a, c)))
                  : ((this._y = 0), (this._z = Math.atan2(s, r)));
              break;
            case "ZYX":
              (this._y = Math.asin(-qe(h, -1, 1))),
                Math.abs(h) < 0.9999999
                  ? ((this._x = Math.atan2(u, d)), (this._z = Math.atan2(s, r)))
                  : ((this._x = 0), (this._z = Math.atan2(-a, c)));
              break;
            case "YZX":
              (this._z = Math.asin(qe(s, -1, 1))),
                Math.abs(s) < 0.9999999
                  ? ((this._x = Math.atan2(-l, c)),
                    (this._y = Math.atan2(-h, r)))
                  : ((this._x = 0), (this._y = Math.atan2(o, d)));
              break;
            case "XZY":
              (this._z = Math.asin(-qe(a, -1, 1))),
                Math.abs(a) < 0.9999999
                  ? ((this._x = Math.atan2(u, c)), (this._y = Math.atan2(o, r)))
                  : ((this._x = Math.atan2(-l, d)), (this._y = 0));
              break;
            default:
              console.warn(
                "THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " +
                  e
              );
          }
          return (this._order = e), !0 === n && this._onChangeCallback(), this;
        }
        setFromQuaternion(t, e, n) {
          return (
            si.makeRotationFromQuaternion(t),
            this.setFromRotationMatrix(si, e, n)
          );
        }
        setFromVector3(t, e = this._order) {
          return this.set(t.x, t.y, t.z, e);
        }
        reorder(t) {
          return ci.setFromEuler(this), this.setFromQuaternion(ci, t);
        }
        equals(t) {
          return (
            t._x === this._x &&
            t._y === this._y &&
            t._z === this._z &&
            t._order === this._order
          );
        }
        fromArray(t) {
          return (
            (this._x = t[0]),
            (this._y = t[1]),
            (this._z = t[2]),
            void 0 !== t[3] && (this._order = t[3]),
            this._onChangeCallback(),
            this
          );
        }
        toArray(t = [], e = 0) {
          return (
            (t[e] = this._x),
            (t[e + 1] = this._y),
            (t[e + 2] = this._z),
            (t[e + 3] = this._order),
            t
          );
        }
        toVector3(t) {
          return t
            ? t.set(this._x, this._y, this._z)
            : new wn(this._x, this._y, this._z);
        }
        _onChange(t) {
          return (this._onChangeCallback = t), this;
        }
        _onChangeCallback() {}
      }
      (li.prototype.isEuler = !0),
        (li.DefaultOrder = "XYZ"),
        (li.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"]);
      class hi {
        constructor() {
          this.mask = 1;
        }
        set(t) {
          this.mask = ((1 << t) | 0) >>> 0;
        }
        enable(t) {
          this.mask |= (1 << t) | 0;
        }
        enableAll() {
          this.mask = -1;
        }
        toggle(t) {
          this.mask ^= (1 << t) | 0;
        }
        disable(t) {
          this.mask &= ~((1 << t) | 0);
        }
        disableAll() {
          this.mask = 0;
        }
        test(t) {
          return 0 !== (this.mask & t.mask);
        }
        isEnabled(t) {
          return 0 !== (this.mask & ((1 << t) | 0));
        }
      }
      let ui = 0;
      const di = new wn(),
        pi = new bn(),
        fi = new Qn(),
        mi = new wn(),
        gi = new wn(),
        vi = new wn(),
        yi = new bn(),
        xi = new wn(1, 0, 0),
        _i = new wn(0, 1, 0),
        bi = new wn(0, 0, 1),
        wi = { type: "added" },
        Mi = { type: "removed" };
      class Si extends ke {
        constructor() {
          super(),
            Object.defineProperty(this, "id", { value: ui++ }),
            (this.uuid = je()),
            (this.name = ""),
            (this.type = "Object3D"),
            (this.parent = null),
            (this.children = []),
            (this.up = Si.DefaultUp.clone());
          const t = new wn(),
            e = new li(),
            n = new bn(),
            i = new wn(1, 1, 1);
          function r() {
            n.setFromEuler(e, !1);
          }
          function a() {
            e.setFromQuaternion(n, void 0, !1);
          }
          e._onChange(r),
            n._onChange(a),
            Object.defineProperties(this, {
              position: { configurable: !0, enumerable: !0, value: t },
              rotation: { configurable: !0, enumerable: !0, value: e },
              quaternion: { configurable: !0, enumerable: !0, value: n },
              scale: { configurable: !0, enumerable: !0, value: i },
              modelViewMatrix: { value: new Qn() },
              normalMatrix: { value: new Qe() },
            }),
            (this.matrix = new Qn()),
            (this.matrixWorld = new Qn()),
            (this.matrixAutoUpdate = Si.DefaultMatrixAutoUpdate),
            (this.matrixWorldNeedsUpdate = !1),
            (this.layers = new hi()),
            (this.visible = !0),
            (this.castShadow = !1),
            (this.receiveShadow = !1),
            (this.frustumCulled = !0),
            (this.renderOrder = 0),
            (this.animations = []),
            (this.userData = {});
        }
        onBeforeRender() {}
        onAfterRender() {}
        applyMatrix4(t) {
          this.matrixAutoUpdate && this.updateMatrix(),
            this.matrix.premultiply(t),
            this.matrix.decompose(this.position, this.quaternion, this.scale);
        }
        applyQuaternion(t) {
          return this.quaternion.premultiply(t), this;
        }
        setRotationFromAxisAngle(t, e) {
          this.quaternion.setFromAxisAngle(t, e);
        }
        setRotationFromEuler(t) {
          this.quaternion.setFromEuler(t, !0);
        }
        setRotationFromMatrix(t) {
          this.quaternion.setFromRotationMatrix(t);
        }
        setRotationFromQuaternion(t) {
          this.quaternion.copy(t);
        }
        rotateOnAxis(t, e) {
          return pi.setFromAxisAngle(t, e), this.quaternion.multiply(pi), this;
        }
        rotateOnWorldAxis(t, e) {
          return (
            pi.setFromAxisAngle(t, e), this.quaternion.premultiply(pi), this
          );
        }
        rotateX(t) {
          return this.rotateOnAxis(xi, t);
        }
        rotateY(t) {
          return this.rotateOnAxis(_i, t);
        }
        rotateZ(t) {
          return this.rotateOnAxis(bi, t);
        }
        translateOnAxis(t, e) {
          return (
            di.copy(t).applyQuaternion(this.quaternion),
            this.position.add(di.multiplyScalar(e)),
            this
          );
        }
        translateX(t) {
          return this.translateOnAxis(xi, t);
        }
        translateY(t) {
          return this.translateOnAxis(_i, t);
        }
        translateZ(t) {
          return this.translateOnAxis(bi, t);
        }
        localToWorld(t) {
          return t.applyMatrix4(this.matrixWorld);
        }
        worldToLocal(t) {
          return t.applyMatrix4(fi.copy(this.matrixWorld).invert());
        }
        lookAt(t, e, n) {
          t.isVector3 ? mi.copy(t) : mi.set(t, e, n);
          const i = this.parent;
          this.updateWorldMatrix(!0, !1),
            gi.setFromMatrixPosition(this.matrixWorld),
            this.isCamera || this.isLight
              ? fi.lookAt(gi, mi, this.up)
              : fi.lookAt(mi, gi, this.up),
            this.quaternion.setFromRotationMatrix(fi),
            i &&
              (fi.extractRotation(i.matrixWorld),
              pi.setFromRotationMatrix(fi),
              this.quaternion.premultiply(pi.invert()));
        }
        add(t) {
          if (arguments.length > 1) {
            for (let t = 0; t < arguments.length; t++) this.add(arguments[t]);
            return this;
          }
          return t === this
            ? (console.error(
                "THREE.Object3D.add: object can't be added as a child of itself.",
                t
              ),
              this)
            : (t && t.isObject3D
                ? (null !== t.parent && t.parent.remove(t),
                  (t.parent = this),
                  this.children.push(t),
                  t.dispatchEvent(wi))
                : console.error(
                    "THREE.Object3D.add: object not an instance of THREE.Object3D.",
                    t
                  ),
              this);
        }
        remove(t) {
          if (arguments.length > 1) {
            for (let t = 0; t < arguments.length; t++)
              this.remove(arguments[t]);
            return this;
          }
          const e = this.children.indexOf(t);
          return (
            -1 !== e &&
              ((t.parent = null),
              this.children.splice(e, 1),
              t.dispatchEvent(Mi)),
            this
          );
        }
        removeFromParent() {
          const t = this.parent;
          return null !== t && t.remove(this), this;
        }
        clear() {
          for (let t = 0; t < this.children.length; t++) {
            const e = this.children[t];
            (e.parent = null), e.dispatchEvent(Mi);
          }
          return (this.children.length = 0), this;
        }
        attach(t) {
          return (
            this.updateWorldMatrix(!0, !1),
            fi.copy(this.matrixWorld).invert(),
            null !== t.parent &&
              (t.parent.updateWorldMatrix(!0, !1),
              fi.multiply(t.parent.matrixWorld)),
            t.applyMatrix4(fi),
            this.add(t),
            t.updateWorldMatrix(!1, !0),
            this
          );
        }
        getObjectById(t) {
          return this.getObjectByProperty("id", t);
        }
        getObjectByName(t) {
          return this.getObjectByProperty("name", t);
        }
        getObjectByProperty(t, e) {
          if (this[t] === e) return this;
          for (let n = 0, i = this.children.length; n < i; n++) {
            const i = this.children[n],
              r = i.getObjectByProperty(t, e);
            if (void 0 !== r) return r;
          }
        }
        getWorldPosition(t) {
          return (
            this.updateWorldMatrix(!0, !1),
            t.setFromMatrixPosition(this.matrixWorld)
          );
        }
        getWorldQuaternion(t) {
          return (
            this.updateWorldMatrix(!0, !1),
            this.matrixWorld.decompose(gi, t, vi),
            t
          );
        }
        getWorldScale(t) {
          return (
            this.updateWorldMatrix(!0, !1),
            this.matrixWorld.decompose(gi, yi, t),
            t
          );
        }
        getWorldDirection(t) {
          this.updateWorldMatrix(!0, !1);
          const e = this.matrixWorld.elements;
          return t.set(e[8], e[9], e[10]).normalize();
        }
        raycast() {}
        traverse(t) {
          t(this);
          const e = this.children;
          for (let n = 0, i = e.length; n < i; n++) e[n].traverse(t);
        }
        traverseVisible(t) {
          if (!1 === this.visible) return;
          t(this);
          const e = this.children;
          for (let n = 0, i = e.length; n < i; n++) e[n].traverseVisible(t);
        }
        traverseAncestors(t) {
          const e = this.parent;
          null !== e && (t(e), e.traverseAncestors(t));
        }
        updateMatrix() {
          this.matrix.compose(this.position, this.quaternion, this.scale),
            (this.matrixWorldNeedsUpdate = !0);
        }
        updateMatrixWorld(t) {
          this.matrixAutoUpdate && this.updateMatrix(),
            (this.matrixWorldNeedsUpdate || t) &&
              (null === this.parent
                ? this.matrixWorld.copy(this.matrix)
                : this.matrixWorld.multiplyMatrices(
                    this.parent.matrixWorld,
                    this.matrix
                  ),
              (this.matrixWorldNeedsUpdate = !1),
              (t = !0));
          const e = this.children;
          for (let n = 0, i = e.length; n < i; n++) e[n].updateMatrixWorld(t);
        }
        updateWorldMatrix(t, e) {
          const n = this.parent;
          if (
            (!0 === t && null !== n && n.updateWorldMatrix(!0, !1),
            this.matrixAutoUpdate && this.updateMatrix(),
            null === this.parent
              ? this.matrixWorld.copy(this.matrix)
              : this.matrixWorld.multiplyMatrices(
                  this.parent.matrixWorld,
                  this.matrix
                ),
            !0 === e)
          ) {
            const t = this.children;
            for (let e = 0, n = t.length; e < n; e++)
              t[e].updateWorldMatrix(!1, !0);
          }
        }
        toJSON(t) {
          const e = void 0 === t || "string" === typeof t,
            n = {};
          e &&
            ((t = {
              geometries: {},
              materials: {},
              textures: {},
              images: {},
              shapes: {},
              skeletons: {},
              animations: {},
            }),
            (n.metadata = {
              version: 4.5,
              type: "Object",
              generator: "Object3D.toJSON",
            }));
          const i = {};
          function r(e, n) {
            return void 0 === e[n.uuid] && (e[n.uuid] = n.toJSON(t)), n.uuid;
          }
          if (
            ((i.uuid = this.uuid),
            (i.type = this.type),
            "" !== this.name && (i.name = this.name),
            !0 === this.castShadow && (i.castShadow = !0),
            !0 === this.receiveShadow && (i.receiveShadow = !0),
            !1 === this.visible && (i.visible = !1),
            !1 === this.frustumCulled && (i.frustumCulled = !1),
            0 !== this.renderOrder && (i.renderOrder = this.renderOrder),
            "{}" !== JSON.stringify(this.userData) &&
              (i.userData = this.userData),
            (i.layers = this.layers.mask),
            (i.matrix = this.matrix.toArray()),
            !1 === this.matrixAutoUpdate && (i.matrixAutoUpdate = !1),
            this.isInstancedMesh &&
              ((i.type = "InstancedMesh"),
              (i.count = this.count),
              (i.instanceMatrix = this.instanceMatrix.toJSON()),
              null !== this.instanceColor &&
                (i.instanceColor = this.instanceColor.toJSON())),
            this.isScene)
          )
            this.background &&
              (this.background.isColor
                ? (i.background = this.background.toJSON())
                : this.background.isTexture &&
                  (i.background = this.background.toJSON(t).uuid)),
              this.environment &&
                this.environment.isTexture &&
                (i.environment = this.environment.toJSON(t).uuid);
          else if (this.isMesh || this.isLine || this.isPoints) {
            i.geometry = r(t.geometries, this.geometry);
            const e = this.geometry.parameters;
            if (void 0 !== e && void 0 !== e.shapes) {
              const n = e.shapes;
              if (Array.isArray(n))
                for (let e = 0, i = n.length; e < i; e++) {
                  const i = n[e];
                  r(t.shapes, i);
                }
              else r(t.shapes, n);
            }
          }
          if (
            (this.isSkinnedMesh &&
              ((i.bindMode = this.bindMode),
              (i.bindMatrix = this.bindMatrix.toArray()),
              void 0 !== this.skeleton &&
                (r(t.skeletons, this.skeleton),
                (i.skeleton = this.skeleton.uuid))),
            void 0 !== this.material)
          )
            if (Array.isArray(this.material)) {
              const e = [];
              for (let n = 0, i = this.material.length; n < i; n++)
                e.push(r(t.materials, this.material[n]));
              i.material = e;
            } else i.material = r(t.materials, this.material);
          if (this.children.length > 0) {
            i.children = [];
            for (let e = 0; e < this.children.length; e++)
              i.children.push(this.children[e].toJSON(t).object);
          }
          if (this.animations.length > 0) {
            i.animations = [];
            for (let e = 0; e < this.animations.length; e++) {
              const n = this.animations[e];
              i.animations.push(r(t.animations, n));
            }
          }
          if (e) {
            const e = a(t.geometries),
              i = a(t.materials),
              r = a(t.textures),
              o = a(t.images),
              s = a(t.shapes),
              c = a(t.skeletons),
              l = a(t.animations);
            e.length > 0 && (n.geometries = e),
              i.length > 0 && (n.materials = i),
              r.length > 0 && (n.textures = r),
              o.length > 0 && (n.images = o),
              s.length > 0 && (n.shapes = s),
              c.length > 0 && (n.skeletons = c),
              l.length > 0 && (n.animations = l);
          }
          return (n.object = i), n;
          function a(t) {
            const e = [];
            for (const n in t) {
              const i = t[n];
              delete i.metadata, e.push(i);
            }
            return e;
          }
        }
        clone(t) {
          return new this.constructor().copy(this, t);
        }
        copy(t, e = !0) {
          if (
            ((this.name = t.name),
            this.up.copy(t.up),
            this.position.copy(t.position),
            (this.rotation.order = t.rotation.order),
            this.quaternion.copy(t.quaternion),
            this.scale.copy(t.scale),
            this.matrix.copy(t.matrix),
            this.matrixWorld.copy(t.matrixWorld),
            (this.matrixAutoUpdate = t.matrixAutoUpdate),
            (this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate),
            (this.layers.mask = t.layers.mask),
            (this.visible = t.visible),
            (this.castShadow = t.castShadow),
            (this.receiveShadow = t.receiveShadow),
            (this.frustumCulled = t.frustumCulled),
            (this.renderOrder = t.renderOrder),
            (this.userData = JSON.parse(JSON.stringify(t.userData))),
            !0 === e)
          )
            for (let n = 0; n < t.children.length; n++) {
              const e = t.children[n];
              this.add(e.clone());
            }
          return this;
        }
      }
      (Si.DefaultUp = new wn(0, 1, 0)),
        (Si.DefaultMatrixAutoUpdate = !0),
        (Si.prototype.isObject3D = !0);
      const Ei = new wn(),
        Ti = new wn(),
        Ai = new wn(),
        Ci = new wn(),
        Ri = new wn(),
        Li = new wn(),
        Pi = new wn(),
        Di = new wn(),
        Ii = new wn(),
        Oi = new wn();
      class Ni {
        constructor(t = new wn(), e = new wn(), n = new wn()) {
          (this.a = t), (this.b = e), (this.c = n);
        }
        static getNormal(t, e, n, i) {
          i.subVectors(n, e), Ei.subVectors(t, e), i.cross(Ei);
          const r = i.lengthSq();
          return r > 0 ? i.multiplyScalar(1 / Math.sqrt(r)) : i.set(0, 0, 0);
        }
        static getBarycoord(t, e, n, i, r) {
          Ei.subVectors(i, e), Ti.subVectors(n, e), Ai.subVectors(t, e);
          const a = Ei.dot(Ei),
            o = Ei.dot(Ti),
            s = Ei.dot(Ai),
            c = Ti.dot(Ti),
            l = Ti.dot(Ai),
            h = a * c - o * o;
          if (0 === h) return r.set(-2, -1, -1);
          const u = 1 / h,
            d = (c * s - o * l) * u,
            p = (a * l - o * s) * u;
          return r.set(1 - d - p, p, d);
        }
        static containsPoint(t, e, n, i) {
          return (
            this.getBarycoord(t, e, n, i, Ci),
            Ci.x >= 0 && Ci.y >= 0 && Ci.x + Ci.y <= 1
          );
        }
        static getUV(t, e, n, i, r, a, o, s) {
          return (
            this.getBarycoord(t, e, n, i, Ci),
            s.set(0, 0),
            s.addScaledVector(r, Ci.x),
            s.addScaledVector(a, Ci.y),
            s.addScaledVector(o, Ci.z),
            s
          );
        }
        static isFrontFacing(t, e, n, i) {
          return (
            Ei.subVectors(n, e), Ti.subVectors(t, e), Ei.cross(Ti).dot(i) < 0
          );
        }
        set(t, e, n) {
          return this.a.copy(t), this.b.copy(e), this.c.copy(n), this;
        }
        setFromPointsAndIndices(t, e, n, i) {
          return this.a.copy(t[e]), this.b.copy(t[n]), this.c.copy(t[i]), this;
        }
        setFromAttributeAndIndices(t, e, n, i) {
          return (
            this.a.fromBufferAttribute(t, e),
            this.b.fromBufferAttribute(t, n),
            this.c.fromBufferAttribute(t, i),
            this
          );
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(t) {
          return this.a.copy(t.a), this.b.copy(t.b), this.c.copy(t.c), this;
        }
        getArea() {
          return (
            Ei.subVectors(this.c, this.b),
            Ti.subVectors(this.a, this.b),
            0.5 * Ei.cross(Ti).length()
          );
        }
        getMidpoint(t) {
          return t
            .addVectors(this.a, this.b)
            .add(this.c)
            .multiplyScalar(1 / 3);
        }
        getNormal(t) {
          return Ni.getNormal(this.a, this.b, this.c, t);
        }
        getPlane(t) {
          return t.setFromCoplanarPoints(this.a, this.b, this.c);
        }
        getBarycoord(t, e) {
          return Ni.getBarycoord(t, this.a, this.b, this.c, e);
        }
        getUV(t, e, n, i, r) {
          return Ni.getUV(t, this.a, this.b, this.c, e, n, i, r);
        }
        containsPoint(t) {
          return Ni.containsPoint(t, this.a, this.b, this.c);
        }
        isFrontFacing(t) {
          return Ni.isFrontFacing(this.a, this.b, this.c, t);
        }
        intersectsBox(t) {
          return t.intersectsTriangle(this);
        }
        closestPointToPoint(t, e) {
          const n = this.a,
            i = this.b,
            r = this.c;
          let a, o;
          Ri.subVectors(i, n), Li.subVectors(r, n), Di.subVectors(t, n);
          const s = Ri.dot(Di),
            c = Li.dot(Di);
          if (s <= 0 && c <= 0) return e.copy(n);
          Ii.subVectors(t, i);
          const l = Ri.dot(Ii),
            h = Li.dot(Ii);
          if (l >= 0 && h <= l) return e.copy(i);
          const u = s * h - l * c;
          if (u <= 0 && s >= 0 && l <= 0)
            return (a = s / (s - l)), e.copy(n).addScaledVector(Ri, a);
          Oi.subVectors(t, r);
          const d = Ri.dot(Oi),
            p = Li.dot(Oi);
          if (p >= 0 && d <= p) return e.copy(r);
          const f = d * c - s * p;
          if (f <= 0 && c >= 0 && p <= 0)
            return (o = c / (c - p)), e.copy(n).addScaledVector(Li, o);
          const m = l * p - d * h;
          if (m <= 0 && h - l >= 0 && d - p >= 0)
            return (
              Pi.subVectors(r, i),
              (o = (h - l) / (h - l + (d - p))),
              e.copy(i).addScaledVector(Pi, o)
            );
          const g = 1 / (m + f + u);
          return (
            (a = f * g),
            (o = u * g),
            e.copy(n).addScaledVector(Ri, a).addScaledVector(Li, o)
          );
        }
        equals(t) {
          return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c);
        }
      }
      let Bi = 0;
      class zi extends ke {
        constructor() {
          super(),
            Object.defineProperty(this, "id", { value: Bi++ }),
            (this.uuid = je()),
            (this.name = ""),
            (this.type = "Material"),
            (this.fog = !0),
            (this.blending = b),
            (this.side = g),
            (this.vertexColors = !1),
            (this.opacity = 1),
            (this.transparent = !1),
            (this.blendSrc = N),
            (this.blendDst = B),
            (this.blendEquation = T),
            (this.blendSrcAlpha = null),
            (this.blendDstAlpha = null),
            (this.blendEquationAlpha = null),
            (this.depthFunc = j),
            (this.depthTest = !0),
            (this.depthWrite = !0),
            (this.stencilWriteMask = 255),
            (this.stencilFunc = Be),
            (this.stencilRef = 0),
            (this.stencilFuncMask = 255),
            (this.stencilFail = Ne),
            (this.stencilZFail = Ne),
            (this.stencilZPass = Ne),
            (this.stencilWrite = !1),
            (this.clippingPlanes = null),
            (this.clipIntersection = !1),
            (this.clipShadows = !1),
            (this.shadowSide = null),
            (this.colorWrite = !0),
            (this.precision = null),
            (this.polygonOffset = !1),
            (this.polygonOffsetFactor = 0),
            (this.polygonOffsetUnits = 0),
            (this.dithering = !1),
            (this.alphaToCoverage = !1),
            (this.premultipliedAlpha = !1),
            (this.visible = !0),
            (this.toneMapped = !0),
            (this.userData = {}),
            (this.version = 0),
            (this._alphaTest = 0);
        }
        get alphaTest() {
          return this._alphaTest;
        }
        set alphaTest(t) {
          this._alphaTest > 0 !== t > 0 && this.version++,
            (this._alphaTest = t);
        }
        onBuild() {}
        onBeforeRender() {}
        onBeforeCompile() {}
        customProgramCacheKey() {
          return this.onBeforeCompile.toString();
        }
        setValues(t) {
          if (void 0 !== t)
            for (const e in t) {
              const n = t[e];
              if (void 0 === n) {
                console.warn(
                  "THREE.Material: '" + e + "' parameter is undefined."
                );
                continue;
              }
              if ("shading" === e) {
                console.warn(
                  "THREE." +
                    this.type +
                    ": .shading has been removed. Use the boolean .flatShading instead."
                ),
                  (this.flatShading = n === x);
                continue;
              }
              const i = this[e];
              void 0 !== i
                ? i && i.isColor
                  ? i.set(n)
                  : i && i.isVector3 && n && n.isVector3
                  ? i.copy(n)
                  : (this[e] = n)
                : console.warn(
                    "THREE." +
                      this.type +
                      ": '" +
                      e +
                      "' is not a property of this material."
                  );
            }
        }
        toJSON(t) {
          const e = void 0 === t || "string" === typeof t;
          e && (t = { textures: {}, images: {} });
          const n = {
            metadata: {
              version: 4.5,
              type: "Material",
              generator: "Material.toJSON",
            },
          };
          function i(t) {
            const e = [];
            for (const n in t) {
              const i = t[n];
              delete i.metadata, e.push(i);
            }
            return e;
          }
          if (
            ((n.uuid = this.uuid),
            (n.type = this.type),
            "" !== this.name && (n.name = this.name),
            this.color && this.color.isColor && (n.color = this.color.getHex()),
            void 0 !== this.roughness && (n.roughness = this.roughness),
            void 0 !== this.metalness && (n.metalness = this.metalness),
            void 0 !== this.sheen && (n.sheen = this.sheen),
            this.sheenColor &&
              this.sheenColor.isColor &&
              (n.sheenColor = this.sheenColor.getHex()),
            void 0 !== this.sheenRoughness &&
              (n.sheenRoughness = this.sheenRoughness),
            this.emissive &&
              this.emissive.isColor &&
              (n.emissive = this.emissive.getHex()),
            this.emissiveIntensity &&
              1 !== this.emissiveIntensity &&
              (n.emissiveIntensity = this.emissiveIntensity),
            this.specular &&
              this.specular.isColor &&
              (n.specular = this.specular.getHex()),
            void 0 !== this.specularIntensity &&
              (n.specularIntensity = this.specularIntensity),
            this.specularColor &&
              this.specularColor.isColor &&
              (n.specularColor = this.specularColor.getHex()),
            void 0 !== this.shininess && (n.shininess = this.shininess),
            void 0 !== this.clearcoat && (n.clearcoat = this.clearcoat),
            void 0 !== this.clearcoatRoughness &&
              (n.clearcoatRoughness = this.clearcoatRoughness),
            this.clearcoatMap &&
              this.clearcoatMap.isTexture &&
              (n.clearcoatMap = this.clearcoatMap.toJSON(t).uuid),
            this.clearcoatRoughnessMap &&
              this.clearcoatRoughnessMap.isTexture &&
              (n.clearcoatRoughnessMap =
                this.clearcoatRoughnessMap.toJSON(t).uuid),
            this.clearcoatNormalMap &&
              this.clearcoatNormalMap.isTexture &&
              ((n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(t).uuid),
              (n.clearcoatNormalScale = this.clearcoatNormalScale.toArray())),
            this.map && this.map.isTexture && (n.map = this.map.toJSON(t).uuid),
            this.matcap &&
              this.matcap.isTexture &&
              (n.matcap = this.matcap.toJSON(t).uuid),
            this.alphaMap &&
              this.alphaMap.isTexture &&
              (n.alphaMap = this.alphaMap.toJSON(t).uuid),
            this.lightMap &&
              this.lightMap.isTexture &&
              ((n.lightMap = this.lightMap.toJSON(t).uuid),
              (n.lightMapIntensity = this.lightMapIntensity)),
            this.aoMap &&
              this.aoMap.isTexture &&
              ((n.aoMap = this.aoMap.toJSON(t).uuid),
              (n.aoMapIntensity = this.aoMapIntensity)),
            this.bumpMap &&
              this.bumpMap.isTexture &&
              ((n.bumpMap = this.bumpMap.toJSON(t).uuid),
              (n.bumpScale = this.bumpScale)),
            this.normalMap &&
              this.normalMap.isTexture &&
              ((n.normalMap = this.normalMap.toJSON(t).uuid),
              (n.normalMapType = this.normalMapType),
              (n.normalScale = this.normalScale.toArray())),
            this.displacementMap &&
              this.displacementMap.isTexture &&
              ((n.displacementMap = this.displacementMap.toJSON(t).uuid),
              (n.displacementScale = this.displacementScale),
              (n.displacementBias = this.displacementBias)),
            this.roughnessMap &&
              this.roughnessMap.isTexture &&
              (n.roughnessMap = this.roughnessMap.toJSON(t).uuid),
            this.metalnessMap &&
              this.metalnessMap.isTexture &&
              (n.metalnessMap = this.metalnessMap.toJSON(t).uuid),
            this.emissiveMap &&
              this.emissiveMap.isTexture &&
              (n.emissiveMap = this.emissiveMap.toJSON(t).uuid),
            this.specularMap &&
              this.specularMap.isTexture &&
              (n.specularMap = this.specularMap.toJSON(t).uuid),
            this.specularIntensityMap &&
              this.specularIntensityMap.isTexture &&
              (n.specularIntensityMap =
                this.specularIntensityMap.toJSON(t).uuid),
            this.specularColorMap &&
              this.specularColorMap.isTexture &&
              (n.specularColorMap = this.specularColorMap.toJSON(t).uuid),
            this.envMap &&
              this.envMap.isTexture &&
              ((n.envMap = this.envMap.toJSON(t).uuid),
              void 0 !== this.combine && (n.combine = this.combine)),
            void 0 !== this.envMapIntensity &&
              (n.envMapIntensity = this.envMapIntensity),
            void 0 !== this.reflectivity &&
              (n.reflectivity = this.reflectivity),
            void 0 !== this.refractionRatio &&
              (n.refractionRatio = this.refractionRatio),
            this.gradientMap &&
              this.gradientMap.isTexture &&
              (n.gradientMap = this.gradientMap.toJSON(t).uuid),
            void 0 !== this.transmission &&
              (n.transmission = this.transmission),
            this.transmissionMap &&
              this.transmissionMap.isTexture &&
              (n.transmissionMap = this.transmissionMap.toJSON(t).uuid),
            void 0 !== this.thickness && (n.thickness = this.thickness),
            this.thicknessMap &&
              this.thicknessMap.isTexture &&
              (n.thicknessMap = this.thicknessMap.toJSON(t).uuid),
            void 0 !== this.attenuationDistance &&
              (n.attenuationDistance = this.attenuationDistance),
            void 0 !== this.attenuationColor &&
              (n.attenuationColor = this.attenuationColor.getHex()),
            void 0 !== this.size && (n.size = this.size),
            null !== this.shadowSide && (n.shadowSide = this.shadowSide),
            void 0 !== this.sizeAttenuation &&
              (n.sizeAttenuation = this.sizeAttenuation),
            this.blending !== b && (n.blending = this.blending),
            this.side !== g && (n.side = this.side),
            this.vertexColors && (n.vertexColors = !0),
            this.opacity < 1 && (n.opacity = this.opacity),
            !0 === this.transparent && (n.transparent = this.transparent),
            (n.depthFunc = this.depthFunc),
            (n.depthTest = this.depthTest),
            (n.depthWrite = this.depthWrite),
            (n.colorWrite = this.colorWrite),
            (n.stencilWrite = this.stencilWrite),
            (n.stencilWriteMask = this.stencilWriteMask),
            (n.stencilFunc = this.stencilFunc),
            (n.stencilRef = this.stencilRef),
            (n.stencilFuncMask = this.stencilFuncMask),
            (n.stencilFail = this.stencilFail),
            (n.stencilZFail = this.stencilZFail),
            (n.stencilZPass = this.stencilZPass),
            this.rotation &&
              0 !== this.rotation &&
              (n.rotation = this.rotation),
            !0 === this.polygonOffset && (n.polygonOffset = !0),
            0 !== this.polygonOffsetFactor &&
              (n.polygonOffsetFactor = this.polygonOffsetFactor),
            0 !== this.polygonOffsetUnits &&
              (n.polygonOffsetUnits = this.polygonOffsetUnits),
            this.linewidth &&
              1 !== this.linewidth &&
              (n.linewidth = this.linewidth),
            void 0 !== this.dashSize && (n.dashSize = this.dashSize),
            void 0 !== this.gapSize && (n.gapSize = this.gapSize),
            void 0 !== this.scale && (n.scale = this.scale),
            !0 === this.dithering && (n.dithering = !0),
            this.alphaTest > 0 && (n.alphaTest = this.alphaTest),
            !0 === this.alphaToCoverage &&
              (n.alphaToCoverage = this.alphaToCoverage),
            !0 === this.premultipliedAlpha &&
              (n.premultipliedAlpha = this.premultipliedAlpha),
            !0 === this.wireframe && (n.wireframe = this.wireframe),
            this.wireframeLinewidth > 1 &&
              (n.wireframeLinewidth = this.wireframeLinewidth),
            "round" !== this.wireframeLinecap &&
              (n.wireframeLinecap = this.wireframeLinecap),
            "round" !== this.wireframeLinejoin &&
              (n.wireframeLinejoin = this.wireframeLinejoin),
            !0 === this.flatShading && (n.flatShading = this.flatShading),
            !1 === this.visible && (n.visible = !1),
            !1 === this.toneMapped && (n.toneMapped = !1),
            "{}" !== JSON.stringify(this.userData) &&
              (n.userData = this.userData),
            e)
          ) {
            const e = i(t.textures),
              r = i(t.images);
            e.length > 0 && (n.textures = e), r.length > 0 && (n.images = r);
          }
          return n;
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(t) {
          (this.name = t.name),
            (this.fog = t.fog),
            (this.blending = t.blending),
            (this.side = t.side),
            (this.vertexColors = t.vertexColors),
            (this.opacity = t.opacity),
            (this.transparent = t.transparent),
            (this.blendSrc = t.blendSrc),
            (this.blendDst = t.blendDst),
            (this.blendEquation = t.blendEquation),
            (this.blendSrcAlpha = t.blendSrcAlpha),
            (this.blendDstAlpha = t.blendDstAlpha),
            (this.blendEquationAlpha = t.blendEquationAlpha),
            (this.depthFunc = t.depthFunc),
            (this.depthTest = t.depthTest),
            (this.depthWrite = t.depthWrite),
            (this.stencilWriteMask = t.stencilWriteMask),
            (this.stencilFunc = t.stencilFunc),
            (this.stencilRef = t.stencilRef),
            (this.stencilFuncMask = t.stencilFuncMask),
            (this.stencilFail = t.stencilFail),
            (this.stencilZFail = t.stencilZFail),
            (this.stencilZPass = t.stencilZPass),
            (this.stencilWrite = t.stencilWrite);
          const e = t.clippingPlanes;
          let n = null;
          if (null !== e) {
            const t = e.length;
            n = new Array(t);
            for (let i = 0; i !== t; ++i) n[i] = e[i].clone();
          }
          return (
            (this.clippingPlanes = n),
            (this.clipIntersection = t.clipIntersection),
            (this.clipShadows = t.clipShadows),
            (this.shadowSide = t.shadowSide),
            (this.colorWrite = t.colorWrite),
            (this.precision = t.precision),
            (this.polygonOffset = t.polygonOffset),
            (this.polygonOffsetFactor = t.polygonOffsetFactor),
            (this.polygonOffsetUnits = t.polygonOffsetUnits),
            (this.dithering = t.dithering),
            (this.alphaTest = t.alphaTest),
            (this.alphaToCoverage = t.alphaToCoverage),
            (this.premultipliedAlpha = t.premultipliedAlpha),
            (this.visible = t.visible),
            (this.toneMapped = t.toneMapped),
            (this.userData = JSON.parse(JSON.stringify(t.userData))),
            this
          );
        }
        dispose() {
          this.dispatchEvent({ type: "dispose" });
        }
        set needsUpdate(t) {
          !0 === t && this.version++;
        }
      }
      zi.prototype.isMaterial = !0;
      class Ui extends zi {
        constructor(t) {
          super(),
            (this.type = "MeshBasicMaterial"),
            (this.color = new un(16777215)),
            (this.map = null),
            (this.lightMap = null),
            (this.lightMapIntensity = 1),
            (this.aoMap = null),
            (this.aoMapIntensity = 1),
            (this.specularMap = null),
            (this.alphaMap = null),
            (this.envMap = null),
            (this.combine = Z),
            (this.reflectivity = 1),
            (this.refractionRatio = 0.98),
            (this.wireframe = !1),
            (this.wireframeLinewidth = 1),
            (this.wireframeLinecap = "round"),
            (this.wireframeLinejoin = "round"),
            this.setValues(t);
        }
        copy(t) {
          return (
            super.copy(t),
            this.color.copy(t.color),
            (this.map = t.map),
            (this.lightMap = t.lightMap),
            (this.lightMapIntensity = t.lightMapIntensity),
            (this.aoMap = t.aoMap),
            (this.aoMapIntensity = t.aoMapIntensity),
            (this.specularMap = t.specularMap),
            (this.alphaMap = t.alphaMap),
            (this.envMap = t.envMap),
            (this.combine = t.combine),
            (this.reflectivity = t.reflectivity),
            (this.refractionRatio = t.refractionRatio),
            (this.wireframe = t.wireframe),
            (this.wireframeLinewidth = t.wireframeLinewidth),
            (this.wireframeLinecap = t.wireframeLinecap),
            (this.wireframeLinejoin = t.wireframeLinejoin),
            this
          );
        }
      }
      Ui.prototype.isMeshBasicMaterial = !0;
      const Fi = new wn(),
        Hi = new $e();
      class ki {
        constructor(t, e, n) {
          if (Array.isArray(t))
            throw new TypeError(
              "THREE.BufferAttribute: array should be a Typed Array."
            );
          (this.name = ""),
            (this.array = t),
            (this.itemSize = e),
            (this.count = void 0 !== t ? t.length / e : 0),
            (this.normalized = !0 === n),
            (this.usage = ze),
            (this.updateRange = { offset: 0, count: -1 }),
            (this.version = 0);
        }
        onUploadCallback() {}
        set needsUpdate(t) {
          !0 === t && this.version++;
        }
        setUsage(t) {
          return (this.usage = t), this;
        }
        copy(t) {
          return (
            (this.name = t.name),
            (this.array = new t.array.constructor(t.array)),
            (this.itemSize = t.itemSize),
            (this.count = t.count),
            (this.normalized = t.normalized),
            (this.usage = t.usage),
            this
          );
        }
        copyAt(t, e, n) {
          (t *= this.itemSize), (n *= e.itemSize);
          for (let i = 0, r = this.itemSize; i < r; i++)
            this.array[t + i] = e.array[n + i];
          return this;
        }
        copyArray(t) {
          return this.array.set(t), this;
        }
        copyColorsArray(t) {
          const e = this.array;
          let n = 0;
          for (let i = 0, r = t.length; i < r; i++) {
            let r = t[i];
            void 0 === r &&
              (console.warn(
                "THREE.BufferAttribute.copyColorsArray(): color is undefined",
                i
              ),
              (r = new un())),
              (e[n++] = r.r),
              (e[n++] = r.g),
              (e[n++] = r.b);
          }
          return this;
        }
        copyVector2sArray(t) {
          const e = this.array;
          let n = 0;
          for (let i = 0, r = t.length; i < r; i++) {
            let r = t[i];
            void 0 === r &&
              (console.warn(
                "THREE.BufferAttribute.copyVector2sArray(): vector is undefined",
                i
              ),
              (r = new $e())),
              (e[n++] = r.x),
              (e[n++] = r.y);
          }
          return this;
        }
        copyVector3sArray(t) {
          const e = this.array;
          let n = 0;
          for (let i = 0, r = t.length; i < r; i++) {
            let r = t[i];
            void 0 === r &&
              (console.warn(
                "THREE.BufferAttribute.copyVector3sArray(): vector is undefined",
                i
              ),
              (r = new wn())),
              (e[n++] = r.x),
              (e[n++] = r.y),
              (e[n++] = r.z);
          }
          return this;
        }
        copyVector4sArray(t) {
          const e = this.array;
          let n = 0;
          for (let i = 0, r = t.length; i < r; i++) {
            let r = t[i];
            void 0 === r &&
              (console.warn(
                "THREE.BufferAttribute.copyVector4sArray(): vector is undefined",
                i
              ),
              (r = new vn())),
              (e[n++] = r.x),
              (e[n++] = r.y),
              (e[n++] = r.z),
              (e[n++] = r.w);
          }
          return this;
        }
        applyMatrix3(t) {
          if (2 === this.itemSize)
            for (let e = 0, n = this.count; e < n; e++)
              Hi.fromBufferAttribute(this, e),
                Hi.applyMatrix3(t),
                this.setXY(e, Hi.x, Hi.y);
          else if (3 === this.itemSize)
            for (let e = 0, n = this.count; e < n; e++)
              Fi.fromBufferAttribute(this, e),
                Fi.applyMatrix3(t),
                this.setXYZ(e, Fi.x, Fi.y, Fi.z);
          return this;
        }
        applyMatrix4(t) {
          for (let e = 0, n = this.count; e < n; e++)
            (Fi.x = this.getX(e)),
              (Fi.y = this.getY(e)),
              (Fi.z = this.getZ(e)),
              Fi.applyMatrix4(t),
              this.setXYZ(e, Fi.x, Fi.y, Fi.z);
          return this;
        }
        applyNormalMatrix(t) {
          for (let e = 0, n = this.count; e < n; e++)
            (Fi.x = this.getX(e)),
              (Fi.y = this.getY(e)),
              (Fi.z = this.getZ(e)),
              Fi.applyNormalMatrix(t),
              this.setXYZ(e, Fi.x, Fi.y, Fi.z);
          return this;
        }
        transformDirection(t) {
          for (let e = 0, n = this.count; e < n; e++)
            (Fi.x = this.getX(e)),
              (Fi.y = this.getY(e)),
              (Fi.z = this.getZ(e)),
              Fi.transformDirection(t),
              this.setXYZ(e, Fi.x, Fi.y, Fi.z);
          return this;
        }
        set(t, e = 0) {
          return this.array.set(t, e), this;
        }
        getX(t) {
          return this.array[t * this.itemSize];
        }
        setX(t, e) {
          return (this.array[t * this.itemSize] = e), this;
        }
        getY(t) {
          return this.array[t * this.itemSize + 1];
        }
        setY(t, e) {
          return (this.array[t * this.itemSize + 1] = e), this;
        }
        getZ(t) {
          return this.array[t * this.itemSize + 2];
        }
        setZ(t, e) {
          return (this.array[t * this.itemSize + 2] = e), this;
        }
        getW(t) {
          return this.array[t * this.itemSize + 3];
        }
        setW(t, e) {
          return (this.array[t * this.itemSize + 3] = e), this;
        }
        setXY(t, e, n) {
          return (
            (t *= this.itemSize),
            (this.array[t + 0] = e),
            (this.array[t + 1] = n),
            this
          );
        }
        setXYZ(t, e, n, i) {
          return (
            (t *= this.itemSize),
            (this.array[t + 0] = e),
            (this.array[t + 1] = n),
            (this.array[t + 2] = i),
            this
          );
        }
        setXYZW(t, e, n, i, r) {
          return (
            (t *= this.itemSize),
            (this.array[t + 0] = e),
            (this.array[t + 1] = n),
            (this.array[t + 2] = i),
            (this.array[t + 3] = r),
            this
          );
        }
        onUpload(t) {
          return (this.onUploadCallback = t), this;
        }
        clone() {
          return new this.constructor(this.array, this.itemSize).copy(this);
        }
        toJSON() {
          const t = {
            itemSize: this.itemSize,
            type: this.array.constructor.name,
            array: Array.prototype.slice.call(this.array),
            normalized: this.normalized,
          };
          return (
            "" !== this.name && (t.name = this.name),
            this.usage !== ze && (t.usage = this.usage),
            (0 === this.updateRange.offset && -1 === this.updateRange.count) ||
              (t.updateRange = this.updateRange),
            t
          );
        }
      }
      ki.prototype.isBufferAttribute = !0;
      class Gi extends ki {
        constructor(t, e, n) {
          super(new Uint16Array(t), e, n);
        }
      }
      class Vi extends ki {
        constructor(t, e, n) {
          super(new Uint32Array(t), e, n);
        }
      }
      class Wi extends ki {
        constructor(t, e, n) {
          super(new Uint16Array(t), e, n);
        }
      }
      Wi.prototype.isFloat16BufferAttribute = !0;
      class ji extends ki {
        constructor(t, e, n) {
          super(new Float32Array(t), e, n);
        }
      }
      let qi = 0;
      const Xi = new Qn(),
        Yi = new Si(),
        Ji = new wn(),
        Zi = new En(),
        Ki = new En(),
        $i = new wn();
      class Qi extends ke {
        constructor() {
          super(),
            Object.defineProperty(this, "id", { value: qi++ }),
            (this.uuid = je()),
            (this.name = ""),
            (this.type = "BufferGeometry"),
            (this.index = null),
            (this.attributes = {}),
            (this.morphAttributes = {}),
            (this.morphTargetsRelative = !1),
            (this.groups = []),
            (this.boundingBox = null),
            (this.boundingSphere = null),
            (this.drawRange = { start: 0, count: 1 / 0 }),
            (this.userData = {});
        }
        getIndex() {
          return this.index;
        }
        setIndex(t) {
          return (
            Array.isArray(t)
              ? (this.index = new (tn(t) ? Vi : Gi)(t, 1))
              : (this.index = t),
            this
          );
        }
        getAttribute(t) {
          return this.attributes[t];
        }
        setAttribute(t, e) {
          return (this.attributes[t] = e), this;
        }
        deleteAttribute(t) {
          return delete this.attributes[t], this;
        }
        hasAttribute(t) {
          return void 0 !== this.attributes[t];
        }
        addGroup(t, e, n = 0) {
          this.groups.push({ start: t, count: e, materialIndex: n });
        }
        clearGroups() {
          this.groups = [];
        }
        setDrawRange(t, e) {
          (this.drawRange.start = t), (this.drawRange.count = e);
        }
        applyMatrix4(t) {
          const e = this.attributes.position;
          void 0 !== e && (e.applyMatrix4(t), (e.needsUpdate = !0));
          const n = this.attributes.normal;
          if (void 0 !== n) {
            const e = new Qe().getNormalMatrix(t);
            n.applyNormalMatrix(e), (n.needsUpdate = !0);
          }
          const i = this.attributes.tangent;
          return (
            void 0 !== i && (i.transformDirection(t), (i.needsUpdate = !0)),
            null !== this.boundingBox && this.computeBoundingBox(),
            null !== this.boundingSphere && this.computeBoundingSphere(),
            this
          );
        }
        applyQuaternion(t) {
          return Xi.makeRotationFromQuaternion(t), this.applyMatrix4(Xi), this;
        }
        rotateX(t) {
          return Xi.makeRotationX(t), this.applyMatrix4(Xi), this;
        }
        rotateY(t) {
          return Xi.makeRotationY(t), this.applyMatrix4(Xi), this;
        }
        rotateZ(t) {
          return Xi.makeRotationZ(t), this.applyMatrix4(Xi), this;
        }
        translate(t, e, n) {
          return Xi.makeTranslation(t, e, n), this.applyMatrix4(Xi), this;
        }
        scale(t, e, n) {
          return Xi.makeScale(t, e, n), this.applyMatrix4(Xi), this;
        }
        lookAt(t) {
          return (
            Yi.lookAt(t), Yi.updateMatrix(), this.applyMatrix4(Yi.matrix), this
          );
        }
        center() {
          return (
            this.computeBoundingBox(),
            this.boundingBox.getCenter(Ji).negate(),
            this.translate(Ji.x, Ji.y, Ji.z),
            this
          );
        }
        setFromPoints(t) {
          const e = [];
          for (let n = 0, i = t.length; n < i; n++) {
            const i = t[n];
            e.push(i.x, i.y, i.z || 0);
          }
          return this.setAttribute("position", new ji(e, 3)), this;
        }
        computeBoundingBox() {
          null === this.boundingBox && (this.boundingBox = new En());
          const t = this.attributes.position,
            e = this.morphAttributes.position;
          if (t && t.isGLBufferAttribute)
            return (
              console.error(
                'THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',
                this
              ),
              void this.boundingBox.set(
                new wn(-1 / 0, -1 / 0, -1 / 0),
                new wn(1 / 0, 1 / 0, 1 / 0)
              )
            );
          if (void 0 !== t) {
            if ((this.boundingBox.setFromBufferAttribute(t), e))
              for (let n = 0, i = e.length; n < i; n++) {
                const t = e[n];
                Zi.setFromBufferAttribute(t),
                  this.morphTargetsRelative
                    ? ($i.addVectors(this.boundingBox.min, Zi.min),
                      this.boundingBox.expandByPoint($i),
                      $i.addVectors(this.boundingBox.max, Zi.max),
                      this.boundingBox.expandByPoint($i))
                    : (this.boundingBox.expandByPoint(Zi.min),
                      this.boundingBox.expandByPoint(Zi.max));
              }
          } else this.boundingBox.makeEmpty();
          (isNaN(this.boundingBox.min.x) ||
            isNaN(this.boundingBox.min.y) ||
            isNaN(this.boundingBox.min.z)) &&
            console.error(
              'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',
              this
            );
        }
        computeBoundingSphere() {
          null === this.boundingSphere && (this.boundingSphere = new Wn());
          const t = this.attributes.position,
            e = this.morphAttributes.position;
          if (t && t.isGLBufferAttribute)
            return (
              console.error(
                'THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',
                this
              ),
              void this.boundingSphere.set(new wn(), 1 / 0)
            );
          if (t) {
            const n = this.boundingSphere.center;
            if ((Zi.setFromBufferAttribute(t), e))
              for (let t = 0, r = e.length; t < r; t++) {
                const n = e[t];
                Ki.setFromBufferAttribute(n),
                  this.morphTargetsRelative
                    ? ($i.addVectors(Zi.min, Ki.min),
                      Zi.expandByPoint($i),
                      $i.addVectors(Zi.max, Ki.max),
                      Zi.expandByPoint($i))
                    : (Zi.expandByPoint(Ki.min), Zi.expandByPoint(Ki.max));
              }
            Zi.getCenter(n);
            let i = 0;
            for (let e = 0, r = t.count; e < r; e++)
              $i.fromBufferAttribute(t, e),
                (i = Math.max(i, n.distanceToSquared($i)));
            if (e)
              for (let r = 0, a = e.length; r < a; r++) {
                const a = e[r],
                  o = this.morphTargetsRelative;
                for (let e = 0, r = a.count; e < r; e++)
                  $i.fromBufferAttribute(a, e),
                    o && (Ji.fromBufferAttribute(t, e), $i.add(Ji)),
                    (i = Math.max(i, n.distanceToSquared($i)));
              }
            (this.boundingSphere.radius = Math.sqrt(i)),
              isNaN(this.boundingSphere.radius) &&
                console.error(
                  'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
                  this
                );
          }
        }
        computeTangents() {
          const t = this.index,
            e = this.attributes;
          if (
            null === t ||
            void 0 === e.position ||
            void 0 === e.normal ||
            void 0 === e.uv
          )
            return void console.error(
              "THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)"
            );
          const n = t.array,
            i = e.position.array,
            r = e.normal.array,
            a = e.uv.array,
            o = i.length / 3;
          void 0 === e.tangent &&
            this.setAttribute("tangent", new ki(new Float32Array(4 * o), 4));
          const s = e.tangent.array,
            c = [],
            l = [];
          for (let E = 0; E < o; E++) (c[E] = new wn()), (l[E] = new wn());
          const h = new wn(),
            u = new wn(),
            d = new wn(),
            p = new $e(),
            f = new $e(),
            m = new $e(),
            g = new wn(),
            v = new wn();
          function y(t, e, n) {
            h.fromArray(i, 3 * t),
              u.fromArray(i, 3 * e),
              d.fromArray(i, 3 * n),
              p.fromArray(a, 2 * t),
              f.fromArray(a, 2 * e),
              m.fromArray(a, 2 * n),
              u.sub(h),
              d.sub(h),
              f.sub(p),
              m.sub(p);
            const r = 1 / (f.x * m.y - m.x * f.y);
            isFinite(r) &&
              (g
                .copy(u)
                .multiplyScalar(m.y)
                .addScaledVector(d, -f.y)
                .multiplyScalar(r),
              v
                .copy(d)
                .multiplyScalar(f.x)
                .addScaledVector(u, -m.x)
                .multiplyScalar(r),
              c[t].add(g),
              c[e].add(g),
              c[n].add(g),
              l[t].add(v),
              l[e].add(v),
              l[n].add(v));
          }
          let x = this.groups;
          0 === x.length && (x = [{ start: 0, count: n.length }]);
          for (let E = 0, T = x.length; E < T; ++E) {
            const t = x[E],
              e = t.start,
              i = t.count;
            for (let r = e, a = e + i; r < a; r += 3)
              y(n[r + 0], n[r + 1], n[r + 2]);
          }
          const _ = new wn(),
            b = new wn(),
            w = new wn(),
            M = new wn();
          function S(t) {
            w.fromArray(r, 3 * t), M.copy(w);
            const e = c[t];
            _.copy(e),
              _.sub(w.multiplyScalar(w.dot(e))).normalize(),
              b.crossVectors(M, e);
            const n = b.dot(l[t]),
              i = n < 0 ? -1 : 1;
            (s[4 * t] = _.x),
              (s[4 * t + 1] = _.y),
              (s[4 * t + 2] = _.z),
              (s[4 * t + 3] = i);
          }
          for (let E = 0, T = x.length; E < T; ++E) {
            const t = x[E],
              e = t.start,
              i = t.count;
            for (let r = e, a = e + i; r < a; r += 3)
              S(n[r + 0]), S(n[r + 1]), S(n[r + 2]);
          }
        }
        computeVertexNormals() {
          const t = this.index,
            e = this.getAttribute("position");
          if (void 0 !== e) {
            let n = this.getAttribute("normal");
            if (void 0 === n)
              (n = new ki(new Float32Array(3 * e.count), 3)),
                this.setAttribute("normal", n);
            else for (let t = 0, e = n.count; t < e; t++) n.setXYZ(t, 0, 0, 0);
            const i = new wn(),
              r = new wn(),
              a = new wn(),
              o = new wn(),
              s = new wn(),
              c = new wn(),
              l = new wn(),
              h = new wn();
            if (t)
              for (let u = 0, d = t.count; u < d; u += 3) {
                const d = t.getX(u + 0),
                  p = t.getX(u + 1),
                  f = t.getX(u + 2);
                i.fromBufferAttribute(e, d),
                  r.fromBufferAttribute(e, p),
                  a.fromBufferAttribute(e, f),
                  l.subVectors(a, r),
                  h.subVectors(i, r),
                  l.cross(h),
                  o.fromBufferAttribute(n, d),
                  s.fromBufferAttribute(n, p),
                  c.fromBufferAttribute(n, f),
                  o.add(l),
                  s.add(l),
                  c.add(l),
                  n.setXYZ(d, o.x, o.y, o.z),
                  n.setXYZ(p, s.x, s.y, s.z),
                  n.setXYZ(f, c.x, c.y, c.z);
              }
            else
              for (let t = 0, u = e.count; t < u; t += 3)
                i.fromBufferAttribute(e, t + 0),
                  r.fromBufferAttribute(e, t + 1),
                  a.fromBufferAttribute(e, t + 2),
                  l.subVectors(a, r),
                  h.subVectors(i, r),
                  l.cross(h),
                  n.setXYZ(t + 0, l.x, l.y, l.z),
                  n.setXYZ(t + 1, l.x, l.y, l.z),
                  n.setXYZ(t + 2, l.x, l.y, l.z);
            this.normalizeNormals(), (n.needsUpdate = !0);
          }
        }
        merge(t, e) {
          if (!t || !t.isBufferGeometry)
            return void console.error(
              "THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.",
              t
            );
          void 0 === e &&
            ((e = 0),
            console.warn(
              "THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."
            ));
          const n = this.attributes;
          for (const i in n) {
            if (void 0 === t.attributes[i]) continue;
            const r = n[i],
              a = r.array,
              o = t.attributes[i],
              s = o.array,
              c = o.itemSize * e,
              l = Math.min(s.length, a.length - c);
            for (let t = 0, e = c; t < l; t++, e++) a[e] = s[t];
          }
          return this;
        }
        normalizeNormals() {
          const t = this.attributes.normal;
          for (let e = 0, n = t.count; e < n; e++)
            $i.fromBufferAttribute(t, e),
              $i.normalize(),
              t.setXYZ(e, $i.x, $i.y, $i.z);
        }
        toNonIndexed() {
          function t(t, e) {
            const n = t.array,
              i = t.itemSize,
              r = t.normalized,
              a = new n.constructor(e.length * i);
            let o = 0,
              s = 0;
            for (let c = 0, l = e.length; c < l; c++) {
              o = t.isInterleavedBufferAttribute
                ? e[c] * t.data.stride + t.offset
                : e[c] * i;
              for (let t = 0; t < i; t++) a[s++] = n[o++];
            }
            return new ki(a, i, r);
          }
          if (null === this.index)
            return (
              console.warn(
                "THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."
              ),
              this
            );
          const e = new Qi(),
            n = this.index.array,
            i = this.attributes;
          for (const o in i) {
            const r = i[o],
              a = t(r, n);
            e.setAttribute(o, a);
          }
          const r = this.morphAttributes;
          for (const o in r) {
            const i = [],
              a = r[o];
            for (let e = 0, r = a.length; e < r; e++) {
              const r = a[e],
                o = t(r, n);
              i.push(o);
            }
            e.morphAttributes[o] = i;
          }
          e.morphTargetsRelative = this.morphTargetsRelative;
          const a = this.groups;
          for (let o = 0, s = a.length; o < s; o++) {
            const t = a[o];
            e.addGroup(t.start, t.count, t.materialIndex);
          }
          return e;
        }
        toJSON() {
          const t = {
            metadata: {
              version: 4.5,
              type: "BufferGeometry",
              generator: "BufferGeometry.toJSON",
            },
          };
          if (
            ((t.uuid = this.uuid),
            (t.type = this.type),
            "" !== this.name && (t.name = this.name),
            Object.keys(this.userData).length > 0 &&
              (t.userData = this.userData),
            void 0 !== this.parameters)
          ) {
            const e = this.parameters;
            for (const n in e) void 0 !== e[n] && (t[n] = e[n]);
            return t;
          }
          t.data = { attributes: {} };
          const e = this.index;
          null !== e &&
            (t.data.index = {
              type: e.array.constructor.name,
              array: Array.prototype.slice.call(e.array),
            });
          const n = this.attributes;
          for (const s in n) {
            const e = n[s];
            t.data.attributes[s] = e.toJSON(t.data);
          }
          const i = {};
          let r = !1;
          for (const s in this.morphAttributes) {
            const e = this.morphAttributes[s],
              n = [];
            for (let i = 0, r = e.length; i < r; i++) {
              const r = e[i];
              n.push(r.toJSON(t.data));
            }
            n.length > 0 && ((i[s] = n), (r = !0));
          }
          r &&
            ((t.data.morphAttributes = i),
            (t.data.morphTargetsRelative = this.morphTargetsRelative));
          const a = this.groups;
          a.length > 0 && (t.data.groups = JSON.parse(JSON.stringify(a)));
          const o = this.boundingSphere;
          return (
            null !== o &&
              (t.data.boundingSphere = {
                center: o.center.toArray(),
                radius: o.radius,
              }),
            t
          );
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(t) {
          (this.index = null),
            (this.attributes = {}),
            (this.morphAttributes = {}),
            (this.groups = []),
            (this.boundingBox = null),
            (this.boundingSphere = null);
          const e = {};
          this.name = t.name;
          const n = t.index;
          null !== n && this.setIndex(n.clone(e));
          const i = t.attributes;
          for (const c in i) {
            const t = i[c];
            this.setAttribute(c, t.clone(e));
          }
          const r = t.morphAttributes;
          for (const c in r) {
            const t = [],
              n = r[c];
            for (let i = 0, r = n.length; i < r; i++) t.push(n[i].clone(e));
            this.morphAttributes[c] = t;
          }
          this.morphTargetsRelative = t.morphTargetsRelative;
          const a = t.groups;
          for (let c = 0, l = a.length; c < l; c++) {
            const t = a[c];
            this.addGroup(t.start, t.count, t.materialIndex);
          }
          const o = t.boundingBox;
          null !== o && (this.boundingBox = o.clone());
          const s = t.boundingSphere;
          return (
            null !== s && (this.boundingSphere = s.clone()),
            (this.drawRange.start = t.drawRange.start),
            (this.drawRange.count = t.drawRange.count),
            (this.userData = t.userData),
            void 0 !== t.parameters &&
              (this.parameters = Object.assign({}, t.parameters)),
            this
          );
        }
        dispose() {
          this.dispatchEvent({ type: "dispose" });
        }
      }
      Qi.prototype.isBufferGeometry = !0;
      const tr = new Qn(),
        er = new $n(),
        nr = new Wn(),
        ir = new wn(),
        rr = new wn(),
        ar = new wn(),
        or = new wn(),
        sr = new wn(),
        cr = new wn(),
        lr = new wn(),
        hr = new wn(),
        ur = new wn(),
        dr = new $e(),
        pr = new $e(),
        fr = new $e(),
        mr = new wn(),
        gr = new wn();
      class vr extends Si {
        constructor(t = new Qi(), e = new Ui()) {
          super(),
            (this.type = "Mesh"),
            (this.geometry = t),
            (this.material = e),
            this.updateMorphTargets();
        }
        copy(t) {
          return (
            super.copy(t),
            void 0 !== t.morphTargetInfluences &&
              (this.morphTargetInfluences = t.morphTargetInfluences.slice()),
            void 0 !== t.morphTargetDictionary &&
              (this.morphTargetDictionary = Object.assign(
                {},
                t.morphTargetDictionary
              )),
            (this.material = t.material),
            (this.geometry = t.geometry),
            this
          );
        }
        updateMorphTargets() {
          const t = this.geometry;
          if (t.isBufferGeometry) {
            const e = t.morphAttributes,
              n = Object.keys(e);
            if (n.length > 0) {
              const t = e[n[0]];
              if (void 0 !== t) {
                (this.morphTargetInfluences = []),
                  (this.morphTargetDictionary = {});
                for (let e = 0, n = t.length; e < n; e++) {
                  const n = t[e].name || String(e);
                  this.morphTargetInfluences.push(0),
                    (this.morphTargetDictionary[n] = e);
                }
              }
            }
          } else {
            const e = t.morphTargets;
            void 0 !== e &&
              e.length > 0 &&
              console.error(
                "THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
              );
          }
        }
        raycast(t, e) {
          const n = this.geometry,
            i = this.material,
            r = this.matrixWorld;
          if (void 0 === i) return;
          if (
            (null === n.boundingSphere && n.computeBoundingSphere(),
            nr.copy(n.boundingSphere),
            nr.applyMatrix4(r),
            !1 === t.ray.intersectsSphere(nr))
          )
            return;
          if (
            (tr.copy(r).invert(),
            er.copy(t.ray).applyMatrix4(tr),
            null !== n.boundingBox && !1 === er.intersectsBox(n.boundingBox))
          )
            return;
          let a;
          if (n.isBufferGeometry) {
            const r = n.index,
              o = n.attributes.position,
              s = n.morphAttributes.position,
              c = n.morphTargetsRelative,
              l = n.attributes.uv,
              h = n.attributes.uv2,
              u = n.groups,
              d = n.drawRange;
            if (null !== r)
              if (Array.isArray(i))
                for (let n = 0, p = u.length; n < p; n++) {
                  const p = u[n],
                    f = i[p.materialIndex],
                    m = Math.max(p.start, d.start),
                    g = Math.min(
                      r.count,
                      Math.min(p.start + p.count, d.start + d.count)
                    );
                  for (let n = m, i = g; n < i; n += 3) {
                    const i = r.getX(n),
                      u = r.getX(n + 1),
                      d = r.getX(n + 2);
                    (a = xr(this, f, t, er, o, s, c, l, h, i, u, d)),
                      a &&
                        ((a.faceIndex = Math.floor(n / 3)),
                        (a.face.materialIndex = p.materialIndex),
                        e.push(a));
                  }
                }
              else {
                const n = Math.max(0, d.start),
                  u = Math.min(r.count, d.start + d.count);
                for (let d = n, p = u; d < p; d += 3) {
                  const n = r.getX(d),
                    u = r.getX(d + 1),
                    p = r.getX(d + 2);
                  (a = xr(this, i, t, er, o, s, c, l, h, n, u, p)),
                    a && ((a.faceIndex = Math.floor(d / 3)), e.push(a));
                }
              }
            else if (void 0 !== o)
              if (Array.isArray(i))
                for (let n = 0, p = u.length; n < p; n++) {
                  const r = u[n],
                    p = i[r.materialIndex],
                    f = Math.max(r.start, d.start),
                    m = Math.min(
                      o.count,
                      Math.min(r.start + r.count, d.start + d.count)
                    );
                  for (let n = f, i = m; n < i; n += 3) {
                    const i = n,
                      u = n + 1,
                      d = n + 2;
                    (a = xr(this, p, t, er, o, s, c, l, h, i, u, d)),
                      a &&
                        ((a.faceIndex = Math.floor(n / 3)),
                        (a.face.materialIndex = r.materialIndex),
                        e.push(a));
                  }
                }
              else {
                const n = Math.max(0, d.start),
                  r = Math.min(o.count, d.start + d.count);
                for (let u = n, d = r; u < d; u += 3) {
                  const n = u,
                    r = u + 1,
                    d = u + 2;
                  (a = xr(this, i, t, er, o, s, c, l, h, n, r, d)),
                    a && ((a.faceIndex = Math.floor(u / 3)), e.push(a));
                }
              }
          } else
            n.isGeometry &&
              console.error(
                "THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
              );
        }
      }
      function yr(t, e, n, i, r, a, o, s) {
        let c;
        if (
          ((c =
            e.side === v
              ? i.intersectTriangle(o, a, r, !0, s)
              : i.intersectTriangle(r, a, o, e.side !== y, s)),
          null === c)
        )
          return null;
        gr.copy(s), gr.applyMatrix4(t.matrixWorld);
        const l = n.ray.origin.distanceTo(gr);
        return l < n.near || l > n.far
          ? null
          : { distance: l, point: gr.clone(), object: t };
      }
      function xr(t, e, n, i, r, a, o, s, c, l, h, u) {
        ir.fromBufferAttribute(r, l),
          rr.fromBufferAttribute(r, h),
          ar.fromBufferAttribute(r, u);
        const d = t.morphTargetInfluences;
        if (a && d) {
          lr.set(0, 0, 0), hr.set(0, 0, 0), ur.set(0, 0, 0);
          for (let t = 0, e = a.length; t < e; t++) {
            const e = d[t],
              n = a[t];
            0 !== e &&
              (or.fromBufferAttribute(n, l),
              sr.fromBufferAttribute(n, h),
              cr.fromBufferAttribute(n, u),
              o
                ? (lr.addScaledVector(or, e),
                  hr.addScaledVector(sr, e),
                  ur.addScaledVector(cr, e))
                : (lr.addScaledVector(or.sub(ir), e),
                  hr.addScaledVector(sr.sub(rr), e),
                  ur.addScaledVector(cr.sub(ar), e)));
          }
          ir.add(lr), rr.add(hr), ar.add(ur);
        }
        t.isSkinnedMesh &&
          (t.boneTransform(l, ir),
          t.boneTransform(h, rr),
          t.boneTransform(u, ar));
        const p = yr(t, e, n, i, ir, rr, ar, mr);
        if (p) {
          s &&
            (dr.fromBufferAttribute(s, l),
            pr.fromBufferAttribute(s, h),
            fr.fromBufferAttribute(s, u),
            (p.uv = Ni.getUV(mr, ir, rr, ar, dr, pr, fr, new $e()))),
            c &&
              (dr.fromBufferAttribute(c, l),
              pr.fromBufferAttribute(c, h),
              fr.fromBufferAttribute(c, u),
              (p.uv2 = Ni.getUV(mr, ir, rr, ar, dr, pr, fr, new $e())));
          const t = { a: l, b: h, c: u, normal: new wn(), materialIndex: 0 };
          Ni.getNormal(ir, rr, ar, t.normal), (p.face = t);
        }
        return p;
      }
      vr.prototype.isMesh = !0;
      class _r extends Qi {
        constructor(t = 1, e = 1, n = 1, i = 1, r = 1, a = 1) {
          super(),
            (this.type = "BoxGeometry"),
            (this.parameters = {
              width: t,
              height: e,
              depth: n,
              widthSegments: i,
              heightSegments: r,
              depthSegments: a,
            });
          const o = this;
          (i = Math.floor(i)), (r = Math.floor(r)), (a = Math.floor(a));
          const s = [],
            c = [],
            l = [],
            h = [];
          let u = 0,
            d = 0;
          function p(t, e, n, i, r, a, p, f, m, g, v) {
            const y = a / m,
              x = p / g,
              _ = a / 2,
              b = p / 2,
              w = f / 2,
              M = m + 1,
              S = g + 1;
            let E = 0,
              T = 0;
            const A = new wn();
            for (let o = 0; o < S; o++) {
              const a = o * x - b;
              for (let s = 0; s < M; s++) {
                const u = s * y - _;
                (A[t] = u * i),
                  (A[e] = a * r),
                  (A[n] = w),
                  c.push(A.x, A.y, A.z),
                  (A[t] = 0),
                  (A[e] = 0),
                  (A[n] = f > 0 ? 1 : -1),
                  l.push(A.x, A.y, A.z),
                  h.push(s / m),
                  h.push(1 - o / g),
                  (E += 1);
              }
            }
            for (let o = 0; o < g; o++)
              for (let t = 0; t < m; t++) {
                const e = u + t + M * o,
                  n = u + t + M * (o + 1),
                  i = u + (t + 1) + M * (o + 1),
                  r = u + (t + 1) + M * o;
                s.push(e, n, r), s.push(n, i, r), (T += 6);
              }
            o.addGroup(d, T, v), (d += T), (u += E);
          }
          p("z", "y", "x", -1, -1, n, e, t, a, r, 0),
            p("z", "y", "x", 1, -1, n, e, -t, a, r, 1),
            p("x", "z", "y", 1, 1, t, n, e, i, a, 2),
            p("x", "z", "y", 1, -1, t, n, -e, i, a, 3),
            p("x", "y", "z", 1, -1, t, e, n, i, r, 4),
            p("x", "y", "z", -1, -1, t, e, -n, i, r, 5),
            this.setIndex(s),
            this.setAttribute("position", new ji(c, 3)),
            this.setAttribute("normal", new ji(l, 3)),
            this.setAttribute("uv", new ji(h, 2));
        }
        static fromJSON(t) {
          return new _r(
            t.width,
            t.height,
            t.depth,
            t.widthSegments,
            t.heightSegments,
            t.depthSegments
          );
        }
      }
      function br(t) {
        const e = {};
        for (const n in t) {
          e[n] = {};
          for (const i in t[n]) {
            const r = t[n][i];
            r &&
            (r.isColor ||
              r.isMatrix3 ||
              r.isMatrix4 ||
              r.isVector2 ||
              r.isVector3 ||
              r.isVector4 ||
              r.isTexture ||
              r.isQuaternion)
              ? (e[n][i] = r.clone())
              : Array.isArray(r)
              ? (e[n][i] = r.slice())
              : (e[n][i] = r);
          }
        }
        return e;
      }
      function wr(t) {
        const e = {};
        for (let n = 0; n < t.length; n++) {
          const i = br(t[n]);
          for (const t in i) e[t] = i[t];
        }
        return e;
      }
      const Mr = { clone: br, merge: wr };
      var Sr =
          "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",
        Er = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";
      class Tr extends zi {
        constructor(t) {
          super(),
            (this.type = "ShaderMaterial"),
            (this.defines = {}),
            (this.uniforms = {}),
            (this.vertexShader = Sr),
            (this.fragmentShader = Er),
            (this.linewidth = 1),
            (this.wireframe = !1),
            (this.wireframeLinewidth = 1),
            (this.fog = !1),
            (this.lights = !1),
            (this.clipping = !1),
            (this.extensions = {
              derivatives: !1,
              fragDepth: !1,
              drawBuffers: !1,
              shaderTextureLOD: !1,
            }),
            (this.defaultAttributeValues = {
              color: [1, 1, 1],
              uv: [0, 0],
              uv2: [0, 0],
            }),
            (this.index0AttributeName = void 0),
            (this.uniformsNeedUpdate = !1),
            (this.glslVersion = null),
            void 0 !== t &&
              (void 0 !== t.attributes &&
                console.error(
                  "THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."
                ),
              this.setValues(t));
        }
        copy(t) {
          return (
            super.copy(t),
            (this.fragmentShader = t.fragmentShader),
            (this.vertexShader = t.vertexShader),
            (this.uniforms = br(t.uniforms)),
            (this.defines = Object.assign({}, t.defines)),
            (this.wireframe = t.wireframe),
            (this.wireframeLinewidth = t.wireframeLinewidth),
            (this.lights = t.lights),
            (this.clipping = t.clipping),
            (this.extensions = Object.assign({}, t.extensions)),
            (this.glslVersion = t.glslVersion),
            this
          );
        }
        toJSON(t) {
          const e = super.toJSON(t);
          (e.glslVersion = this.glslVersion), (e.uniforms = {});
          for (const i in this.uniforms) {
            const n = this.uniforms[i],
              r = n.value;
            r && r.isTexture
              ? (e.uniforms[i] = { type: "t", value: r.toJSON(t).uuid })
              : r && r.isColor
              ? (e.uniforms[i] = { type: "c", value: r.getHex() })
              : r && r.isVector2
              ? (e.uniforms[i] = { type: "v2", value: r.toArray() })
              : r && r.isVector3
              ? (e.uniforms[i] = { type: "v3", value: r.toArray() })
              : r && r.isVector4
              ? (e.uniforms[i] = { type: "v4", value: r.toArray() })
              : r && r.isMatrix3
              ? (e.uniforms[i] = { type: "m3", value: r.toArray() })
              : r && r.isMatrix4
              ? (e.uniforms[i] = { type: "m4", value: r.toArray() })
              : (e.uniforms[i] = { value: r });
          }
          Object.keys(this.defines).length > 0 && (e.defines = this.defines),
            (e.vertexShader = this.vertexShader),
            (e.fragmentShader = this.fragmentShader);
          const n = {};
          for (const i in this.extensions)
            !0 === this.extensions[i] && (n[i] = !0);
          return Object.keys(n).length > 0 && (e.extensions = n), e;
        }
      }
      Tr.prototype.isShaderMaterial = !0;
      class Ar extends Si {
        constructor() {
          super(),
            (this.type = "Camera"),
            (this.matrixWorldInverse = new Qn()),
            (this.projectionMatrix = new Qn()),
            (this.projectionMatrixInverse = new Qn());
        }
        copy(t, e) {
          return (
            super.copy(t, e),
            this.matrixWorldInverse.copy(t.matrixWorldInverse),
            this.projectionMatrix.copy(t.projectionMatrix),
            this.projectionMatrixInverse.copy(t.projectionMatrixInverse),
            this
          );
        }
        getWorldDirection(t) {
          this.updateWorldMatrix(!0, !1);
          const e = this.matrixWorld.elements;
          return t.set(-e[8], -e[9], -e[10]).normalize();
        }
        updateMatrixWorld(t) {
          super.updateMatrixWorld(t),
            this.matrixWorldInverse.copy(this.matrixWorld).invert();
        }
        updateWorldMatrix(t, e) {
          super.updateWorldMatrix(t, e),
            this.matrixWorldInverse.copy(this.matrixWorld).invert();
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      Ar.prototype.isCamera = !0;
      class Cr extends Ar {
        constructor(t = 50, e = 1, n = 0.1, i = 2e3) {
          super(),
            (this.type = "PerspectiveCamera"),
            (this.fov = t),
            (this.zoom = 1),
            (this.near = n),
            (this.far = i),
            (this.focus = 10),
            (this.aspect = e),
            (this.view = null),
            (this.filmGauge = 35),
            (this.filmOffset = 0),
            this.updateProjectionMatrix();
        }
        copy(t, e) {
          return (
            super.copy(t, e),
            (this.fov = t.fov),
            (this.zoom = t.zoom),
            (this.near = t.near),
            (this.far = t.far),
            (this.focus = t.focus),
            (this.aspect = t.aspect),
            (this.view = null === t.view ? null : Object.assign({}, t.view)),
            (this.filmGauge = t.filmGauge),
            (this.filmOffset = t.filmOffset),
            this
          );
        }
        setFocalLength(t) {
          const e = (0.5 * this.getFilmHeight()) / t;
          (this.fov = 2 * We * Math.atan(e)), this.updateProjectionMatrix();
        }
        getFocalLength() {
          const t = Math.tan(0.5 * Ve * this.fov);
          return (0.5 * this.getFilmHeight()) / t;
        }
        getEffectiveFOV() {
          return 2 * We * Math.atan(Math.tan(0.5 * Ve * this.fov) / this.zoom);
        }
        getFilmWidth() {
          return this.filmGauge * Math.min(this.aspect, 1);
        }
        getFilmHeight() {
          return this.filmGauge / Math.max(this.aspect, 1);
        }
        setViewOffset(t, e, n, i, r, a) {
          (this.aspect = t / e),
            null === this.view &&
              (this.view = {
                enabled: !0,
                fullWidth: 1,
                fullHeight: 1,
                offsetX: 0,
                offsetY: 0,
                width: 1,
                height: 1,
              }),
            (this.view.enabled = !0),
            (this.view.fullWidth = t),
            (this.view.fullHeight = e),
            (this.view.offsetX = n),
            (this.view.offsetY = i),
            (this.view.width = r),
            (this.view.height = a),
            this.updateProjectionMatrix();
        }
        clearViewOffset() {
          null !== this.view && (this.view.enabled = !1),
            this.updateProjectionMatrix();
        }
        updateProjectionMatrix() {
          const t = this.near;
          let e = (t * Math.tan(0.5 * Ve * this.fov)) / this.zoom,
            n = 2 * e,
            i = this.aspect * n,
            r = -0.5 * i;
          const a = this.view;
          if (null !== this.view && this.view.enabled) {
            const t = a.fullWidth,
              o = a.fullHeight;
            (r += (a.offsetX * i) / t),
              (e -= (a.offsetY * n) / o),
              (i *= a.width / t),
              (n *= a.height / o);
          }
          const o = this.filmOffset;
          0 !== o && (r += (t * o) / this.getFilmWidth()),
            this.projectionMatrix.makePerspective(
              r,
              r + i,
              e,
              e - n,
              t,
              this.far
            ),
            this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
        }
        toJSON(t) {
          const e = super.toJSON(t);
          return (
            (e.object.fov = this.fov),
            (e.object.zoom = this.zoom),
            (e.object.near = this.near),
            (e.object.far = this.far),
            (e.object.focus = this.focus),
            (e.object.aspect = this.aspect),
            null !== this.view &&
              (e.object.view = Object.assign({}, this.view)),
            (e.object.filmGauge = this.filmGauge),
            (e.object.filmOffset = this.filmOffset),
            e
          );
        }
      }
      Cr.prototype.isPerspectiveCamera = !0;
      const Rr = 90,
        Lr = 1;
      class Pr extends Si {
        constructor(t, e, n) {
          if (
            (super(),
            (this.type = "CubeCamera"),
            !0 !== n.isWebGLCubeRenderTarget)
          )
            return void console.error(
              "THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter."
            );
          this.renderTarget = n;
          const i = new Cr(Rr, Lr, t, e);
          (i.layers = this.layers),
            i.up.set(0, -1, 0),
            i.lookAt(new wn(1, 0, 0)),
            this.add(i);
          const r = new Cr(Rr, Lr, t, e);
          (r.layers = this.layers),
            r.up.set(0, -1, 0),
            r.lookAt(new wn(-1, 0, 0)),
            this.add(r);
          const a = new Cr(Rr, Lr, t, e);
          (a.layers = this.layers),
            a.up.set(0, 0, 1),
            a.lookAt(new wn(0, 1, 0)),
            this.add(a);
          const o = new Cr(Rr, Lr, t, e);
          (o.layers = this.layers),
            o.up.set(0, 0, -1),
            o.lookAt(new wn(0, -1, 0)),
            this.add(o);
          const s = new Cr(Rr, Lr, t, e);
          (s.layers = this.layers),
            s.up.set(0, -1, 0),
            s.lookAt(new wn(0, 0, 1)),
            this.add(s);
          const c = new Cr(Rr, Lr, t, e);
          (c.layers = this.layers),
            c.up.set(0, -1, 0),
            c.lookAt(new wn(0, 0, -1)),
            this.add(c);
        }
        update(t, e) {
          null === this.parent && this.updateMatrixWorld();
          const n = this.renderTarget,
            [i, r, a, o, s, c] = this.children,
            l = t.xr.enabled,
            h = t.getRenderTarget();
          t.xr.enabled = !1;
          const u = n.texture.generateMipmaps;
          (n.texture.generateMipmaps = !1),
            t.setRenderTarget(n, 0),
            t.render(e, i),
            t.setRenderTarget(n, 1),
            t.render(e, r),
            t.setRenderTarget(n, 2),
            t.render(e, a),
            t.setRenderTarget(n, 3),
            t.render(e, o),
            t.setRenderTarget(n, 4),
            t.render(e, s),
            (n.texture.generateMipmaps = u),
            t.setRenderTarget(n, 5),
            t.render(e, c),
            t.setRenderTarget(h),
            (t.xr.enabled = l),
            (n.texture.needsPMREMUpdate = !0);
        }
      }
      class Dr extends mn {
        constructor(t, e, n, i, r, a, o, s, c, l) {
          (t = void 0 !== t ? t : []),
            (e = void 0 !== e ? e : st),
            super(t, e, n, i, r, a, o, s, c, l),
            (this.flipY = !1);
        }
        get images() {
          return this.image;
        }
        set images(t) {
          this.image = t;
        }
      }
      Dr.prototype.isCubeTexture = !0;
      class Ir extends yn {
        constructor(t, e, n) {
          Number.isInteger(e) &&
            (console.warn(
              "THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"
            ),
            (e = n)),
            super(t, t, e),
            (e = e || {}),
            (this.texture = new Dr(
              void 0,
              e.mapping,
              e.wrapS,
              e.wrapT,
              e.magFilter,
              e.minFilter,
              e.format,
              e.type,
              e.anisotropy,
              e.encoding
            )),
            (this.texture.isRenderTargetTexture = !0),
            (this.texture.generateMipmaps =
              void 0 !== e.generateMipmaps && e.generateMipmaps),
            (this.texture.minFilter =
              void 0 !== e.minFilter ? e.minFilter : xt);
        }
        fromEquirectangularTexture(t, e) {
          (this.texture.type = e.type),
            (this.texture.format = Nt),
            (this.texture.encoding = e.encoding),
            (this.texture.generateMipmaps = e.generateMipmaps),
            (this.texture.minFilter = e.minFilter),
            (this.texture.magFilter = e.magFilter);
          const n = {
              uniforms: { tEquirect: { value: null } },
              vertexShader:
                "\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t",
              fragmentShader:
                "\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t",
            },
            i = new _r(5, 5, 5),
            r = new Tr({
              name: "CubemapFromEquirect",
              uniforms: br(n.uniforms),
              vertexShader: n.vertexShader,
              fragmentShader: n.fragmentShader,
              side: v,
              blending: _,
            });
          r.uniforms.tEquirect.value = e;
          const a = new vr(i, r),
            o = e.minFilter;
          e.minFilter === bt && (e.minFilter = xt);
          const s = new Pr(1, 10, this);
          return (
            s.update(t, a),
            (e.minFilter = o),
            a.geometry.dispose(),
            a.material.dispose(),
            this
          );
        }
        clear(t, e, n, i) {
          const r = t.getRenderTarget();
          for (let a = 0; a < 6; a++)
            t.setRenderTarget(this, a), t.clear(e, n, i);
          t.setRenderTarget(r);
        }
      }
      Ir.prototype.isWebGLCubeRenderTarget = !0;
      const Or = new wn(),
        Nr = new wn(),
        Br = new Qe();
      class zr {
        constructor(t = new wn(1, 0, 0), e = 0) {
          (this.normal = t), (this.constant = e);
        }
        set(t, e) {
          return this.normal.copy(t), (this.constant = e), this;
        }
        setComponents(t, e, n, i) {
          return this.normal.set(t, e, n), (this.constant = i), this;
        }
        setFromNormalAndCoplanarPoint(t, e) {
          return (
            this.normal.copy(t), (this.constant = -e.dot(this.normal)), this
          );
        }
        setFromCoplanarPoints(t, e, n) {
          const i = Or.subVectors(n, e).cross(Nr.subVectors(t, e)).normalize();
          return this.setFromNormalAndCoplanarPoint(i, t), this;
        }
        copy(t) {
          return this.normal.copy(t.normal), (this.constant = t.constant), this;
        }
        normalize() {
          const t = 1 / this.normal.length();
          return this.normal.multiplyScalar(t), (this.constant *= t), this;
        }
        negate() {
          return (this.constant *= -1), this.normal.negate(), this;
        }
        distanceToPoint(t) {
          return this.normal.dot(t) + this.constant;
        }
        distanceToSphere(t) {
          return this.distanceToPoint(t.center) - t.radius;
        }
        projectPoint(t, e) {
          return e
            .copy(this.normal)
            .multiplyScalar(-this.distanceToPoint(t))
            .add(t);
        }
        intersectLine(t, e) {
          const n = t.delta(Or),
            i = this.normal.dot(n);
          if (0 === i)
            return 0 === this.distanceToPoint(t.start) ? e.copy(t.start) : null;
          const r = -(t.start.dot(this.normal) + this.constant) / i;
          return r < 0 || r > 1
            ? null
            : e.copy(n).multiplyScalar(r).add(t.start);
        }
        intersectsLine(t) {
          const e = this.distanceToPoint(t.start),
            n = this.distanceToPoint(t.end);
          return (e < 0 && n > 0) || (n < 0 && e > 0);
        }
        intersectsBox(t) {
          return t.intersectsPlane(this);
        }
        intersectsSphere(t) {
          return t.intersectsPlane(this);
        }
        coplanarPoint(t) {
          return t.copy(this.normal).multiplyScalar(-this.constant);
        }
        applyMatrix4(t, e) {
          const n = e || Br.getNormalMatrix(t),
            i = this.coplanarPoint(Or).applyMatrix4(t),
            r = this.normal.applyMatrix3(n).normalize();
          return (this.constant = -i.dot(r)), this;
        }
        translate(t) {
          return (this.constant -= t.dot(this.normal)), this;
        }
        equals(t) {
          return t.normal.equals(this.normal) && t.constant === this.constant;
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      zr.prototype.isPlane = !0;
      const Ur = new Wn(),
        Fr = new wn();
      class Hr {
        constructor(
          t = new zr(),
          e = new zr(),
          n = new zr(),
          i = new zr(),
          r = new zr(),
          a = new zr()
        ) {
          this.planes = [t, e, n, i, r, a];
        }
        set(t, e, n, i, r, a) {
          const o = this.planes;
          return (
            o[0].copy(t),
            o[1].copy(e),
            o[2].copy(n),
            o[3].copy(i),
            o[4].copy(r),
            o[5].copy(a),
            this
          );
        }
        copy(t) {
          const e = this.planes;
          for (let n = 0; n < 6; n++) e[n].copy(t.planes[n]);
          return this;
        }
        setFromProjectionMatrix(t) {
          const e = this.planes,
            n = t.elements,
            i = n[0],
            r = n[1],
            a = n[2],
            o = n[3],
            s = n[4],
            c = n[5],
            l = n[6],
            h = n[7],
            u = n[8],
            d = n[9],
            p = n[10],
            f = n[11],
            m = n[12],
            g = n[13],
            v = n[14],
            y = n[15];
          return (
            e[0].setComponents(o - i, h - s, f - u, y - m).normalize(),
            e[1].setComponents(o + i, h + s, f + u, y + m).normalize(),
            e[2].setComponents(o + r, h + c, f + d, y + g).normalize(),
            e[3].setComponents(o - r, h - c, f - d, y - g).normalize(),
            e[4].setComponents(o - a, h - l, f - p, y - v).normalize(),
            e[5].setComponents(o + a, h + l, f + p, y + v).normalize(),
            this
          );
        }
        intersectsObject(t) {
          const e = t.geometry;
          return (
            null === e.boundingSphere && e.computeBoundingSphere(),
            Ur.copy(e.boundingSphere).applyMatrix4(t.matrixWorld),
            this.intersectsSphere(Ur)
          );
        }
        intersectsSprite(t) {
          return (
            Ur.center.set(0, 0, 0),
            (Ur.radius = 0.7071067811865476),
            Ur.applyMatrix4(t.matrixWorld),
            this.intersectsSphere(Ur)
          );
        }
        intersectsSphere(t) {
          const e = this.planes,
            n = t.center,
            i = -t.radius;
          for (let r = 0; r < 6; r++) {
            const t = e[r].distanceToPoint(n);
            if (t < i) return !1;
          }
          return !0;
        }
        intersectsBox(t) {
          const e = this.planes;
          for (let n = 0; n < 6; n++) {
            const i = e[n];
            if (
              ((Fr.x = i.normal.x > 0 ? t.max.x : t.min.x),
              (Fr.y = i.normal.y > 0 ? t.max.y : t.min.y),
              (Fr.z = i.normal.z > 0 ? t.max.z : t.min.z),
              i.distanceToPoint(Fr) < 0)
            )
              return !1;
          }
          return !0;
        }
        containsPoint(t) {
          const e = this.planes;
          for (let n = 0; n < 6; n++)
            if (e[n].distanceToPoint(t) < 0) return !1;
          return !0;
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      function kr() {
        let t = null,
          e = !1,
          n = null,
          i = null;
        function r(e, a) {
          n(e, a), (i = t.requestAnimationFrame(r));
        }
        return {
          start: function () {
            !0 !== e &&
              null !== n &&
              ((i = t.requestAnimationFrame(r)), (e = !0));
          },
          stop: function () {
            t.cancelAnimationFrame(i), (e = !1);
          },
          setAnimationLoop: function (t) {
            n = t;
          },
          setContext: function (e) {
            t = e;
          },
        };
      }
      function Gr(t, e) {
        const n = e.isWebGL2,
          i = new WeakMap();
        function r(e, i) {
          const r = e.array,
            a = e.usage,
            o = t.createBuffer();
          t.bindBuffer(i, o), t.bufferData(i, r, a), e.onUploadCallback();
          let s = 5126;
          return (
            r instanceof Float32Array
              ? (s = 5126)
              : r instanceof Float64Array
              ? console.warn(
                  "THREE.WebGLAttributes: Unsupported data buffer format: Float64Array."
                )
              : r instanceof Uint16Array
              ? e.isFloat16BufferAttribute
                ? n
                  ? (s = 5131)
                  : console.warn(
                      "THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2."
                    )
                : (s = 5123)
              : r instanceof Int16Array
              ? (s = 5122)
              : r instanceof Uint32Array
              ? (s = 5125)
              : r instanceof Int32Array
              ? (s = 5124)
              : r instanceof Int8Array
              ? (s = 5120)
              : (r instanceof Uint8Array || r instanceof Uint8ClampedArray) &&
                (s = 5121),
            {
              buffer: o,
              type: s,
              bytesPerElement: r.BYTES_PER_ELEMENT,
              version: e.version,
            }
          );
        }
        function a(e, i, r) {
          const a = i.array,
            o = i.updateRange;
          t.bindBuffer(r, e),
            -1 === o.count
              ? t.bufferSubData(r, 0, a)
              : (n
                  ? t.bufferSubData(
                      r,
                      o.offset * a.BYTES_PER_ELEMENT,
                      a,
                      o.offset,
                      o.count
                    )
                  : t.bufferSubData(
                      r,
                      o.offset * a.BYTES_PER_ELEMENT,
                      a.subarray(o.offset, o.offset + o.count)
                    ),
                (o.count = -1));
        }
        function o(t) {
          return t.isInterleavedBufferAttribute && (t = t.data), i.get(t);
        }
        function s(e) {
          e.isInterleavedBufferAttribute && (e = e.data);
          const n = i.get(e);
          n && (t.deleteBuffer(n.buffer), i.delete(e));
        }
        function c(t, e) {
          if (t.isGLBufferAttribute) {
            const e = i.get(t);
            return void (
              (!e || e.version < t.version) &&
              i.set(t, {
                buffer: t.buffer,
                type: t.type,
                bytesPerElement: t.elementSize,
                version: t.version,
              })
            );
          }
          t.isInterleavedBufferAttribute && (t = t.data);
          const n = i.get(t);
          void 0 === n
            ? i.set(t, r(t, e))
            : n.version < t.version &&
              (a(n.buffer, t, e), (n.version = t.version));
        }
        return { get: o, remove: s, update: c };
      }
      class Vr extends Qi {
        constructor(t = 1, e = 1, n = 1, i = 1) {
          super(),
            (this.type = "PlaneGeometry"),
            (this.parameters = {
              width: t,
              height: e,
              widthSegments: n,
              heightSegments: i,
            });
          const r = t / 2,
            a = e / 2,
            o = Math.floor(n),
            s = Math.floor(i),
            c = o + 1,
            l = s + 1,
            h = t / o,
            u = e / s,
            d = [],
            p = [],
            f = [],
            m = [];
          for (let g = 0; g < l; g++) {
            const t = g * u - a;
            for (let e = 0; e < c; e++) {
              const n = e * h - r;
              p.push(n, -t, 0),
                f.push(0, 0, 1),
                m.push(e / o),
                m.push(1 - g / s);
            }
          }
          for (let g = 0; g < s; g++)
            for (let t = 0; t < o; t++) {
              const e = t + c * g,
                n = t + c * (g + 1),
                i = t + 1 + c * (g + 1),
                r = t + 1 + c * g;
              d.push(e, n, r), d.push(n, i, r);
            }
          this.setIndex(d),
            this.setAttribute("position", new ji(p, 3)),
            this.setAttribute("normal", new ji(f, 3)),
            this.setAttribute("uv", new ji(m, 2));
        }
        static fromJSON(t) {
          return new Vr(t.width, t.height, t.widthSegments, t.heightSegments);
        }
      }
      var Wr =
          "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif",
        jr = "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
        qr =
          "#ifdef USE_ALPHATEST\n\tif ( diffuseColor.a < alphaTest ) discard;\n#endif",
        Xr = "#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif",
        Yr =
          "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif",
        Jr =
          "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
        Zr = "vec3 transformed = vec3( position );",
        Kr =
          "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",
        $r =
          "vec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenColor * ( D * V );\n}\n#endif",
        Qr =
          "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",
        ta =
          "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif",
        ea =
          "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",
        na =
          "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif",
        ia =
          "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif",
        ra =
          "#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif",
        aa =
          "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif",
        oa =
          "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif",
        sa =
          "#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif",
        ca =
          "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}",
        la =
          "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_maxMipLevel 8.0\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_maxTileSize 256.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\tfloat texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 1.0 ) + 0.5;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tif ( mipInt < cubeUV_maxMipLevel ) {\n\t\t\tuv.y += 2.0 * cubeUV_maxTileSize;\n\t\t}\n\t\tuv.y += filterInt * 2.0 * cubeUV_minTileSize;\n\t\tuv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\n\t\tuv *= texelSize;\n\t\treturn texture2D( envMap, uv ).rgb;\n\t}\n\t#define r0 1.0\n\t#define v0 0.339\n\t#define m0 - 2.0\n\t#define r1 0.8\n\t#define v1 0.276\n\t#define m1 - 1.0\n\t#define r4 0.4\n\t#define v4 0.046\n\t#define m4 2.0\n\t#define r5 0.305\n\t#define v5 0.016\n\t#define m5 3.0\n\t#define r6 0.21\n\t#define v6 0.0038\n\t#define m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= r1 ) {\n\t\t\tmip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n\t\t} else if ( roughness >= r4 ) {\n\t\t\tmip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n\t\t} else if ( roughness >= r5 ) {\n\t\t\tmip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n\t\t} else if ( roughness >= r6 ) {\n\t\t\tmip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif",
        ha =
          "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",
        ua =
          "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",
        da =
          "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif",
        pa =
          "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",
        fa = "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",
        ma = "gl_FragColor = linearToOutputTexel( gl_FragColor );",
        ga =
          "vec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}",
        va =
          "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",
        ya =
          "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif",
        xa =
          "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",
        _a =
          "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",
        ba =
          "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",
        wa = "#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif",
        Ma = "#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif",
        Sa =
          "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",
        Ea =
          "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",
        Ta =
          "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn vec3( texture2D( gradientMap, coord ).r );\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}",
        Aa =
          "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tlightMapIrradiance *= PI;\n\t#endif\n\treflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif",
        Ca =
          "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
        Ra =
          "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry.normal );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry.normal );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointLightInfo( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotLightInfo( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalLightInfo( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry.normal );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif",
        La =
          "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tif ( cutoffDistance > 0.0 ) {\n\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t}\n\t\treturn distanceFalloff;\n\t#else\n\t\tif ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\t\treturn pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t\t}\n\t\treturn 1.0;\n\t#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif",
        Pa =
          "#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getIBLIrradiance( const in vec3 normal ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 reflectVec;\n\t\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\t\treflectVec = reflect( - viewDir, normal );\n\t\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t\t#else\n\t\t\t\treflectVec = refract( - viewDir, normal, refractionRatio );\n\t\t\t#endif\n\t\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t\treturn envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n#endif",
        Da =
          "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;",
        Ia =
          "varying vec3 vViewPosition;\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)",
        Oa =
          "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
        Na =
          "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)",
        Ba =
          "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n\t#ifdef SPECULAR\n\t\tfloat specularIntensityFactor = specularIntensity;\n\t\tvec3 specularColorFactor = specularColor;\n\t\t#ifdef USE_SPECULARINTENSITYMAP\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;\n\t\t#endif\n\t\t#ifdef USE_SPECULARCOLORMAP\n\t\t\tspecularColorFactor *= texture2D( specularColorMap, vUv ).rgb;\n\t\t#endif\n\t\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n\t#else\n\t\tfloat specularIntensityFactor = 1.0;\n\t\tvec3 specularColorFactor = vec3( 1.0 );\n\t\tmaterial.specularF90 = 1.0;\n\t#endif\n\tmaterial.specularColor = mix( min( pow2( ( ior - 1.0 ) / ( ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\tmaterial.clearcoatF0 = vec3( 0.04 );\n\tmaterial.clearcoatF90 = 1.0;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheenColor;\n\t#ifdef USE_SHEENCOLORMAP\n\t\tmaterial.sheenColor *= texture2D( sheenColorMap, vUv ).rgb;\n\t#endif\n\tmaterial.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n\t#ifdef USE_SHEENROUGHNESSMAP\n\t\tmaterial.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;\n\t#endif\n#endif",
        za =
          "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat roughness;\n\tvec3 specularColor;\n\tfloat specularF90;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tvec3 clearcoatF0;\n\t\tfloat clearcoatF90;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tvec3 sheenColor;\n\t\tfloat sheenRoughness;\n\t#endif\n};\nvec3 clearcoatSpecular = vec3( 0.0 );\nvec3 sheenSpecular = vec3( 0.0 );\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat r2 = roughness * roughness;\n\tfloat a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n\tfloat b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n\tfloat DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n\treturn saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n\treturn fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\treturn specularColor * fab.x + specularF90 * fab.y;\n}\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\tvec3 FssEss = specularColor * fab.x + specularF90 * fab.y;\n\tfloat Ess = fab.x + fab.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.roughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = dotNLcc * directLight.color;\n\t\tclearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );\n\t#endif\n\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );\n\t#endif\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tcomputeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",
        Ua =
          "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef USE_CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointLightInfo( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotLightInfo( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalLightInfo( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",
        Fa =
          "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getIBLIrradiance( geometry.normal );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );\n\t#endif\n#endif",
        Ha =
          "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif",
        ka =
          "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
        Ga =
          "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",
        Va =
          "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",
        Wa =
          "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif",
        ja =
          "#ifdef USE_MAP\n\tvec4 sampledDiffuseColor = texture2D( map, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tsampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n\t#endif\n\tdiffuseColor *= sampledDiffuseColor;\n#endif",
        qa = "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",
        Xa =
          "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tdiffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",
        Ya =
          "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
        Ja =
          "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",
        Za =
          "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
        Ka =
          "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1, 2 ) * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\t\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\t\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\t\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\t#endif\n#endif",
        $a =
          "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t\tuniform sampler2DArray morphTargetsTexture;\n\t\tuniform vec2 morphTargetsTextureSize;\n\t\tvec3 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset, const in int stride ) {\n\t\t\tfloat texelIndex = float( vertexIndex * stride + offset );\n\t\t\tfloat y = floor( texelIndex / morphTargetsTextureSize.x );\n\t\t\tfloat x = texelIndex - y * morphTargetsTextureSize.x;\n\t\t\tvec3 morphUV = vec3( ( x + 0.5 ) / morphTargetsTextureSize.x, y / morphTargetsTextureSize.y, morphTargetIndex );\n\t\t\treturn texture( morphTargetsTexture, morphUV ).xyz;\n\t\t}\n\t#else\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\tuniform float morphTargetInfluences[ 8 ];\n\t\t#else\n\t\t\tuniform float morphTargetInfluences[ 4 ];\n\t\t#endif\n\t#endif\n#endif",
        Qa =
          "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\t#ifndef USE_MORPHNORMALS\n\t\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0, 1 ) * morphTargetInfluences[ i ];\n\t\t\t#else\n\t\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0, 2 ) * morphTargetInfluences[ i ];\n\t\t\t#endif\n\t\t}\n\t#else\n\t\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\t\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\t\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\t\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t\t#endif\n\t#endif\n#endif",
        to =
          "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * faceDirection;\n\t\t\tbitangent = bitangent * faceDirection;\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;",
        eo =
          "#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif",
        no =
          "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",
        io =
          "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",
        ro =
          "#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif",
        ao =
          "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n\t\treturn normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n\t}\n#endif",
        oo =
          "#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif",
        so =
          "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n\t#endif\n#endif",
        co =
          "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif",
        lo =
          "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= transmissionAlpha + 0.1;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );",
        ho =
          "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}",
        uo =
          "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",
        po =
          "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",
        fo =
          "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",
        mo =
          "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",
        go =
          "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",
        vo =
          "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
        yo =
          "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",
        xo =
          "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",
        _o =
          "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif",
        bo =
          "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}",
        wo =
          "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
        Mo =
          "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif",
        So =
          "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",
        Eo =
          "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",
        To =
          "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
        Ao = "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
        Co =
          "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",
        Ro =
          "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }",
        Lo =
          "#ifdef USE_TRANSMISSION\n\tfloat transmissionAlpha = 1.0;\n\tfloat transmissionFactor = transmission;\n\tfloat thicknessFactor = thickness;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\ttransmissionFactor *= texture2D( transmissionMap, vUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tthicknessFactor *= texture2D( thicknessMap, vUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\tvec4 transmission = getIBLVolumeRefraction(\n\t\tn, v, roughnessFactor, material.diffuseColor, material.specularColor, material.specularF90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,\n\t\tattenuationColor, attenuationDistance );\n\ttotalDiffuse = mix( totalDiffuse, transmission.rgb, transmissionFactor );\n\ttransmissionAlpha = mix( transmissionAlpha, transmission.a, transmissionFactor );\n#endif",
        Po =
          "#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec3 vWorldPosition;\n\tvec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n\t\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\t\treturn normalize( refractionVector ) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness( const in float roughness, const in float ior ) {\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t}\n\tvec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n\t\tfloat framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\treturn texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\t\t#else\n\t\t\treturn texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\t\t#endif\n\t}\n\tvec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tif ( attenuationDistance == 0.0 ) {\n\t\t\treturn radiance;\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n\t\t\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );\t\t\treturn transmittance * radiance;\n\t\t}\n\t}\n\tvec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n\t\tconst in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n\t\tconst in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,\n\t\tconst in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\trefractionCoords += 1.0;\n\t\trefractionCoords /= 2.0;\n\t\tvec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\t\tvec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );\n\t\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n\t\treturn vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );\n\t}\n#endif",
        Do =
          "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif",
        Io =
          "#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif",
        Oo =
          "#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",
        No =
          "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",
        Bo =
          "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif",
        zo =
          "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif",
        Uo =
          "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif";
      const Fo =
          "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",
        Ho =
          "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tgl_FragColor = texture2D( t2D, vUv );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
        ko =
          "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
        Go =
          "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
        Vo =
          "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}",
        Wo =
          "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}",
        jo =
          "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",
        qo =
          "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",
        Xo =
          "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",
        Yo =
          "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
        Jo =
          "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
        Zo =
          "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
        Ko =
          "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",
        $o =
          "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
        Qo =
          "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
        ts =
          "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
        es =
          "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",
        ns =
          "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t#else\n\t\tvec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
        is =
          "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",
        rs =
          "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n\t#ifdef OPAQUE\n\t\tgl_FragColor.a = 1.0;\n\t#endif\n}",
        as =
          "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
        os =
          "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
        ss =
          "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition.xyz;\n#endif\n}",
        cs =
          "#define STANDARD\n#ifdef PHYSICAL\n\t#define IOR\n\t#define SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n\tuniform float ior;\n#endif\n#ifdef SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularColor;\n\t#ifdef USE_SPECULARINTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n\t#ifdef USE_SPECULARCOLORMAP\n\t\tuniform sampler2D specularColorMap;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheenColor;\n\tuniform float sheenRoughness;\n\t#ifdef USE_SHEENCOLORMAP\n\t\tuniform sampler2D sheenColorMap;\n\t#endif\n\t#ifdef USE_SHEENROUGHNESSMAP\n\t\tuniform sampler2D sheenRoughnessMap;\n\t#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\t#ifdef USE_SHEEN\n\t\tfloat sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n\t\toutgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\t\toutgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;\n\t#endif\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
        ls =
          "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
        hs =
          "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
        us =
          "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",
        ds =
          "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
        ps =
          "#include <common>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
        fs =
          "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
        ms =
          "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
        gs =
          "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
        vs = {
          alphamap_fragment: Wr,
          alphamap_pars_fragment: jr,
          alphatest_fragment: qr,
          alphatest_pars_fragment: Xr,
          aomap_fragment: Yr,
          aomap_pars_fragment: Jr,
          begin_vertex: Zr,
          beginnormal_vertex: Kr,
          bsdfs: $r,
          bumpmap_pars_fragment: Qr,
          clipping_planes_fragment: ta,
          clipping_planes_pars_fragment: ea,
          clipping_planes_pars_vertex: na,
          clipping_planes_vertex: ia,
          color_fragment: ra,
          color_pars_fragment: aa,
          color_pars_vertex: oa,
          color_vertex: sa,
          common: ca,
          cube_uv_reflection_fragment: la,
          defaultnormal_vertex: ha,
          displacementmap_pars_vertex: ua,
          displacementmap_vertex: da,
          emissivemap_fragment: pa,
          emissivemap_pars_fragment: fa,
          encodings_fragment: ma,
          encodings_pars_fragment: ga,
          envmap_fragment: va,
          envmap_common_pars_fragment: ya,
          envmap_pars_fragment: xa,
          envmap_pars_vertex: _a,
          envmap_physical_pars_fragment: Pa,
          envmap_vertex: ba,
          fog_vertex: wa,
          fog_pars_vertex: Ma,
          fog_fragment: Sa,
          fog_pars_fragment: Ea,
          gradientmap_pars_fragment: Ta,
          lightmap_fragment: Aa,
          lightmap_pars_fragment: Ca,
          lights_lambert_vertex: Ra,
          lights_pars_begin: La,
          lights_toon_fragment: Da,
          lights_toon_pars_fragment: Ia,
          lights_phong_fragment: Oa,
          lights_phong_pars_fragment: Na,
          lights_physical_fragment: Ba,
          lights_physical_pars_fragment: za,
          lights_fragment_begin: Ua,
          lights_fragment_maps: Fa,
          lights_fragment_end: Ha,
          logdepthbuf_fragment: ka,
          logdepthbuf_pars_fragment: Ga,
          logdepthbuf_pars_vertex: Va,
          logdepthbuf_vertex: Wa,
          map_fragment: ja,
          map_pars_fragment: qa,
          map_particle_fragment: Xa,
          map_particle_pars_fragment: Ya,
          metalnessmap_fragment: Ja,
          metalnessmap_pars_fragment: Za,
          morphnormal_vertex: Ka,
          morphtarget_pars_vertex: $a,
          morphtarget_vertex: Qa,
          normal_fragment_begin: to,
          normal_fragment_maps: eo,
          normal_pars_fragment: no,
          normal_pars_vertex: io,
          normal_vertex: ro,
          normalmap_pars_fragment: ao,
          clearcoat_normal_fragment_begin: oo,
          clearcoat_normal_fragment_maps: so,
          clearcoat_pars_fragment: co,
          output_fragment: lo,
          packing: ho,
          premultiplied_alpha_fragment: uo,
          project_vertex: po,
          dithering_fragment: fo,
          dithering_pars_fragment: mo,
          roughnessmap_fragment: go,
          roughnessmap_pars_fragment: vo,
          shadowmap_pars_fragment: yo,
          shadowmap_pars_vertex: xo,
          shadowmap_vertex: _o,
          shadowmask_pars_fragment: bo,
          skinbase_vertex: wo,
          skinning_pars_vertex: Mo,
          skinning_vertex: So,
          skinnormal_vertex: Eo,
          specularmap_fragment: To,
          specularmap_pars_fragment: Ao,
          tonemapping_fragment: Co,
          tonemapping_pars_fragment: Ro,
          transmission_fragment: Lo,
          transmission_pars_fragment: Po,
          uv_pars_fragment: Do,
          uv_pars_vertex: Io,
          uv_vertex: Oo,
          uv2_pars_fragment: No,
          uv2_pars_vertex: Bo,
          uv2_vertex: zo,
          worldpos_vertex: Uo,
          background_vert: Fo,
          background_frag: Ho,
          cube_vert: ko,
          cube_frag: Go,
          depth_vert: Vo,
          depth_frag: Wo,
          distanceRGBA_vert: jo,
          distanceRGBA_frag: qo,
          equirect_vert: Xo,
          equirect_frag: Yo,
          linedashed_vert: Jo,
          linedashed_frag: Zo,
          meshbasic_vert: Ko,
          meshbasic_frag: $o,
          meshlambert_vert: Qo,
          meshlambert_frag: ts,
          meshmatcap_vert: es,
          meshmatcap_frag: ns,
          meshnormal_vert: is,
          meshnormal_frag: rs,
          meshphong_vert: as,
          meshphong_frag: os,
          meshphysical_vert: ss,
          meshphysical_frag: cs,
          meshtoon_vert: ls,
          meshtoon_frag: hs,
          points_vert: us,
          points_frag: ds,
          shadow_vert: ps,
          shadow_frag: fs,
          sprite_vert: ms,
          sprite_frag: gs,
        },
        ys = {
          common: {
            diffuse: { value: new un(16777215) },
            opacity: { value: 1 },
            map: { value: null },
            uvTransform: { value: new Qe() },
            uv2Transform: { value: new Qe() },
            alphaMap: { value: null },
            alphaTest: { value: 0 },
          },
          specularmap: { specularMap: { value: null } },
          envmap: {
            envMap: { value: null },
            flipEnvMap: { value: -1 },
            reflectivity: { value: 1 },
            ior: { value: 1.5 },
            refractionRatio: { value: 0.98 },
          },
          aomap: { aoMap: { value: null }, aoMapIntensity: { value: 1 } },
          lightmap: {
            lightMap: { value: null },
            lightMapIntensity: { value: 1 },
          },
          emissivemap: { emissiveMap: { value: null } },
          bumpmap: { bumpMap: { value: null }, bumpScale: { value: 1 } },
          normalmap: {
            normalMap: { value: null },
            normalScale: { value: new $e(1, 1) },
          },
          displacementmap: {
            displacementMap: { value: null },
            displacementScale: { value: 1 },
            displacementBias: { value: 0 },
          },
          roughnessmap: { roughnessMap: { value: null } },
          metalnessmap: { metalnessMap: { value: null } },
          gradientmap: { gradientMap: { value: null } },
          fog: {
            fogDensity: { value: 25e-5 },
            fogNear: { value: 1 },
            fogFar: { value: 2e3 },
            fogColor: { value: new un(16777215) },
          },
          lights: {
            ambientLightColor: { value: [] },
            lightProbe: { value: [] },
            directionalLights: {
              value: [],
              properties: { direction: {}, color: {} },
            },
            directionalLightShadows: {
              value: [],
              properties: {
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {},
              },
            },
            directionalShadowMap: { value: [] },
            directionalShadowMatrix: { value: [] },
            spotLights: {
              value: [],
              properties: {
                color: {},
                position: {},
                direction: {},
                distance: {},
                coneCos: {},
                penumbraCos: {},
                decay: {},
              },
            },
            spotLightShadows: {
              value: [],
              properties: {
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {},
              },
            },
            spotShadowMap: { value: [] },
            spotShadowMatrix: { value: [] },
            pointLights: {
              value: [],
              properties: { color: {}, position: {}, decay: {}, distance: {} },
            },
            pointLightShadows: {
              value: [],
              properties: {
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {},
                shadowCameraNear: {},
                shadowCameraFar: {},
              },
            },
            pointShadowMap: { value: [] },
            pointShadowMatrix: { value: [] },
            hemisphereLights: {
              value: [],
              properties: { direction: {}, skyColor: {}, groundColor: {} },
            },
            rectAreaLights: {
              value: [],
              properties: { color: {}, position: {}, width: {}, height: {} },
            },
            ltc_1: { value: null },
            ltc_2: { value: null },
          },
          points: {
            diffuse: { value: new un(16777215) },
            opacity: { value: 1 },
            size: { value: 1 },
            scale: { value: 1 },
            map: { value: null },
            alphaMap: { value: null },
            alphaTest: { value: 0 },
            uvTransform: { value: new Qe() },
          },
          sprite: {
            diffuse: { value: new un(16777215) },
            opacity: { value: 1 },
            center: { value: new $e(0.5, 0.5) },
            rotation: { value: 0 },
            map: { value: null },
            alphaMap: { value: null },
            alphaTest: { value: 0 },
            uvTransform: { value: new Qe() },
          },
        },
        xs = {
          basic: {
            uniforms: wr([
              ys.common,
              ys.specularmap,
              ys.envmap,
              ys.aomap,
              ys.lightmap,
              ys.fog,
            ]),
            vertexShader: vs.meshbasic_vert,
            fragmentShader: vs.meshbasic_frag,
          },
          lambert: {
            uniforms: wr([
              ys.common,
              ys.specularmap,
              ys.envmap,
              ys.aomap,
              ys.lightmap,
              ys.emissivemap,
              ys.fog,
              ys.lights,
              { emissive: { value: new un(0) } },
            ]),
            vertexShader: vs.meshlambert_vert,
            fragmentShader: vs.meshlambert_frag,
          },
          phong: {
            uniforms: wr([
              ys.common,
              ys.specularmap,
              ys.envmap,
              ys.aomap,
              ys.lightmap,
              ys.emissivemap,
              ys.bumpmap,
              ys.normalmap,
              ys.displacementmap,
              ys.fog,
              ys.lights,
              {
                emissive: { value: new un(0) },
                specular: { value: new un(1118481) },
                shininess: { value: 30 },
              },
            ]),
            vertexShader: vs.meshphong_vert,
            fragmentShader: vs.meshphong_frag,
          },
          standard: {
            uniforms: wr([
              ys.common,
              ys.envmap,
              ys.aomap,
              ys.lightmap,
              ys.emissivemap,
              ys.bumpmap,
              ys.normalmap,
              ys.displacementmap,
              ys.roughnessmap,
              ys.metalnessmap,
              ys.fog,
              ys.lights,
              {
                emissive: { value: new un(0) },
                roughness: { value: 1 },
                metalness: { value: 0 },
                envMapIntensity: { value: 1 },
              },
            ]),
            vertexShader: vs.meshphysical_vert,
            fragmentShader: vs.meshphysical_frag,
          },
          toon: {
            uniforms: wr([
              ys.common,
              ys.aomap,
              ys.lightmap,
              ys.emissivemap,
              ys.bumpmap,
              ys.normalmap,
              ys.displacementmap,
              ys.gradientmap,
              ys.fog,
              ys.lights,
              { emissive: { value: new un(0) } },
            ]),
            vertexShader: vs.meshtoon_vert,
            fragmentShader: vs.meshtoon_frag,
          },
          matcap: {
            uniforms: wr([
              ys.common,
              ys.bumpmap,
              ys.normalmap,
              ys.displacementmap,
              ys.fog,
              { matcap: { value: null } },
            ]),
            vertexShader: vs.meshmatcap_vert,
            fragmentShader: vs.meshmatcap_frag,
          },
          points: {
            uniforms: wr([ys.points, ys.fog]),
            vertexShader: vs.points_vert,
            fragmentShader: vs.points_frag,
          },
          dashed: {
            uniforms: wr([
              ys.common,
              ys.fog,
              {
                scale: { value: 1 },
                dashSize: { value: 1 },
                totalSize: { value: 2 },
              },
            ]),
            vertexShader: vs.linedashed_vert,
            fragmentShader: vs.linedashed_frag,
          },
          depth: {
            uniforms: wr([ys.common, ys.displacementmap]),
            vertexShader: vs.depth_vert,
            fragmentShader: vs.depth_frag,
          },
          normal: {
            uniforms: wr([
              ys.common,
              ys.bumpmap,
              ys.normalmap,
              ys.displacementmap,
              { opacity: { value: 1 } },
            ]),
            vertexShader: vs.meshnormal_vert,
            fragmentShader: vs.meshnormal_frag,
          },
          sprite: {
            uniforms: wr([ys.sprite, ys.fog]),
            vertexShader: vs.sprite_vert,
            fragmentShader: vs.sprite_frag,
          },
          background: {
            uniforms: {
              uvTransform: { value: new Qe() },
              t2D: { value: null },
            },
            vertexShader: vs.background_vert,
            fragmentShader: vs.background_frag,
          },
          cube: {
            uniforms: wr([ys.envmap, { opacity: { value: 1 } }]),
            vertexShader: vs.cube_vert,
            fragmentShader: vs.cube_frag,
          },
          equirect: {
            uniforms: { tEquirect: { value: null } },
            vertexShader: vs.equirect_vert,
            fragmentShader: vs.equirect_frag,
          },
          distanceRGBA: {
            uniforms: wr([
              ys.common,
              ys.displacementmap,
              {
                referencePosition: { value: new wn() },
                nearDistance: { value: 1 },
                farDistance: { value: 1e3 },
              },
            ]),
            vertexShader: vs.distanceRGBA_vert,
            fragmentShader: vs.distanceRGBA_frag,
          },
          shadow: {
            uniforms: wr([
              ys.lights,
              ys.fog,
              { color: { value: new un(0) }, opacity: { value: 1 } },
            ]),
            vertexShader: vs.shadow_vert,
            fragmentShader: vs.shadow_frag,
          },
        };
      function _s(t, e, n, i, r, a) {
        const o = new un(0);
        let s,
          c,
          l = !0 === r ? 0 : 1,
          h = null,
          u = 0,
          d = null;
        function p(n, r) {
          let a = !1,
            p = !0 === r.isScene ? r.background : null;
          p && p.isTexture && (p = e.get(p));
          const m = t.xr,
            y = m.getSession && m.getSession();
          y && "additive" === y.environmentBlendMode && (p = null),
            null === p ? f(o, l) : p && p.isColor && (f(p, 1), (a = !0)),
            (t.autoClear || a) &&
              t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil),
            p && (p.isCubeTexture || p.mapping === ut)
              ? (void 0 === c &&
                  ((c = new vr(
                    new _r(1, 1, 1),
                    new Tr({
                      name: "BackgroundCubeMaterial",
                      uniforms: br(xs.cube.uniforms),
                      vertexShader: xs.cube.vertexShader,
                      fragmentShader: xs.cube.fragmentShader,
                      side: v,
                      depthTest: !1,
                      depthWrite: !1,
                      fog: !1,
                    })
                  )),
                  c.geometry.deleteAttribute("normal"),
                  c.geometry.deleteAttribute("uv"),
                  (c.onBeforeRender = function (t, e, n) {
                    this.matrixWorld.copyPosition(n.matrixWorld);
                  }),
                  Object.defineProperty(c.material, "envMap", {
                    get: function () {
                      return this.uniforms.envMap.value;
                    },
                  }),
                  i.update(c)),
                (c.material.uniforms.envMap.value = p),
                (c.material.uniforms.flipEnvMap.value =
                  p.isCubeTexture && !1 === p.isRenderTargetTexture ? -1 : 1),
                (h === p && u === p.version && d === t.toneMapping) ||
                  ((c.material.needsUpdate = !0),
                  (h = p),
                  (u = p.version),
                  (d = t.toneMapping)),
                n.unshift(c, c.geometry, c.material, 0, 0, null))
              : p &&
                p.isTexture &&
                (void 0 === s &&
                  ((s = new vr(
                    new Vr(2, 2),
                    new Tr({
                      name: "BackgroundMaterial",
                      uniforms: br(xs.background.uniforms),
                      vertexShader: xs.background.vertexShader,
                      fragmentShader: xs.background.fragmentShader,
                      side: g,
                      depthTest: !1,
                      depthWrite: !1,
                      fog: !1,
                    })
                  )),
                  s.geometry.deleteAttribute("normal"),
                  Object.defineProperty(s.material, "map", {
                    get: function () {
                      return this.uniforms.t2D.value;
                    },
                  }),
                  i.update(s)),
                (s.material.uniforms.t2D.value = p),
                !0 === p.matrixAutoUpdate && p.updateMatrix(),
                s.material.uniforms.uvTransform.value.copy(p.matrix),
                (h === p && u === p.version && d === t.toneMapping) ||
                  ((s.material.needsUpdate = !0),
                  (h = p),
                  (u = p.version),
                  (d = t.toneMapping)),
                n.unshift(s, s.geometry, s.material, 0, 0, null));
        }
        function f(t, e) {
          n.buffers.color.setClear(t.r, t.g, t.b, e, a);
        }
        return {
          getClearColor: function () {
            return o;
          },
          setClearColor: function (t, e = 1) {
            o.set(t), (l = e), f(o, l);
          },
          getClearAlpha: function () {
            return l;
          },
          setClearAlpha: function (t) {
            (l = t), f(o, l);
          },
          render: p,
        };
      }
      function bs(t, e, n, i) {
        const r = t.getParameter(34921),
          a = i.isWebGL2 ? null : e.get("OES_vertex_array_object"),
          o = i.isWebGL2 || null !== a,
          s = {},
          c = m(null);
        let l = c;
        function h(e, i, r, a, s) {
          let c = !1;
          if (o) {
            const t = f(a, r, i);
            l !== t && ((l = t), d(l.object)), (c = g(a, s)), c && v(a, s);
          } else {
            const t = !0 === i.wireframe;
            (l.geometry === a.id && l.program === r.id && l.wireframe === t) ||
              ((l.geometry = a.id),
              (l.program = r.id),
              (l.wireframe = t),
              (c = !0));
          }
          !0 === e.isInstancedMesh && (c = !0),
            null !== s && n.update(s, 34963),
            c &&
              (M(e, i, r, a),
              null !== s && t.bindBuffer(34963, n.get(s).buffer));
        }
        function u() {
          return i.isWebGL2 ? t.createVertexArray() : a.createVertexArrayOES();
        }
        function d(e) {
          return i.isWebGL2 ? t.bindVertexArray(e) : a.bindVertexArrayOES(e);
        }
        function p(e) {
          return i.isWebGL2
            ? t.deleteVertexArray(e)
            : a.deleteVertexArrayOES(e);
        }
        function f(t, e, n) {
          const i = !0 === n.wireframe;
          let r = s[t.id];
          void 0 === r && ((r = {}), (s[t.id] = r));
          let a = r[e.id];
          void 0 === a && ((a = {}), (r[e.id] = a));
          let o = a[i];
          return void 0 === o && ((o = m(u())), (a[i] = o)), o;
        }
        function m(t) {
          const e = [],
            n = [],
            i = [];
          for (let a = 0; a < r; a++) (e[a] = 0), (n[a] = 0), (i[a] = 0);
          return {
            geometry: null,
            program: null,
            wireframe: !1,
            newAttributes: e,
            enabledAttributes: n,
            attributeDivisors: i,
            object: t,
            attributes: {},
            index: null,
          };
        }
        function g(t, e) {
          const n = l.attributes,
            i = t.attributes;
          let r = 0;
          for (const a in i) {
            const t = n[a],
              e = i[a];
            if (void 0 === t) return !0;
            if (t.attribute !== e) return !0;
            if (t.data !== e.data) return !0;
            r++;
          }
          return l.attributesNum !== r || l.index !== e;
        }
        function v(t, e) {
          const n = {},
            i = t.attributes;
          let r = 0;
          for (const a in i) {
            const t = i[a],
              e = {};
            (e.attribute = t), t.data && (e.data = t.data), (n[a] = e), r++;
          }
          (l.attributes = n), (l.attributesNum = r), (l.index = e);
        }
        function y() {
          const t = l.newAttributes;
          for (let e = 0, n = t.length; e < n; e++) t[e] = 0;
        }
        function x(t) {
          _(t, 0);
        }
        function _(n, r) {
          const a = l.newAttributes,
            o = l.enabledAttributes,
            s = l.attributeDivisors;
          if (
            ((a[n] = 1),
            0 === o[n] && (t.enableVertexAttribArray(n), (o[n] = 1)),
            s[n] !== r)
          ) {
            const a = i.isWebGL2 ? t : e.get("ANGLE_instanced_arrays");
            a[i.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](
              n,
              r
            ),
              (s[n] = r);
          }
        }
        function b() {
          const e = l.newAttributes,
            n = l.enabledAttributes;
          for (let i = 0, r = n.length; i < r; i++)
            n[i] !== e[i] && (t.disableVertexAttribArray(i), (n[i] = 0));
        }
        function w(e, n, r, a, o, s) {
          !0 !== i.isWebGL2 || (5124 !== r && 5125 !== r)
            ? t.vertexAttribPointer(e, n, r, a, o, s)
            : t.vertexAttribIPointer(e, n, r, o, s);
        }
        function M(r, a, o, s) {
          if (
            !1 === i.isWebGL2 &&
            (r.isInstancedMesh || s.isInstancedBufferGeometry) &&
            null === e.get("ANGLE_instanced_arrays")
          )
            return;
          y();
          const c = s.attributes,
            l = o.getAttributes(),
            h = a.defaultAttributeValues;
          for (const e in l) {
            const i = l[e];
            if (i.location >= 0) {
              let a = c[e];
              if (
                (void 0 === a &&
                  ("instanceMatrix" === e &&
                    r.instanceMatrix &&
                    (a = r.instanceMatrix),
                  "instanceColor" === e &&
                    r.instanceColor &&
                    (a = r.instanceColor)),
                void 0 !== a)
              ) {
                const e = a.normalized,
                  o = a.itemSize,
                  c = n.get(a);
                if (void 0 === c) continue;
                const l = c.buffer,
                  h = c.type,
                  u = c.bytesPerElement;
                if (a.isInterleavedBufferAttribute) {
                  const n = a.data,
                    c = n.stride,
                    d = a.offset;
                  if (n && n.isInstancedInterleavedBuffer) {
                    for (let t = 0; t < i.locationSize; t++)
                      _(i.location + t, n.meshPerAttribute);
                    !0 !== r.isInstancedMesh &&
                      void 0 === s._maxInstanceCount &&
                      (s._maxInstanceCount = n.meshPerAttribute * n.count);
                  } else
                    for (let t = 0; t < i.locationSize; t++) x(i.location + t);
                  t.bindBuffer(34962, l);
                  for (let t = 0; t < i.locationSize; t++)
                    w(
                      i.location + t,
                      o / i.locationSize,
                      h,
                      e,
                      c * u,
                      (d + (o / i.locationSize) * t) * u
                    );
                } else {
                  if (a.isInstancedBufferAttribute) {
                    for (let t = 0; t < i.locationSize; t++)
                      _(i.location + t, a.meshPerAttribute);
                    !0 !== r.isInstancedMesh &&
                      void 0 === s._maxInstanceCount &&
                      (s._maxInstanceCount = a.meshPerAttribute * a.count);
                  } else
                    for (let t = 0; t < i.locationSize; t++) x(i.location + t);
                  t.bindBuffer(34962, l);
                  for (let t = 0; t < i.locationSize; t++)
                    w(
                      i.location + t,
                      o / i.locationSize,
                      h,
                      e,
                      o * u,
                      (o / i.locationSize) * t * u
                    );
                }
              } else if (void 0 !== h) {
                const n = h[e];
                if (void 0 !== n)
                  switch (n.length) {
                    case 2:
                      t.vertexAttrib2fv(i.location, n);
                      break;
                    case 3:
                      t.vertexAttrib3fv(i.location, n);
                      break;
                    case 4:
                      t.vertexAttrib4fv(i.location, n);
                      break;
                    default:
                      t.vertexAttrib1fv(i.location, n);
                  }
              }
            }
          }
          b();
        }
        function S() {
          A();
          for (const t in s) {
            const e = s[t];
            for (const t in e) {
              const n = e[t];
              for (const t in n) p(n[t].object), delete n[t];
              delete e[t];
            }
            delete s[t];
          }
        }
        function E(t) {
          if (void 0 === s[t.id]) return;
          const e = s[t.id];
          for (const n in e) {
            const t = e[n];
            for (const e in t) p(t[e].object), delete t[e];
            delete e[n];
          }
          delete s[t.id];
        }
        function T(t) {
          for (const e in s) {
            const n = s[e];
            if (void 0 === n[t.id]) continue;
            const i = n[t.id];
            for (const t in i) p(i[t].object), delete i[t];
            delete n[t.id];
          }
        }
        function A() {
          C(), l !== c && ((l = c), d(l.object));
        }
        function C() {
          (c.geometry = null), (c.program = null), (c.wireframe = !1);
        }
        return {
          setup: h,
          reset: A,
          resetDefaultState: C,
          dispose: S,
          releaseStatesOfGeometry: E,
          releaseStatesOfProgram: T,
          initAttributes: y,
          enableAttribute: x,
          disableUnusedAttributes: b,
        };
      }
      function ws(t, e, n, i) {
        const r = i.isWebGL2;
        let a;
        function o(t) {
          a = t;
        }
        function s(e, i) {
          t.drawArrays(a, e, i), n.update(i, a, 1);
        }
        function c(i, o, s) {
          if (0 === s) return;
          let c, l;
          if (r) (c = t), (l = "drawArraysInstanced");
          else if (
            ((c = e.get("ANGLE_instanced_arrays")),
            (l = "drawArraysInstancedANGLE"),
            null === c)
          )
            return void console.error(
              "THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
            );
          c[l](a, i, o, s), n.update(o, a, s);
        }
        (this.setMode = o), (this.render = s), (this.renderInstances = c);
      }
      function Ms(t, e, n) {
        let i;
        function r() {
          if (void 0 !== i) return i;
          if (!0 === e.has("EXT_texture_filter_anisotropic")) {
            const n = e.get("EXT_texture_filter_anisotropic");
            i = t.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
          } else i = 0;
          return i;
        }
        function a(e) {
          if ("highp" === e) {
            if (
              t.getShaderPrecisionFormat(35633, 36338).precision > 0 &&
              t.getShaderPrecisionFormat(35632, 36338).precision > 0
            )
              return "highp";
            e = "mediump";
          }
          return "mediump" === e &&
            t.getShaderPrecisionFormat(35633, 36337).precision > 0 &&
            t.getShaderPrecisionFormat(35632, 36337).precision > 0
            ? "mediump"
            : "lowp";
        }
        const o =
          ("undefined" !== typeof WebGL2RenderingContext &&
            t instanceof WebGL2RenderingContext) ||
          ("undefined" !== typeof WebGL2ComputeRenderingContext &&
            t instanceof WebGL2ComputeRenderingContext);
        let s = void 0 !== n.precision ? n.precision : "highp";
        const c = a(s);
        c !== s &&
          (console.warn(
            "THREE.WebGLRenderer:",
            s,
            "not supported, using",
            c,
            "instead."
          ),
          (s = c));
        const l = o || e.has("WEBGL_draw_buffers"),
          h = !0 === n.logarithmicDepthBuffer,
          u = t.getParameter(34930),
          d = t.getParameter(35660),
          p = t.getParameter(3379),
          f = t.getParameter(34076),
          m = t.getParameter(34921),
          g = t.getParameter(36347),
          v = t.getParameter(36348),
          y = t.getParameter(36349),
          x = d > 0,
          _ = o || e.has("OES_texture_float"),
          b = x && _,
          w = o ? t.getParameter(36183) : 0;
        return {
          isWebGL2: o,
          drawBuffers: l,
          getMaxAnisotropy: r,
          getMaxPrecision: a,
          precision: s,
          logarithmicDepthBuffer: h,
          maxTextures: u,
          maxVertexTextures: d,
          maxTextureSize: p,
          maxCubemapSize: f,
          maxAttributes: m,
          maxVertexUniforms: g,
          maxVaryings: v,
          maxFragmentUniforms: y,
          vertexTextures: x,
          floatFragmentTextures: _,
          floatVertexTextures: b,
          maxSamples: w,
        };
      }
      function Ss(t) {
        const e = this;
        let n = null,
          i = 0,
          r = !1,
          a = !1;
        const o = new zr(),
          s = new Qe(),
          c = { value: null, needsUpdate: !1 };
        function l() {
          c.value !== n && ((c.value = n), (c.needsUpdate = i > 0)),
            (e.numPlanes = i),
            (e.numIntersection = 0);
        }
        function h(t, n, i, r) {
          const a = null !== t ? t.length : 0;
          let l = null;
          if (0 !== a) {
            if (((l = c.value), !0 !== r || null === l)) {
              const e = i + 4 * a,
                r = n.matrixWorldInverse;
              s.getNormalMatrix(r),
                (null === l || l.length < e) && (l = new Float32Array(e));
              for (let n = 0, c = i; n !== a; ++n, c += 4)
                o.copy(t[n]).applyMatrix4(r, s),
                  o.normal.toArray(l, c),
                  (l[c + 3] = o.constant);
            }
            (c.value = l), (c.needsUpdate = !0);
          }
          return (e.numPlanes = a), (e.numIntersection = 0), l;
        }
        (this.uniform = c),
          (this.numPlanes = 0),
          (this.numIntersection = 0),
          (this.init = function (t, e, a) {
            const o = 0 !== t.length || e || 0 !== i || r;
            return (r = e), (n = h(t, a, 0)), (i = t.length), o;
          }),
          (this.beginShadows = function () {
            (a = !0), h(null);
          }),
          (this.endShadows = function () {
            (a = !1), l();
          }),
          (this.setState = function (e, o, s) {
            const u = e.clippingPlanes,
              d = e.clipIntersection,
              p = e.clipShadows,
              f = t.get(e);
            if (!r || null === u || 0 === u.length || (a && !p))
              a ? h(null) : l();
            else {
              const t = a ? 0 : i,
                e = 4 * t;
              let r = f.clippingState || null;
              (c.value = r), (r = h(u, o, e, s));
              for (let i = 0; i !== e; ++i) r[i] = n[i];
              (f.clippingState = r),
                (this.numIntersection = d ? this.numPlanes : 0),
                (this.numPlanes += t);
            }
          });
      }
      function Es(t) {
        let e = new WeakMap();
        function n(t, e) {
          return e === lt ? (t.mapping = st) : e === ht && (t.mapping = ct), t;
        }
        function i(i) {
          if (i && i.isTexture && !1 === i.isRenderTargetTexture) {
            const a = i.mapping;
            if (a === lt || a === ht) {
              if (e.has(i)) {
                const t = e.get(i).texture;
                return n(t, i.mapping);
              }
              {
                const a = i.image;
                if (a && a.height > 0) {
                  const o = new Ir(a.height / 2);
                  return (
                    o.fromEquirectangularTexture(t, i),
                    e.set(i, o),
                    i.addEventListener("dispose", r),
                    n(o.texture, i.mapping)
                  );
                }
                return null;
              }
            }
          }
          return i;
        }
        function r(t) {
          const n = t.target;
          n.removeEventListener("dispose", r);
          const i = e.get(n);
          void 0 !== i && (e.delete(n), i.dispose());
        }
        function a() {
          e = new WeakMap();
        }
        return { get: i, dispose: a };
      }
      xs.physical = {
        uniforms: wr([
          xs.standard.uniforms,
          {
            clearcoat: { value: 0 },
            clearcoatMap: { value: null },
            clearcoatRoughness: { value: 0 },
            clearcoatRoughnessMap: { value: null },
            clearcoatNormalScale: { value: new $e(1, 1) },
            clearcoatNormalMap: { value: null },
            sheen: { value: 0 },
            sheenColor: { value: new un(0) },
            sheenColorMap: { value: null },
            sheenRoughness: { value: 1 },
            sheenRoughnessMap: { value: null },
            transmission: { value: 0 },
            transmissionMap: { value: null },
            transmissionSamplerSize: { value: new $e() },
            transmissionSamplerMap: { value: null },
            thickness: { value: 0 },
            thicknessMap: { value: null },
            attenuationDistance: { value: 0 },
            attenuationColor: { value: new un(0) },
            specularIntensity: { value: 1 },
            specularIntensityMap: { value: null },
            specularColor: { value: new un(1, 1, 1) },
            specularColorMap: { value: null },
          },
        ]),
        vertexShader: vs.meshphysical_vert,
        fragmentShader: vs.meshphysical_frag,
      };
      class Ts extends Ar {
        constructor(t = -1, e = 1, n = 1, i = -1, r = 0.1, a = 2e3) {
          super(),
            (this.type = "OrthographicCamera"),
            (this.zoom = 1),
            (this.view = null),
            (this.left = t),
            (this.right = e),
            (this.top = n),
            (this.bottom = i),
            (this.near = r),
            (this.far = a),
            this.updateProjectionMatrix();
        }
        copy(t, e) {
          return (
            super.copy(t, e),
            (this.left = t.left),
            (this.right = t.right),
            (this.top = t.top),
            (this.bottom = t.bottom),
            (this.near = t.near),
            (this.far = t.far),
            (this.zoom = t.zoom),
            (this.view = null === t.view ? null : Object.assign({}, t.view)),
            this
          );
        }
        setViewOffset(t, e, n, i, r, a) {
          null === this.view &&
            (this.view = {
              enabled: !0,
              fullWidth: 1,
              fullHeight: 1,
              offsetX: 0,
              offsetY: 0,
              width: 1,
              height: 1,
            }),
            (this.view.enabled = !0),
            (this.view.fullWidth = t),
            (this.view.fullHeight = e),
            (this.view.offsetX = n),
            (this.view.offsetY = i),
            (this.view.width = r),
            (this.view.height = a),
            this.updateProjectionMatrix();
        }
        clearViewOffset() {
          null !== this.view && (this.view.enabled = !1),
            this.updateProjectionMatrix();
        }
        updateProjectionMatrix() {
          const t = (this.right - this.left) / (2 * this.zoom),
            e = (this.top - this.bottom) / (2 * this.zoom),
            n = (this.right + this.left) / 2,
            i = (this.top + this.bottom) / 2;
          let r = n - t,
            a = n + t,
            o = i + e,
            s = i - e;
          if (null !== this.view && this.view.enabled) {
            const t =
                (this.right - this.left) / this.view.fullWidth / this.zoom,
              e = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
            (r += t * this.view.offsetX),
              (a = r + t * this.view.width),
              (o -= e * this.view.offsetY),
              (s = o - e * this.view.height);
          }
          this.projectionMatrix.makeOrthographic(
            r,
            a,
            o,
            s,
            this.near,
            this.far
          ),
            this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
        }
        toJSON(t) {
          const e = super.toJSON(t);
          return (
            (e.object.zoom = this.zoom),
            (e.object.left = this.left),
            (e.object.right = this.right),
            (e.object.top = this.top),
            (e.object.bottom = this.bottom),
            (e.object.near = this.near),
            (e.object.far = this.far),
            null !== this.view &&
              (e.object.view = Object.assign({}, this.view)),
            e
          );
        }
      }
      Ts.prototype.isOrthographicCamera = !0;
      class As extends Tr {
        constructor(t) {
          super(t), (this.type = "RawShaderMaterial");
        }
      }
      As.prototype.isRawShaderMaterial = !0;
      const Cs = 4,
        Rs = 8,
        Ls = Math.pow(2, Rs),
        Ps = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582],
        Ds = Rs - Cs + 1 + Ps.length,
        Is = 20,
        Os = new Ts(),
        { _lodPlanes: Ns, _sizeLods: Bs, _sigmas: zs } = Ws(),
        Us = new un();
      let Fs = null;
      const Hs = (1 + Math.sqrt(5)) / 2,
        ks = 1 / Hs,
        Gs = [
          new wn(1, 1, 1),
          new wn(-1, 1, 1),
          new wn(1, 1, -1),
          new wn(-1, 1, -1),
          new wn(0, Hs, ks),
          new wn(0, Hs, -ks),
          new wn(ks, 0, Hs),
          new wn(-ks, 0, Hs),
          new wn(Hs, ks, 0),
          new wn(-Hs, ks, 0),
        ];
      class Vs {
        constructor(t) {
          (this._renderer = t),
            (this._pingPongRenderTarget = null),
            (this._blurMaterial = Xs(Is)),
            (this._equirectShader = null),
            (this._cubemapShader = null),
            this._compileMaterial(this._blurMaterial);
        }
        fromScene(t, e = 0, n = 0.1, i = 100) {
          Fs = this._renderer.getRenderTarget();
          const r = this._allocateTargets();
          return (
            this._sceneToCubeUV(t, n, i, r),
            e > 0 && this._blur(r, 0, 0, e),
            this._applyPMREM(r),
            this._cleanup(r),
            r
          );
        }
        fromEquirectangular(t, e = null) {
          return this._fromTexture(t, e);
        }
        fromCubemap(t, e = null) {
          return this._fromTexture(t, e);
        }
        compileCubemapShader() {
          null === this._cubemapShader &&
            ((this._cubemapShader = Js()),
            this._compileMaterial(this._cubemapShader));
        }
        compileEquirectangularShader() {
          null === this._equirectShader &&
            ((this._equirectShader = Ys()),
            this._compileMaterial(this._equirectShader));
        }
        dispose() {
          this._blurMaterial.dispose(),
            null !== this._pingPongRenderTarget &&
              this._pingPongRenderTarget.dispose(),
            null !== this._cubemapShader && this._cubemapShader.dispose(),
            null !== this._equirectShader && this._equirectShader.dispose();
          for (let t = 0; t < Ns.length; t++) Ns[t].dispose();
        }
        _cleanup(t) {
          this._renderer.setRenderTarget(Fs),
            (t.scissorTest = !1),
            qs(t, 0, 0, t.width, t.height);
        }
        _fromTexture(t, e) {
          Fs = this._renderer.getRenderTarget();
          const n = e || this._allocateTargets(t);
          return (
            this._textureToCubeUV(t, n),
            this._applyPMREM(n),
            this._cleanup(n),
            n
          );
        }
        _allocateTargets(t) {
          const e = {
              magFilter: xt,
              minFilter: xt,
              generateMipmaps: !1,
              type: Rt,
              format: Nt,
              encoding: Re,
              depthBuffer: !1,
            },
            n = js(e);
          return (
            (n.depthBuffer = !t),
            null === this._pingPongRenderTarget &&
              (this._pingPongRenderTarget = js(e)),
            n
          );
        }
        _compileMaterial(t) {
          const e = new vr(Ns[0], t);
          this._renderer.compile(e, Os);
        }
        _sceneToCubeUV(t, e, n, i) {
          const r = 90,
            a = 1,
            o = new Cr(r, a, e, n),
            s = [1, -1, 1, 1, 1, 1],
            c = [1, 1, 1, -1, -1, -1],
            l = this._renderer,
            h = l.autoClear,
            u = l.toneMapping;
          l.getClearColor(Us), (l.toneMapping = tt), (l.autoClear = !1);
          const d = new Ui({
              name: "PMREM.Background",
              side: v,
              depthWrite: !1,
              depthTest: !1,
            }),
            p = new vr(new _r(), d);
          let f = !1;
          const m = t.background;
          m
            ? m.isColor && (d.color.copy(m), (t.background = null), (f = !0))
            : (d.color.copy(Us), (f = !0));
          for (let g = 0; g < 6; g++) {
            const e = g % 3;
            0 === e
              ? (o.up.set(0, s[g], 0), o.lookAt(c[g], 0, 0))
              : 1 === e
              ? (o.up.set(0, 0, s[g]), o.lookAt(0, c[g], 0))
              : (o.up.set(0, s[g], 0), o.lookAt(0, 0, c[g])),
              qs(i, e * Ls, g > 2 ? Ls : 0, Ls, Ls),
              l.setRenderTarget(i),
              f && l.render(p, o),
              l.render(t, o);
          }
          p.geometry.dispose(),
            p.material.dispose(),
            (l.toneMapping = u),
            (l.autoClear = h),
            (t.background = m);
        }
        _textureToCubeUV(t, e) {
          const n = this._renderer,
            i = t.mapping === st || t.mapping === ct;
          i
            ? (null === this._cubemapShader && (this._cubemapShader = Js()),
              (this._cubemapShader.uniforms.flipEnvMap.value =
                !1 === t.isRenderTargetTexture ? -1 : 1))
            : null === this._equirectShader && (this._equirectShader = Ys());
          const r = i ? this._cubemapShader : this._equirectShader,
            a = new vr(Ns[0], r),
            o = r.uniforms;
          (o["envMap"].value = t),
            i ||
              o["texelSize"].value.set(1 / t.image.width, 1 / t.image.height),
            qs(e, 0, 0, 3 * Ls, 2 * Ls),
            n.setRenderTarget(e),
            n.render(a, Os);
        }
        _applyPMREM(t) {
          const e = this._renderer,
            n = e.autoClear;
          e.autoClear = !1;
          for (let i = 1; i < Ds; i++) {
            const e = Math.sqrt(zs[i] * zs[i] - zs[i - 1] * zs[i - 1]),
              n = Gs[(i - 1) % Gs.length];
            this._blur(t, i - 1, i, e, n);
          }
          e.autoClear = n;
        }
        _blur(t, e, n, i, r) {
          const a = this._pingPongRenderTarget;
          this._halfBlur(t, a, e, n, i, "latitudinal", r),
            this._halfBlur(a, t, n, n, i, "longitudinal", r);
        }
        _halfBlur(t, e, n, i, r, a, o) {
          const s = this._renderer,
            c = this._blurMaterial;
          "latitudinal" !== a &&
            "longitudinal" !== a &&
            console.error(
              "blur direction must be either latitudinal or longitudinal!"
            );
          const l = 3,
            h = new vr(Ns[i], c),
            u = c.uniforms,
            d = Bs[n] - 1,
            p = isFinite(r) ? Math.PI / (2 * d) : (2 * Math.PI) / (2 * Is - 1),
            f = r / p,
            m = isFinite(r) ? 1 + Math.floor(l * f) : Is;
          m > Is &&
            console.warn(
              `sigmaRadians, ${r}, is too large and will clip, as it requested ${m} samples when the maximum is set to ${Is}`
            );
          const g = [];
          let v = 0;
          for (let b = 0; b < Is; ++b) {
            const t = b / f,
              e = Math.exp((-t * t) / 2);
            g.push(e), 0 === b ? (v += e) : b < m && (v += 2 * e);
          }
          for (let b = 0; b < g.length; b++) g[b] = g[b] / v;
          (u["envMap"].value = t.texture),
            (u["samples"].value = m),
            (u["weights"].value = g),
            (u["latitudinal"].value = "latitudinal" === a),
            o && (u["poleAxis"].value = o),
            (u["dTheta"].value = p),
            (u["mipInt"].value = Rs - n);
          const y = Bs[i],
            x = 3 * Math.max(0, Ls - 2 * y),
            _ =
              (0 === i ? 0 : 2 * Ls) + 2 * y * (i > Rs - Cs ? i - Rs + Cs : 0);
          qs(e, x, _, 3 * y, 2 * y), s.setRenderTarget(e), s.render(h, Os);
        }
      }
      function Ws() {
        const t = [],
          e = [],
          n = [];
        let i = Rs;
        for (let r = 0; r < Ds; r++) {
          const a = Math.pow(2, i);
          e.push(a);
          let o = 1 / a;
          r > Rs - Cs ? (o = Ps[r - Rs + Cs - 1]) : 0 === r && (o = 0),
            n.push(o);
          const s = 1 / (a - 1),
            c = -s / 2,
            l = 1 + s / 2,
            h = [c, c, l, c, l, l, c, c, l, l, c, l],
            u = 6,
            d = 6,
            p = 3,
            f = 2,
            m = 1,
            g = new Float32Array(p * d * u),
            v = new Float32Array(f * d * u),
            y = new Float32Array(m * d * u);
          for (let t = 0; t < u; t++) {
            const e = ((t % 3) * 2) / 3 - 1,
              n = t > 2 ? 0 : -1,
              i = [
                e,
                n,
                0,
                e + 2 / 3,
                n,
                0,
                e + 2 / 3,
                n + 1,
                0,
                e,
                n,
                0,
                e + 2 / 3,
                n + 1,
                0,
                e,
                n + 1,
                0,
              ];
            g.set(i, p * d * t), v.set(h, f * d * t);
            const r = [t, t, t, t, t, t];
            y.set(r, m * d * t);
          }
          const x = new Qi();
          x.setAttribute("position", new ki(g, p)),
            x.setAttribute("uv", new ki(v, f)),
            x.setAttribute("faceIndex", new ki(y, m)),
            t.push(x),
            i > Cs && i--;
        }
        return { _lodPlanes: t, _sizeLods: e, _sigmas: n };
      }
      function js(t) {
        const e = new yn(3 * Ls, 3 * Ls, t);
        return (
          (e.texture.mapping = ut),
          (e.texture.name = "PMREM.cubeUv"),
          (e.scissorTest = !0),
          e
        );
      }
      function qs(t, e, n, i, r) {
        t.viewport.set(e, n, i, r), t.scissor.set(e, n, i, r);
      }
      function Xs(t) {
        const e = new Float32Array(t),
          n = new wn(0, 1, 0),
          i = new As({
            name: "SphericalGaussianBlur",
            defines: { n: t },
            uniforms: {
              envMap: { value: null },
              samples: { value: 1 },
              weights: { value: e },
              latitudinal: { value: !1 },
              dTheta: { value: 0 },
              mipInt: { value: 0 },
              poleAxis: { value: n },
            },
            vertexShader: Zs(),
            fragmentShader:
              "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t",
            blending: _,
            depthTest: !1,
            depthWrite: !1,
          });
        return i;
      }
      function Ys() {
        const t = new $e(1, 1),
          e = new As({
            name: "EquirectangularToCubeUV",
            uniforms: { envMap: { value: null }, texelSize: { value: t } },
            vertexShader: Zs(),
            fragmentShader:
              "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform vec2 texelSize;\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tvec2 f = fract( uv / texelSize - 0.5 );\n\t\t\t\tuv -= f * texelSize;\n\t\t\t\tvec3 tl = texture2D ( envMap, uv ).rgb;\n\t\t\t\tuv.x += texelSize.x;\n\t\t\t\tvec3 tr = texture2D ( envMap, uv ).rgb;\n\t\t\t\tuv.y += texelSize.y;\n\t\t\t\tvec3 br = texture2D ( envMap, uv ).rgb;\n\t\t\t\tuv.x -= texelSize.x;\n\t\t\t\tvec3 bl = texture2D ( envMap, uv ).rgb;\n\n\t\t\t\tvec3 tm = mix( tl, tr, f.x );\n\t\t\t\tvec3 bm = mix( bl, br, f.x );\n\t\t\t\tgl_FragColor.rgb = mix( tm, bm, f.y );\n\n\t\t\t}\n\t\t",
            blending: _,
            depthTest: !1,
            depthWrite: !1,
          });
        return e;
      }
      function Js() {
        const t = new As({
          name: "CubemapToCubeUV",
          uniforms: { envMap: { value: null }, flipEnvMap: { value: -1 } },
          vertexShader: Zs(),
          fragmentShader:
            "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tuniform float flipEnvMap;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );\n\n\t\t\t}\n\t\t",
          blending: _,
          depthTest: !1,
          depthWrite: !1,
        });
        return t;
      }
      function Zs() {
        return "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t";
      }
      function Ks(t) {
        let e = new WeakMap(),
          n = null;
        function i(i) {
          if (i && i.isTexture) {
            const o = i.mapping,
              s = o === lt || o === ht,
              c = o === st || o === ct;
            if (s || c) {
              if (i.isRenderTargetTexture && !0 === i.needsPMREMUpdate) {
                i.needsPMREMUpdate = !1;
                let r = e.get(i);
                return (
                  null === n && (n = new Vs(t)),
                  (r = s ? n.fromEquirectangular(i, r) : n.fromCubemap(i, r)),
                  e.set(i, r),
                  r.texture
                );
              }
              if (e.has(i)) return e.get(i).texture;
              {
                const o = i.image;
                if ((s && o && o.height > 0) || (c && o && r(o))) {
                  null === n && (n = new Vs(t));
                  const r = s ? n.fromEquirectangular(i) : n.fromCubemap(i);
                  return (
                    e.set(i, r), i.addEventListener("dispose", a), r.texture
                  );
                }
                return null;
              }
            }
          }
          return i;
        }
        function r(t) {
          let e = 0;
          const n = 6;
          for (let i = 0; i < n; i++) void 0 !== t[i] && e++;
          return e === n;
        }
        function a(t) {
          const n = t.target;
          n.removeEventListener("dispose", a);
          const i = e.get(n);
          void 0 !== i && (e.delete(n), i.dispose());
        }
        function o() {
          (e = new WeakMap()), null !== n && (n.dispose(), (n = null));
        }
        return { get: i, dispose: o };
      }
      function $s(t) {
        const e = {};
        function n(n) {
          if (void 0 !== e[n]) return e[n];
          let i;
          switch (n) {
            case "WEBGL_depth_texture":
              i =
                t.getExtension("WEBGL_depth_texture") ||
                t.getExtension("MOZ_WEBGL_depth_texture") ||
                t.getExtension("WEBKIT_WEBGL_depth_texture");
              break;
            case "EXT_texture_filter_anisotropic":
              i =
                t.getExtension("EXT_texture_filter_anisotropic") ||
                t.getExtension("MOZ_EXT_texture_filter_anisotropic") ||
                t.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
              break;
            case "WEBGL_compressed_texture_s3tc":
              i =
                t.getExtension("WEBGL_compressed_texture_s3tc") ||
                t.getExtension("MOZ_WEBGL_compressed_texture_s3tc") ||
                t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
              break;
            case "WEBGL_compressed_texture_pvrtc":
              i =
                t.getExtension("WEBGL_compressed_texture_pvrtc") ||
                t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
              break;
            default:
              i = t.getExtension(n);
          }
          return (e[n] = i), i;
        }
        return {
          has: function (t) {
            return null !== n(t);
          },
          init: function (t) {
            t.isWebGL2
              ? n("EXT_color_buffer_float")
              : (n("WEBGL_depth_texture"),
                n("OES_texture_float"),
                n("OES_texture_half_float"),
                n("OES_texture_half_float_linear"),
                n("OES_standard_derivatives"),
                n("OES_element_index_uint"),
                n("OES_vertex_array_object"),
                n("ANGLE_instanced_arrays")),
              n("OES_texture_float_linear"),
              n("EXT_color_buffer_half_float"),
              n("WEBGL_multisampled_render_to_texture");
          },
          get: function (t) {
            const e = n(t);
            return (
              null === e &&
                console.warn(
                  "THREE.WebGLRenderer: " + t + " extension not supported."
                ),
              e
            );
          },
        };
      }
      function Qs(t, e, n, i) {
        const r = {},
          a = new WeakMap();
        function o(t) {
          const s = t.target;
          null !== s.index && e.remove(s.index);
          for (const n in s.attributes) e.remove(s.attributes[n]);
          s.removeEventListener("dispose", o), delete r[s.id];
          const c = a.get(s);
          c && (e.remove(c), a.delete(s)),
            i.releaseStatesOfGeometry(s),
            !0 === s.isInstancedBufferGeometry && delete s._maxInstanceCount,
            n.memory.geometries--;
        }
        function s(t, e) {
          return (
            !0 === r[e.id] ||
              (e.addEventListener("dispose", o),
              (r[e.id] = !0),
              n.memory.geometries++),
            e
          );
        }
        function c(t) {
          const n = t.attributes;
          for (const r in n) e.update(n[r], 34962);
          const i = t.morphAttributes;
          for (const r in i) {
            const t = i[r];
            for (let n = 0, i = t.length; n < i; n++) e.update(t[n], 34962);
          }
        }
        function l(t) {
          const n = [],
            i = t.index,
            r = t.attributes.position;
          let o = 0;
          if (null !== i) {
            const t = i.array;
            o = i.version;
            for (let e = 0, i = t.length; e < i; e += 3) {
              const i = t[e + 0],
                r = t[e + 1],
                a = t[e + 2];
              n.push(i, r, r, a, a, i);
            }
          } else {
            const t = r.array;
            o = r.version;
            for (let e = 0, i = t.length / 3 - 1; e < i; e += 3) {
              const t = e + 0,
                i = e + 1,
                r = e + 2;
              n.push(t, i, i, r, r, t);
            }
          }
          const s = new (tn(n) ? Vi : Gi)(n, 1);
          s.version = o;
          const c = a.get(t);
          c && e.remove(c), a.set(t, s);
        }
        function h(t) {
          const e = a.get(t);
          if (e) {
            const n = t.index;
            null !== n && e.version < n.version && l(t);
          } else l(t);
          return a.get(t);
        }
        return { get: s, update: c, getWireframeAttribute: h };
      }
      function tc(t, e, n, i) {
        const r = i.isWebGL2;
        let a, o, s;
        function c(t) {
          a = t;
        }
        function l(t) {
          (o = t.type), (s = t.bytesPerElement);
        }
        function h(e, i) {
          t.drawElements(a, i, o, e * s), n.update(i, a, 1);
        }
        function u(i, c, l) {
          if (0 === l) return;
          let h, u;
          if (r) (h = t), (u = "drawElementsInstanced");
          else if (
            ((h = e.get("ANGLE_instanced_arrays")),
            (u = "drawElementsInstancedANGLE"),
            null === h)
          )
            return void console.error(
              "THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
            );
          h[u](a, c, o, i * s, l), n.update(c, a, l);
        }
        (this.setMode = c),
          (this.setIndex = l),
          (this.render = h),
          (this.renderInstances = u);
      }
      function ec(t) {
        const e = { geometries: 0, textures: 0 },
          n = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 };
        function i(t, e, i) {
          switch ((n.calls++, e)) {
            case 4:
              n.triangles += i * (t / 3);
              break;
            case 1:
              n.lines += i * (t / 2);
              break;
            case 3:
              n.lines += i * (t - 1);
              break;
            case 2:
              n.lines += i * t;
              break;
            case 0:
              n.points += i * t;
              break;
            default:
              console.error("THREE.WebGLInfo: Unknown draw mode:", e);
              break;
          }
        }
        function r() {
          n.frame++,
            (n.calls = 0),
            (n.triangles = 0),
            (n.points = 0),
            (n.lines = 0);
        }
        return {
          memory: e,
          render: n,
          programs: null,
          autoReset: !0,
          reset: r,
          update: i,
        };
      }
      class nc extends mn {
        constructor(t = null, e = 1, n = 1, i = 1) {
          super(null),
            (this.image = { data: t, width: e, height: n, depth: i }),
            (this.magFilter = gt),
            (this.minFilter = gt),
            (this.wrapR = ft),
            (this.generateMipmaps = !1),
            (this.flipY = !1),
            (this.unpackAlignment = 1);
        }
      }
      function ic(t, e) {
        return t[0] - e[0];
      }
      function rc(t, e) {
        return Math.abs(e[1]) - Math.abs(t[1]);
      }
      function ac(t, e) {
        let n = 1;
        const i = e.isInterleavedBufferAttribute ? e.data.array : e.array;
        i instanceof Int8Array
          ? (n = 127)
          : i instanceof Int16Array
          ? (n = 32767)
          : i instanceof Int32Array
          ? (n = 2147483647)
          : console.error(
              "THREE.WebGLMorphtargets: Unsupported morph attribute data type: ",
              i
            ),
          t.divideScalar(n);
      }
      function oc(t, e, n) {
        const i = {},
          r = new Float32Array(8),
          a = new WeakMap(),
          o = new wn(),
          s = [];
        for (let l = 0; l < 8; l++) s[l] = [l, 0];
        function c(c, l, h, u) {
          const d = c.morphTargetInfluences;
          if (!0 === e.isWebGL2) {
            const i = l.morphAttributes.position.length;
            let r = a.get(l);
            if (void 0 === r || r.count !== i) {
              void 0 !== r && r.texture.dispose();
              const t = void 0 !== l.morphAttributes.normal,
                n = l.morphAttributes.position,
                s = l.morphAttributes.normal || [],
                c = l.attributes.position.count,
                h = !0 === t ? 2 : 1;
              let u = c * h,
                d = 1;
              u > e.maxTextureSize &&
                ((d = Math.ceil(u / e.maxTextureSize)), (u = e.maxTextureSize));
              const f = new Float32Array(u * d * 4 * i),
                m = new nc(f, u, d, i);
              (m.format = Nt), (m.type = Ct), (m.needsUpdate = !0);
              const g = 4 * h;
              for (let e = 0; e < i; e++) {
                const i = n[e],
                  r = s[e],
                  a = u * d * 4 * e;
                for (let e = 0; e < i.count; e++) {
                  o.fromBufferAttribute(i, e), !0 === i.normalized && ac(o, i);
                  const n = e * g;
                  (f[a + n + 0] = o.x),
                    (f[a + n + 1] = o.y),
                    (f[a + n + 2] = o.z),
                    (f[a + n + 3] = 0),
                    !0 === t &&
                      (o.fromBufferAttribute(r, e),
                      !0 === r.normalized && ac(o, r),
                      (f[a + n + 4] = o.x),
                      (f[a + n + 5] = o.y),
                      (f[a + n + 6] = o.z),
                      (f[a + n + 7] = 0));
                }
              }
              function p() {
                m.dispose(), a.delete(l), l.removeEventListener("dispose", p);
              }
              (r = { count: i, texture: m, size: new $e(u, d) }),
                a.set(l, r),
                l.addEventListener("dispose", p);
            }
            let s = 0;
            for (let t = 0; t < d.length; t++) s += d[t];
            const c = l.morphTargetsRelative ? 1 : 1 - s;
            u.getUniforms().setValue(t, "morphTargetBaseInfluence", c),
              u.getUniforms().setValue(t, "morphTargetInfluences", d),
              u.getUniforms().setValue(t, "morphTargetsTexture", r.texture, n),
              u.getUniforms().setValue(t, "morphTargetsTextureSize", r.size);
          } else {
            const e = void 0 === d ? 0 : d.length;
            let n = i[l.id];
            if (void 0 === n || n.length !== e) {
              n = [];
              for (let t = 0; t < e; t++) n[t] = [t, 0];
              i[l.id] = n;
            }
            for (let t = 0; t < e; t++) {
              const e = n[t];
              (e[0] = t), (e[1] = d[t]);
            }
            n.sort(rc);
            for (let t = 0; t < 8; t++)
              t < e && n[t][1]
                ? ((s[t][0] = n[t][0]), (s[t][1] = n[t][1]))
                : ((s[t][0] = Number.MAX_SAFE_INTEGER), (s[t][1] = 0));
            s.sort(ic);
            const a = l.morphAttributes.position,
              o = l.morphAttributes.normal;
            let c = 0;
            for (let t = 0; t < 8; t++) {
              const e = s[t],
                n = e[0],
                i = e[1];
              n !== Number.MAX_SAFE_INTEGER && i
                ? (a &&
                    l.getAttribute("morphTarget" + t) !== a[n] &&
                    l.setAttribute("morphTarget" + t, a[n]),
                  o &&
                    l.getAttribute("morphNormal" + t) !== o[n] &&
                    l.setAttribute("morphNormal" + t, o[n]),
                  (r[t] = i),
                  (c += i))
                : (a &&
                    !0 === l.hasAttribute("morphTarget" + t) &&
                    l.deleteAttribute("morphTarget" + t),
                  o &&
                    !0 === l.hasAttribute("morphNormal" + t) &&
                    l.deleteAttribute("morphNormal" + t),
                  (r[t] = 0));
            }
            const h = l.morphTargetsRelative ? 1 : 1 - c;
            u.getUniforms().setValue(t, "morphTargetBaseInfluence", h),
              u.getUniforms().setValue(t, "morphTargetInfluences", r);
          }
        }
        return { update: c };
      }
      function sc(t, e, n, i) {
        let r = new WeakMap();
        function a(t) {
          const a = i.render.frame,
            o = t.geometry,
            c = e.get(t, o);
          return (
            r.get(c) !== a && (e.update(c), r.set(c, a)),
            t.isInstancedMesh &&
              (!1 === t.hasEventListener("dispose", s) &&
                t.addEventListener("dispose", s),
              n.update(t.instanceMatrix, 34962),
              null !== t.instanceColor && n.update(t.instanceColor, 34962)),
            c
          );
        }
        function o() {
          r = new WeakMap();
        }
        function s(t) {
          const e = t.target;
          e.removeEventListener("dispose", s),
            n.remove(e.instanceMatrix),
            null !== e.instanceColor && n.remove(e.instanceColor);
        }
        return { update: a, dispose: o };
      }
      nc.prototype.isDataTexture2DArray = !0;
      class cc extends mn {
        constructor(t = null, e = 1, n = 1, i = 1) {
          super(null),
            (this.image = { data: t, width: e, height: n, depth: i }),
            (this.magFilter = gt),
            (this.minFilter = gt),
            (this.wrapR = ft),
            (this.generateMipmaps = !1),
            (this.flipY = !1),
            (this.unpackAlignment = 1);
        }
      }
      cc.prototype.isDataTexture3D = !0;
      const lc = new mn(),
        hc = new nc(),
        uc = new cc(),
        dc = new Dr(),
        pc = [],
        fc = [],
        mc = new Float32Array(16),
        gc = new Float32Array(9),
        vc = new Float32Array(4);
      function yc(t, e, n) {
        const i = t[0];
        if (i <= 0 || i > 0) return t;
        const r = e * n;
        let a = pc[r];
        if (
          (void 0 === a && ((a = new Float32Array(r)), (pc[r] = a)), 0 !== e)
        ) {
          i.toArray(a, 0);
          for (let i = 1, r = 0; i !== e; ++i) (r += n), t[i].toArray(a, r);
        }
        return a;
      }
      function xc(t, e) {
        if (t.length !== e.length) return !1;
        for (let n = 0, i = t.length; n < i; n++) if (t[n] !== e[n]) return !1;
        return !0;
      }
      function _c(t, e) {
        for (let n = 0, i = e.length; n < i; n++) t[n] = e[n];
      }
      function bc(t, e) {
        let n = fc[e];
        void 0 === n && ((n = new Int32Array(e)), (fc[e] = n));
        for (let i = 0; i !== e; ++i) n[i] = t.allocateTextureUnit();
        return n;
      }
      function wc(t, e) {
        const n = this.cache;
        n[0] !== e && (t.uniform1f(this.addr, e), (n[0] = e));
      }
      function Mc(t, e) {
        const n = this.cache;
        if (void 0 !== e.x)
          (n[0] === e.x && n[1] === e.y) ||
            (t.uniform2f(this.addr, e.x, e.y), (n[0] = e.x), (n[1] = e.y));
        else {
          if (xc(n, e)) return;
          t.uniform2fv(this.addr, e), _c(n, e);
        }
      }
      function Sc(t, e) {
        const n = this.cache;
        if (void 0 !== e.x)
          (n[0] === e.x && n[1] === e.y && n[2] === e.z) ||
            (t.uniform3f(this.addr, e.x, e.y, e.z),
            (n[0] = e.x),
            (n[1] = e.y),
            (n[2] = e.z));
        else if (void 0 !== e.r)
          (n[0] === e.r && n[1] === e.g && n[2] === e.b) ||
            (t.uniform3f(this.addr, e.r, e.g, e.b),
            (n[0] = e.r),
            (n[1] = e.g),
            (n[2] = e.b));
        else {
          if (xc(n, e)) return;
          t.uniform3fv(this.addr, e), _c(n, e);
        }
      }
      function Ec(t, e) {
        const n = this.cache;
        if (void 0 !== e.x)
          (n[0] === e.x && n[1] === e.y && n[2] === e.z && n[3] === e.w) ||
            (t.uniform4f(this.addr, e.x, e.y, e.z, e.w),
            (n[0] = e.x),
            (n[1] = e.y),
            (n[2] = e.z),
            (n[3] = e.w));
        else {
          if (xc(n, e)) return;
          t.uniform4fv(this.addr, e), _c(n, e);
        }
      }
      function Tc(t, e) {
        const n = this.cache,
          i = e.elements;
        if (void 0 === i) {
          if (xc(n, e)) return;
          t.uniformMatrix2fv(this.addr, !1, e), _c(n, e);
        } else {
          if (xc(n, i)) return;
          vc.set(i), t.uniformMatrix2fv(this.addr, !1, vc), _c(n, i);
        }
      }
      function Ac(t, e) {
        const n = this.cache,
          i = e.elements;
        if (void 0 === i) {
          if (xc(n, e)) return;
          t.uniformMatrix3fv(this.addr, !1, e), _c(n, e);
        } else {
          if (xc(n, i)) return;
          gc.set(i), t.uniformMatrix3fv(this.addr, !1, gc), _c(n, i);
        }
      }
      function Cc(t, e) {
        const n = this.cache,
          i = e.elements;
        if (void 0 === i) {
          if (xc(n, e)) return;
          t.uniformMatrix4fv(this.addr, !1, e), _c(n, e);
        } else {
          if (xc(n, i)) return;
          mc.set(i), t.uniformMatrix4fv(this.addr, !1, mc), _c(n, i);
        }
      }
      function Rc(t, e) {
        const n = this.cache;
        n[0] !== e && (t.uniform1i(this.addr, e), (n[0] = e));
      }
      function Lc(t, e) {
        const n = this.cache;
        xc(n, e) || (t.uniform2iv(this.addr, e), _c(n, e));
      }
      function Pc(t, e) {
        const n = this.cache;
        xc(n, e) || (t.uniform3iv(this.addr, e), _c(n, e));
      }
      function Dc(t, e) {
        const n = this.cache;
        xc(n, e) || (t.uniform4iv(this.addr, e), _c(n, e));
      }
      function Ic(t, e) {
        const n = this.cache;
        n[0] !== e && (t.uniform1ui(this.addr, e), (n[0] = e));
      }
      function Oc(t, e) {
        const n = this.cache;
        xc(n, e) || (t.uniform2uiv(this.addr, e), _c(n, e));
      }
      function Nc(t, e) {
        const n = this.cache;
        xc(n, e) || (t.uniform3uiv(this.addr, e), _c(n, e));
      }
      function Bc(t, e) {
        const n = this.cache;
        xc(n, e) || (t.uniform4uiv(this.addr, e), _c(n, e));
      }
      function zc(t, e, n) {
        const i = this.cache,
          r = n.allocateTextureUnit();
        i[0] !== r && (t.uniform1i(this.addr, r), (i[0] = r)),
          n.safeSetTexture2D(e || lc, r);
      }
      function Uc(t, e, n) {
        const i = this.cache,
          r = n.allocateTextureUnit();
        i[0] !== r && (t.uniform1i(this.addr, r), (i[0] = r)),
          n.setTexture3D(e || uc, r);
      }
      function Fc(t, e, n) {
        const i = this.cache,
          r = n.allocateTextureUnit();
        i[0] !== r && (t.uniform1i(this.addr, r), (i[0] = r)),
          n.safeSetTextureCube(e || dc, r);
      }
      function Hc(t, e, n) {
        const i = this.cache,
          r = n.allocateTextureUnit();
        i[0] !== r && (t.uniform1i(this.addr, r), (i[0] = r)),
          n.setTexture2DArray(e || hc, r);
      }
      function kc(t) {
        switch (t) {
          case 5126:
            return wc;
          case 35664:
            return Mc;
          case 35665:
            return Sc;
          case 35666:
            return Ec;
          case 35674:
            return Tc;
          case 35675:
            return Ac;
          case 35676:
            return Cc;
          case 5124:
          case 35670:
            return Rc;
          case 35667:
          case 35671:
            return Lc;
          case 35668:
          case 35672:
            return Pc;
          case 35669:
          case 35673:
            return Dc;
          case 5125:
            return Ic;
          case 36294:
            return Oc;
          case 36295:
            return Nc;
          case 36296:
            return Bc;
          case 35678:
          case 36198:
          case 36298:
          case 36306:
          case 35682:
            return zc;
          case 35679:
          case 36299:
          case 36307:
            return Uc;
          case 35680:
          case 36300:
          case 36308:
          case 36293:
            return Fc;
          case 36289:
          case 36303:
          case 36311:
          case 36292:
            return Hc;
        }
      }
      function Gc(t, e) {
        t.uniform1fv(this.addr, e);
      }
      function Vc(t, e) {
        const n = yc(e, this.size, 2);
        t.uniform2fv(this.addr, n);
      }
      function Wc(t, e) {
        const n = yc(e, this.size, 3);
        t.uniform3fv(this.addr, n);
      }
      function jc(t, e) {
        const n = yc(e, this.size, 4);
        t.uniform4fv(this.addr, n);
      }
      function qc(t, e) {
        const n = yc(e, this.size, 4);
        t.uniformMatrix2fv(this.addr, !1, n);
      }
      function Xc(t, e) {
        const n = yc(e, this.size, 9);
        t.uniformMatrix3fv(this.addr, !1, n);
      }
      function Yc(t, e) {
        const n = yc(e, this.size, 16);
        t.uniformMatrix4fv(this.addr, !1, n);
      }
      function Jc(t, e) {
        t.uniform1iv(this.addr, e);
      }
      function Zc(t, e) {
        t.uniform2iv(this.addr, e);
      }
      function Kc(t, e) {
        t.uniform3iv(this.addr, e);
      }
      function $c(t, e) {
        t.uniform4iv(this.addr, e);
      }
      function Qc(t, e) {
        t.uniform1uiv(this.addr, e);
      }
      function tl(t, e) {
        t.uniform2uiv(this.addr, e);
      }
      function el(t, e) {
        t.uniform3uiv(this.addr, e);
      }
      function nl(t, e) {
        t.uniform4uiv(this.addr, e);
      }
      function il(t, e, n) {
        const i = e.length,
          r = bc(n, i);
        t.uniform1iv(this.addr, r);
        for (let a = 0; a !== i; ++a) n.safeSetTexture2D(e[a] || lc, r[a]);
      }
      function rl(t, e, n) {
        const i = e.length,
          r = bc(n, i);
        t.uniform1iv(this.addr, r);
        for (let a = 0; a !== i; ++a) n.setTexture3D(e[a] || uc, r[a]);
      }
      function al(t, e, n) {
        const i = e.length,
          r = bc(n, i);
        t.uniform1iv(this.addr, r);
        for (let a = 0; a !== i; ++a) n.safeSetTextureCube(e[a] || dc, r[a]);
      }
      function ol(t, e, n) {
        const i = e.length,
          r = bc(n, i);
        t.uniform1iv(this.addr, r);
        for (let a = 0; a !== i; ++a) n.setTexture2DArray(e[a] || hc, r[a]);
      }
      function sl(t) {
        switch (t) {
          case 5126:
            return Gc;
          case 35664:
            return Vc;
          case 35665:
            return Wc;
          case 35666:
            return jc;
          case 35674:
            return qc;
          case 35675:
            return Xc;
          case 35676:
            return Yc;
          case 5124:
          case 35670:
            return Jc;
          case 35667:
          case 35671:
            return Zc;
          case 35668:
          case 35672:
            return Kc;
          case 35669:
          case 35673:
            return $c;
          case 5125:
            return Qc;
          case 36294:
            return tl;
          case 36295:
            return el;
          case 36296:
            return nl;
          case 35678:
          case 36198:
          case 36298:
          case 36306:
          case 35682:
            return il;
          case 35679:
          case 36299:
          case 36307:
            return rl;
          case 35680:
          case 36300:
          case 36308:
          case 36293:
            return al;
          case 36289:
          case 36303:
          case 36311:
          case 36292:
            return ol;
        }
      }
      function cl(t, e, n) {
        (this.id = t),
          (this.addr = n),
          (this.cache = []),
          (this.setValue = kc(e.type));
      }
      function ll(t, e, n) {
        (this.id = t),
          (this.addr = n),
          (this.cache = []),
          (this.size = e.size),
          (this.setValue = sl(e.type));
      }
      function hl(t) {
        (this.id = t), (this.seq = []), (this.map = {});
      }
      (ll.prototype.updateCache = function (t) {
        const e = this.cache;
        t instanceof Float32Array &&
          e.length !== t.length &&
          (this.cache = new Float32Array(t.length)),
          _c(e, t);
      }),
        (hl.prototype.setValue = function (t, e, n) {
          const i = this.seq;
          for (let r = 0, a = i.length; r !== a; ++r) {
            const a = i[r];
            a.setValue(t, e[a.id], n);
          }
        });
      const ul = /(\w+)(\])?(\[|\.)?/g;
      function dl(t, e) {
        t.seq.push(e), (t.map[e.id] = e);
      }
      function pl(t, e, n) {
        const i = t.name,
          r = i.length;
        ul.lastIndex = 0;
        while (1) {
          const a = ul.exec(i),
            o = ul.lastIndex;
          let s = a[1];
          const c = "]" === a[2],
            l = a[3];
          if ((c && (s |= 0), void 0 === l || ("[" === l && o + 2 === r))) {
            dl(n, void 0 === l ? new cl(s, t, e) : new ll(s, t, e));
            break;
          }
          {
            const t = n.map;
            let e = t[s];
            void 0 === e && ((e = new hl(s)), dl(n, e)), (n = e);
          }
        }
      }
      function fl(t, e) {
        (this.seq = []), (this.map = {});
        const n = t.getProgramParameter(e, 35718);
        for (let i = 0; i < n; ++i) {
          const n = t.getActiveUniform(e, i),
            r = t.getUniformLocation(e, n.name);
          pl(n, r, this);
        }
      }
      function ml(t, e, n) {
        const i = t.createShader(e);
        return t.shaderSource(i, n), t.compileShader(i), i;
      }
      (fl.prototype.setValue = function (t, e, n, i) {
        const r = this.map[e];
        void 0 !== r && r.setValue(t, n, i);
      }),
        (fl.prototype.setOptional = function (t, e, n) {
          const i = e[n];
          void 0 !== i && this.setValue(t, n, i);
        }),
        (fl.upload = function (t, e, n, i) {
          for (let r = 0, a = e.length; r !== a; ++r) {
            const a = e[r],
              o = n[a.id];
            !1 !== o.needsUpdate && a.setValue(t, o.value, i);
          }
        }),
        (fl.seqWithValue = function (t, e) {
          const n = [];
          for (let i = 0, r = t.length; i !== r; ++i) {
            const r = t[i];
            r.id in e && n.push(r);
          }
          return n;
        });
      let gl = 0;
      function vl(t) {
        const e = t.split("\n");
        for (let n = 0; n < e.length; n++) e[n] = n + 1 + ": " + e[n];
        return e.join("\n");
      }
      function yl(t) {
        switch (t) {
          case Re:
            return ["Linear", "( value )"];
          case Le:
            return ["sRGB", "( value )"];
          default:
            return (
              console.warn("THREE.WebGLProgram: Unsupported encoding:", t),
              ["Linear", "( value )"]
            );
        }
      }
      function xl(t, e, n) {
        const i = t.getShaderParameter(e, 35713),
          r = t.getShaderInfoLog(e).trim();
        return i && "" === r
          ? ""
          : n.toUpperCase() + "\n\n" + r + "\n\n" + vl(t.getShaderSource(e));
      }
      function _l(t, e) {
        const n = yl(e);
        return (
          "vec4 " + t + "( vec4 value ) { return LinearTo" + n[0] + n[1] + "; }"
        );
      }
      function bl(t, e) {
        let n;
        switch (e) {
          case et:
            n = "Linear";
            break;
          case nt:
            n = "Reinhard";
            break;
          case it:
            n = "OptimizedCineon";
            break;
          case rt:
            n = "ACESFilmic";
            break;
          case at:
            n = "Custom";
            break;
          default:
            console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e),
              (n = "Linear");
        }
        return (
          "vec3 " +
          t +
          "( vec3 color ) { return " +
          n +
          "ToneMapping( color ); }"
        );
      }
      function wl(t) {
        const e = [
          t.extensionDerivatives ||
          t.envMapCubeUV ||
          t.bumpMap ||
          t.tangentSpaceNormalMap ||
          t.clearcoatNormalMap ||
          t.flatShading ||
          "physical" === t.shaderID
            ? "#extension GL_OES_standard_derivatives : enable"
            : "",
          (t.extensionFragDepth || t.logarithmicDepthBuffer) &&
          t.rendererExtensionFragDepth
            ? "#extension GL_EXT_frag_depth : enable"
            : "",
          t.extensionDrawBuffers && t.rendererExtensionDrawBuffers
            ? "#extension GL_EXT_draw_buffers : require"
            : "",
          (t.extensionShaderTextureLOD || t.envMap || t.transmission) &&
          t.rendererExtensionShaderTextureLod
            ? "#extension GL_EXT_shader_texture_lod : enable"
            : "",
        ];
        return e.filter(El).join("\n");
      }
      function Ml(t) {
        const e = [];
        for (const n in t) {
          const i = t[n];
          !1 !== i && e.push("#define " + n + " " + i);
        }
        return e.join("\n");
      }
      function Sl(t, e) {
        const n = {},
          i = t.getProgramParameter(e, 35721);
        for (let r = 0; r < i; r++) {
          const i = t.getActiveAttrib(e, r),
            a = i.name;
          let o = 1;
          35674 === i.type && (o = 2),
            35675 === i.type && (o = 3),
            35676 === i.type && (o = 4),
            (n[a] = {
              type: i.type,
              location: t.getAttribLocation(e, a),
              locationSize: o,
            });
        }
        return n;
      }
      function El(t) {
        return "" !== t;
      }
      function Tl(t, e) {
        return t
          .replace(/NUM_DIR_LIGHTS/g, e.numDirLights)
          .replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights)
          .replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights)
          .replace(/NUM_POINT_LIGHTS/g, e.numPointLights)
          .replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights)
          .replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows)
          .replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows)
          .replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows);
      }
      function Al(t, e) {
        return t
          .replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes)
          .replace(
            /UNION_CLIPPING_PLANES/g,
            e.numClippingPlanes - e.numClipIntersection
          );
      }
      const Cl = /^[ \t]*#include +<([\w\d./]+)>/gm;
      function Rl(t) {
        return t.replace(Cl, Ll);
      }
      function Ll(t, e) {
        const n = vs[e];
        if (void 0 === n)
          throw new Error("Can not resolve #include <" + e + ">");
        return Rl(n);
      }
      const Pl =
          /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,
        Dl =
          /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
      function Il(t) {
        return t.replace(Dl, Nl).replace(Pl, Ol);
      }
      function Ol(t, e, n, i) {
        return (
          console.warn(
            "WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."
          ),
          Nl(t, e, n, i)
        );
      }
      function Nl(t, e, n, i) {
        let r = "";
        for (let a = parseInt(e); a < parseInt(n); a++)
          r += i
            .replace(/\[\s*i\s*\]/g, "[ " + a + " ]")
            .replace(/UNROLLED_LOOP_INDEX/g, a);
        return r;
      }
      function Bl(t) {
        let e =
          "precision " +
          t.precision +
          " float;\nprecision " +
          t.precision +
          " int;";
        return (
          "highp" === t.precision
            ? (e += "\n#define HIGH_PRECISION")
            : "mediump" === t.precision
            ? (e += "\n#define MEDIUM_PRECISION")
            : "lowp" === t.precision && (e += "\n#define LOW_PRECISION"),
          e
        );
      }
      function zl(t) {
        let e = "SHADOWMAP_TYPE_BASIC";
        return (
          t.shadowMapType === p
            ? (e = "SHADOWMAP_TYPE_PCF")
            : t.shadowMapType === f
            ? (e = "SHADOWMAP_TYPE_PCF_SOFT")
            : t.shadowMapType === m && (e = "SHADOWMAP_TYPE_VSM"),
          e
        );
      }
      function Ul(t) {
        let e = "ENVMAP_TYPE_CUBE";
        if (t.envMap)
          switch (t.envMapMode) {
            case st:
            case ct:
              e = "ENVMAP_TYPE_CUBE";
              break;
            case ut:
            case dt:
              e = "ENVMAP_TYPE_CUBE_UV";
              break;
          }
        return e;
      }
      function Fl(t) {
        let e = "ENVMAP_MODE_REFLECTION";
        if (t.envMap)
          switch (t.envMapMode) {
            case ct:
            case dt:
              e = "ENVMAP_MODE_REFRACTION";
              break;
          }
        return e;
      }
      function Hl(t) {
        let e = "ENVMAP_BLENDING_NONE";
        if (t.envMap)
          switch (t.combine) {
            case Z:
              e = "ENVMAP_BLENDING_MULTIPLY";
              break;
            case K:
              e = "ENVMAP_BLENDING_MIX";
              break;
            case Q:
              e = "ENVMAP_BLENDING_ADD";
              break;
          }
        return e;
      }
      function kl(t, e, n, i) {
        const r = t.getContext(),
          a = n.defines;
        let o = n.vertexShader,
          s = n.fragmentShader;
        const c = zl(n),
          l = Ul(n),
          h = Fl(n),
          u = Hl(n),
          d = n.isWebGL2 ? "" : wl(n),
          p = Ml(a),
          f = r.createProgram();
        let m,
          g,
          v = n.glslVersion ? "#version " + n.glslVersion + "\n" : "";
        n.isRawShaderMaterial
          ? ((m = [p].filter(El).join("\n")),
            m.length > 0 && (m += "\n"),
            (g = [d, p].filter(El).join("\n")),
            g.length > 0 && (g += "\n"))
          : ((m = [
              Bl(n),
              "#define SHADER_NAME " + n.shaderName,
              p,
              n.instancing ? "#define USE_INSTANCING" : "",
              n.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
              n.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "",
              "#define MAX_BONES " + n.maxBones,
              n.useFog && n.fog ? "#define USE_FOG" : "",
              n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "",
              n.map ? "#define USE_MAP" : "",
              n.envMap ? "#define USE_ENVMAP" : "",
              n.envMap ? "#define " + h : "",
              n.lightMap ? "#define USE_LIGHTMAP" : "",
              n.aoMap ? "#define USE_AOMAP" : "",
              n.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
              n.bumpMap ? "#define USE_BUMPMAP" : "",
              n.normalMap ? "#define USE_NORMALMAP" : "",
              n.normalMap && n.objectSpaceNormalMap
                ? "#define OBJECTSPACE_NORMALMAP"
                : "",
              n.normalMap && n.tangentSpaceNormalMap
                ? "#define TANGENTSPACE_NORMALMAP"
                : "",
              n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
              n.clearcoatRoughnessMap
                ? "#define USE_CLEARCOAT_ROUGHNESSMAP"
                : "",
              n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
              n.displacementMap && n.supportsVertexTextures
                ? "#define USE_DISPLACEMENTMAP"
                : "",
              n.specularMap ? "#define USE_SPECULARMAP" : "",
              n.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "",
              n.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "",
              n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
              n.metalnessMap ? "#define USE_METALNESSMAP" : "",
              n.alphaMap ? "#define USE_ALPHAMAP" : "",
              n.transmission ? "#define USE_TRANSMISSION" : "",
              n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
              n.thicknessMap ? "#define USE_THICKNESSMAP" : "",
              n.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "",
              n.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "",
              n.vertexTangents ? "#define USE_TANGENT" : "",
              n.vertexColors ? "#define USE_COLOR" : "",
              n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
              n.vertexUvs ? "#define USE_UV" : "",
              n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
              n.flatShading ? "#define FLAT_SHADED" : "",
              n.skinning ? "#define USE_SKINNING" : "",
              n.useVertexTexture ? "#define BONE_TEXTURE" : "",
              n.morphTargets ? "#define USE_MORPHTARGETS" : "",
              n.morphNormals && !1 === n.flatShading
                ? "#define USE_MORPHNORMALS"
                : "",
              n.morphTargets && n.isWebGL2
                ? "#define MORPHTARGETS_TEXTURE"
                : "",
              n.morphTargets && n.isWebGL2
                ? "#define MORPHTARGETS_COUNT " + n.morphTargetsCount
                : "",
              n.doubleSided ? "#define DOUBLE_SIDED" : "",
              n.flipSided ? "#define FLIP_SIDED" : "",
              n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
              n.shadowMapEnabled ? "#define " + c : "",
              n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
              n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
              n.logarithmicDepthBuffer && n.rendererExtensionFragDepth
                ? "#define USE_LOGDEPTHBUF_EXT"
                : "",
              "uniform mat4 modelMatrix;",
              "uniform mat4 modelViewMatrix;",
              "uniform mat4 projectionMatrix;",
              "uniform mat4 viewMatrix;",
              "uniform mat3 normalMatrix;",
              "uniform vec3 cameraPosition;",
              "uniform bool isOrthographic;",
              "#ifdef USE_INSTANCING",
              "\tattribute mat4 instanceMatrix;",
              "#endif",
              "#ifdef USE_INSTANCING_COLOR",
              "\tattribute vec3 instanceColor;",
              "#endif",
              "attribute vec3 position;",
              "attribute vec3 normal;",
              "attribute vec2 uv;",
              "#ifdef USE_TANGENT",
              "\tattribute vec4 tangent;",
              "#endif",
              "#if defined( USE_COLOR_ALPHA )",
              "\tattribute vec4 color;",
              "#elif defined( USE_COLOR )",
              "\tattribute vec3 color;",
              "#endif",
              "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )",
              "\tattribute vec3 morphTarget0;",
              "\tattribute vec3 morphTarget1;",
              "\tattribute vec3 morphTarget2;",
              "\tattribute vec3 morphTarget3;",
              "\t#ifdef USE_MORPHNORMALS",
              "\t\tattribute vec3 morphNormal0;",
              "\t\tattribute vec3 morphNormal1;",
              "\t\tattribute vec3 morphNormal2;",
              "\t\tattribute vec3 morphNormal3;",
              "\t#else",
              "\t\tattribute vec3 morphTarget4;",
              "\t\tattribute vec3 morphTarget5;",
              "\t\tattribute vec3 morphTarget6;",
              "\t\tattribute vec3 morphTarget7;",
              "\t#endif",
              "#endif",
              "#ifdef USE_SKINNING",
              "\tattribute vec4 skinIndex;",
              "\tattribute vec4 skinWeight;",
              "#endif",
              "\n",
            ]
              .filter(El)
              .join("\n")),
            (g = [
              d,
              Bl(n),
              "#define SHADER_NAME " + n.shaderName,
              p,
              n.useFog && n.fog ? "#define USE_FOG" : "",
              n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "",
              n.map ? "#define USE_MAP" : "",
              n.matcap ? "#define USE_MATCAP" : "",
              n.envMap ? "#define USE_ENVMAP" : "",
              n.envMap ? "#define " + l : "",
              n.envMap ? "#define " + h : "",
              n.envMap ? "#define " + u : "",
              n.lightMap ? "#define USE_LIGHTMAP" : "",
              n.aoMap ? "#define USE_AOMAP" : "",
              n.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
              n.bumpMap ? "#define USE_BUMPMAP" : "",
              n.normalMap ? "#define USE_NORMALMAP" : "",
              n.normalMap && n.objectSpaceNormalMap
                ? "#define OBJECTSPACE_NORMALMAP"
                : "",
              n.normalMap && n.tangentSpaceNormalMap
                ? "#define TANGENTSPACE_NORMALMAP"
                : "",
              n.clearcoat ? "#define USE_CLEARCOAT" : "",
              n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
              n.clearcoatRoughnessMap
                ? "#define USE_CLEARCOAT_ROUGHNESSMAP"
                : "",
              n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
              n.specularMap ? "#define USE_SPECULARMAP" : "",
              n.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "",
              n.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "",
              n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
              n.metalnessMap ? "#define USE_METALNESSMAP" : "",
              n.alphaMap ? "#define USE_ALPHAMAP" : "",
              n.alphaTest ? "#define USE_ALPHATEST" : "",
              n.sheen ? "#define USE_SHEEN" : "",
              n.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "",
              n.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "",
              n.transmission ? "#define USE_TRANSMISSION" : "",
              n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
              n.thicknessMap ? "#define USE_THICKNESSMAP" : "",
              n.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "",
              n.vertexTangents ? "#define USE_TANGENT" : "",
              n.vertexColors || n.instancingColor ? "#define USE_COLOR" : "",
              n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
              n.vertexUvs ? "#define USE_UV" : "",
              n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
              n.gradientMap ? "#define USE_GRADIENTMAP" : "",
              n.flatShading ? "#define FLAT_SHADED" : "",
              n.doubleSided ? "#define DOUBLE_SIDED" : "",
              n.flipSided ? "#define FLIP_SIDED" : "",
              n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
              n.shadowMapEnabled ? "#define " + c : "",
              n.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
              n.physicallyCorrectLights
                ? "#define PHYSICALLY_CORRECT_LIGHTS"
                : "",
              n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
              n.logarithmicDepthBuffer && n.rendererExtensionFragDepth
                ? "#define USE_LOGDEPTHBUF_EXT"
                : "",
              (n.extensionShaderTextureLOD || n.envMap) &&
              n.rendererExtensionShaderTextureLod
                ? "#define TEXTURE_LOD_EXT"
                : "",
              "uniform mat4 viewMatrix;",
              "uniform vec3 cameraPosition;",
              "uniform bool isOrthographic;",
              n.toneMapping !== tt ? "#define TONE_MAPPING" : "",
              n.toneMapping !== tt ? vs["tonemapping_pars_fragment"] : "",
              n.toneMapping !== tt ? bl("toneMapping", n.toneMapping) : "",
              n.dithering ? "#define DITHERING" : "",
              n.transparent ? "" : "#define OPAQUE",
              vs["encodings_pars_fragment"],
              _l("linearToOutputTexel", n.outputEncoding),
              n.depthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "",
              "\n",
            ]
              .filter(El)
              .join("\n"))),
          (o = Rl(o)),
          (o = Tl(o, n)),
          (o = Al(o, n)),
          (s = Rl(s)),
          (s = Tl(s, n)),
          (s = Al(s, n)),
          (o = Il(o)),
          (s = Il(s)),
          n.isWebGL2 &&
            !0 !== n.isRawShaderMaterial &&
            ((v = "#version 300 es\n"),
            (m =
              [
                "precision mediump sampler2DArray;",
                "#define attribute in",
                "#define varying out",
                "#define texture2D texture",
              ].join("\n") +
              "\n" +
              m),
            (g =
              [
                "#define varying in",
                n.glslVersion === Fe
                  ? ""
                  : "layout(location = 0) out highp vec4 pc_fragColor;",
                n.glslVersion === Fe ? "" : "#define gl_FragColor pc_fragColor",
                "#define gl_FragDepthEXT gl_FragDepth",
                "#define texture2D texture",
                "#define textureCube texture",
                "#define texture2DProj textureProj",
                "#define texture2DLodEXT textureLod",
                "#define texture2DProjLodEXT textureProjLod",
                "#define textureCubeLodEXT textureLod",
                "#define texture2DGradEXT textureGrad",
                "#define texture2DProjGradEXT textureProjGrad",
                "#define textureCubeGradEXT textureGrad",
              ].join("\n") +
              "\n" +
              g));
        const y = v + m + o,
          x = v + g + s,
          _ = ml(r, 35633, y),
          b = ml(r, 35632, x);
        if (
          (r.attachShader(f, _),
          r.attachShader(f, b),
          void 0 !== n.index0AttributeName
            ? r.bindAttribLocation(f, 0, n.index0AttributeName)
            : !0 === n.morphTargets && r.bindAttribLocation(f, 0, "position"),
          r.linkProgram(f),
          t.debug.checkShaderErrors)
        ) {
          const t = r.getProgramInfoLog(f).trim(),
            e = r.getShaderInfoLog(_).trim(),
            n = r.getShaderInfoLog(b).trim();
          let i = !0,
            a = !0;
          if (!1 === r.getProgramParameter(f, 35714)) {
            i = !1;
            const e = xl(r, _, "vertex"),
              n = xl(r, b, "fragment");
            console.error(
              "THREE.WebGLProgram: Shader Error " +
                r.getError() +
                " - VALIDATE_STATUS " +
                r.getProgramParameter(f, 35715) +
                "\n\nProgram Info Log: " +
                t +
                "\n" +
                e +
                "\n" +
                n
            );
          } else
            "" !== t
              ? console.warn("THREE.WebGLProgram: Program Info Log:", t)
              : ("" !== e && "" !== n) || (a = !1);
          a &&
            (this.diagnostics = {
              runnable: i,
              programLog: t,
              vertexShader: { log: e, prefix: m },
              fragmentShader: { log: n, prefix: g },
            });
        }
        let w, M;
        return (
          r.deleteShader(_),
          r.deleteShader(b),
          (this.getUniforms = function () {
            return void 0 === w && (w = new fl(r, f)), w;
          }),
          (this.getAttributes = function () {
            return void 0 === M && (M = Sl(r, f)), M;
          }),
          (this.destroy = function () {
            i.releaseStatesOfProgram(this),
              r.deleteProgram(f),
              (this.program = void 0);
          }),
          (this.name = n.shaderName),
          (this.id = gl++),
          (this.cacheKey = e),
          (this.usedTimes = 1),
          (this.program = f),
          (this.vertexShader = _),
          (this.fragmentShader = b),
          this
        );
      }
      let Gl = 0;
      class Vl {
        constructor() {
          (this.shaderCache = new Map()), (this.materialCache = new Map());
        }
        update(t) {
          const e = t.vertexShader,
            n = t.fragmentShader,
            i = this._getShaderStage(e),
            r = this._getShaderStage(n),
            a = this._getShaderCacheForMaterial(t);
          return (
            !1 === a.has(i) && (a.add(i), i.usedTimes++),
            !1 === a.has(r) && (a.add(r), r.usedTimes++),
            this
          );
        }
        remove(t) {
          const e = this.materialCache.get(t);
          for (const n of e)
            n.usedTimes--, 0 === n.usedTimes && this.shaderCache.delete(n);
          return this.materialCache.delete(t), this;
        }
        getVertexShaderID(t) {
          return this._getShaderStage(t.vertexShader).id;
        }
        getFragmentShaderID(t) {
          return this._getShaderStage(t.fragmentShader).id;
        }
        dispose() {
          this.shaderCache.clear(), this.materialCache.clear();
        }
        _getShaderCacheForMaterial(t) {
          const e = this.materialCache;
          return !1 === e.has(t) && e.set(t, new Set()), e.get(t);
        }
        _getShaderStage(t) {
          const e = this.shaderCache;
          if (!1 === e.has(t)) {
            const n = new Wl();
            e.set(t, n);
          }
          return e.get(t);
        }
      }
      class Wl {
        constructor() {
          (this.id = Gl++), (this.usedTimes = 0);
        }
      }
      function jl(t, e, n, i, r, a, o) {
        const s = new hi(),
          c = new Vl(),
          l = [],
          h = r.isWebGL2,
          u = r.logarithmicDepthBuffer,
          d = r.floatVertexTextures,
          p = r.maxVertexUniforms,
          f = r.vertexTextures;
        let m = r.precision;
        const g = {
          MeshDepthMaterial: "depth",
          MeshDistanceMaterial: "distanceRGBA",
          MeshNormalMaterial: "normal",
          MeshBasicMaterial: "basic",
          MeshLambertMaterial: "lambert",
          MeshPhongMaterial: "phong",
          MeshToonMaterial: "toon",
          MeshStandardMaterial: "physical",
          MeshPhysicalMaterial: "physical",
          MeshMatcapMaterial: "matcap",
          LineBasicMaterial: "basic",
          LineDashedMaterial: "dashed",
          PointsMaterial: "points",
          ShadowMaterial: "shadow",
          SpriteMaterial: "sprite",
        };
        function x(t) {
          const e = t.skeleton,
            n = e.bones;
          if (d) return 1024;
          {
            const t = p,
              e = Math.floor((t - 20) / 4),
              i = Math.min(e, n.length);
            return i < n.length
              ? (console.warn(
                  "THREE.WebGLRenderer: Skeleton has " +
                    n.length +
                    " bones. This GPU supports " +
                    i +
                    "."
                ),
                0)
              : i;
          }
        }
        function _(a, s, l, p, _) {
          const b = p.fog,
            w = a.isMeshStandardMaterial ? p.environment : null,
            M = (a.isMeshStandardMaterial ? n : e).get(a.envMap || w),
            S = g[a.type],
            E = _.isSkinnedMesh ? x(_) : 0;
          let T, A, C, R;
          if (
            (null !== a.precision &&
              ((m = r.getMaxPrecision(a.precision)),
              m !== a.precision &&
                console.warn(
                  "THREE.WebGLProgram.getParameters:",
                  a.precision,
                  "not supported, using",
                  m,
                  "instead."
                )),
            S)
          ) {
            const t = xs[S];
            (T = t.vertexShader), (A = t.fragmentShader);
          } else
            (T = a.vertexShader),
              (A = a.fragmentShader),
              c.update(a),
              (C = c.getVertexShaderID(a)),
              (R = c.getFragmentShaderID(a));
          const L = t.getRenderTarget(),
            P = a.alphaTest > 0,
            D = a.clearcoat > 0,
            I = {
              isWebGL2: h,
              shaderID: S,
              shaderName: a.type,
              vertexShader: T,
              fragmentShader: A,
              defines: a.defines,
              customVertexShaderID: C,
              customFragmentShaderID: R,
              isRawShaderMaterial: !0 === a.isRawShaderMaterial,
              glslVersion: a.glslVersion,
              precision: m,
              instancing: !0 === _.isInstancedMesh,
              instancingColor:
                !0 === _.isInstancedMesh && null !== _.instanceColor,
              supportsVertexTextures: f,
              outputEncoding:
                null === L
                  ? t.outputEncoding
                  : !0 === L.isXRRenderTarget
                  ? L.texture.encoding
                  : Re,
              map: !!a.map,
              matcap: !!a.matcap,
              envMap: !!M,
              envMapMode: M && M.mapping,
              envMapCubeUV: !!M && (M.mapping === ut || M.mapping === dt),
              lightMap: !!a.lightMap,
              aoMap: !!a.aoMap,
              emissiveMap: !!a.emissiveMap,
              bumpMap: !!a.bumpMap,
              normalMap: !!a.normalMap,
              objectSpaceNormalMap: a.normalMapType === Oe,
              tangentSpaceNormalMap: a.normalMapType === Ie,
              decodeVideoTexture:
                !!a.map && !0 === a.map.isVideoTexture && a.map.encoding === Le,
              clearcoat: D,
              clearcoatMap: D && !!a.clearcoatMap,
              clearcoatRoughnessMap: D && !!a.clearcoatRoughnessMap,
              clearcoatNormalMap: D && !!a.clearcoatNormalMap,
              displacementMap: !!a.displacementMap,
              roughnessMap: !!a.roughnessMap,
              metalnessMap: !!a.metalnessMap,
              specularMap: !!a.specularMap,
              specularIntensityMap: !!a.specularIntensityMap,
              specularColorMap: !!a.specularColorMap,
              transparent: a.transparent,
              alphaMap: !!a.alphaMap,
              alphaTest: P,
              gradientMap: !!a.gradientMap,
              sheen: a.sheen > 0,
              sheenColorMap: !!a.sheenColorMap,
              sheenRoughnessMap: !!a.sheenRoughnessMap,
              transmission: a.transmission > 0,
              transmissionMap: !!a.transmissionMap,
              thicknessMap: !!a.thicknessMap,
              combine: a.combine,
              vertexTangents:
                !!a.normalMap &&
                !!_.geometry &&
                !!_.geometry.attributes.tangent,
              vertexColors: a.vertexColors,
              vertexAlphas:
                !0 === a.vertexColors &&
                !!_.geometry &&
                !!_.geometry.attributes.color &&
                4 === _.geometry.attributes.color.itemSize,
              vertexUvs:
                !!a.map ||
                !!a.bumpMap ||
                !!a.normalMap ||
                !!a.specularMap ||
                !!a.alphaMap ||
                !!a.emissiveMap ||
                !!a.roughnessMap ||
                !!a.metalnessMap ||
                !!a.clearcoatMap ||
                !!a.clearcoatRoughnessMap ||
                !!a.clearcoatNormalMap ||
                !!a.displacementMap ||
                !!a.transmissionMap ||
                !!a.thicknessMap ||
                !!a.specularIntensityMap ||
                !!a.specularColorMap ||
                !!a.sheenColorMap ||
                !!a.sheenRoughnessMap,
              uvsVertexOnly:
                !(
                  a.map ||
                  a.bumpMap ||
                  a.normalMap ||
                  a.specularMap ||
                  a.alphaMap ||
                  a.emissiveMap ||
                  a.roughnessMap ||
                  a.metalnessMap ||
                  a.clearcoatNormalMap ||
                  a.transmission > 0 ||
                  a.transmissionMap ||
                  a.thicknessMap ||
                  a.specularIntensityMap ||
                  a.specularColorMap ||
                  a.sheen > 0 ||
                  a.sheenColorMap ||
                  a.sheenRoughnessMap
                ) && !!a.displacementMap,
              fog: !!b,
              useFog: a.fog,
              fogExp2: b && b.isFogExp2,
              flatShading: !!a.flatShading,
              sizeAttenuation: a.sizeAttenuation,
              logarithmicDepthBuffer: u,
              skinning: !0 === _.isSkinnedMesh && E > 0,
              maxBones: E,
              useVertexTexture: d,
              morphTargets:
                !!_.geometry && !!_.geometry.morphAttributes.position,
              morphNormals: !!_.geometry && !!_.geometry.morphAttributes.normal,
              morphTargetsCount:
                _.geometry && _.geometry.morphAttributes.position
                  ? _.geometry.morphAttributes.position.length
                  : 0,
              numDirLights: s.directional.length,
              numPointLights: s.point.length,
              numSpotLights: s.spot.length,
              numRectAreaLights: s.rectArea.length,
              numHemiLights: s.hemi.length,
              numDirLightShadows: s.directionalShadowMap.length,
              numPointLightShadows: s.pointShadowMap.length,
              numSpotLightShadows: s.spotShadowMap.length,
              numClippingPlanes: o.numPlanes,
              numClipIntersection: o.numIntersection,
              dithering: a.dithering,
              shadowMapEnabled: t.shadowMap.enabled && l.length > 0,
              shadowMapType: t.shadowMap.type,
              toneMapping: a.toneMapped ? t.toneMapping : tt,
              physicallyCorrectLights: t.physicallyCorrectLights,
              premultipliedAlpha: a.premultipliedAlpha,
              doubleSided: a.side === y,
              flipSided: a.side === v,
              depthPacking: void 0 !== a.depthPacking && a.depthPacking,
              index0AttributeName: a.index0AttributeName,
              extensionDerivatives: a.extensions && a.extensions.derivatives,
              extensionFragDepth: a.extensions && a.extensions.fragDepth,
              extensionDrawBuffers: a.extensions && a.extensions.drawBuffers,
              extensionShaderTextureLOD:
                a.extensions && a.extensions.shaderTextureLOD,
              rendererExtensionFragDepth: h || i.has("EXT_frag_depth"),
              rendererExtensionDrawBuffers: h || i.has("WEBGL_draw_buffers"),
              rendererExtensionShaderTextureLod:
                h || i.has("EXT_shader_texture_lod"),
              customProgramCacheKey: a.customProgramCacheKey(),
            };
          return I;
        }
        function b(e) {
          const n = [];
          if (
            (e.shaderID
              ? n.push(e.shaderID)
              : (n.push(e.customVertexShaderID),
                n.push(e.customFragmentShaderID)),
            void 0 !== e.defines)
          )
            for (const t in e.defines) n.push(t), n.push(e.defines[t]);
          return (
            !1 === e.isRawShaderMaterial &&
              (w(n, e), M(n, e), n.push(t.outputEncoding)),
            n.push(e.customProgramCacheKey),
            n.join()
          );
        }
        function w(t, e) {
          t.push(e.precision),
            t.push(e.outputEncoding),
            t.push(e.envMapMode),
            t.push(e.combine),
            t.push(e.vertexUvs),
            t.push(e.fogExp2),
            t.push(e.sizeAttenuation),
            t.push(e.maxBones),
            t.push(e.morphTargetsCount),
            t.push(e.numDirLights),
            t.push(e.numPointLights),
            t.push(e.numSpotLights),
            t.push(e.numHemiLights),
            t.push(e.numRectAreaLights),
            t.push(e.numDirLightShadows),
            t.push(e.numPointLightShadows),
            t.push(e.numSpotLightShadows),
            t.push(e.shadowMapType),
            t.push(e.toneMapping),
            t.push(e.numClippingPlanes),
            t.push(e.numClipIntersection);
        }
        function M(t, e) {
          s.disableAll(),
            e.isWebGL2 && s.enable(0),
            e.supportsVertexTextures && s.enable(1),
            e.instancing && s.enable(2),
            e.instancingColor && s.enable(3),
            e.map && s.enable(4),
            e.matcap && s.enable(5),
            e.envMap && s.enable(6),
            e.envMapCubeUV && s.enable(7),
            e.lightMap && s.enable(8),
            e.aoMap && s.enable(9),
            e.emissiveMap && s.enable(10),
            e.bumpMap && s.enable(11),
            e.normalMap && s.enable(12),
            e.objectSpaceNormalMap && s.enable(13),
            e.tangentSpaceNormalMap && s.enable(14),
            e.clearcoat && s.enable(15),
            e.clearcoatMap && s.enable(16),
            e.clearcoatRoughnessMap && s.enable(17),
            e.clearcoatNormalMap && s.enable(18),
            e.displacementMap && s.enable(19),
            e.specularMap && s.enable(20),
            e.roughnessMap && s.enable(21),
            e.metalnessMap && s.enable(22),
            e.gradientMap && s.enable(23),
            e.alphaMap && s.enable(24),
            e.alphaTest && s.enable(25),
            e.vertexColors && s.enable(26),
            e.vertexAlphas && s.enable(27),
            e.vertexUvs && s.enable(28),
            e.vertexTangents && s.enable(29),
            e.uvsVertexOnly && s.enable(30),
            e.fog && s.enable(31),
            t.push(s.mask),
            s.disableAll(),
            e.useFog && s.enable(0),
            e.flatShading && s.enable(1),
            e.logarithmicDepthBuffer && s.enable(2),
            e.skinning && s.enable(3),
            e.useVertexTexture && s.enable(4),
            e.morphTargets && s.enable(5),
            e.morphNormals && s.enable(6),
            e.premultipliedAlpha && s.enable(7),
            e.shadowMapEnabled && s.enable(8),
            e.physicallyCorrectLights && s.enable(9),
            e.doubleSided && s.enable(10),
            e.flipSided && s.enable(11),
            e.depthPacking && s.enable(12),
            e.dithering && s.enable(13),
            e.specularIntensityMap && s.enable(14),
            e.specularColorMap && s.enable(15),
            e.transmission && s.enable(16),
            e.transmissionMap && s.enable(17),
            e.thicknessMap && s.enable(18),
            e.sheen && s.enable(19),
            e.sheenColorMap && s.enable(20),
            e.sheenRoughnessMap && s.enable(21),
            e.decodeVideoTexture && s.enable(22),
            e.transparent && s.enable(23),
            t.push(s.mask);
        }
        function S(t) {
          const e = g[t.type];
          let n;
          if (e) {
            const t = xs[e];
            n = Mr.clone(t.uniforms);
          } else n = t.uniforms;
          return n;
        }
        function E(e, n) {
          let i;
          for (let t = 0, r = l.length; t < r; t++) {
            const e = l[t];
            if (e.cacheKey === n) {
              (i = e), ++i.usedTimes;
              break;
            }
          }
          return void 0 === i && ((i = new kl(t, n, e, a)), l.push(i)), i;
        }
        function T(t) {
          if (0 === --t.usedTimes) {
            const e = l.indexOf(t);
            (l[e] = l[l.length - 1]), l.pop(), t.destroy();
          }
        }
        function A(t) {
          c.remove(t);
        }
        function C() {
          c.dispose();
        }
        return {
          getParameters: _,
          getProgramCacheKey: b,
          getUniforms: S,
          acquireProgram: E,
          releaseProgram: T,
          releaseShaderCache: A,
          programs: l,
          dispose: C,
        };
      }
      function ql() {
        let t = new WeakMap();
        function e(e) {
          let n = t.get(e);
          return void 0 === n && ((n = {}), t.set(e, n)), n;
        }
        function n(e) {
          t.delete(e);
        }
        function i(e, n, i) {
          t.get(e)[n] = i;
        }
        function r() {
          t = new WeakMap();
        }
        return { get: e, remove: n, update: i, dispose: r };
      }
      function Xl(t, e) {
        return t.groupOrder !== e.groupOrder
          ? t.groupOrder - e.groupOrder
          : t.renderOrder !== e.renderOrder
          ? t.renderOrder - e.renderOrder
          : t.material.id !== e.material.id
          ? t.material.id - e.material.id
          : t.z !== e.z
          ? t.z - e.z
          : t.id - e.id;
      }
      function Yl(t, e) {
        return t.groupOrder !== e.groupOrder
          ? t.groupOrder - e.groupOrder
          : t.renderOrder !== e.renderOrder
          ? t.renderOrder - e.renderOrder
          : t.z !== e.z
          ? e.z - t.z
          : t.id - e.id;
      }
      function Jl() {
        const t = [];
        let e = 0;
        const n = [],
          i = [],
          r = [];
        function a() {
          (e = 0), (n.length = 0), (i.length = 0), (r.length = 0);
        }
        function o(n, i, r, a, o, s) {
          let c = t[e];
          return (
            void 0 === c
              ? ((c = {
                  id: n.id,
                  object: n,
                  geometry: i,
                  material: r,
                  groupOrder: a,
                  renderOrder: n.renderOrder,
                  z: o,
                  group: s,
                }),
                (t[e] = c))
              : ((c.id = n.id),
                (c.object = n),
                (c.geometry = i),
                (c.material = r),
                (c.groupOrder = a),
                (c.renderOrder = n.renderOrder),
                (c.z = o),
                (c.group = s)),
            e++,
            c
          );
        }
        function s(t, e, a, s, c, l) {
          const h = o(t, e, a, s, c, l);
          a.transmission > 0
            ? i.push(h)
            : !0 === a.transparent
            ? r.push(h)
            : n.push(h);
        }
        function c(t, e, a, s, c, l) {
          const h = o(t, e, a, s, c, l);
          a.transmission > 0
            ? i.unshift(h)
            : !0 === a.transparent
            ? r.unshift(h)
            : n.unshift(h);
        }
        function l(t, e) {
          n.length > 1 && n.sort(t || Xl),
            i.length > 1 && i.sort(e || Yl),
            r.length > 1 && r.sort(e || Yl);
        }
        function h() {
          for (let n = e, i = t.length; n < i; n++) {
            const e = t[n];
            if (null === e.id) break;
            (e.id = null),
              (e.object = null),
              (e.geometry = null),
              (e.material = null),
              (e.group = null);
          }
        }
        return {
          opaque: n,
          transmissive: i,
          transparent: r,
          init: a,
          push: s,
          unshift: c,
          finish: h,
          sort: l,
        };
      }
      function Zl() {
        let t = new WeakMap();
        function e(e, n) {
          let i;
          return (
            !1 === t.has(e)
              ? ((i = new Jl()), t.set(e, [i]))
              : n >= t.get(e).length
              ? ((i = new Jl()), t.get(e).push(i))
              : (i = t.get(e)[n]),
            i
          );
        }
        function n() {
          t = new WeakMap();
        }
        return { get: e, dispose: n };
      }
      function Kl() {
        const t = {};
        return {
          get: function (e) {
            if (void 0 !== t[e.id]) return t[e.id];
            let n;
            switch (e.type) {
              case "DirectionalLight":
                n = { direction: new wn(), color: new un() };
                break;
              case "SpotLight":
                n = {
                  position: new wn(),
                  direction: new wn(),
                  color: new un(),
                  distance: 0,
                  coneCos: 0,
                  penumbraCos: 0,
                  decay: 0,
                };
                break;
              case "PointLight":
                n = {
                  position: new wn(),
                  color: new un(),
                  distance: 0,
                  decay: 0,
                };
                break;
              case "HemisphereLight":
                n = {
                  direction: new wn(),
                  skyColor: new un(),
                  groundColor: new un(),
                };
                break;
              case "RectAreaLight":
                n = {
                  color: new un(),
                  position: new wn(),
                  halfWidth: new wn(),
                  halfHeight: new wn(),
                };
                break;
            }
            return (t[e.id] = n), n;
          },
        };
      }
      function $l() {
        const t = {};
        return {
          get: function (e) {
            if (void 0 !== t[e.id]) return t[e.id];
            let n;
            switch (e.type) {
              case "DirectionalLight":
                n = {
                  shadowBias: 0,
                  shadowNormalBias: 0,
                  shadowRadius: 1,
                  shadowMapSize: new $e(),
                };
                break;
              case "SpotLight":
                n = {
                  shadowBias: 0,
                  shadowNormalBias: 0,
                  shadowRadius: 1,
                  shadowMapSize: new $e(),
                };
                break;
              case "PointLight":
                n = {
                  shadowBias: 0,
                  shadowNormalBias: 0,
                  shadowRadius: 1,
                  shadowMapSize: new $e(),
                  shadowCameraNear: 1,
                  shadowCameraFar: 1e3,
                };
                break;
            }
            return (t[e.id] = n), n;
          },
        };
      }
      let Ql = 0;
      function th(t, e) {
        return (e.castShadow ? 1 : 0) - (t.castShadow ? 1 : 0);
      }
      function eh(t, e) {
        const n = new Kl(),
          i = $l(),
          r = {
            version: 0,
            hash: {
              directionalLength: -1,
              pointLength: -1,
              spotLength: -1,
              rectAreaLength: -1,
              hemiLength: -1,
              numDirectionalShadows: -1,
              numPointShadows: -1,
              numSpotShadows: -1,
            },
            ambient: [0, 0, 0],
            probe: [],
            directional: [],
            directionalShadow: [],
            directionalShadowMap: [],
            directionalShadowMatrix: [],
            spot: [],
            spotShadow: [],
            spotShadowMap: [],
            spotShadowMatrix: [],
            rectArea: [],
            rectAreaLTC1: null,
            rectAreaLTC2: null,
            point: [],
            pointShadow: [],
            pointShadowMap: [],
            pointShadowMatrix: [],
            hemi: [],
          };
        for (let h = 0; h < 9; h++) r.probe.push(new wn());
        const a = new wn(),
          o = new Qn(),
          s = new Qn();
        function c(a, o) {
          let s = 0,
            c = 0,
            l = 0;
          for (let t = 0; t < 9; t++) r.probe[t].set(0, 0, 0);
          let h = 0,
            u = 0,
            d = 0,
            p = 0,
            f = 0,
            m = 0,
            g = 0,
            v = 0;
          a.sort(th);
          const y = !0 !== o ? Math.PI : 1;
          for (let t = 0, e = a.length; t < e; t++) {
            const e = a[t],
              o = e.color,
              x = e.intensity,
              _ = e.distance,
              b = e.shadow && e.shadow.map ? e.shadow.map.texture : null;
            if (e.isAmbientLight)
              (s += o.r * x * y), (c += o.g * x * y), (l += o.b * x * y);
            else if (e.isLightProbe)
              for (let t = 0; t < 9; t++)
                r.probe[t].addScaledVector(e.sh.coefficients[t], x);
            else if (e.isDirectionalLight) {
              const t = n.get(e);
              if (
                (t.color.copy(e.color).multiplyScalar(e.intensity * y),
                e.castShadow)
              ) {
                const t = e.shadow,
                  n = i.get(e);
                (n.shadowBias = t.bias),
                  (n.shadowNormalBias = t.normalBias),
                  (n.shadowRadius = t.radius),
                  (n.shadowMapSize = t.mapSize),
                  (r.directionalShadow[h] = n),
                  (r.directionalShadowMap[h] = b),
                  (r.directionalShadowMatrix[h] = e.shadow.matrix),
                  m++;
              }
              (r.directional[h] = t), h++;
            } else if (e.isSpotLight) {
              const t = n.get(e);
              if (
                (t.position.setFromMatrixPosition(e.matrixWorld),
                t.color.copy(o).multiplyScalar(x * y),
                (t.distance = _),
                (t.coneCos = Math.cos(e.angle)),
                (t.penumbraCos = Math.cos(e.angle * (1 - e.penumbra))),
                (t.decay = e.decay),
                e.castShadow)
              ) {
                const t = e.shadow,
                  n = i.get(e);
                (n.shadowBias = t.bias),
                  (n.shadowNormalBias = t.normalBias),
                  (n.shadowRadius = t.radius),
                  (n.shadowMapSize = t.mapSize),
                  (r.spotShadow[d] = n),
                  (r.spotShadowMap[d] = b),
                  (r.spotShadowMatrix[d] = e.shadow.matrix),
                  v++;
              }
              (r.spot[d] = t), d++;
            } else if (e.isRectAreaLight) {
              const t = n.get(e);
              t.color.copy(o).multiplyScalar(x),
                t.halfWidth.set(0.5 * e.width, 0, 0),
                t.halfHeight.set(0, 0.5 * e.height, 0),
                (r.rectArea[p] = t),
                p++;
            } else if (e.isPointLight) {
              const t = n.get(e);
              if (
                (t.color.copy(e.color).multiplyScalar(e.intensity * y),
                (t.distance = e.distance),
                (t.decay = e.decay),
                e.castShadow)
              ) {
                const t = e.shadow,
                  n = i.get(e);
                (n.shadowBias = t.bias),
                  (n.shadowNormalBias = t.normalBias),
                  (n.shadowRadius = t.radius),
                  (n.shadowMapSize = t.mapSize),
                  (n.shadowCameraNear = t.camera.near),
                  (n.shadowCameraFar = t.camera.far),
                  (r.pointShadow[u] = n),
                  (r.pointShadowMap[u] = b),
                  (r.pointShadowMatrix[u] = e.shadow.matrix),
                  g++;
              }
              (r.point[u] = t), u++;
            } else if (e.isHemisphereLight) {
              const t = n.get(e);
              t.skyColor.copy(e.color).multiplyScalar(x * y),
                t.groundColor.copy(e.groundColor).multiplyScalar(x * y),
                (r.hemi[f] = t),
                f++;
            }
          }
          p > 0 &&
            (e.isWebGL2 || !0 === t.has("OES_texture_float_linear")
              ? ((r.rectAreaLTC1 = ys.LTC_FLOAT_1),
                (r.rectAreaLTC2 = ys.LTC_FLOAT_2))
              : !0 === t.has("OES_texture_half_float_linear")
              ? ((r.rectAreaLTC1 = ys.LTC_HALF_1),
                (r.rectAreaLTC2 = ys.LTC_HALF_2))
              : console.error(
                  "THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions."
                )),
            (r.ambient[0] = s),
            (r.ambient[1] = c),
            (r.ambient[2] = l);
          const x = r.hash;
          (x.directionalLength === h &&
            x.pointLength === u &&
            x.spotLength === d &&
            x.rectAreaLength === p &&
            x.hemiLength === f &&
            x.numDirectionalShadows === m &&
            x.numPointShadows === g &&
            x.numSpotShadows === v) ||
            ((r.directional.length = h),
            (r.spot.length = d),
            (r.rectArea.length = p),
            (r.point.length = u),
            (r.hemi.length = f),
            (r.directionalShadow.length = m),
            (r.directionalShadowMap.length = m),
            (r.pointShadow.length = g),
            (r.pointShadowMap.length = g),
            (r.spotShadow.length = v),
            (r.spotShadowMap.length = v),
            (r.directionalShadowMatrix.length = m),
            (r.pointShadowMatrix.length = g),
            (r.spotShadowMatrix.length = v),
            (x.directionalLength = h),
            (x.pointLength = u),
            (x.spotLength = d),
            (x.rectAreaLength = p),
            (x.hemiLength = f),
            (x.numDirectionalShadows = m),
            (x.numPointShadows = g),
            (x.numSpotShadows = v),
            (r.version = Ql++));
        }
        function l(t, e) {
          let n = 0,
            i = 0,
            c = 0,
            l = 0,
            h = 0;
          const u = e.matrixWorldInverse;
          for (let d = 0, p = t.length; d < p; d++) {
            const e = t[d];
            if (e.isDirectionalLight) {
              const t = r.directional[n];
              t.direction.setFromMatrixPosition(e.matrixWorld),
                a.setFromMatrixPosition(e.target.matrixWorld),
                t.direction.sub(a),
                t.direction.transformDirection(u),
                n++;
            } else if (e.isSpotLight) {
              const t = r.spot[c];
              t.position.setFromMatrixPosition(e.matrixWorld),
                t.position.applyMatrix4(u),
                t.direction.setFromMatrixPosition(e.matrixWorld),
                a.setFromMatrixPosition(e.target.matrixWorld),
                t.direction.sub(a),
                t.direction.transformDirection(u),
                c++;
            } else if (e.isRectAreaLight) {
              const t = r.rectArea[l];
              t.position.setFromMatrixPosition(e.matrixWorld),
                t.position.applyMatrix4(u),
                s.identity(),
                o.copy(e.matrixWorld),
                o.premultiply(u),
                s.extractRotation(o),
                t.halfWidth.set(0.5 * e.width, 0, 0),
                t.halfHeight.set(0, 0.5 * e.height, 0),
                t.halfWidth.applyMatrix4(s),
                t.halfHeight.applyMatrix4(s),
                l++;
            } else if (e.isPointLight) {
              const t = r.point[i];
              t.position.setFromMatrixPosition(e.matrixWorld),
                t.position.applyMatrix4(u),
                i++;
            } else if (e.isHemisphereLight) {
              const t = r.hemi[h];
              t.direction.setFromMatrixPosition(e.matrixWorld),
                t.direction.transformDirection(u),
                t.direction.normalize(),
                h++;
            }
          }
        }
        return { setup: c, setupView: l, state: r };
      }
      function nh(t, e) {
        const n = new eh(t, e),
          i = [],
          r = [];
        function a() {
          (i.length = 0), (r.length = 0);
        }
        function o(t) {
          i.push(t);
        }
        function s(t) {
          r.push(t);
        }
        function c(t) {
          n.setup(i, t);
        }
        function l(t) {
          n.setupView(i, t);
        }
        const h = { lightsArray: i, shadowsArray: r, lights: n };
        return {
          init: a,
          state: h,
          setupLights: c,
          setupLightsView: l,
          pushLight: o,
          pushShadow: s,
        };
      }
      function ih(t, e) {
        let n = new WeakMap();
        function i(i, r = 0) {
          let a;
          return (
            !1 === n.has(i)
              ? ((a = new nh(t, e)), n.set(i, [a]))
              : r >= n.get(i).length
              ? ((a = new nh(t, e)), n.get(i).push(a))
              : (a = n.get(i)[r]),
            a
          );
        }
        function r() {
          n = new WeakMap();
        }
        return { get: i, dispose: r };
      }
      class rh extends zi {
        constructor(t) {
          super(),
            (this.type = "MeshDepthMaterial"),
            (this.depthPacking = Pe),
            (this.map = null),
            (this.alphaMap = null),
            (this.displacementMap = null),
            (this.displacementScale = 1),
            (this.displacementBias = 0),
            (this.wireframe = !1),
            (this.wireframeLinewidth = 1),
            (this.fog = !1),
            this.setValues(t);
        }
        copy(t) {
          return (
            super.copy(t),
            (this.depthPacking = t.depthPacking),
            (this.map = t.map),
            (this.alphaMap = t.alphaMap),
            (this.displacementMap = t.displacementMap),
            (this.displacementScale = t.displacementScale),
            (this.displacementBias = t.displacementBias),
            (this.wireframe = t.wireframe),
            (this.wireframeLinewidth = t.wireframeLinewidth),
            this
          );
        }
      }
      rh.prototype.isMeshDepthMaterial = !0;
      class ah extends zi {
        constructor(t) {
          super(),
            (this.type = "MeshDistanceMaterial"),
            (this.referencePosition = new wn()),
            (this.nearDistance = 1),
            (this.farDistance = 1e3),
            (this.map = null),
            (this.alphaMap = null),
            (this.displacementMap = null),
            (this.displacementScale = 1),
            (this.displacementBias = 0),
            (this.fog = !1),
            this.setValues(t);
        }
        copy(t) {
          return (
            super.copy(t),
            this.referencePosition.copy(t.referencePosition),
            (this.nearDistance = t.nearDistance),
            (this.farDistance = t.farDistance),
            (this.map = t.map),
            (this.alphaMap = t.alphaMap),
            (this.displacementMap = t.displacementMap),
            (this.displacementScale = t.displacementScale),
            (this.displacementBias = t.displacementBias),
            this
          );
        }
      }
      ah.prototype.isMeshDistanceMaterial = !0;
      const oh = "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}",
        sh =
          "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tconst float samples = float( VSM_SAMPLES );\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i < samples; i ++ ) {\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}";
      function ch(t, e, n) {
        let i = new Hr();
        const r = new $e(),
          a = new $e(),
          o = new vn(),
          s = new rh({ depthPacking: De }),
          c = new ah(),
          l = {},
          h = n.maxTextureSize,
          u = { 0: v, 1: g, 2: y },
          d = new Tr({
            defines: { VSM_SAMPLES: 8 },
            uniforms: {
              shadow_pass: { value: null },
              resolution: { value: new $e() },
              radius: { value: 4 },
            },
            vertexShader: oh,
            fragmentShader: sh,
          }),
          f = d.clone();
        f.defines.HORIZONTAL_PASS = 1;
        const x = new Qi();
        x.setAttribute(
          "position",
          new ki(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3)
        );
        const b = new vr(x, d),
          w = this;
        function M(n, i) {
          const r = e.update(b);
          d.defines.VSM_SAMPLES !== n.blurSamples &&
            ((d.defines.VSM_SAMPLES = n.blurSamples),
            (f.defines.VSM_SAMPLES = n.blurSamples),
            (d.needsUpdate = !0),
            (f.needsUpdate = !0)),
            (d.uniforms.shadow_pass.value = n.map.texture),
            (d.uniforms.resolution.value = n.mapSize),
            (d.uniforms.radius.value = n.radius),
            t.setRenderTarget(n.mapPass),
            t.clear(),
            t.renderBufferDirect(i, null, r, d, b, null),
            (f.uniforms.shadow_pass.value = n.mapPass.texture),
            (f.uniforms.resolution.value = n.mapSize),
            (f.uniforms.radius.value = n.radius),
            t.setRenderTarget(n.map),
            t.clear(),
            t.renderBufferDirect(i, null, r, f, b, null);
        }
        function S(e, n, i, r, a, o, h) {
          let d = null;
          const p =
            !0 === r.isPointLight
              ? e.customDistanceMaterial
              : e.customDepthMaterial;
          if (
            ((d = void 0 !== p ? p : !0 === r.isPointLight ? c : s),
            (t.localClippingEnabled &&
              !0 === i.clipShadows &&
              0 !== i.clippingPlanes.length) ||
              (i.displacementMap && 0 !== i.displacementScale) ||
              (i.alphaMap && i.alphaTest > 0))
          ) {
            const t = d.uuid,
              e = i.uuid;
            let n = l[t];
            void 0 === n && ((n = {}), (l[t] = n));
            let r = n[e];
            void 0 === r && ((r = d.clone()), (n[e] = r)), (d = r);
          }
          return (
            (d.visible = i.visible),
            (d.wireframe = i.wireframe),
            (d.side =
              h === m
                ? null !== i.shadowSide
                  ? i.shadowSide
                  : i.side
                : null !== i.shadowSide
                ? i.shadowSide
                : u[i.side]),
            (d.alphaMap = i.alphaMap),
            (d.alphaTest = i.alphaTest),
            (d.clipShadows = i.clipShadows),
            (d.clippingPlanes = i.clippingPlanes),
            (d.clipIntersection = i.clipIntersection),
            (d.displacementMap = i.displacementMap),
            (d.displacementScale = i.displacementScale),
            (d.displacementBias = i.displacementBias),
            (d.wireframeLinewidth = i.wireframeLinewidth),
            (d.linewidth = i.linewidth),
            !0 === r.isPointLight &&
              !0 === d.isMeshDistanceMaterial &&
              (d.referencePosition.setFromMatrixPosition(r.matrixWorld),
              (d.nearDistance = a),
              (d.farDistance = o)),
            d
          );
        }
        function E(n, r, a, o, s) {
          if (!1 === n.visible) return;
          const c = n.layers.test(r.layers);
          if (
            c &&
            (n.isMesh || n.isLine || n.isPoints) &&
            (n.castShadow || (n.receiveShadow && s === m)) &&
            (!n.frustumCulled || i.intersectsObject(n))
          ) {
            n.modelViewMatrix.multiplyMatrices(
              a.matrixWorldInverse,
              n.matrixWorld
            );
            const i = e.update(n),
              r = n.material;
            if (Array.isArray(r)) {
              const e = i.groups;
              for (let c = 0, l = e.length; c < l; c++) {
                const l = e[c],
                  h = r[l.materialIndex];
                if (h && h.visible) {
                  const e = S(n, i, h, o, a.near, a.far, s);
                  t.renderBufferDirect(a, null, i, e, n, l);
                }
              }
            } else if (r.visible) {
              const e = S(n, i, r, o, a.near, a.far, s);
              t.renderBufferDirect(a, null, i, e, n, null);
            }
          }
          const l = n.children;
          for (let t = 0, e = l.length; t < e; t++) E(l[t], r, a, o, s);
        }
        (this.enabled = !1),
          (this.autoUpdate = !0),
          (this.needsUpdate = !1),
          (this.type = p),
          (this.render = function (e, n, s) {
            if (!1 === w.enabled) return;
            if (!1 === w.autoUpdate && !1 === w.needsUpdate) return;
            if (0 === e.length) return;
            const c = t.getRenderTarget(),
              l = t.getActiveCubeFace(),
              u = t.getActiveMipmapLevel(),
              d = t.state;
            d.setBlending(_),
              d.buffers.color.setClear(1, 1, 1, 1),
              d.buffers.depth.setTest(!0),
              d.setScissorTest(!1);
            for (let p = 0, f = e.length; p < f; p++) {
              const c = e[p],
                l = c.shadow;
              if (void 0 === l) {
                console.warn("THREE.WebGLShadowMap:", c, "has no shadow.");
                continue;
              }
              if (!1 === l.autoUpdate && !1 === l.needsUpdate) continue;
              r.copy(l.mapSize);
              const u = l.getFrameExtents();
              if (
                (r.multiply(u),
                a.copy(l.mapSize),
                (r.x > h || r.y > h) &&
                  (r.x > h &&
                    ((a.x = Math.floor(h / u.x)),
                    (r.x = a.x * u.x),
                    (l.mapSize.x = a.x)),
                  r.y > h &&
                    ((a.y = Math.floor(h / u.y)),
                    (r.y = a.y * u.y),
                    (l.mapSize.y = a.y))),
                null === l.map && !l.isPointLightShadow && this.type === m)
              ) {
                const t = { minFilter: xt, magFilter: xt, format: Nt };
                (l.map = new yn(r.x, r.y, t)),
                  (l.map.texture.name = c.name + ".shadowMap"),
                  (l.mapPass = new yn(r.x, r.y, t)),
                  l.camera.updateProjectionMatrix();
              }
              if (null === l.map) {
                const t = { minFilter: gt, magFilter: gt, format: Nt };
                (l.map = new yn(r.x, r.y, t)),
                  (l.map.texture.name = c.name + ".shadowMap"),
                  l.camera.updateProjectionMatrix();
              }
              t.setRenderTarget(l.map), t.clear();
              const f = l.getViewportCount();
              for (let t = 0; t < f; t++) {
                const e = l.getViewport(t);
                o.set(a.x * e.x, a.y * e.y, a.x * e.z, a.y * e.w),
                  d.viewport(o),
                  l.updateMatrices(c, t),
                  (i = l.getFrustum()),
                  E(n, s, l.camera, c, this.type);
              }
              l.isPointLightShadow || this.type !== m || M(l, s),
                (l.needsUpdate = !1);
            }
            (w.needsUpdate = !1), t.setRenderTarget(c, l, u);
          });
      }
      function lh(t, e, n) {
        const i = n.isWebGL2;
        function r() {
          let e = !1;
          const n = new vn();
          let i = null;
          const r = new vn(0, 0, 0, 0);
          return {
            setMask: function (n) {
              i === n || e || (t.colorMask(n, n, n, n), (i = n));
            },
            setLocked: function (t) {
              e = t;
            },
            setClear: function (e, i, a, o, s) {
              !0 === s && ((e *= o), (i *= o), (a *= o)),
                n.set(e, i, a, o),
                !1 === r.equals(n) && (t.clearColor(e, i, a, o), r.copy(n));
            },
            reset: function () {
              (e = !1), (i = null), r.set(-1, 0, 0, 0);
            },
          };
        }
        function a() {
          let e = !1,
            n = null,
            i = null,
            r = null;
          return {
            setTest: function (t) {
              t ? wt(2929) : Mt(2929);
            },
            setMask: function (i) {
              n === i || e || (t.depthMask(i), (n = i));
            },
            setFunc: function (e) {
              if (i !== e) {
                if (e)
                  switch (e) {
                    case G:
                      t.depthFunc(512);
                      break;
                    case V:
                      t.depthFunc(519);
                      break;
                    case W:
                      t.depthFunc(513);
                      break;
                    case j:
                      t.depthFunc(515);
                      break;
                    case q:
                      t.depthFunc(514);
                      break;
                    case X:
                      t.depthFunc(518);
                      break;
                    case Y:
                      t.depthFunc(516);
                      break;
                    case J:
                      t.depthFunc(517);
                      break;
                    default:
                      t.depthFunc(515);
                  }
                else t.depthFunc(515);
                i = e;
              }
            },
            setLocked: function (t) {
              e = t;
            },
            setClear: function (e) {
              r !== e && (t.clearDepth(e), (r = e));
            },
            reset: function () {
              (e = !1), (n = null), (i = null), (r = null);
            },
          };
        }
        function o() {
          let e = !1,
            n = null,
            i = null,
            r = null,
            a = null,
            o = null,
            s = null,
            c = null,
            l = null;
          return {
            setTest: function (t) {
              e || (t ? wt(2960) : Mt(2960));
            },
            setMask: function (i) {
              n === i || e || (t.stencilMask(i), (n = i));
            },
            setFunc: function (e, n, o) {
              (i === e && r === n && a === o) ||
                (t.stencilFunc(e, n, o), (i = e), (r = n), (a = o));
            },
            setOp: function (e, n, i) {
              (o === e && s === n && c === i) ||
                (t.stencilOp(e, n, i), (o = e), (s = n), (c = i));
            },
            setLocked: function (t) {
              e = t;
            },
            setClear: function (e) {
              l !== e && (t.clearStencil(e), (l = e));
            },
            reset: function () {
              (e = !1),
                (n = null),
                (i = null),
                (r = null),
                (a = null),
                (o = null),
                (s = null),
                (c = null),
                (l = null);
            },
          };
        }
        const s = new r(),
          c = new a(),
          l = new o();
        let p = {},
          f = {},
          m = new WeakMap(),
          g = [],
          x = null,
          Z = !1,
          K = null,
          $ = null,
          Q = null,
          tt = null,
          et = null,
          nt = null,
          it = null,
          rt = !1,
          at = null,
          ot = null,
          st = null,
          ct = null,
          lt = null;
        const ht = t.getParameter(35661);
        let ut = !1,
          dt = 0;
        const pt = t.getParameter(7938);
        -1 !== pt.indexOf("WebGL")
          ? ((dt = parseFloat(/^WebGL (\d)/.exec(pt)[1])), (ut = dt >= 1))
          : -1 !== pt.indexOf("OpenGL ES") &&
            ((dt = parseFloat(/^OpenGL ES (\d)/.exec(pt)[1])), (ut = dt >= 2));
        let ft = null,
          mt = {};
        const gt = t.getParameter(3088),
          vt = t.getParameter(2978),
          yt = new vn().fromArray(gt),
          xt = new vn().fromArray(vt);
        function _t(e, n, i) {
          const r = new Uint8Array(4),
            a = t.createTexture();
          t.bindTexture(e, a),
            t.texParameteri(e, 10241, 9728),
            t.texParameteri(e, 10240, 9728);
          for (let o = 0; o < i; o++)
            t.texImage2D(n + o, 0, 6408, 1, 1, 0, 6408, 5121, r);
          return a;
        }
        const bt = {};
        function wt(e) {
          !0 !== p[e] && (t.enable(e), (p[e] = !0));
        }
        function Mt(e) {
          !1 !== p[e] && (t.disable(e), (p[e] = !1));
        }
        function St(e, n) {
          return (
            f[e] !== n &&
            (t.bindFramebuffer(e, n),
            (f[e] = n),
            i && (36009 === e && (f[36160] = n), 36160 === e && (f[36009] = n)),
            !0)
          );
        }
        function Et(i, r) {
          let a = g,
            o = !1;
          if (i)
            if (
              ((a = m.get(r)),
              void 0 === a && ((a = []), m.set(r, a)),
              i.isWebGLMultipleRenderTargets)
            ) {
              const t = i.texture;
              if (a.length !== t.length || 36064 !== a[0]) {
                for (let e = 0, n = t.length; e < n; e++) a[e] = 36064 + e;
                (a.length = t.length), (o = !0);
              }
            } else 36064 !== a[0] && ((a[0] = 36064), (o = !0));
          else 1029 !== a[0] && ((a[0] = 1029), (o = !0));
          o &&
            (n.isWebGL2
              ? t.drawBuffers(a)
              : e.get("WEBGL_draw_buffers").drawBuffersWEBGL(a));
        }
        function Tt(e) {
          return x !== e && (t.useProgram(e), (x = e), !0);
        }
        (bt[3553] = _t(3553, 3553, 1)),
          (bt[34067] = _t(34067, 34069, 6)),
          s.setClear(0, 0, 0, 1),
          c.setClear(1),
          l.setClear(0),
          wt(2929),
          c.setFunc(j),
          Pt(!1),
          Dt(u),
          wt(2884),
          Rt(_);
        const At = { [T]: 32774, [A]: 32778, [C]: 32779 };
        if (i) (At[R] = 32775), (At[L] = 32776);
        else {
          const t = e.get("EXT_blend_minmax");
          null !== t && ((At[R] = t.MIN_EXT), (At[L] = t.MAX_EXT));
        }
        const Ct = {
          [P]: 0,
          [D]: 1,
          [I]: 768,
          [N]: 770,
          [k]: 776,
          [F]: 774,
          [z]: 772,
          [O]: 769,
          [B]: 771,
          [H]: 775,
          [U]: 773,
        };
        function Rt(e, n, i, r, a, o, s, c) {
          if (e !== _) {
            if ((!1 === Z && (wt(3042), (Z = !0)), e === E))
              (a = a || n),
                (o = o || i),
                (s = s || r),
                (n === $ && a === et) ||
                  (t.blendEquationSeparate(At[n], At[a]), ($ = n), (et = a)),
                (i === Q && r === tt && o === nt && s === it) ||
                  (t.blendFuncSeparate(Ct[i], Ct[r], Ct[o], Ct[s]),
                  (Q = i),
                  (tt = r),
                  (nt = o),
                  (it = s)),
                (K = e),
                (rt = null);
            else if (e !== K || c !== rt) {
              if (
                (($ === T && et === T) ||
                  (t.blendEquation(32774), ($ = T), (et = T)),
                c)
              )
                switch (e) {
                  case b:
                    t.blendFuncSeparate(1, 771, 1, 771);
                    break;
                  case w:
                    t.blendFunc(1, 1);
                    break;
                  case M:
                    t.blendFuncSeparate(0, 769, 0, 1);
                    break;
                  case S:
                    t.blendFuncSeparate(0, 768, 0, 770);
                    break;
                  default:
                    console.error("THREE.WebGLState: Invalid blending: ", e);
                    break;
                }
              else
                switch (e) {
                  case b:
                    t.blendFuncSeparate(770, 771, 1, 771);
                    break;
                  case w:
                    t.blendFunc(770, 1);
                    break;
                  case M:
                    t.blendFuncSeparate(0, 769, 0, 1);
                    break;
                  case S:
                    t.blendFunc(0, 768);
                    break;
                  default:
                    console.error("THREE.WebGLState: Invalid blending: ", e);
                    break;
                }
              (Q = null),
                (tt = null),
                (nt = null),
                (it = null),
                (K = e),
                (rt = c);
            }
          } else !0 === Z && (Mt(3042), (Z = !1));
        }
        function Lt(t, e) {
          t.side === y ? Mt(2884) : wt(2884);
          let n = t.side === v;
          e && (n = !n),
            Pt(n),
            t.blending === b && !1 === t.transparent
              ? Rt(_)
              : Rt(
                  t.blending,
                  t.blendEquation,
                  t.blendSrc,
                  t.blendDst,
                  t.blendEquationAlpha,
                  t.blendSrcAlpha,
                  t.blendDstAlpha,
                  t.premultipliedAlpha
                ),
            c.setFunc(t.depthFunc),
            c.setTest(t.depthTest),
            c.setMask(t.depthWrite),
            s.setMask(t.colorWrite);
          const i = t.stencilWrite;
          l.setTest(i),
            i &&
              (l.setMask(t.stencilWriteMask),
              l.setFunc(t.stencilFunc, t.stencilRef, t.stencilFuncMask),
              l.setOp(t.stencilFail, t.stencilZFail, t.stencilZPass)),
            Ot(t.polygonOffset, t.polygonOffsetFactor, t.polygonOffsetUnits),
            !0 === t.alphaToCoverage ? wt(32926) : Mt(32926);
        }
        function Pt(e) {
          at !== e && (e ? t.frontFace(2304) : t.frontFace(2305), (at = e));
        }
        function Dt(e) {
          e !== h
            ? (wt(2884),
              e !== ot &&
                (e === u
                  ? t.cullFace(1029)
                  : e === d
                  ? t.cullFace(1028)
                  : t.cullFace(1032)))
            : Mt(2884),
            (ot = e);
        }
        function It(e) {
          e !== st && (ut && t.lineWidth(e), (st = e));
        }
        function Ot(e, n, i) {
          e
            ? (wt(32823),
              (ct === n && lt === i) ||
                (t.polygonOffset(n, i), (ct = n), (lt = i)))
            : Mt(32823);
        }
        function Nt(t) {
          t ? wt(3089) : Mt(3089);
        }
        function Bt(e) {
          void 0 === e && (e = 33984 + ht - 1),
            ft !== e && (t.activeTexture(e), (ft = e));
        }
        function zt(e, n) {
          null === ft && Bt();
          let i = mt[ft];
          void 0 === i &&
            ((i = { type: void 0, texture: void 0 }), (mt[ft] = i)),
            (i.type === e && i.texture === n) ||
              (t.bindTexture(e, n || bt[e]), (i.type = e), (i.texture = n));
        }
        function Ut() {
          const e = mt[ft];
          void 0 !== e &&
            void 0 !== e.type &&
            (t.bindTexture(e.type, null),
            (e.type = void 0),
            (e.texture = void 0));
        }
        function Ft() {
          try {
            t.compressedTexImage2D.apply(t, arguments);
          } catch (e) {
            console.error("THREE.WebGLState:", e);
          }
        }
        function Ht() {
          try {
            t.texSubImage2D.apply(t, arguments);
          } catch (e) {
            console.error("THREE.WebGLState:", e);
          }
        }
        function kt() {
          try {
            t.texSubImage3D.apply(t, arguments);
          } catch (e) {
            console.error("THREE.WebGLState:", e);
          }
        }
        function Gt() {
          try {
            t.compressedTexSubImage2D.apply(t, arguments);
          } catch (e) {
            console.error("THREE.WebGLState:", e);
          }
        }
        function Vt() {
          try {
            t.texStorage2D.apply(t, arguments);
          } catch (e) {
            console.error("THREE.WebGLState:", e);
          }
        }
        function Wt() {
          try {
            t.texStorage3D.apply(t, arguments);
          } catch (e) {
            console.error("THREE.WebGLState:", e);
          }
        }
        function jt() {
          try {
            t.texImage2D.apply(t, arguments);
          } catch (e) {
            console.error("THREE.WebGLState:", e);
          }
        }
        function qt() {
          try {
            t.texImage3D.apply(t, arguments);
          } catch (e) {
            console.error("THREE.WebGLState:", e);
          }
        }
        function Xt(e) {
          !1 === yt.equals(e) && (t.scissor(e.x, e.y, e.z, e.w), yt.copy(e));
        }
        function Yt(e) {
          !1 === xt.equals(e) && (t.viewport(e.x, e.y, e.z, e.w), xt.copy(e));
        }
        function Jt() {
          t.disable(3042),
            t.disable(2884),
            t.disable(2929),
            t.disable(32823),
            t.disable(3089),
            t.disable(2960),
            t.disable(32926),
            t.blendEquation(32774),
            t.blendFunc(1, 0),
            t.blendFuncSeparate(1, 0, 1, 0),
            t.colorMask(!0, !0, !0, !0),
            t.clearColor(0, 0, 0, 0),
            t.depthMask(!0),
            t.depthFunc(513),
            t.clearDepth(1),
            t.stencilMask(4294967295),
            t.stencilFunc(519, 0, 4294967295),
            t.stencilOp(7680, 7680, 7680),
            t.clearStencil(0),
            t.cullFace(1029),
            t.frontFace(2305),
            t.polygonOffset(0, 0),
            t.activeTexture(33984),
            t.bindFramebuffer(36160, null),
            !0 === i &&
              (t.bindFramebuffer(36009, null), t.bindFramebuffer(36008, null)),
            t.useProgram(null),
            t.lineWidth(1),
            t.scissor(0, 0, t.canvas.width, t.canvas.height),
            t.viewport(0, 0, t.canvas.width, t.canvas.height),
            (p = {}),
            (ft = null),
            (mt = {}),
            (f = {}),
            (m = new WeakMap()),
            (g = []),
            (x = null),
            (Z = !1),
            (K = null),
            ($ = null),
            (Q = null),
            (tt = null),
            (et = null),
            (nt = null),
            (it = null),
            (rt = !1),
            (at = null),
            (ot = null),
            (st = null),
            (ct = null),
            (lt = null),
            yt.set(0, 0, t.canvas.width, t.canvas.height),
            xt.set(0, 0, t.canvas.width, t.canvas.height),
            s.reset(),
            c.reset(),
            l.reset();
        }
        return {
          buffers: { color: s, depth: c, stencil: l },
          enable: wt,
          disable: Mt,
          bindFramebuffer: St,
          drawBuffers: Et,
          useProgram: Tt,
          setBlending: Rt,
          setMaterial: Lt,
          setFlipSided: Pt,
          setCullFace: Dt,
          setLineWidth: It,
          setPolygonOffset: Ot,
          setScissorTest: Nt,
          activeTexture: Bt,
          bindTexture: zt,
          unbindTexture: Ut,
          compressedTexImage2D: Ft,
          texImage2D: jt,
          texImage3D: qt,
          texStorage2D: Vt,
          texStorage3D: Wt,
          texSubImage2D: Ht,
          texSubImage3D: kt,
          compressedTexSubImage2D: Gt,
          scissor: Xt,
          viewport: Yt,
          reset: Jt,
        };
      }
      function hh(t, e, n, i, r, a, o) {
        const s = r.isWebGL2,
          c = r.maxTextures,
          l = r.maxCubemapSize,
          h = r.maxTextureSize,
          u = r.maxSamples,
          d = e.has("WEBGL_multisampled_render_to_texture"),
          p = d ? e.get("WEBGL_multisampled_render_to_texture") : void 0,
          f = new WeakMap();
        let m,
          g = !1;
        try {
          g =
            "undefined" !== typeof OffscreenCanvas &&
            null !== new OffscreenCanvas(1, 1).getContext("2d");
        } catch (rt) {}
        function v(t, e) {
          return g ? new OffscreenCanvas(t, e) : rn("canvas");
        }
        function y(t, e, n, i) {
          let r = 1;
          if (
            ((t.width > i || t.height > i) &&
              (r = i / Math.max(t.width, t.height)),
            r < 1 || !0 === e)
          ) {
            if (
              ("undefined" !== typeof HTMLImageElement &&
                t instanceof HTMLImageElement) ||
              ("undefined" !== typeof HTMLCanvasElement &&
                t instanceof HTMLCanvasElement) ||
              ("undefined" !== typeof ImageBitmap && t instanceof ImageBitmap)
            ) {
              const i = e ? Ke : Math.floor,
                a = i(r * t.width),
                o = i(r * t.height);
              void 0 === m && (m = v(a, o));
              const s = n ? v(a, o) : m;
              (s.width = a), (s.height = o);
              const c = s.getContext("2d");
              return (
                c.drawImage(t, 0, 0, a, o),
                console.warn(
                  "THREE.WebGLRenderer: Texture has been resized from (" +
                    t.width +
                    "x" +
                    t.height +
                    ") to (" +
                    a +
                    "x" +
                    o +
                    ")."
                ),
                s
              );
            }
            return (
              "data" in t &&
                console.warn(
                  "THREE.WebGLRenderer: Image in DataTexture is too big (" +
                    t.width +
                    "x" +
                    t.height +
                    ")."
                ),
              t
            );
          }
          return t;
        }
        function x(t) {
          return Je(t.width) && Je(t.height);
        }
        function _(t) {
          return (
            !s &&
            (t.wrapS !== ft ||
              t.wrapT !== ft ||
              (t.minFilter !== gt && t.minFilter !== xt))
          );
        }
        function b(t, e) {
          return (
            t.generateMipmaps && e && t.minFilter !== gt && t.minFilter !== xt
          );
        }
        function w(e) {
          t.generateMipmap(e);
        }
        function M(n, i, r, a, o = !1) {
          if (!1 === s) return i;
          if (null !== n) {
            if (void 0 !== t[n]) return t[n];
            console.warn(
              "THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" +
                n +
                "'"
            );
          }
          let c = i;
          return (
            6403 === i &&
              (5126 === r && (c = 33326),
              5131 === r && (c = 33325),
              5121 === r && (c = 33321)),
            33319 === i &&
              (5126 === r && (c = 33328),
              5131 === r && (c = 33327),
              5121 === r && (c = 33323)),
            6408 === i &&
              (5126 === r && (c = 34836),
              5131 === r && (c = 34842),
              5121 === r && (c = a === Le && !1 === o ? 35907 : 32856),
              32819 === r && (c = 32854),
              32820 === r && (c = 32855)),
            (33325 !== c &&
              33326 !== c &&
              33327 !== c &&
              33328 !== c &&
              34842 !== c &&
              34836 !== c) ||
              e.get("EXT_color_buffer_float"),
            c
          );
        }
        function S(t, e, n) {
          return !0 === b(t, n) ||
            (t.isFramebufferTexture && t.minFilter !== gt && t.minFilter !== xt)
            ? Math.log2(Math.max(e.width, e.height)) + 1
            : void 0 !== t.mipmaps && t.mipmaps.length > 0
            ? t.mipmaps.length
            : t.isCompressedTexture && Array.isArray(t.image)
            ? e.mipmaps.length
            : 1;
        }
        function E(t) {
          return t === gt || t === vt || t === yt ? 9728 : 9729;
        }
        function T(t) {
          const e = t.target;
          e.removeEventListener("dispose", T),
            C(e),
            e.isVideoTexture && f.delete(e),
            o.memory.textures--;
        }
        function A(t) {
          const e = t.target;
          e.removeEventListener("dispose", A), R(e);
        }
        function C(e) {
          const n = i.get(e);
          void 0 !== n.__webglInit &&
            (t.deleteTexture(n.__webglTexture), i.remove(e));
        }
        function R(e) {
          const n = e.texture,
            r = i.get(e),
            a = i.get(n);
          if (e) {
            if (
              (void 0 !== a.__webglTexture &&
                (t.deleteTexture(a.__webglTexture), o.memory.textures--),
              e.depthTexture && e.depthTexture.dispose(),
              e.isWebGLCubeRenderTarget)
            )
              for (let e = 0; e < 6; e++)
                t.deleteFramebuffer(r.__webglFramebuffer[e]),
                  r.__webglDepthbuffer &&
                    t.deleteRenderbuffer(r.__webglDepthbuffer[e]);
            else
              t.deleteFramebuffer(r.__webglFramebuffer),
                r.__webglDepthbuffer &&
                  t.deleteRenderbuffer(r.__webglDepthbuffer),
                r.__webglMultisampledFramebuffer &&
                  t.deleteFramebuffer(r.__webglMultisampledFramebuffer),
                r.__webglColorRenderbuffer &&
                  t.deleteRenderbuffer(r.__webglColorRenderbuffer),
                r.__webglDepthRenderbuffer &&
                  t.deleteRenderbuffer(r.__webglDepthRenderbuffer);
            if (e.isWebGLMultipleRenderTargets)
              for (let e = 0, r = n.length; e < r; e++) {
                const r = i.get(n[e]);
                r.__webglTexture &&
                  (t.deleteTexture(r.__webglTexture), o.memory.textures--),
                  i.remove(n[e]);
              }
            i.remove(n), i.remove(e);
          }
        }
        let L = 0;
        function P() {
          L = 0;
        }
        function D() {
          const t = L;
          return (
            t >= c &&
              console.warn(
                "THREE.WebGLTextures: Trying to use " +
                  t +
                  " texture units while this GPU supports only " +
                  c
              ),
            (L += 1),
            t
          );
        }
        function I(t, e) {
          const r = i.get(t);
          if (
            (t.isVideoTexture && $(t),
            t.version > 0 && r.__version !== t.version)
          ) {
            const n = t.image;
            if (void 0 === n)
              console.warn(
                "THREE.WebGLRenderer: Texture marked for update but image is undefined"
              );
            else {
              if (!1 !== n.complete) return void k(r, t, e);
              console.warn(
                "THREE.WebGLRenderer: Texture marked for update but image is incomplete"
              );
            }
          }
          n.activeTexture(33984 + e), n.bindTexture(3553, r.__webglTexture);
        }
        function O(t, e) {
          const r = i.get(t);
          t.version > 0 && r.__version !== t.version
            ? k(r, t, e)
            : (n.activeTexture(33984 + e),
              n.bindTexture(35866, r.__webglTexture));
        }
        function N(t, e) {
          const r = i.get(t);
          t.version > 0 && r.__version !== t.version
            ? k(r, t, e)
            : (n.activeTexture(33984 + e),
              n.bindTexture(32879, r.__webglTexture));
        }
        function B(t, e) {
          const r = i.get(t);
          t.version > 0 && r.__version !== t.version
            ? G(r, t, e)
            : (n.activeTexture(33984 + e),
              n.bindTexture(34067, r.__webglTexture));
        }
        const z = { [pt]: 10497, [ft]: 33071, [mt]: 33648 },
          U = {
            [gt]: 9728,
            [vt]: 9984,
            [yt]: 9986,
            [xt]: 9729,
            [_t]: 9985,
            [bt]: 9987,
          };
        function F(n, a, o) {
          if (
            (o
              ? (t.texParameteri(n, 10242, z[a.wrapS]),
                t.texParameteri(n, 10243, z[a.wrapT]),
                (32879 !== n && 35866 !== n) ||
                  t.texParameteri(n, 32882, z[a.wrapR]),
                t.texParameteri(n, 10240, U[a.magFilter]),
                t.texParameteri(n, 10241, U[a.minFilter]))
              : (t.texParameteri(n, 10242, 33071),
                t.texParameteri(n, 10243, 33071),
                (32879 !== n && 35866 !== n) ||
                  t.texParameteri(n, 32882, 33071),
                (a.wrapS === ft && a.wrapT === ft) ||
                  console.warn(
                    "THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."
                  ),
                t.texParameteri(n, 10240, E(a.magFilter)),
                t.texParameteri(n, 10241, E(a.minFilter)),
                a.minFilter !== gt &&
                  a.minFilter !== xt &&
                  console.warn(
                    "THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter."
                  )),
            !0 === e.has("EXT_texture_filter_anisotropic"))
          ) {
            const o = e.get("EXT_texture_filter_anisotropic");
            if (a.type === Ct && !1 === e.has("OES_texture_float_linear"))
              return;
            if (
              !1 === s &&
              a.type === Rt &&
              !1 === e.has("OES_texture_half_float_linear")
            )
              return;
            (a.anisotropy > 1 || i.get(a).__currentAnisotropy) &&
              (t.texParameterf(
                n,
                o.TEXTURE_MAX_ANISOTROPY_EXT,
                Math.min(a.anisotropy, r.getMaxAnisotropy())
              ),
              (i.get(a).__currentAnisotropy = a.anisotropy));
          }
        }
        function H(e, n) {
          void 0 === e.__webglInit &&
            ((e.__webglInit = !0),
            n.addEventListener("dispose", T),
            (e.__webglTexture = t.createTexture()),
            o.memory.textures++);
        }
        function k(e, i, r) {
          let o = 3553;
          i.isDataTexture2DArray && (o = 35866),
            i.isDataTexture3D && (o = 32879),
            H(e, i),
            n.activeTexture(33984 + r),
            n.bindTexture(o, e.__webglTexture),
            t.pixelStorei(37440, i.flipY),
            t.pixelStorei(37441, i.premultiplyAlpha),
            t.pixelStorei(3317, i.unpackAlignment),
            t.pixelStorei(37443, 0);
          const c = _(i) && !1 === x(i.image);
          let l = y(i.image, c, !1, h);
          l = Q(i, l);
          const u = x(l) || s,
            d = a.convert(i.format, i.encoding);
          let p,
            f = a.convert(i.type),
            m = M(i.internalFormat, d, f, i.encoding, i.isVideoTexture);
          F(o, i, u);
          const g = i.mipmaps,
            v = s && !0 !== i.isVideoTexture,
            E = void 0 === e.__version,
            T = S(i, l, u);
          if (i.isDepthTexture)
            (m = 6402),
              s
                ? (m =
                    i.type === Ct
                      ? 36012
                      : i.type === At
                      ? 33190
                      : i.type === Dt
                      ? 35056
                      : 33189)
                : i.type === Ct &&
                  console.error(
                    "WebGLRenderer: Floating point depth texture requires WebGL2."
                  ),
              i.format === Ut &&
                6402 === m &&
                i.type !== Et &&
                i.type !== At &&
                (console.warn(
                  "THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."
                ),
                (i.type = Et),
                (f = a.convert(i.type))),
              i.format === Ft &&
                6402 === m &&
                ((m = 34041),
                i.type !== Dt &&
                  (console.warn(
                    "THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."
                  ),
                  (i.type = Dt),
                  (f = a.convert(i.type)))),
              v && E
                ? n.texStorage2D(3553, 1, m, l.width, l.height)
                : n.texImage2D(3553, 0, m, l.width, l.height, 0, d, f, null);
          else if (i.isDataTexture)
            if (g.length > 0 && u) {
              v && E && n.texStorage2D(3553, T, m, g[0].width, g[0].height);
              for (let t = 0, e = g.length; t < e; t++)
                (p = g[t]),
                  v
                    ? n.texSubImage2D(
                        3553,
                        0,
                        0,
                        0,
                        p.width,
                        p.height,
                        d,
                        f,
                        p.data
                      )
                    : n.texImage2D(
                        3553,
                        t,
                        m,
                        p.width,
                        p.height,
                        0,
                        d,
                        f,
                        p.data
                      );
              i.generateMipmaps = !1;
            } else
              v
                ? (E && n.texStorage2D(3553, T, m, l.width, l.height),
                  n.texSubImage2D(
                    3553,
                    0,
                    0,
                    0,
                    l.width,
                    l.height,
                    d,
                    f,
                    l.data
                  ))
                : n.texImage2D(3553, 0, m, l.width, l.height, 0, d, f, l.data);
          else if (i.isCompressedTexture) {
            v && E && n.texStorage2D(3553, T, m, g[0].width, g[0].height);
            for (let t = 0, e = g.length; t < e; t++)
              (p = g[t]),
                i.format !== Nt
                  ? null !== d
                    ? v
                      ? n.compressedTexSubImage2D(
                          3553,
                          t,
                          0,
                          0,
                          p.width,
                          p.height,
                          d,
                          p.data
                        )
                      : n.compressedTexImage2D(
                          3553,
                          t,
                          m,
                          p.width,
                          p.height,
                          0,
                          p.data
                        )
                    : console.warn(
                        "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"
                      )
                  : v
                  ? n.texSubImage2D(
                      3553,
                      t,
                      0,
                      0,
                      p.width,
                      p.height,
                      d,
                      f,
                      p.data
                    )
                  : n.texImage2D(
                      3553,
                      t,
                      m,
                      p.width,
                      p.height,
                      0,
                      d,
                      f,
                      p.data
                    );
          } else if (i.isDataTexture2DArray)
            v
              ? (E && n.texStorage3D(35866, T, m, l.width, l.height, l.depth),
                n.texSubImage3D(
                  35866,
                  0,
                  0,
                  0,
                  0,
                  l.width,
                  l.height,
                  l.depth,
                  d,
                  f,
                  l.data
                ))
              : n.texImage3D(
                  35866,
                  0,
                  m,
                  l.width,
                  l.height,
                  l.depth,
                  0,
                  d,
                  f,
                  l.data
                );
          else if (i.isDataTexture3D)
            v
              ? (E && n.texStorage3D(32879, T, m, l.width, l.height, l.depth),
                n.texSubImage3D(
                  32879,
                  0,
                  0,
                  0,
                  0,
                  l.width,
                  l.height,
                  l.depth,
                  d,
                  f,
                  l.data
                ))
              : n.texImage3D(
                  32879,
                  0,
                  m,
                  l.width,
                  l.height,
                  l.depth,
                  0,
                  d,
                  f,
                  l.data
                );
          else if (i.isFramebufferTexture)
            v && E
              ? n.texStorage2D(3553, T, m, l.width, l.height)
              : n.texImage2D(3553, 0, m, l.width, l.height, 0, d, f, null);
          else if (g.length > 0 && u) {
            v && E && n.texStorage2D(3553, T, m, g[0].width, g[0].height);
            for (let t = 0, e = g.length; t < e; t++)
              (p = g[t]),
                v
                  ? n.texSubImage2D(3553, t, 0, 0, d, f, p)
                  : n.texImage2D(3553, t, m, d, f, p);
            i.generateMipmaps = !1;
          } else
            v
              ? (E && n.texStorage2D(3553, T, m, l.width, l.height),
                n.texSubImage2D(3553, 0, 0, 0, d, f, l))
              : n.texImage2D(3553, 0, m, d, f, l);
          b(i, u) && w(o),
            (e.__version = i.version),
            i.onUpdate && i.onUpdate(i);
        }
        function G(e, i, r) {
          if (6 !== i.image.length) return;
          H(e, i),
            n.activeTexture(33984 + r),
            n.bindTexture(34067, e.__webglTexture),
            t.pixelStorei(37440, i.flipY),
            t.pixelStorei(37441, i.premultiplyAlpha),
            t.pixelStorei(3317, i.unpackAlignment),
            t.pixelStorei(37443, 0);
          const o =
              i && (i.isCompressedTexture || i.image[0].isCompressedTexture),
            c = i.image[0] && i.image[0].isDataTexture,
            h = [];
          for (let t = 0; t < 6; t++)
            (h[t] =
              o || c
                ? c
                  ? i.image[t].image
                  : i.image[t]
                : y(i.image[t], !1, !0, l)),
              (h[t] = Q(i, h[t]));
          const u = h[0],
            d = x(u) || s,
            p = a.convert(i.format, i.encoding),
            f = a.convert(i.type),
            m = M(i.internalFormat, p, f, i.encoding),
            g = s && !0 !== i.isVideoTexture,
            v = void 0 === e.__version;
          let _,
            E = S(i, u, d);
          if ((F(34067, i, d), o)) {
            g && v && n.texStorage2D(34067, E, m, u.width, u.height);
            for (let t = 0; t < 6; t++) {
              _ = h[t].mipmaps;
              for (let e = 0; e < _.length; e++) {
                const r = _[e];
                i.format !== Nt
                  ? null !== p
                    ? g
                      ? n.compressedTexSubImage2D(
                          34069 + t,
                          e,
                          0,
                          0,
                          r.width,
                          r.height,
                          p,
                          r.data
                        )
                      : n.compressedTexImage2D(
                          34069 + t,
                          e,
                          m,
                          r.width,
                          r.height,
                          0,
                          r.data
                        )
                    : console.warn(
                        "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"
                      )
                  : g
                  ? n.texSubImage2D(
                      34069 + t,
                      e,
                      0,
                      0,
                      r.width,
                      r.height,
                      p,
                      f,
                      r.data
                    )
                  : n.texImage2D(
                      34069 + t,
                      e,
                      m,
                      r.width,
                      r.height,
                      0,
                      p,
                      f,
                      r.data
                    );
              }
            }
          } else {
            (_ = i.mipmaps),
              g &&
                v &&
                (_.length > 0 && E++,
                n.texStorage2D(34067, E, m, h[0].width, h[0].height));
            for (let t = 0; t < 6; t++)
              if (c) {
                g
                  ? n.texSubImage2D(
                      34069 + t,
                      0,
                      0,
                      0,
                      h[t].width,
                      h[t].height,
                      p,
                      f,
                      h[t].data
                    )
                  : n.texImage2D(
                      34069 + t,
                      0,
                      m,
                      h[t].width,
                      h[t].height,
                      0,
                      p,
                      f,
                      h[t].data
                    );
                for (let e = 0; e < _.length; e++) {
                  const i = _[e],
                    r = i.image[t].image;
                  g
                    ? n.texSubImage2D(
                        34069 + t,
                        e + 1,
                        0,
                        0,
                        r.width,
                        r.height,
                        p,
                        f,
                        r.data
                      )
                    : n.texImage2D(
                        34069 + t,
                        e + 1,
                        m,
                        r.width,
                        r.height,
                        0,
                        p,
                        f,
                        r.data
                      );
                }
              } else {
                g
                  ? n.texSubImage2D(34069 + t, 0, 0, 0, p, f, h[t])
                  : n.texImage2D(34069 + t, 0, m, p, f, h[t]);
                for (let e = 0; e < _.length; e++) {
                  const i = _[e];
                  g
                    ? n.texSubImage2D(34069 + t, e + 1, 0, 0, p, f, i.image[t])
                    : n.texImage2D(34069 + t, e + 1, m, p, f, i.image[t]);
                }
              }
          }
          b(i, d) && w(34067),
            (e.__version = i.version),
            i.onUpdate && i.onUpdate(i);
        }
        function V(e, r, o, s, c) {
          const l = a.convert(o.format, o.encoding),
            h = a.convert(o.type),
            u = M(o.internalFormat, l, h, o.encoding),
            d = i.get(r);
          d.__hasExternalTextures ||
            (32879 === c || 35866 === c
              ? n.texImage3D(c, 0, u, r.width, r.height, r.depth, 0, l, h, null)
              : n.texImage2D(c, 0, u, r.width, r.height, 0, l, h, null)),
            n.bindFramebuffer(36160, e),
            r.useRenderToTexture
              ? p.framebufferTexture2DMultisampleEXT(
                  36160,
                  s,
                  c,
                  i.get(o).__webglTexture,
                  0,
                  K(r)
                )
              : t.framebufferTexture2D(36160, s, c, i.get(o).__webglTexture, 0),
            n.bindFramebuffer(36160, null);
        }
        function W(e, n, i) {
          if (
            (t.bindRenderbuffer(36161, e), n.depthBuffer && !n.stencilBuffer)
          ) {
            let r = 33189;
            if (i || n.useRenderToTexture) {
              const e = n.depthTexture;
              e &&
                e.isDepthTexture &&
                (e.type === Ct ? (r = 36012) : e.type === At && (r = 33190));
              const i = K(n);
              n.useRenderToTexture
                ? p.renderbufferStorageMultisampleEXT(
                    36161,
                    i,
                    r,
                    n.width,
                    n.height
                  )
                : t.renderbufferStorageMultisample(
                    36161,
                    i,
                    r,
                    n.width,
                    n.height
                  );
            } else t.renderbufferStorage(36161, r, n.width, n.height);
            t.framebufferRenderbuffer(36160, 36096, 36161, e);
          } else if (n.depthBuffer && n.stencilBuffer) {
            const r = K(n);
            i && n.useRenderbuffer
              ? t.renderbufferStorageMultisample(
                  36161,
                  r,
                  35056,
                  n.width,
                  n.height
                )
              : n.useRenderToTexture
              ? p.renderbufferStorageMultisampleEXT(
                  36161,
                  r,
                  35056,
                  n.width,
                  n.height
                )
              : t.renderbufferStorage(36161, 34041, n.width, n.height),
              t.framebufferRenderbuffer(36160, 33306, 36161, e);
          } else {
            const e =
                !0 === n.isWebGLMultipleRenderTargets
                  ? n.texture[0]
                  : n.texture,
              r = a.convert(e.format, e.encoding),
              o = a.convert(e.type),
              s = M(e.internalFormat, r, o, e.encoding),
              c = K(n);
            i && n.useRenderbuffer
              ? t.renderbufferStorageMultisample(36161, c, s, n.width, n.height)
              : n.useRenderToTexture
              ? p.renderbufferStorageMultisampleEXT(
                  36161,
                  c,
                  s,
                  n.width,
                  n.height
                )
              : t.renderbufferStorage(36161, s, n.width, n.height);
          }
          t.bindRenderbuffer(36161, null);
        }
        function j(e, r) {
          const a = r && r.isWebGLCubeRenderTarget;
          if (a)
            throw new Error(
              "Depth Texture with cube render targets is not supported"
            );
          if (
            (n.bindFramebuffer(36160, e),
            !r.depthTexture || !r.depthTexture.isDepthTexture)
          )
            throw new Error(
              "renderTarget.depthTexture must be an instance of THREE.DepthTexture"
            );
          (i.get(r.depthTexture).__webglTexture &&
            r.depthTexture.image.width === r.width &&
            r.depthTexture.image.height === r.height) ||
            ((r.depthTexture.image.width = r.width),
            (r.depthTexture.image.height = r.height),
            (r.depthTexture.needsUpdate = !0)),
            I(r.depthTexture, 0);
          const o = i.get(r.depthTexture).__webglTexture,
            s = K(r);
          if (r.depthTexture.format === Ut)
            r.useRenderToTexture
              ? p.framebufferTexture2DMultisampleEXT(
                  36160,
                  36096,
                  3553,
                  o,
                  0,
                  s
                )
              : t.framebufferTexture2D(36160, 36096, 3553, o, 0);
          else {
            if (r.depthTexture.format !== Ft)
              throw new Error("Unknown depthTexture format");
            r.useRenderToTexture
              ? p.framebufferTexture2DMultisampleEXT(
                  36160,
                  33306,
                  3553,
                  o,
                  0,
                  s
                )
              : t.framebufferTexture2D(36160, 33306, 3553, o, 0);
          }
        }
        function q(e) {
          const r = i.get(e),
            a = !0 === e.isWebGLCubeRenderTarget;
          if (e.depthTexture && !r.__autoAllocateDepthBuffer) {
            if (a)
              throw new Error(
                "target.depthTexture not supported in Cube render targets"
              );
            j(r.__webglFramebuffer, e);
          } else if (a) {
            r.__webglDepthbuffer = [];
            for (let i = 0; i < 6; i++)
              n.bindFramebuffer(36160, r.__webglFramebuffer[i]),
                (r.__webglDepthbuffer[i] = t.createRenderbuffer()),
                W(r.__webglDepthbuffer[i], e, !1);
          } else
            n.bindFramebuffer(36160, r.__webglFramebuffer),
              (r.__webglDepthbuffer = t.createRenderbuffer()),
              W(r.__webglDepthbuffer, e, !1);
          n.bindFramebuffer(36160, null);
        }
        function X(t, e, n) {
          const r = i.get(t);
          void 0 !== e && V(r.__webglFramebuffer, t, t.texture, 36064, 3553),
            void 0 !== n && q(t);
        }
        function Y(e) {
          const c = e.texture,
            l = i.get(e),
            h = i.get(c);
          e.addEventListener("dispose", A),
            !0 !== e.isWebGLMultipleRenderTargets &&
              (void 0 === h.__webglTexture &&
                (h.__webglTexture = t.createTexture()),
              (h.__version = c.version),
              o.memory.textures++);
          const u = !0 === e.isWebGLCubeRenderTarget,
            d = !0 === e.isWebGLMultipleRenderTargets,
            p = c.isDataTexture3D || c.isDataTexture2DArray,
            f = x(e) || s;
          if (u) {
            l.__webglFramebuffer = [];
            for (let e = 0; e < 6; e++)
              l.__webglFramebuffer[e] = t.createFramebuffer();
          } else if (((l.__webglFramebuffer = t.createFramebuffer()), d))
            if (r.drawBuffers) {
              const n = e.texture;
              for (let e = 0, r = n.length; e < r; e++) {
                const r = i.get(n[e]);
                void 0 === r.__webglTexture &&
                  ((r.__webglTexture = t.createTexture()), o.memory.textures++);
              }
            } else
              console.warn(
                "THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension."
              );
          else if (e.useRenderbuffer)
            if (s) {
              (l.__webglMultisampledFramebuffer = t.createFramebuffer()),
                (l.__webglColorRenderbuffer = t.createRenderbuffer()),
                t.bindRenderbuffer(36161, l.__webglColorRenderbuffer);
              const i = a.convert(c.format, c.encoding),
                r = a.convert(c.type),
                o = M(c.internalFormat, i, r, c.encoding),
                s = K(e);
              t.renderbufferStorageMultisample(36161, s, o, e.width, e.height),
                n.bindFramebuffer(36160, l.__webglMultisampledFramebuffer),
                t.framebufferRenderbuffer(
                  36160,
                  36064,
                  36161,
                  l.__webglColorRenderbuffer
                ),
                t.bindRenderbuffer(36161, null),
                e.depthBuffer &&
                  ((l.__webglDepthRenderbuffer = t.createRenderbuffer()),
                  W(l.__webglDepthRenderbuffer, e, !0)),
                n.bindFramebuffer(36160, null);
            } else
              console.warn(
                "THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2."
              );
          if (u) {
            n.bindTexture(34067, h.__webglTexture), F(34067, c, f);
            for (let t = 0; t < 6; t++)
              V(l.__webglFramebuffer[t], e, c, 36064, 34069 + t);
            b(c, f) && w(34067), n.unbindTexture();
          } else if (d) {
            const t = e.texture;
            for (let r = 0, a = t.length; r < a; r++) {
              const a = t[r],
                o = i.get(a);
              n.bindTexture(3553, o.__webglTexture),
                F(3553, a, f),
                V(l.__webglFramebuffer, e, a, 36064 + r, 3553),
                b(a, f) && w(3553);
            }
            n.unbindTexture();
          } else {
            let t = 3553;
            if (p)
              if (s) {
                const e = c.isDataTexture3D;
                t = e ? 32879 : 35866;
              } else
                console.warn(
                  "THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2."
                );
            n.bindTexture(t, h.__webglTexture),
              F(t, c, f),
              V(l.__webglFramebuffer, e, c, 36064, t),
              b(c, f) && w(t),
              n.unbindTexture();
          }
          e.depthBuffer && q(e);
        }
        function J(t) {
          const e = x(t) || s,
            r = !0 === t.isWebGLMultipleRenderTargets ? t.texture : [t.texture];
          for (let a = 0, o = r.length; a < o; a++) {
            const o = r[a];
            if (b(o, e)) {
              const e = t.isWebGLCubeRenderTarget ? 34067 : 3553,
                r = i.get(o).__webglTexture;
              n.bindTexture(e, r), w(e), n.unbindTexture();
            }
          }
        }
        function Z(e) {
          if (e.useRenderbuffer)
            if (s) {
              const r = e.width,
                a = e.height;
              let o = 16384;
              const s = [36064],
                c = e.stencilBuffer ? 33306 : 36096;
              e.depthBuffer && s.push(c),
                e.ignoreDepthForMultisampleCopy ||
                  (e.depthBuffer && (o |= 256), e.stencilBuffer && (o |= 1024));
              const l = i.get(e);
              n.bindFramebuffer(36008, l.__webglMultisampledFramebuffer),
                n.bindFramebuffer(36009, l.__webglFramebuffer),
                e.ignoreDepthForMultisampleCopy &&
                  (t.invalidateFramebuffer(36008, [c]),
                  t.invalidateFramebuffer(36009, [c])),
                t.blitFramebuffer(0, 0, r, a, 0, 0, r, a, o, 9728),
                t.invalidateFramebuffer(36008, s),
                n.bindFramebuffer(36008, null),
                n.bindFramebuffer(36009, l.__webglMultisampledFramebuffer);
            } else
              console.warn(
                "THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2."
              );
        }
        function K(t) {
          return s && (t.useRenderbuffer || t.useRenderToTexture)
            ? Math.min(u, t.samples)
            : 0;
        }
        function $(t) {
          const e = o.render.frame;
          f.get(t) !== e && (f.set(t, e), t.update());
        }
        function Q(t, n) {
          const i = t.encoding,
            r = t.format,
            a = t.type;
          return (
            !0 === t.isCompressedTexture ||
              !0 === t.isVideoTexture ||
              t.format === He ||
              (i !== Re &&
                (i === Le
                  ? !1 === s
                    ? !0 === e.has("EXT_sRGB") && r === Nt
                      ? ((t.format = He),
                        (t.minFilter = xt),
                        (t.generateMipmaps = !1))
                      : (n = pn.sRGBToLinear(n))
                    : (r === Nt && a === wt) ||
                      console.warn(
                        "THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType."
                      )
                  : console.error(
                      "THREE.WebGLTextures: Unsupported texture encoding:",
                      i
                    ))),
            n
          );
        }
        let tt = !1,
          et = !1;
        function nt(t, e) {
          t &&
            t.isWebGLRenderTarget &&
            (!1 === tt &&
              (console.warn(
                "THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."
              ),
              (tt = !0)),
            (t = t.texture)),
            I(t, e);
        }
        function it(t, e) {
          t &&
            t.isWebGLCubeRenderTarget &&
            (!1 === et &&
              (console.warn(
                "THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."
              ),
              (et = !0)),
            (t = t.texture)),
            B(t, e);
        }
        (this.allocateTextureUnit = D),
          (this.resetTextureUnits = P),
          (this.setTexture2D = I),
          (this.setTexture2DArray = O),
          (this.setTexture3D = N),
          (this.setTextureCube = B),
          (this.rebindTextures = X),
          (this.setupRenderTarget = Y),
          (this.updateRenderTargetMipmap = J),
          (this.updateMultisampleRenderTarget = Z),
          (this.setupDepthRenderbuffer = q),
          (this.setupFrameBufferTexture = V),
          (this.safeSetTexture2D = nt),
          (this.safeSetTextureCube = it);
      }
      function uh(t, e, n) {
        const i = n.isWebGL2;
        function r(t, n = null) {
          let r;
          if (t === wt) return 5121;
          if (t === Lt) return 32819;
          if (t === Pt) return 32820;
          if (t === Mt) return 5120;
          if (t === St) return 5122;
          if (t === Et) return 5123;
          if (t === Tt) return 5124;
          if (t === At) return 5125;
          if (t === Ct) return 5126;
          if (t === Rt)
            return i
              ? 5131
              : ((r = e.get("OES_texture_half_float")),
                null !== r ? r.HALF_FLOAT_OES : null);
          if (t === It) return 6406;
          if (t === Nt) return 6408;
          if (t === Bt) return 6409;
          if (t === zt) return 6410;
          if (t === Ut) return 6402;
          if (t === Ft) return 34041;
          if (t === Ht) return 6403;
          if (t === Ot)
            return (
              console.warn(
                "THREE.WebGLRenderer: THREE.RGBFormat has been removed. Use THREE.RGBAFormat instead. https://github.com/mrdoob/three.js/pull/23228"
              ),
              6408
            );
          if (t === He)
            return (
              (r = e.get("EXT_sRGB")), null !== r ? r.SRGB_ALPHA_EXT : null
            );
          if (t === kt) return 36244;
          if (t === Gt) return 33319;
          if (t === Vt) return 33320;
          if (t === Wt) return 36249;
          if (t === jt || t === qt || t === Xt || t === Yt)
            if (n === Le) {
              if (
                ((r = e.get("WEBGL_compressed_texture_s3tc_srgb")), null === r)
              )
                return null;
              if (t === jt) return r.COMPRESSED_SRGB_S3TC_DXT1_EXT;
              if (t === qt) return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
              if (t === Xt) return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
              if (t === Yt) return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
            } else {
              if (((r = e.get("WEBGL_compressed_texture_s3tc")), null === r))
                return null;
              if (t === jt) return r.COMPRESSED_RGB_S3TC_DXT1_EXT;
              if (t === qt) return r.COMPRESSED_RGBA_S3TC_DXT1_EXT;
              if (t === Xt) return r.COMPRESSED_RGBA_S3TC_DXT3_EXT;
              if (t === Yt) return r.COMPRESSED_RGBA_S3TC_DXT5_EXT;
            }
          if (t === Jt || t === Zt || t === Kt || t === $t) {
            if (((r = e.get("WEBGL_compressed_texture_pvrtc")), null === r))
              return null;
            if (t === Jt) return r.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
            if (t === Zt) return r.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
            if (t === Kt) return r.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
            if (t === $t) return r.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
          }
          if (t === Qt)
            return (
              (r = e.get("WEBGL_compressed_texture_etc1")),
              null !== r ? r.COMPRESSED_RGB_ETC1_WEBGL : null
            );
          if (t === te || t === ee) {
            if (((r = e.get("WEBGL_compressed_texture_etc")), null === r))
              return null;
            if (t === te)
              return n === Le
                ? r.COMPRESSED_SRGB8_ETC2
                : r.COMPRESSED_RGB8_ETC2;
            if (t === ee)
              return n === Le
                ? r.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC
                : r.COMPRESSED_RGBA8_ETC2_EAC;
          }
          if (
            t === ne ||
            t === ie ||
            t === re ||
            t === ae ||
            t === oe ||
            t === se ||
            t === ce ||
            t === le ||
            t === he ||
            t === ue ||
            t === de ||
            t === pe ||
            t === fe ||
            t === me
          ) {
            if (((r = e.get("WEBGL_compressed_texture_astc")), null === r))
              return null;
            if (t === ne)
              return n === Le
                ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR
                : r.COMPRESSED_RGBA_ASTC_4x4_KHR;
            if (t === ie)
              return n === Le
                ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR
                : r.COMPRESSED_RGBA_ASTC_5x4_KHR;
            if (t === re)
              return n === Le
                ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR
                : r.COMPRESSED_RGBA_ASTC_5x5_KHR;
            if (t === ae)
              return n === Le
                ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR
                : r.COMPRESSED_RGBA_ASTC_6x5_KHR;
            if (t === oe)
              return n === Le
                ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR
                : r.COMPRESSED_RGBA_ASTC_6x6_KHR;
            if (t === se)
              return n === Le
                ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR
                : r.COMPRESSED_RGBA_ASTC_8x5_KHR;
            if (t === ce)
              return n === Le
                ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR
                : r.COMPRESSED_RGBA_ASTC_8x6_KHR;
            if (t === le)
              return n === Le
                ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR
                : r.COMPRESSED_RGBA_ASTC_8x8_KHR;
            if (t === he)
              return n === Le
                ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR
                : r.COMPRESSED_RGBA_ASTC_10x5_KHR;
            if (t === ue)
              return n === Le
                ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR
                : r.COMPRESSED_RGBA_ASTC_10x6_KHR;
            if (t === de)
              return n === Le
                ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR
                : r.COMPRESSED_RGBA_ASTC_10x8_KHR;
            if (t === pe)
              return n === Le
                ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR
                : r.COMPRESSED_RGBA_ASTC_10x10_KHR;
            if (t === fe)
              return n === Le
                ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR
                : r.COMPRESSED_RGBA_ASTC_12x10_KHR;
            if (t === me)
              return n === Le
                ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR
                : r.COMPRESSED_RGBA_ASTC_12x12_KHR;
          }
          if (t === ge) {
            if (((r = e.get("EXT_texture_compression_bptc")), null === r))
              return null;
            if (t === ge)
              return n === Le
                ? r.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT
                : r.COMPRESSED_RGBA_BPTC_UNORM_EXT;
          }
          return t === Dt
            ? i
              ? 34042
              : ((r = e.get("WEBGL_depth_texture")),
                null !== r ? r.UNSIGNED_INT_24_8_WEBGL : null)
            : void 0;
        }
        return { convert: r };
      }
      class dh extends Cr {
        constructor(t = []) {
          super(), (this.cameras = t);
        }
      }
      dh.prototype.isArrayCamera = !0;
      class ph extends Si {
        constructor() {
          super(), (this.type = "Group");
        }
      }
      ph.prototype.isGroup = !0;
      const fh = { type: "move" };
      class mh {
        constructor() {
          (this._targetRay = null), (this._grip = null), (this._hand = null);
        }
        getHandSpace() {
          return (
            null === this._hand &&
              ((this._hand = new ph()),
              (this._hand.matrixAutoUpdate = !1),
              (this._hand.visible = !1),
              (this._hand.joints = {}),
              (this._hand.inputState = { pinching: !1 })),
            this._hand
          );
        }
        getTargetRaySpace() {
          return (
            null === this._targetRay &&
              ((this._targetRay = new ph()),
              (this._targetRay.matrixAutoUpdate = !1),
              (this._targetRay.visible = !1),
              (this._targetRay.hasLinearVelocity = !1),
              (this._targetRay.linearVelocity = new wn()),
              (this._targetRay.hasAngularVelocity = !1),
              (this._targetRay.angularVelocity = new wn())),
            this._targetRay
          );
        }
        getGripSpace() {
          return (
            null === this._grip &&
              ((this._grip = new ph()),
              (this._grip.matrixAutoUpdate = !1),
              (this._grip.visible = !1),
              (this._grip.hasLinearVelocity = !1),
              (this._grip.linearVelocity = new wn()),
              (this._grip.hasAngularVelocity = !1),
              (this._grip.angularVelocity = new wn())),
            this._grip
          );
        }
        dispatchEvent(t) {
          return (
            null !== this._targetRay && this._targetRay.dispatchEvent(t),
            null !== this._grip && this._grip.dispatchEvent(t),
            null !== this._hand && this._hand.dispatchEvent(t),
            this
          );
        }
        disconnect(t) {
          return (
            this.dispatchEvent({ type: "disconnected", data: t }),
            null !== this._targetRay && (this._targetRay.visible = !1),
            null !== this._grip && (this._grip.visible = !1),
            null !== this._hand && (this._hand.visible = !1),
            this
          );
        }
        update(t, e, n) {
          let i = null,
            r = null,
            a = null;
          const o = this._targetRay,
            s = this._grip,
            c = this._hand;
          if (t && "visible-blurred" !== e.session.visibilityState)
            if (
              (null !== o &&
                ((i = e.getPose(t.targetRaySpace, n)),
                null !== i &&
                  (o.matrix.fromArray(i.transform.matrix),
                  o.matrix.decompose(o.position, o.rotation, o.scale),
                  i.linearVelocity
                    ? ((o.hasLinearVelocity = !0),
                      o.linearVelocity.copy(i.linearVelocity))
                    : (o.hasLinearVelocity = !1),
                  i.angularVelocity
                    ? ((o.hasAngularVelocity = !0),
                      o.angularVelocity.copy(i.angularVelocity))
                    : (o.hasAngularVelocity = !1),
                  this.dispatchEvent(fh))),
              c && t.hand)
            ) {
              a = !0;
              for (const a of t.hand.values()) {
                const t = e.getJointPose(a, n);
                if (void 0 === c.joints[a.jointName]) {
                  const t = new ph();
                  (t.matrixAutoUpdate = !1),
                    (t.visible = !1),
                    (c.joints[a.jointName] = t),
                    c.add(t);
                }
                const i = c.joints[a.jointName];
                null !== t &&
                  (i.matrix.fromArray(t.transform.matrix),
                  i.matrix.decompose(i.position, i.rotation, i.scale),
                  (i.jointRadius = t.radius)),
                  (i.visible = null !== t);
              }
              const i = c.joints["index-finger-tip"],
                r = c.joints["thumb-tip"],
                o = i.position.distanceTo(r.position),
                s = 0.02,
                l = 0.005;
              c.inputState.pinching && o > s + l
                ? ((c.inputState.pinching = !1),
                  this.dispatchEvent({
                    type: "pinchend",
                    handedness: t.handedness,
                    target: this,
                  }))
                : !c.inputState.pinching &&
                  o <= s - l &&
                  ((c.inputState.pinching = !0),
                  this.dispatchEvent({
                    type: "pinchstart",
                    handedness: t.handedness,
                    target: this,
                  }));
            } else
              null !== s &&
                t.gripSpace &&
                ((r = e.getPose(t.gripSpace, n)),
                null !== r &&
                  (s.matrix.fromArray(r.transform.matrix),
                  s.matrix.decompose(s.position, s.rotation, s.scale),
                  r.linearVelocity
                    ? ((s.hasLinearVelocity = !0),
                      s.linearVelocity.copy(r.linearVelocity))
                    : (s.hasLinearVelocity = !1),
                  r.angularVelocity
                    ? ((s.hasAngularVelocity = !0),
                      s.angularVelocity.copy(r.angularVelocity))
                    : (s.hasAngularVelocity = !1)));
          return (
            null !== o && (o.visible = null !== i),
            null !== s && (s.visible = null !== r),
            null !== c && (c.visible = null !== a),
            this
          );
        }
      }
      class gh extends mn {
        constructor(t, e, n, i, r, a, o, s, c, l) {
          if (((l = void 0 !== l ? l : Ut), l !== Ut && l !== Ft))
            throw new Error(
              "DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat"
            );
          void 0 === n && l === Ut && (n = Et),
            void 0 === n && l === Ft && (n = Dt),
            super(null, i, r, a, o, s, l, n, c),
            (this.image = { width: t, height: e }),
            (this.magFilter = void 0 !== o ? o : gt),
            (this.minFilter = void 0 !== s ? s : gt),
            (this.flipY = !1),
            (this.generateMipmaps = !1);
        }
      }
      gh.prototype.isDepthTexture = !0;
      class vh extends ke {
        constructor(t, e) {
          super();
          const n = this;
          let i = null,
            r = 1,
            a = null,
            o = "local-floor";
          const s = t.extensions.has("WEBGL_multisampled_render_to_texture");
          let c = null,
            l = null,
            h = null,
            u = null,
            d = !1,
            p = null;
          const f = e.getContextAttributes();
          let m = null,
            g = null;
          const v = [],
            y = new Map(),
            x = new Cr();
          x.layers.enable(1), (x.viewport = new vn());
          const _ = new Cr();
          _.layers.enable(2), (_.viewport = new vn());
          const b = [x, _],
            w = new dh();
          w.layers.enable(1), w.layers.enable(2);
          let M = null,
            S = null;
          function E(t) {
            const e = y.get(t.inputSource);
            e && e.dispatchEvent({ type: t.type, data: t.inputSource });
          }
          function T() {
            y.forEach(function (t, e) {
              t.disconnect(e);
            }),
              y.clear(),
              (M = null),
              (S = null),
              t.setRenderTarget(m),
              (u = null),
              (h = null),
              (l = null),
              (i = null),
              (g = null),
              O.stop(),
              (n.isPresenting = !1),
              n.dispatchEvent({ type: "sessionend" });
          }
          function A(t) {
            const e = i.inputSources;
            for (let n = 0; n < v.length; n++) y.set(e[n], v[n]);
            for (let n = 0; n < t.removed.length; n++) {
              const e = t.removed[n],
                i = y.get(e);
              i &&
                (i.dispatchEvent({ type: "disconnected", data: e }),
                y.delete(e));
            }
            for (let n = 0; n < t.added.length; n++) {
              const e = t.added[n],
                i = y.get(e);
              i && i.dispatchEvent({ type: "connected", data: e });
            }
          }
          (this.cameraAutoUpdate = !0),
            (this.enabled = !1),
            (this.isPresenting = !1),
            (this.getController = function (t) {
              let e = v[t];
              return (
                void 0 === e && ((e = new mh()), (v[t] = e)),
                e.getTargetRaySpace()
              );
            }),
            (this.getControllerGrip = function (t) {
              let e = v[t];
              return (
                void 0 === e && ((e = new mh()), (v[t] = e)), e.getGripSpace()
              );
            }),
            (this.getHand = function (t) {
              let e = v[t];
              return (
                void 0 === e && ((e = new mh()), (v[t] = e)), e.getHandSpace()
              );
            }),
            (this.setFramebufferScaleFactor = function (t) {
              (r = t),
                !0 === n.isPresenting &&
                  console.warn(
                    "THREE.WebXRManager: Cannot change framebuffer scale while presenting."
                  );
            }),
            (this.setReferenceSpaceType = function (t) {
              (o = t),
                !0 === n.isPresenting &&
                  console.warn(
                    "THREE.WebXRManager: Cannot change reference space type while presenting."
                  );
            }),
            (this.getReferenceSpace = function () {
              return a;
            }),
            (this.getBaseLayer = function () {
              return null !== h ? h : u;
            }),
            (this.getBinding = function () {
              return l;
            }),
            (this.getFrame = function () {
              return p;
            }),
            (this.getSession = function () {
              return i;
            }),
            (this.setSession = async function (c) {
              if (((i = c), null !== i)) {
                if (
                  ((m = t.getRenderTarget()),
                  i.addEventListener("select", E),
                  i.addEventListener("selectstart", E),
                  i.addEventListener("selectend", E),
                  i.addEventListener("squeeze", E),
                  i.addEventListener("squeezestart", E),
                  i.addEventListener("squeezeend", E),
                  i.addEventListener("end", T),
                  i.addEventListener("inputsourceschange", A),
                  !0 !== f.xrCompatible && (await e.makeXRCompatible()),
                  void 0 === i.renderState.layers ||
                    !1 === t.capabilities.isWebGL2)
                ) {
                  const n = {
                    antialias: void 0 !== i.renderState.layers || f.antialias,
                    alpha: f.alpha,
                    depth: f.depth,
                    stencil: f.stencil,
                    framebufferScaleFactor: r,
                  };
                  (u = new XRWebGLLayer(i, e, n)),
                    i.updateRenderState({ baseLayer: u }),
                    (g = new yn(u.framebufferWidth, u.framebufferHeight, {
                      format: Nt,
                      type: wt,
                      encoding: t.outputEncoding,
                    }));
                } else {
                  d = f.antialias;
                  let n = null,
                    a = null,
                    o = null;
                  f.depth &&
                    ((o = f.stencil ? 35056 : 33190),
                    (n = f.stencil ? Ft : Ut),
                    (a = f.stencil ? Dt : Et));
                  const c = {
                    colorFormat: t.outputEncoding === Le ? 35907 : 32856,
                    depthFormat: o,
                    scaleFactor: r,
                  };
                  (l = new XRWebGLBinding(i, e)),
                    (h = l.createProjectionLayer(c)),
                    i.updateRenderState({ layers: [h] }),
                    (g = d
                      ? new _n(h.textureWidth, h.textureHeight, {
                          format: Nt,
                          type: wt,
                          depthTexture: new gh(
                            h.textureWidth,
                            h.textureHeight,
                            a,
                            void 0,
                            void 0,
                            void 0,
                            void 0,
                            void 0,
                            void 0,
                            n
                          ),
                          stencilBuffer: f.stencil,
                          ignoreDepth: h.ignoreDepthValues,
                          useRenderToTexture: s,
                          encoding: t.outputEncoding,
                        })
                      : new yn(h.textureWidth, h.textureHeight, {
                          format: Nt,
                          type: wt,
                          depthTexture: new gh(
                            h.textureWidth,
                            h.textureHeight,
                            a,
                            void 0,
                            void 0,
                            void 0,
                            void 0,
                            void 0,
                            void 0,
                            n
                          ),
                          stencilBuffer: f.stencil,
                          ignoreDepth: h.ignoreDepthValues,
                          encoding: t.outputEncoding,
                        }));
                }
                (g.isXRRenderTarget = !0),
                  this.setFoveation(1),
                  (a = await i.requestReferenceSpace(o)),
                  O.setContext(i),
                  O.start(),
                  (n.isPresenting = !0),
                  n.dispatchEvent({ type: "sessionstart" });
              }
            });
          const C = new wn(),
            R = new wn();
          function L(t, e, n) {
            C.setFromMatrixPosition(e.matrixWorld),
              R.setFromMatrixPosition(n.matrixWorld);
            const i = C.distanceTo(R),
              r = e.projectionMatrix.elements,
              a = n.projectionMatrix.elements,
              o = r[14] / (r[10] - 1),
              s = r[14] / (r[10] + 1),
              c = (r[9] + 1) / r[5],
              l = (r[9] - 1) / r[5],
              h = (r[8] - 1) / r[0],
              u = (a[8] + 1) / a[0],
              d = o * h,
              p = o * u,
              f = i / (-h + u),
              m = f * -h;
            e.matrixWorld.decompose(t.position, t.quaternion, t.scale),
              t.translateX(m),
              t.translateZ(f),
              t.matrixWorld.compose(t.position, t.quaternion, t.scale),
              t.matrixWorldInverse.copy(t.matrixWorld).invert();
            const g = o + f,
              v = s + f,
              y = d - m,
              x = p + (i - m),
              _ = ((c * s) / v) * g,
              b = ((l * s) / v) * g;
            t.projectionMatrix.makePerspective(y, x, _, b, g, v);
          }
          function P(t, e) {
            null === e
              ? t.matrixWorld.copy(t.matrix)
              : t.matrixWorld.multiplyMatrices(e.matrixWorld, t.matrix),
              t.matrixWorldInverse.copy(t.matrixWorld).invert();
          }
          (this.updateCamera = function (t) {
            if (null === i) return;
            (w.near = _.near = x.near = t.near),
              (w.far = _.far = x.far = t.far),
              (M === w.near && S === w.far) ||
                (i.updateRenderState({ depthNear: w.near, depthFar: w.far }),
                (M = w.near),
                (S = w.far));
            const e = t.parent,
              n = w.cameras;
            P(w, e);
            for (let i = 0; i < n.length; i++) P(n[i], e);
            w.matrixWorld.decompose(w.position, w.quaternion, w.scale),
              t.position.copy(w.position),
              t.quaternion.copy(w.quaternion),
              t.scale.copy(w.scale),
              t.matrix.copy(w.matrix),
              t.matrixWorld.copy(w.matrixWorld);
            const r = t.children;
            for (let i = 0, a = r.length; i < a; i++)
              r[i].updateMatrixWorld(!0);
            2 === n.length
              ? L(w, x, _)
              : w.projectionMatrix.copy(x.projectionMatrix);
          }),
            (this.getCamera = function () {
              return w;
            }),
            (this.getFoveation = function () {
              return null !== h
                ? h.fixedFoveation
                : null !== u
                ? u.fixedFoveation
                : void 0;
            }),
            (this.setFoveation = function (t) {
              null !== h && (h.fixedFoveation = t),
                null !== u &&
                  void 0 !== u.fixedFoveation &&
                  (u.fixedFoveation = t);
            });
          let D = null;
          function I(e, n) {
            if (((c = n.getViewerPose(a)), (p = n), null !== c)) {
              const e = c.views;
              null !== u &&
                (t.setRenderTargetFramebuffer(g, u.framebuffer),
                t.setRenderTarget(g));
              let n = !1;
              e.length !== w.cameras.length &&
                ((w.cameras.length = 0), (n = !0));
              for (let i = 0; i < e.length; i++) {
                const r = e[i];
                let a = null;
                if (null !== u) a = u.getViewport(r);
                else {
                  const e = l.getViewSubImage(h, r);
                  (a = e.viewport),
                    0 === i &&
                      (t.setRenderTargetTextures(
                        g,
                        e.colorTexture,
                        h.ignoreDepthValues ? void 0 : e.depthStencilTexture
                      ),
                      t.setRenderTarget(g));
                }
                const o = b[i];
                o.matrix.fromArray(r.transform.matrix),
                  o.projectionMatrix.fromArray(r.projectionMatrix),
                  o.viewport.set(a.x, a.y, a.width, a.height),
                  0 === i && w.matrix.copy(o.matrix),
                  !0 === n && w.cameras.push(o);
              }
            }
            const r = i.inputSources;
            for (let t = 0; t < v.length; t++) {
              const e = v[t],
                i = r[t];
              e.update(i, n, a);
            }
            D && D(e, n), (p = null);
          }
          const O = new kr();
          O.setAnimationLoop(I),
            (this.setAnimationLoop = function (t) {
              D = t;
            }),
            (this.dispose = function () {});
        }
      }
      function yh(t) {
        function e(t, e) {
          t.fogColor.value.copy(e.color),
            e.isFog
              ? ((t.fogNear.value = e.near), (t.fogFar.value = e.far))
              : e.isFogExp2 && (t.fogDensity.value = e.density);
        }
        function n(t, e, n, v, y) {
          e.isMeshBasicMaterial
            ? i(t, e)
            : e.isMeshLambertMaterial
            ? (i(t, e), c(t, e))
            : e.isMeshToonMaterial
            ? (i(t, e), h(t, e))
            : e.isMeshPhongMaterial
            ? (i(t, e), l(t, e))
            : e.isMeshStandardMaterial
            ? (i(t, e), e.isMeshPhysicalMaterial ? d(t, e, y) : u(t, e))
            : e.isMeshMatcapMaterial
            ? (i(t, e), p(t, e))
            : e.isMeshDepthMaterial
            ? (i(t, e), f(t, e))
            : e.isMeshDistanceMaterial
            ? (i(t, e), m(t, e))
            : e.isMeshNormalMaterial
            ? (i(t, e), g(t, e))
            : e.isLineBasicMaterial
            ? (r(t, e), e.isLineDashedMaterial && a(t, e))
            : e.isPointsMaterial
            ? o(t, e, n, v)
            : e.isSpriteMaterial
            ? s(t, e)
            : e.isShadowMaterial
            ? (t.color.value.copy(e.color), (t.opacity.value = e.opacity))
            : e.isShaderMaterial && (e.uniformsNeedUpdate = !1);
        }
        function i(e, n) {
          (e.opacity.value = n.opacity),
            n.color && e.diffuse.value.copy(n.color),
            n.emissive &&
              e.emissive.value
                .copy(n.emissive)
                .multiplyScalar(n.emissiveIntensity),
            n.map && (e.map.value = n.map),
            n.alphaMap && (e.alphaMap.value = n.alphaMap),
            n.specularMap && (e.specularMap.value = n.specularMap),
            n.alphaTest > 0 && (e.alphaTest.value = n.alphaTest);
          const i = t.get(n).envMap;
          let r, a;
          i &&
            ((e.envMap.value = i),
            (e.flipEnvMap.value =
              i.isCubeTexture && !1 === i.isRenderTargetTexture ? -1 : 1),
            (e.reflectivity.value = n.reflectivity),
            (e.ior.value = n.ior),
            (e.refractionRatio.value = n.refractionRatio)),
            n.lightMap &&
              ((e.lightMap.value = n.lightMap),
              (e.lightMapIntensity.value = n.lightMapIntensity)),
            n.aoMap &&
              ((e.aoMap.value = n.aoMap),
              (e.aoMapIntensity.value = n.aoMapIntensity)),
            n.map
              ? (r = n.map)
              : n.specularMap
              ? (r = n.specularMap)
              : n.displacementMap
              ? (r = n.displacementMap)
              : n.normalMap
              ? (r = n.normalMap)
              : n.bumpMap
              ? (r = n.bumpMap)
              : n.roughnessMap
              ? (r = n.roughnessMap)
              : n.metalnessMap
              ? (r = n.metalnessMap)
              : n.alphaMap
              ? (r = n.alphaMap)
              : n.emissiveMap
              ? (r = n.emissiveMap)
              : n.clearcoatMap
              ? (r = n.clearcoatMap)
              : n.clearcoatNormalMap
              ? (r = n.clearcoatNormalMap)
              : n.clearcoatRoughnessMap
              ? (r = n.clearcoatRoughnessMap)
              : n.specularIntensityMap
              ? (r = n.specularIntensityMap)
              : n.specularColorMap
              ? (r = n.specularColorMap)
              : n.transmissionMap
              ? (r = n.transmissionMap)
              : n.thicknessMap
              ? (r = n.thicknessMap)
              : n.sheenColorMap
              ? (r = n.sheenColorMap)
              : n.sheenRoughnessMap && (r = n.sheenRoughnessMap),
            void 0 !== r &&
              (r.isWebGLRenderTarget && (r = r.texture),
              !0 === r.matrixAutoUpdate && r.updateMatrix(),
              e.uvTransform.value.copy(r.matrix)),
            n.aoMap ? (a = n.aoMap) : n.lightMap && (a = n.lightMap),
            void 0 !== a &&
              (a.isWebGLRenderTarget && (a = a.texture),
              !0 === a.matrixAutoUpdate && a.updateMatrix(),
              e.uv2Transform.value.copy(a.matrix));
        }
        function r(t, e) {
          t.diffuse.value.copy(e.color), (t.opacity.value = e.opacity);
        }
        function a(t, e) {
          (t.dashSize.value = e.dashSize),
            (t.totalSize.value = e.dashSize + e.gapSize),
            (t.scale.value = e.scale);
        }
        function o(t, e, n, i) {
          let r;
          t.diffuse.value.copy(e.color),
            (t.opacity.value = e.opacity),
            (t.size.value = e.size * n),
            (t.scale.value = 0.5 * i),
            e.map && (t.map.value = e.map),
            e.alphaMap && (t.alphaMap.value = e.alphaMap),
            e.alphaTest > 0 && (t.alphaTest.value = e.alphaTest),
            e.map ? (r = e.map) : e.alphaMap && (r = e.alphaMap),
            void 0 !== r &&
              (!0 === r.matrixAutoUpdate && r.updateMatrix(),
              t.uvTransform.value.copy(r.matrix));
        }
        function s(t, e) {
          let n;
          t.diffuse.value.copy(e.color),
            (t.opacity.value = e.opacity),
            (t.rotation.value = e.rotation),
            e.map && (t.map.value = e.map),
            e.alphaMap && (t.alphaMap.value = e.alphaMap),
            e.alphaTest > 0 && (t.alphaTest.value = e.alphaTest),
            e.map ? (n = e.map) : e.alphaMap && (n = e.alphaMap),
            void 0 !== n &&
              (!0 === n.matrixAutoUpdate && n.updateMatrix(),
              t.uvTransform.value.copy(n.matrix));
        }
        function c(t, e) {
          e.emissiveMap && (t.emissiveMap.value = e.emissiveMap);
        }
        function l(t, e) {
          t.specular.value.copy(e.specular),
            (t.shininess.value = Math.max(e.shininess, 1e-4)),
            e.emissiveMap && (t.emissiveMap.value = e.emissiveMap),
            e.bumpMap &&
              ((t.bumpMap.value = e.bumpMap),
              (t.bumpScale.value = e.bumpScale),
              e.side === v && (t.bumpScale.value *= -1)),
            e.normalMap &&
              ((t.normalMap.value = e.normalMap),
              t.normalScale.value.copy(e.normalScale),
              e.side === v && t.normalScale.value.negate()),
            e.displacementMap &&
              ((t.displacementMap.value = e.displacementMap),
              (t.displacementScale.value = e.displacementScale),
              (t.displacementBias.value = e.displacementBias));
        }
        function h(t, e) {
          e.gradientMap && (t.gradientMap.value = e.gradientMap),
            e.emissiveMap && (t.emissiveMap.value = e.emissiveMap),
            e.bumpMap &&
              ((t.bumpMap.value = e.bumpMap),
              (t.bumpScale.value = e.bumpScale),
              e.side === v && (t.bumpScale.value *= -1)),
            e.normalMap &&
              ((t.normalMap.value = e.normalMap),
              t.normalScale.value.copy(e.normalScale),
              e.side === v && t.normalScale.value.negate()),
            e.displacementMap &&
              ((t.displacementMap.value = e.displacementMap),
              (t.displacementScale.value = e.displacementScale),
              (t.displacementBias.value = e.displacementBias));
        }
        function u(e, n) {
          (e.roughness.value = n.roughness),
            (e.metalness.value = n.metalness),
            n.roughnessMap && (e.roughnessMap.value = n.roughnessMap),
            n.metalnessMap && (e.metalnessMap.value = n.metalnessMap),
            n.emissiveMap && (e.emissiveMap.value = n.emissiveMap),
            n.bumpMap &&
              ((e.bumpMap.value = n.bumpMap),
              (e.bumpScale.value = n.bumpScale),
              n.side === v && (e.bumpScale.value *= -1)),
            n.normalMap &&
              ((e.normalMap.value = n.normalMap),
              e.normalScale.value.copy(n.normalScale),
              n.side === v && e.normalScale.value.negate()),
            n.displacementMap &&
              ((e.displacementMap.value = n.displacementMap),
              (e.displacementScale.value = n.displacementScale),
              (e.displacementBias.value = n.displacementBias));
          const i = t.get(n).envMap;
          i && (e.envMapIntensity.value = n.envMapIntensity);
        }
        function d(t, e, n) {
          u(t, e),
            (t.ior.value = e.ior),
            e.sheen > 0 &&
              (t.sheenColor.value.copy(e.sheenColor).multiplyScalar(e.sheen),
              (t.sheenRoughness.value = e.sheenRoughness),
              e.sheenColorMap && (t.sheenColorMap.value = e.sheenColorMap),
              e.sheenRoughnessMap &&
                (t.sheenRoughnessMap.value = e.sheenRoughnessMap)),
            e.clearcoat > 0 &&
              ((t.clearcoat.value = e.clearcoat),
              (t.clearcoatRoughness.value = e.clearcoatRoughness),
              e.clearcoatMap && (t.clearcoatMap.value = e.clearcoatMap),
              e.clearcoatRoughnessMap &&
                (t.clearcoatRoughnessMap.value = e.clearcoatRoughnessMap),
              e.clearcoatNormalMap &&
                (t.clearcoatNormalScale.value.copy(e.clearcoatNormalScale),
                (t.clearcoatNormalMap.value = e.clearcoatNormalMap),
                e.side === v && t.clearcoatNormalScale.value.negate())),
            e.transmission > 0 &&
              ((t.transmission.value = e.transmission),
              (t.transmissionSamplerMap.value = n.texture),
              t.transmissionSamplerSize.value.set(n.width, n.height),
              e.transmissionMap &&
                (t.transmissionMap.value = e.transmissionMap),
              (t.thickness.value = e.thickness),
              e.thicknessMap && (t.thicknessMap.value = e.thicknessMap),
              (t.attenuationDistance.value = e.attenuationDistance),
              t.attenuationColor.value.copy(e.attenuationColor)),
            (t.specularIntensity.value = e.specularIntensity),
            t.specularColor.value.copy(e.specularColor),
            e.specularIntensityMap &&
              (t.specularIntensityMap.value = e.specularIntensityMap),
            e.specularColorMap &&
              (t.specularColorMap.value = e.specularColorMap);
        }
        function p(t, e) {
          e.matcap && (t.matcap.value = e.matcap),
            e.bumpMap &&
              ((t.bumpMap.value = e.bumpMap),
              (t.bumpScale.value = e.bumpScale),
              e.side === v && (t.bumpScale.value *= -1)),
            e.normalMap &&
              ((t.normalMap.value = e.normalMap),
              t.normalScale.value.copy(e.normalScale),
              e.side === v && t.normalScale.value.negate()),
            e.displacementMap &&
              ((t.displacementMap.value = e.displacementMap),
              (t.displacementScale.value = e.displacementScale),
              (t.displacementBias.value = e.displacementBias));
        }
        function f(t, e) {
          e.displacementMap &&
            ((t.displacementMap.value = e.displacementMap),
            (t.displacementScale.value = e.displacementScale),
            (t.displacementBias.value = e.displacementBias));
        }
        function m(t, e) {
          e.displacementMap &&
            ((t.displacementMap.value = e.displacementMap),
            (t.displacementScale.value = e.displacementScale),
            (t.displacementBias.value = e.displacementBias)),
            t.referencePosition.value.copy(e.referencePosition),
            (t.nearDistance.value = e.nearDistance),
            (t.farDistance.value = e.farDistance);
        }
        function g(t, e) {
          e.bumpMap &&
            ((t.bumpMap.value = e.bumpMap),
            (t.bumpScale.value = e.bumpScale),
            e.side === v && (t.bumpScale.value *= -1)),
            e.normalMap &&
              ((t.normalMap.value = e.normalMap),
              t.normalScale.value.copy(e.normalScale),
              e.side === v && t.normalScale.value.negate()),
            e.displacementMap &&
              ((t.displacementMap.value = e.displacementMap),
              (t.displacementScale.value = e.displacementScale),
              (t.displacementBias.value = e.displacementBias));
        }
        return { refreshFogUniforms: e, refreshMaterialUniforms: n };
      }
      function xh() {
        const t = rn("canvas");
        return (t.style.display = "block"), t;
      }
      function _h(t = {}) {
        const e = void 0 !== t.canvas ? t.canvas : xh(),
          n = void 0 !== t.context ? t.context : null,
          i = void 0 !== t.alpha && t.alpha,
          r = void 0 === t.depth || t.depth,
          a = void 0 === t.stencil || t.stencil,
          o = void 0 !== t.antialias && t.antialias,
          s = void 0 === t.premultipliedAlpha || t.premultipliedAlpha,
          c = void 0 !== t.preserveDrawingBuffer && t.preserveDrawingBuffer,
          h = void 0 !== t.powerPreference ? t.powerPreference : "default",
          u =
            void 0 !== t.failIfMajorPerformanceCaveat &&
            t.failIfMajorPerformanceCaveat;
        let d = null,
          p = null;
        const f = [],
          m = [];
        (this.domElement = e),
          (this.debug = { checkShaderErrors: !0 }),
          (this.autoClear = !0),
          (this.autoClearColor = !0),
          (this.autoClearDepth = !0),
          (this.autoClearStencil = !0),
          (this.sortObjects = !0),
          (this.clippingPlanes = []),
          (this.localClippingEnabled = !1),
          (this.outputEncoding = Re),
          (this.physicallyCorrectLights = !1),
          (this.toneMapping = tt),
          (this.toneMappingExposure = 1);
        const x = this;
        let _ = !1,
          b = 0,
          w = 0,
          M = null,
          S = -1,
          E = null;
        const T = new vn(),
          A = new vn();
        let C = null,
          R = e.width,
          L = e.height,
          P = 1,
          D = null,
          I = null;
        const O = new vn(0, 0, R, L),
          N = new vn(0, 0, R, L);
        let B = !1;
        const z = new Hr();
        let U = !1,
          F = !1,
          H = null;
        const k = new Qn(),
          G = new wn(),
          V = {
            background: null,
            fog: null,
            environment: null,
            overrideMaterial: null,
            isScene: !0,
          };
        function W() {
          return null === M ? P : 1;
        }
        let j,
          q,
          X,
          Y,
          J,
          Z,
          K,
          $,
          Q,
          et,
          nt,
          it,
          rt,
          at,
          ot,
          st,
          ct,
          lt,
          ht,
          ut,
          dt,
          pt,
          mt,
          vt = n;
        function yt(t, n) {
          for (let i = 0; i < t.length; i++) {
            const r = t[i],
              a = e.getContext(r, n);
            if (null !== a) return a;
          }
          return null;
        }
        try {
          const t = {
            alpha: !0,
            depth: r,
            stencil: a,
            antialias: o,
            premultipliedAlpha: s,
            preserveDrawingBuffer: c,
            powerPreference: h,
            failIfMajorPerformanceCaveat: u,
          };
          if (
            ("setAttribute" in e &&
              e.setAttribute("data-engine", "three.js r" + l),
            e.addEventListener("webglcontextlost", Mt, !1),
            e.addEventListener("webglcontextrestored", St, !1),
            null === vt)
          ) {
            const e = ["webgl2", "webgl", "experimental-webgl"];
            if (
              (!0 === x.isWebGL1Renderer && e.shift(),
              (vt = yt(e, t)),
              null === vt)
            )
              throw yt(e)
                ? new Error(
                    "Error creating WebGL context with your selected attributes."
                  )
                : new Error("Error creating WebGL context.");
          }
          void 0 === vt.getShaderPrecisionFormat &&
            (vt.getShaderPrecisionFormat = function () {
              return { rangeMin: 1, rangeMax: 1, precision: 1 };
            });
        } catch (qt) {
          throw (console.error("THREE.WebGLRenderer: " + qt.message), qt);
        }
        function xt() {
          (j = new $s(vt)),
            (q = new Ms(vt, j, t)),
            j.init(q),
            (pt = new uh(vt, j, q)),
            (X = new lh(vt, j, q)),
            (Y = new ec(vt)),
            (J = new ql()),
            (Z = new hh(vt, j, X, J, q, pt, Y)),
            (K = new Es(x)),
            ($ = new Ks(x)),
            (Q = new Gr(vt, q)),
            (mt = new bs(vt, j, Q, q)),
            (et = new Qs(vt, Q, Y, mt)),
            (nt = new sc(vt, et, Q, Y)),
            (ht = new oc(vt, q, Z)),
            (st = new Ss(J)),
            (it = new jl(x, K, $, j, q, mt, st)),
            (rt = new yh(J)),
            (at = new Zl()),
            (ot = new ih(j, q)),
            (lt = new _s(x, K, X, nt, i, s)),
            (ct = new ch(x, nt, q)),
            (ut = new ws(vt, j, Y, q)),
            (dt = new tc(vt, j, Y, q)),
            (Y.programs = it.programs),
            (x.capabilities = q),
            (x.extensions = j),
            (x.properties = J),
            (x.renderLists = at),
            (x.shadowMap = ct),
            (x.state = X),
            (x.info = Y);
        }
        xt();
        const _t = new vh(x, vt);
        function Mt(t) {
          t.preventDefault(),
            console.log("THREE.WebGLRenderer: Context Lost."),
            (_ = !0);
        }
        function St() {
          console.log("THREE.WebGLRenderer: Context Restored."), (_ = !1);
          const t = Y.autoReset,
            e = ct.enabled,
            n = ct.autoUpdate,
            i = ct.needsUpdate,
            r = ct.type;
          xt(),
            (Y.autoReset = t),
            (ct.enabled = e),
            (ct.autoUpdate = n),
            (ct.needsUpdate = i),
            (ct.type = r);
        }
        function Et(t) {
          const e = t.target;
          e.removeEventListener("dispose", Et), Tt(e);
        }
        function Tt(t) {
          At(t), J.remove(t);
        }
        function At(t) {
          const e = J.get(t).programs;
          void 0 !== e &&
            (e.forEach(function (t) {
              it.releaseProgram(t);
            }),
            t.isShaderMaterial && it.releaseShaderCache(t));
        }
        (this.xr = _t),
          (this.getContext = function () {
            return vt;
          }),
          (this.getContextAttributes = function () {
            return vt.getContextAttributes();
          }),
          (this.forceContextLoss = function () {
            const t = j.get("WEBGL_lose_context");
            t && t.loseContext();
          }),
          (this.forceContextRestore = function () {
            const t = j.get("WEBGL_lose_context");
            t && t.restoreContext();
          }),
          (this.getPixelRatio = function () {
            return P;
          }),
          (this.setPixelRatio = function (t) {
            void 0 !== t && ((P = t), this.setSize(R, L, !1));
          }),
          (this.getSize = function (t) {
            return t.set(R, L);
          }),
          (this.setSize = function (t, n, i) {
            _t.isPresenting
              ? console.warn(
                  "THREE.WebGLRenderer: Can't change size while VR device is presenting."
                )
              : ((R = t),
                (L = n),
                (e.width = Math.floor(t * P)),
                (e.height = Math.floor(n * P)),
                !1 !== i &&
                  ((e.style.width = t + "px"), (e.style.height = n + "px")),
                this.setViewport(0, 0, t, n));
          }),
          (this.getDrawingBufferSize = function (t) {
            return t.set(R * P, L * P).floor();
          }),
          (this.setDrawingBufferSize = function (t, n, i) {
            (R = t),
              (L = n),
              (P = i),
              (e.width = Math.floor(t * i)),
              (e.height = Math.floor(n * i)),
              this.setViewport(0, 0, t, n);
          }),
          (this.getCurrentViewport = function (t) {
            return t.copy(T);
          }),
          (this.getViewport = function (t) {
            return t.copy(O);
          }),
          (this.setViewport = function (t, e, n, i) {
            t.isVector4 ? O.set(t.x, t.y, t.z, t.w) : O.set(t, e, n, i),
              X.viewport(T.copy(O).multiplyScalar(P).floor());
          }),
          (this.getScissor = function (t) {
            return t.copy(N);
          }),
          (this.setScissor = function (t, e, n, i) {
            t.isVector4 ? N.set(t.x, t.y, t.z, t.w) : N.set(t, e, n, i),
              X.scissor(A.copy(N).multiplyScalar(P).floor());
          }),
          (this.getScissorTest = function () {
            return B;
          }),
          (this.setScissorTest = function (t) {
            X.setScissorTest((B = t));
          }),
          (this.setOpaqueSort = function (t) {
            D = t;
          }),
          (this.setTransparentSort = function (t) {
            I = t;
          }),
          (this.getClearColor = function (t) {
            return t.copy(lt.getClearColor());
          }),
          (this.setClearColor = function () {
            lt.setClearColor.apply(lt, arguments);
          }),
          (this.getClearAlpha = function () {
            return lt.getClearAlpha();
          }),
          (this.setClearAlpha = function () {
            lt.setClearAlpha.apply(lt, arguments);
          }),
          (this.clear = function (t, e, n) {
            let i = 0;
            (void 0 === t || t) && (i |= 16384),
              (void 0 === e || e) && (i |= 256),
              (void 0 === n || n) && (i |= 1024),
              vt.clear(i);
          }),
          (this.clearColor = function () {
            this.clear(!0, !1, !1);
          }),
          (this.clearDepth = function () {
            this.clear(!1, !0, !1);
          }),
          (this.clearStencil = function () {
            this.clear(!1, !1, !0);
          }),
          (this.dispose = function () {
            e.removeEventListener("webglcontextlost", Mt, !1),
              e.removeEventListener("webglcontextrestored", St, !1),
              at.dispose(),
              ot.dispose(),
              J.dispose(),
              K.dispose(),
              $.dispose(),
              nt.dispose(),
              mt.dispose(),
              it.dispose(),
              _t.dispose(),
              _t.removeEventListener("sessionstart", Dt),
              _t.removeEventListener("sessionend", It),
              H && (H.dispose(), (H = null)),
              Ot.stop();
          }),
          (this.renderBufferDirect = function (t, e, n, i, r, a) {
            null === e && (e = V);
            const o = r.isMesh && r.matrixWorld.determinant() < 0,
              s = Vt(t, e, n, i, r);
            X.setMaterial(i, o);
            let c = n.index;
            const l = n.attributes.position;
            if (null === c) {
              if (void 0 === l || 0 === l.count) return;
            } else if (0 === c.count) return;
            let h,
              u = 1;
            !0 === i.wireframe && ((c = et.getWireframeAttribute(n)), (u = 2)),
              mt.setup(r, i, s, n, c);
            let d = ut;
            null !== c && ((h = Q.get(c)), (d = dt), d.setIndex(h));
            const p = null !== c ? c.count : l.count,
              f = n.drawRange.start * u,
              m = n.drawRange.count * u,
              g = null !== a ? a.start * u : 0,
              v = null !== a ? a.count * u : 1 / 0,
              y = Math.max(f, g),
              x = Math.min(p, f + m, g + v) - 1,
              _ = Math.max(0, x - y + 1);
            if (0 !== _) {
              if (r.isMesh)
                !0 === i.wireframe
                  ? (X.setLineWidth(i.wireframeLinewidth * W()), d.setMode(1))
                  : d.setMode(4);
              else if (r.isLine) {
                let t = i.linewidth;
                void 0 === t && (t = 1),
                  X.setLineWidth(t * W()),
                  r.isLineSegments
                    ? d.setMode(1)
                    : r.isLineLoop
                    ? d.setMode(2)
                    : d.setMode(3);
              } else r.isPoints ? d.setMode(0) : r.isSprite && d.setMode(4);
              if (r.isInstancedMesh) d.renderInstances(y, _, r.count);
              else if (n.isInstancedBufferGeometry) {
                const t = Math.min(n.instanceCount, n._maxInstanceCount);
                d.renderInstances(y, _, t);
              } else d.render(y, _);
            }
          }),
          (this.compile = function (t, e) {
            (p = ot.get(t)),
              p.init(),
              m.push(p),
              t.traverseVisible(function (t) {
                t.isLight &&
                  t.layers.test(e.layers) &&
                  (p.pushLight(t), t.castShadow && p.pushShadow(t));
              }),
              p.setupLights(x.physicallyCorrectLights),
              t.traverse(function (e) {
                const n = e.material;
                if (n)
                  if (Array.isArray(n))
                    for (let i = 0; i < n.length; i++) {
                      const r = n[i];
                      kt(r, t, e);
                    }
                  else kt(n, t, e);
              }),
              m.pop(),
              (p = null);
          });
        let Lt = null;
        function Pt(t) {
          Lt && Lt(t);
        }
        function Dt() {
          Ot.stop();
        }
        function It() {
          Ot.start();
        }
        const Ot = new kr();
        function Bt(t, e, n, i) {
          if (!1 === t.visible) return;
          const r = t.layers.test(e.layers);
          if (r)
            if (t.isGroup) n = t.renderOrder;
            else if (t.isLOD) !0 === t.autoUpdate && t.update(e);
            else if (t.isLight) p.pushLight(t), t.castShadow && p.pushShadow(t);
            else if (t.isSprite) {
              if (!t.frustumCulled || z.intersectsSprite(t)) {
                i && G.setFromMatrixPosition(t.matrixWorld).applyMatrix4(k);
                const e = nt.update(t),
                  r = t.material;
                r.visible && d.push(t, e, r, n, G.z, null);
              }
            } else if (
              (t.isMesh || t.isLine || t.isPoints) &&
              (t.isSkinnedMesh &&
                t.skeleton.frame !== Y.render.frame &&
                (t.skeleton.update(), (t.skeleton.frame = Y.render.frame)),
              !t.frustumCulled || z.intersectsObject(t))
            ) {
              i && G.setFromMatrixPosition(t.matrixWorld).applyMatrix4(k);
              const e = nt.update(t),
                r = t.material;
              if (Array.isArray(r)) {
                const i = e.groups;
                for (let a = 0, o = i.length; a < o; a++) {
                  const o = i[a],
                    s = r[o.materialIndex];
                  s && s.visible && d.push(t, e, s, n, G.z, o);
                }
              } else r.visible && d.push(t, e, r, n, G.z, null);
            }
          const a = t.children;
          for (let o = 0, s = a.length; o < s; o++) Bt(a[o], e, n, i);
        }
        function zt(t, e, n, i) {
          const r = t.opaque,
            a = t.transmissive,
            o = t.transparent;
          p.setupLightsView(n),
            a.length > 0 && Ut(r, e, n),
            i && X.viewport(T.copy(i)),
            r.length > 0 && Ft(r, e, n),
            a.length > 0 && Ft(a, e, n),
            o.length > 0 && Ft(o, e, n);
        }
        function Ut(t, e, n) {
          if (null === H) {
            const t = !0 === o && !0 === q.isWebGL2,
              e = t ? _n : yn;
            H = new e(1024, 1024, {
              generateMipmaps: !0,
              type: null !== pt.convert(Rt) ? Rt : wt,
              minFilter: bt,
              magFilter: gt,
              wrapS: ft,
              wrapT: ft,
              useRenderToTexture: j.has("WEBGL_multisampled_render_to_texture"),
            });
          }
          const i = x.getRenderTarget();
          x.setRenderTarget(H), x.clear();
          const r = x.toneMapping;
          (x.toneMapping = tt),
            Ft(t, e, n),
            (x.toneMapping = r),
            Z.updateMultisampleRenderTarget(H),
            Z.updateRenderTargetMipmap(H),
            x.setRenderTarget(i);
        }
        function Ft(t, e, n) {
          const i = !0 === e.isScene ? e.overrideMaterial : null;
          for (let r = 0, a = t.length; r < a; r++) {
            const a = t[r],
              o = a.object,
              s = a.geometry,
              c = null === i ? a.material : i,
              l = a.group;
            o.layers.test(n.layers) && Ht(o, e, n, s, c, l);
          }
        }
        function Ht(t, e, n, i, r, a) {
          t.onBeforeRender(x, e, n, i, r, a),
            t.modelViewMatrix.multiplyMatrices(
              n.matrixWorldInverse,
              t.matrixWorld
            ),
            t.normalMatrix.getNormalMatrix(t.modelViewMatrix),
            r.onBeforeRender(x, e, n, i, t, a),
            !0 === r.transparent && r.side === y
              ? ((r.side = v),
                (r.needsUpdate = !0),
                x.renderBufferDirect(n, e, i, r, t, a),
                (r.side = g),
                (r.needsUpdate = !0),
                x.renderBufferDirect(n, e, i, r, t, a),
                (r.side = y))
              : x.renderBufferDirect(n, e, i, r, t, a),
            t.onAfterRender(x, e, n, i, r, a);
        }
        function kt(t, e, n) {
          !0 !== e.isScene && (e = V);
          const i = J.get(t),
            r = p.state.lights,
            a = p.state.shadowsArray,
            o = r.state.version,
            s = it.getParameters(t, r.state, a, e, n),
            c = it.getProgramCacheKey(s);
          let l = i.programs;
          (i.environment = t.isMeshStandardMaterial ? e.environment : null),
            (i.fog = e.fog),
            (i.envMap = (t.isMeshStandardMaterial ? $ : K).get(
              t.envMap || i.environment
            )),
            void 0 === l &&
              (t.addEventListener("dispose", Et),
              (l = new Map()),
              (i.programs = l));
          let h = l.get(c);
          if (void 0 !== h) {
            if (i.currentProgram === h && i.lightsStateVersion === o)
              return Gt(t, s), h;
          } else
            (s.uniforms = it.getUniforms(t)),
              t.onBuild(n, s, x),
              t.onBeforeCompile(s, x),
              (h = it.acquireProgram(s, c)),
              l.set(c, h),
              (i.uniforms = s.uniforms);
          const u = i.uniforms;
          ((t.isShaderMaterial || t.isRawShaderMaterial) &&
            !0 !== t.clipping) ||
            (u.clippingPlanes = st.uniform),
            Gt(t, s),
            (i.needsLights = jt(t)),
            (i.lightsStateVersion = o),
            i.needsLights &&
              ((u.ambientLightColor.value = r.state.ambient),
              (u.lightProbe.value = r.state.probe),
              (u.directionalLights.value = r.state.directional),
              (u.directionalLightShadows.value = r.state.directionalShadow),
              (u.spotLights.value = r.state.spot),
              (u.spotLightShadows.value = r.state.spotShadow),
              (u.rectAreaLights.value = r.state.rectArea),
              (u.ltc_1.value = r.state.rectAreaLTC1),
              (u.ltc_2.value = r.state.rectAreaLTC2),
              (u.pointLights.value = r.state.point),
              (u.pointLightShadows.value = r.state.pointShadow),
              (u.hemisphereLights.value = r.state.hemi),
              (u.directionalShadowMap.value = r.state.directionalShadowMap),
              (u.directionalShadowMatrix.value =
                r.state.directionalShadowMatrix),
              (u.spotShadowMap.value = r.state.spotShadowMap),
              (u.spotShadowMatrix.value = r.state.spotShadowMatrix),
              (u.pointShadowMap.value = r.state.pointShadowMap),
              (u.pointShadowMatrix.value = r.state.pointShadowMatrix));
          const d = h.getUniforms(),
            f = fl.seqWithValue(d.seq, u);
          return (i.currentProgram = h), (i.uniformsList = f), h;
        }
        function Gt(t, e) {
          const n = J.get(t);
          (n.outputEncoding = e.outputEncoding),
            (n.instancing = e.instancing),
            (n.skinning = e.skinning),
            (n.morphTargets = e.morphTargets),
            (n.morphNormals = e.morphNormals),
            (n.morphTargetsCount = e.morphTargetsCount),
            (n.numClippingPlanes = e.numClippingPlanes),
            (n.numIntersection = e.numClipIntersection),
            (n.vertexAlphas = e.vertexAlphas),
            (n.vertexTangents = e.vertexTangents),
            (n.toneMapping = e.toneMapping);
        }
        function Vt(t, e, n, i, r) {
          !0 !== e.isScene && (e = V), Z.resetTextureUnits();
          const a = e.fog,
            o = i.isMeshStandardMaterial ? e.environment : null,
            s =
              null === M
                ? x.outputEncoding
                : !0 === M.isXRRenderTarget
                ? M.texture.encoding
                : Re,
            c = (i.isMeshStandardMaterial ? $ : K).get(i.envMap || o),
            l =
              !0 === i.vertexColors &&
              !!n.attributes.color &&
              4 === n.attributes.color.itemSize,
            h = !!i.normalMap && !!n.attributes.tangent,
            u = !!n.morphAttributes.position,
            d = !!n.morphAttributes.normal,
            f = n.morphAttributes.position
              ? n.morphAttributes.position.length
              : 0,
            m = i.toneMapped ? x.toneMapping : tt,
            g = J.get(i),
            v = p.state.lights;
          if (!0 === U && (!0 === F || t !== E)) {
            const e = t === E && i.id === S;
            st.setState(i, t, e);
          }
          let y = !1;
          i.version === g.__version
            ? (g.needsLights && g.lightsStateVersion !== v.state.version) ||
              g.outputEncoding !== s ||
              (r.isInstancedMesh && !1 === g.instancing)
              ? (y = !0)
              : r.isInstancedMesh || !0 !== g.instancing
              ? r.isSkinnedMesh && !1 === g.skinning
                ? (y = !0)
                : r.isSkinnedMesh || !0 !== g.skinning
                ? g.envMap !== c || (i.fog && g.fog !== a)
                  ? (y = !0)
                  : void 0 === g.numClippingPlanes ||
                    (g.numClippingPlanes === st.numPlanes &&
                      g.numIntersection === st.numIntersection)
                  ? (g.vertexAlphas !== l ||
                      g.vertexTangents !== h ||
                      g.morphTargets !== u ||
                      g.morphNormals !== d ||
                      g.toneMapping !== m ||
                      (!0 === q.isWebGL2 && g.morphTargetsCount !== f)) &&
                    (y = !0)
                  : (y = !0)
                : (y = !0)
              : (y = !0)
            : ((y = !0), (g.__version = i.version));
          let _ = g.currentProgram;
          !0 === y && (_ = kt(i, e, r));
          let b = !1,
            w = !1,
            T = !1;
          const A = _.getUniforms(),
            C = g.uniforms;
          if (
            (X.useProgram(_.program) && ((b = !0), (w = !0), (T = !0)),
            i.id !== S && ((S = i.id), (w = !0)),
            b || E !== t)
          ) {
            if (
              (A.setValue(vt, "projectionMatrix", t.projectionMatrix),
              q.logarithmicDepthBuffer &&
                A.setValue(
                  vt,
                  "logDepthBufFC",
                  2 / (Math.log(t.far + 1) / Math.LN2)
                ),
              E !== t && ((E = t), (w = !0), (T = !0)),
              i.isShaderMaterial ||
                i.isMeshPhongMaterial ||
                i.isMeshToonMaterial ||
                i.isMeshStandardMaterial ||
                i.envMap)
            ) {
              const e = A.map.cameraPosition;
              void 0 !== e &&
                e.setValue(vt, G.setFromMatrixPosition(t.matrixWorld));
            }
            (i.isMeshPhongMaterial ||
              i.isMeshToonMaterial ||
              i.isMeshLambertMaterial ||
              i.isMeshBasicMaterial ||
              i.isMeshStandardMaterial ||
              i.isShaderMaterial) &&
              A.setValue(vt, "isOrthographic", !0 === t.isOrthographicCamera),
              (i.isMeshPhongMaterial ||
                i.isMeshToonMaterial ||
                i.isMeshLambertMaterial ||
                i.isMeshBasicMaterial ||
                i.isMeshStandardMaterial ||
                i.isShaderMaterial ||
                i.isShadowMaterial ||
                r.isSkinnedMesh) &&
                A.setValue(vt, "viewMatrix", t.matrixWorldInverse);
          }
          if (r.isSkinnedMesh) {
            A.setOptional(vt, r, "bindMatrix"),
              A.setOptional(vt, r, "bindMatrixInverse");
            const t = r.skeleton;
            t &&
              (q.floatVertexTextures
                ? (null === t.boneTexture && t.computeBoneTexture(),
                  A.setValue(vt, "boneTexture", t.boneTexture, Z),
                  A.setValue(vt, "boneTextureSize", t.boneTextureSize))
                : A.setOptional(vt, t, "boneMatrices"));
          }
          return (
            !n ||
              (void 0 === n.morphAttributes.position &&
                void 0 === n.morphAttributes.normal) ||
              ht.update(r, n, i, _),
            (w || g.receiveShadow !== r.receiveShadow) &&
              ((g.receiveShadow = r.receiveShadow),
              A.setValue(vt, "receiveShadow", r.receiveShadow)),
            w &&
              (A.setValue(vt, "toneMappingExposure", x.toneMappingExposure),
              g.needsLights && Wt(C, T),
              a && i.fog && rt.refreshFogUniforms(C, a),
              rt.refreshMaterialUniforms(C, i, P, L, H),
              fl.upload(vt, g.uniformsList, C, Z)),
            i.isShaderMaterial &&
              !0 === i.uniformsNeedUpdate &&
              (fl.upload(vt, g.uniformsList, C, Z),
              (i.uniformsNeedUpdate = !1)),
            i.isSpriteMaterial && A.setValue(vt, "center", r.center),
            A.setValue(vt, "modelViewMatrix", r.modelViewMatrix),
            A.setValue(vt, "normalMatrix", r.normalMatrix),
            A.setValue(vt, "modelMatrix", r.matrixWorld),
            _
          );
        }
        function Wt(t, e) {
          (t.ambientLightColor.needsUpdate = e),
            (t.lightProbe.needsUpdate = e),
            (t.directionalLights.needsUpdate = e),
            (t.directionalLightShadows.needsUpdate = e),
            (t.pointLights.needsUpdate = e),
            (t.pointLightShadows.needsUpdate = e),
            (t.spotLights.needsUpdate = e),
            (t.spotLightShadows.needsUpdate = e),
            (t.rectAreaLights.needsUpdate = e),
            (t.hemisphereLights.needsUpdate = e);
        }
        function jt(t) {
          return (
            t.isMeshLambertMaterial ||
            t.isMeshToonMaterial ||
            t.isMeshPhongMaterial ||
            t.isMeshStandardMaterial ||
            t.isShadowMaterial ||
            (t.isShaderMaterial && !0 === t.lights)
          );
        }
        Ot.setAnimationLoop(Pt),
          "undefined" !== typeof window && Ot.setContext(window),
          (this.setAnimationLoop = function (t) {
            (Lt = t),
              _t.setAnimationLoop(t),
              null === t ? Ot.stop() : Ot.start();
          }),
          _t.addEventListener("sessionstart", Dt),
          _t.addEventListener("sessionend", It),
          (this.render = function (t, e) {
            if (void 0 !== e && !0 !== e.isCamera)
              return void console.error(
                "THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera."
              );
            if (!0 === _) return;
            !0 === t.autoUpdate && t.updateMatrixWorld(),
              null === e.parent && e.updateMatrixWorld(),
              !0 === _t.enabled &&
                !0 === _t.isPresenting &&
                (!0 === _t.cameraAutoUpdate && _t.updateCamera(e),
                (e = _t.getCamera())),
              !0 === t.isScene && t.onBeforeRender(x, t, e, M),
              (p = ot.get(t, m.length)),
              p.init(),
              m.push(p),
              k.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse),
              z.setFromProjectionMatrix(k),
              (F = this.localClippingEnabled),
              (U = st.init(this.clippingPlanes, F, e)),
              (d = at.get(t, f.length)),
              d.init(),
              f.push(d),
              Bt(t, e, 0, x.sortObjects),
              d.finish(),
              !0 === x.sortObjects && d.sort(D, I),
              !0 === U && st.beginShadows();
            const n = p.state.shadowsArray;
            if (
              (ct.render(n, t, e),
              !0 === U && st.endShadows(),
              !0 === this.info.autoReset && this.info.reset(),
              lt.render(d, t),
              p.setupLights(x.physicallyCorrectLights),
              e.isArrayCamera)
            ) {
              const n = e.cameras;
              for (let e = 0, i = n.length; e < i; e++) {
                const i = n[e];
                zt(d, t, i, i.viewport);
              }
            } else zt(d, t, e);
            null !== M &&
              (Z.updateMultisampleRenderTarget(M),
              Z.updateRenderTargetMipmap(M)),
              !0 === t.isScene && t.onAfterRender(x, t, e),
              X.buffers.depth.setTest(!0),
              X.buffers.depth.setMask(!0),
              X.buffers.color.setMask(!0),
              X.setPolygonOffset(!1),
              mt.resetDefaultState(),
              (S = -1),
              (E = null),
              m.pop(),
              (p = m.length > 0 ? m[m.length - 1] : null),
              f.pop(),
              (d = f.length > 0 ? f[f.length - 1] : null);
          }),
          (this.getActiveCubeFace = function () {
            return b;
          }),
          (this.getActiveMipmapLevel = function () {
            return w;
          }),
          (this.getRenderTarget = function () {
            return M;
          }),
          (this.setRenderTargetTextures = function (t, e, n) {
            (J.get(t.texture).__webglTexture = e),
              (J.get(t.depthTexture).__webglTexture = n);
            const i = J.get(t);
            (i.__hasExternalTextures = !0),
              i.__hasExternalTextures &&
                ((i.__autoAllocateDepthBuffer = void 0 === n),
                i.__autoAllocateDepthBuffer ||
                  (t.useRenderToTexture &&
                    (console.warn(
                      "render-to-texture extension was disabled because an external texture was provided"
                    ),
                    (t.useRenderToTexture = !1),
                    (t.useRenderbuffer = !0))));
          }),
          (this.setRenderTargetFramebuffer = function (t, e) {
            const n = J.get(t);
            (n.__webglFramebuffer = e),
              (n.__useDefaultFramebuffer = void 0 === e);
          }),
          (this.setRenderTarget = function (t, e = 0, n = 0) {
            (M = t), (b = e), (w = n);
            let i = !0;
            if (t) {
              const e = J.get(t);
              void 0 !== e.__useDefaultFramebuffer
                ? (X.bindFramebuffer(36160, null), (i = !1))
                : void 0 === e.__webglFramebuffer
                ? Z.setupRenderTarget(t)
                : e.__hasExternalTextures &&
                  Z.rebindTextures(
                    t,
                    J.get(t.texture).__webglTexture,
                    J.get(t.depthTexture).__webglTexture
                  );
            }
            let r = null,
              a = !1,
              o = !1;
            if (t) {
              const n = t.texture;
              (n.isDataTexture3D || n.isDataTexture2DArray) && (o = !0);
              const i = J.get(t).__webglFramebuffer;
              t.isWebGLCubeRenderTarget
                ? ((r = i[e]), (a = !0))
                : (r = t.useRenderbuffer
                    ? J.get(t).__webglMultisampledFramebuffer
                    : i),
                T.copy(t.viewport),
                A.copy(t.scissor),
                (C = t.scissorTest);
            } else
              T.copy(O).multiplyScalar(P).floor(),
                A.copy(N).multiplyScalar(P).floor(),
                (C = B);
            const s = X.bindFramebuffer(36160, r);
            if (
              (s && q.drawBuffers && i && X.drawBuffers(t, r),
              X.viewport(T),
              X.scissor(A),
              X.setScissorTest(C),
              a)
            ) {
              const i = J.get(t.texture);
              vt.framebufferTexture2D(
                36160,
                36064,
                34069 + e,
                i.__webglTexture,
                n
              );
            } else if (o) {
              const i = J.get(t.texture),
                r = e || 0;
              vt.framebufferTextureLayer(
                36160,
                36064,
                i.__webglTexture,
                n || 0,
                r
              );
            }
            S = -1;
          }),
          (this.readRenderTargetPixels = function (t, e, n, i, r, a, o) {
            if (!t || !t.isWebGLRenderTarget)
              return void console.error(
                "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget."
              );
            let s = J.get(t).__webglFramebuffer;
            if ((t.isWebGLCubeRenderTarget && void 0 !== o && (s = s[o]), s)) {
              X.bindFramebuffer(36160, s);
              try {
                const o = t.texture,
                  s = o.format,
                  c = o.type;
                if (s !== Nt && pt.convert(s) !== vt.getParameter(35739))
                  return void console.error(
                    "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format."
                  );
                const l =
                  c === Rt &&
                  (j.has("EXT_color_buffer_half_float") ||
                    (q.isWebGL2 && j.has("EXT_color_buffer_float")));
                if (
                  c !== wt &&
                  pt.convert(c) !== vt.getParameter(35738) &&
                  (c !== Ct ||
                    !(
                      q.isWebGL2 ||
                      j.has("OES_texture_float") ||
                      j.has("WEBGL_color_buffer_float")
                    )) &&
                  !l
                )
                  return void console.error(
                    "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type."
                  );
                36053 === vt.checkFramebufferStatus(36160)
                  ? e >= 0 &&
                    e <= t.width - i &&
                    n >= 0 &&
                    n <= t.height - r &&
                    vt.readPixels(e, n, i, r, pt.convert(s), pt.convert(c), a)
                  : console.error(
                      "THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete."
                    );
              } finally {
                const t = null !== M ? J.get(M).__webglFramebuffer : null;
                X.bindFramebuffer(36160, t);
              }
            }
          }),
          (this.copyFramebufferToTexture = function (t, e, n = 0) {
            if (!0 !== e.isFramebufferTexture)
              return void console.error(
                "THREE.WebGLRenderer: copyFramebufferToTexture() can only be used with FramebufferTexture."
              );
            const i = Math.pow(2, -n),
              r = Math.floor(e.image.width * i),
              a = Math.floor(e.image.height * i);
            Z.setTexture2D(e, 0),
              vt.copyTexSubImage2D(3553, n, 0, 0, t.x, t.y, r, a),
              X.unbindTexture();
          }),
          (this.copyTextureToTexture = function (t, e, n, i = 0) {
            const r = e.image.width,
              a = e.image.height,
              o = pt.convert(n.format),
              s = pt.convert(n.type);
            Z.setTexture2D(n, 0),
              vt.pixelStorei(37440, n.flipY),
              vt.pixelStorei(37441, n.premultiplyAlpha),
              vt.pixelStorei(3317, n.unpackAlignment),
              e.isDataTexture
                ? vt.texSubImage2D(3553, i, t.x, t.y, r, a, o, s, e.image.data)
                : e.isCompressedTexture
                ? vt.compressedTexSubImage2D(
                    3553,
                    i,
                    t.x,
                    t.y,
                    e.mipmaps[0].width,
                    e.mipmaps[0].height,
                    o,
                    e.mipmaps[0].data
                  )
                : vt.texSubImage2D(3553, i, t.x, t.y, o, s, e.image),
              0 === i && n.generateMipmaps && vt.generateMipmap(3553),
              X.unbindTexture();
          }),
          (this.copyTextureToTexture3D = function (t, e, n, i, r = 0) {
            if (x.isWebGL1Renderer)
              return void console.warn(
                "THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2."
              );
            const a = t.max.x - t.min.x + 1,
              o = t.max.y - t.min.y + 1,
              s = t.max.z - t.min.z + 1,
              c = pt.convert(i.format),
              l = pt.convert(i.type);
            let h;
            if (i.isDataTexture3D) Z.setTexture3D(i, 0), (h = 32879);
            else {
              if (!i.isDataTexture2DArray)
                return void console.warn(
                  "THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray."
                );
              Z.setTexture2DArray(i, 0), (h = 35866);
            }
            vt.pixelStorei(37440, i.flipY),
              vt.pixelStorei(37441, i.premultiplyAlpha),
              vt.pixelStorei(3317, i.unpackAlignment);
            const u = vt.getParameter(3314),
              d = vt.getParameter(32878),
              p = vt.getParameter(3316),
              f = vt.getParameter(3315),
              m = vt.getParameter(32877),
              g = n.isCompressedTexture ? n.mipmaps[0] : n.image;
            vt.pixelStorei(3314, g.width),
              vt.pixelStorei(32878, g.height),
              vt.pixelStorei(3316, t.min.x),
              vt.pixelStorei(3315, t.min.y),
              vt.pixelStorei(32877, t.min.z),
              n.isDataTexture || n.isDataTexture3D
                ? vt.texSubImage3D(h, r, e.x, e.y, e.z, a, o, s, c, l, g.data)
                : n.isCompressedTexture
                ? (console.warn(
                    "THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."
                  ),
                  vt.compressedTexSubImage3D(
                    h,
                    r,
                    e.x,
                    e.y,
                    e.z,
                    a,
                    o,
                    s,
                    c,
                    g.data
                  ))
                : vt.texSubImage3D(h, r, e.x, e.y, e.z, a, o, s, c, l, g),
              vt.pixelStorei(3314, u),
              vt.pixelStorei(32878, d),
              vt.pixelStorei(3316, p),
              vt.pixelStorei(3315, f),
              vt.pixelStorei(32877, m),
              0 === r && i.generateMipmaps && vt.generateMipmap(h),
              X.unbindTexture();
          }),
          (this.initTexture = function (t) {
            Z.setTexture2D(t, 0), X.unbindTexture();
          }),
          (this.resetState = function () {
            (b = 0), (w = 0), (M = null), X.reset(), mt.reset();
          }),
          "undefined" !== typeof __THREE_DEVTOOLS__ &&
            __THREE_DEVTOOLS__.dispatchEvent(
              new CustomEvent("observe", { detail: this })
            );
      }
      _h.prototype.isWebGLRenderer = !0;
      class bh extends _h {}
      bh.prototype.isWebGL1Renderer = !0;
      class wh {
        constructor(t, e = 25e-5) {
          (this.name = ""), (this.color = new un(t)), (this.density = e);
        }
        clone() {
          return new wh(this.color, this.density);
        }
        toJSON() {
          return {
            type: "FogExp2",
            color: this.color.getHex(),
            density: this.density,
          };
        }
      }
      wh.prototype.isFogExp2 = !0;
      class Mh {
        constructor(t, e = 1, n = 1e3) {
          (this.name = ""),
            (this.color = new un(t)),
            (this.near = e),
            (this.far = n);
        }
        clone() {
          return new Mh(this.color, this.near, this.far);
        }
        toJSON() {
          return {
            type: "Fog",
            color: this.color.getHex(),
            near: this.near,
            far: this.far,
          };
        }
      }
      Mh.prototype.isFog = !0;
      class Sh extends Si {
        constructor() {
          super(),
            (this.type = "Scene"),
            (this.background = null),
            (this.environment = null),
            (this.fog = null),
            (this.overrideMaterial = null),
            (this.autoUpdate = !0),
            "undefined" !== typeof __THREE_DEVTOOLS__ &&
              __THREE_DEVTOOLS__.dispatchEvent(
                new CustomEvent("observe", { detail: this })
              );
        }
        copy(t, e) {
          return (
            super.copy(t, e),
            null !== t.background && (this.background = t.background.clone()),
            null !== t.environment &&
              (this.environment = t.environment.clone()),
            null !== t.fog && (this.fog = t.fog.clone()),
            null !== t.overrideMaterial &&
              (this.overrideMaterial = t.overrideMaterial.clone()),
            (this.autoUpdate = t.autoUpdate),
            (this.matrixAutoUpdate = t.matrixAutoUpdate),
            this
          );
        }
        toJSON(t) {
          const e = super.toJSON(t);
          return null !== this.fog && (e.object.fog = this.fog.toJSON()), e;
        }
      }
      Sh.prototype.isScene = !0;
      class Eh {
        constructor(t, e) {
          (this.array = t),
            (this.stride = e),
            (this.count = void 0 !== t ? t.length / e : 0),
            (this.usage = ze),
            (this.updateRange = { offset: 0, count: -1 }),
            (this.version = 0),
            (this.uuid = je());
        }
        onUploadCallback() {}
        set needsUpdate(t) {
          !0 === t && this.version++;
        }
        setUsage(t) {
          return (this.usage = t), this;
        }
        copy(t) {
          return (
            (this.array = new t.array.constructor(t.array)),
            (this.count = t.count),
            (this.stride = t.stride),
            (this.usage = t.usage),
            this
          );
        }
        copyAt(t, e, n) {
          (t *= this.stride), (n *= e.stride);
          for (let i = 0, r = this.stride; i < r; i++)
            this.array[t + i] = e.array[n + i];
          return this;
        }
        set(t, e = 0) {
          return this.array.set(t, e), this;
        }
        clone(t) {
          void 0 === t.arrayBuffers && (t.arrayBuffers = {}),
            void 0 === this.array.buffer._uuid &&
              (this.array.buffer._uuid = je()),
            void 0 === t.arrayBuffers[this.array.buffer._uuid] &&
              (t.arrayBuffers[this.array.buffer._uuid] =
                this.array.slice(0).buffer);
          const e = new this.array.constructor(
              t.arrayBuffers[this.array.buffer._uuid]
            ),
            n = new this.constructor(e, this.stride);
          return n.setUsage(this.usage), n;
        }
        onUpload(t) {
          return (this.onUploadCallback = t), this;
        }
        toJSON(t) {
          return (
            void 0 === t.arrayBuffers && (t.arrayBuffers = {}),
            void 0 === this.array.buffer._uuid &&
              (this.array.buffer._uuid = je()),
            void 0 === t.arrayBuffers[this.array.buffer._uuid] &&
              (t.arrayBuffers[this.array.buffer._uuid] =
                Array.prototype.slice.call(new Uint32Array(this.array.buffer))),
            {
              uuid: this.uuid,
              buffer: this.array.buffer._uuid,
              type: this.array.constructor.name,
              stride: this.stride,
            }
          );
        }
      }
      Eh.prototype.isInterleavedBuffer = !0;
      const Th = new wn();
      class Ah {
        constructor(t, e, n, i = !1) {
          (this.name = ""),
            (this.data = t),
            (this.itemSize = e),
            (this.offset = n),
            (this.normalized = !0 === i);
        }
        get count() {
          return this.data.count;
        }
        get array() {
          return this.data.array;
        }
        set needsUpdate(t) {
          this.data.needsUpdate = t;
        }
        applyMatrix4(t) {
          for (let e = 0, n = this.data.count; e < n; e++)
            (Th.x = this.getX(e)),
              (Th.y = this.getY(e)),
              (Th.z = this.getZ(e)),
              Th.applyMatrix4(t),
              this.setXYZ(e, Th.x, Th.y, Th.z);
          return this;
        }
        applyNormalMatrix(t) {
          for (let e = 0, n = this.count; e < n; e++)
            (Th.x = this.getX(e)),
              (Th.y = this.getY(e)),
              (Th.z = this.getZ(e)),
              Th.applyNormalMatrix(t),
              this.setXYZ(e, Th.x, Th.y, Th.z);
          return this;
        }
        transformDirection(t) {
          for (let e = 0, n = this.count; e < n; e++)
            (Th.x = this.getX(e)),
              (Th.y = this.getY(e)),
              (Th.z = this.getZ(e)),
              Th.transformDirection(t),
              this.setXYZ(e, Th.x, Th.y, Th.z);
          return this;
        }
        setX(t, e) {
          return (
            (this.data.array[t * this.data.stride + this.offset] = e), this
          );
        }
        setY(t, e) {
          return (
            (this.data.array[t * this.data.stride + this.offset + 1] = e), this
          );
        }
        setZ(t, e) {
          return (
            (this.data.array[t * this.data.stride + this.offset + 2] = e), this
          );
        }
        setW(t, e) {
          return (
            (this.data.array[t * this.data.stride + this.offset + 3] = e), this
          );
        }
        getX(t) {
          return this.data.array[t * this.data.stride + this.offset];
        }
        getY(t) {
          return this.data.array[t * this.data.stride + this.offset + 1];
        }
        getZ(t) {
          return this.data.array[t * this.data.stride + this.offset + 2];
        }
        getW(t) {
          return this.data.array[t * this.data.stride + this.offset + 3];
        }
        setXY(t, e, n) {
          return (
            (t = t * this.data.stride + this.offset),
            (this.data.array[t + 0] = e),
            (this.data.array[t + 1] = n),
            this
          );
        }
        setXYZ(t, e, n, i) {
          return (
            (t = t * this.data.stride + this.offset),
            (this.data.array[t + 0] = e),
            (this.data.array[t + 1] = n),
            (this.data.array[t + 2] = i),
            this
          );
        }
        setXYZW(t, e, n, i, r) {
          return (
            (t = t * this.data.stride + this.offset),
            (this.data.array[t + 0] = e),
            (this.data.array[t + 1] = n),
            (this.data.array[t + 2] = i),
            (this.data.array[t + 3] = r),
            this
          );
        }
        clone(t) {
          if (void 0 === t) {
            console.log(
              "THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data."
            );
            const t = [];
            for (let e = 0; e < this.count; e++) {
              const n = e * this.data.stride + this.offset;
              for (let e = 0; e < this.itemSize; e++)
                t.push(this.data.array[n + e]);
            }
            return new ki(
              new this.array.constructor(t),
              this.itemSize,
              this.normalized
            );
          }
          return (
            void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}),
            void 0 === t.interleavedBuffers[this.data.uuid] &&
              (t.interleavedBuffers[this.data.uuid] = this.data.clone(t)),
            new Ah(
              t.interleavedBuffers[this.data.uuid],
              this.itemSize,
              this.offset,
              this.normalized
            )
          );
        }
        toJSON(t) {
          if (void 0 === t) {
            console.log(
              "THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data."
            );
            const t = [];
            for (let e = 0; e < this.count; e++) {
              const n = e * this.data.stride + this.offset;
              for (let e = 0; e < this.itemSize; e++)
                t.push(this.data.array[n + e]);
            }
            return {
              itemSize: this.itemSize,
              type: this.array.constructor.name,
              array: t,
              normalized: this.normalized,
            };
          }
          return (
            void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}),
            void 0 === t.interleavedBuffers[this.data.uuid] &&
              (t.interleavedBuffers[this.data.uuid] = this.data.toJSON(t)),
            {
              isInterleavedBufferAttribute: !0,
              itemSize: this.itemSize,
              data: this.data.uuid,
              offset: this.offset,
              normalized: this.normalized,
            }
          );
        }
      }
      Ah.prototype.isInterleavedBufferAttribute = !0;
      class Ch extends zi {
        constructor(t) {
          super(),
            (this.type = "SpriteMaterial"),
            (this.color = new un(16777215)),
            (this.map = null),
            (this.alphaMap = null),
            (this.rotation = 0),
            (this.sizeAttenuation = !0),
            (this.transparent = !0),
            this.setValues(t);
        }
        copy(t) {
          return (
            super.copy(t),
            this.color.copy(t.color),
            (this.map = t.map),
            (this.alphaMap = t.alphaMap),
            (this.rotation = t.rotation),
            (this.sizeAttenuation = t.sizeAttenuation),
            this
          );
        }
      }
      let Rh;
      Ch.prototype.isSpriteMaterial = !0;
      const Lh = new wn(),
        Ph = new wn(),
        Dh = new wn(),
        Ih = new $e(),
        Oh = new $e(),
        Nh = new Qn(),
        Bh = new wn(),
        zh = new wn(),
        Uh = new wn(),
        Fh = new $e(),
        Hh = new $e(),
        kh = new $e();
      class Gh extends Si {
        constructor(t) {
          if ((super(), (this.type = "Sprite"), void 0 === Rh)) {
            Rh = new Qi();
            const t = new Float32Array([
                -0.5, -0.5, 0, 0, 0, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, 0, 1, 1,
                -0.5, 0.5, 0, 0, 1,
              ]),
              e = new Eh(t, 5);
            Rh.setIndex([0, 1, 2, 0, 2, 3]),
              Rh.setAttribute("position", new Ah(e, 3, 0, !1)),
              Rh.setAttribute("uv", new Ah(e, 2, 3, !1));
          }
          (this.geometry = Rh),
            (this.material = void 0 !== t ? t : new Ch()),
            (this.center = new $e(0.5, 0.5));
        }
        raycast(t, e) {
          null === t.camera &&
            console.error(
              'THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'
            ),
            Ph.setFromMatrixScale(this.matrixWorld),
            Nh.copy(t.camera.matrixWorld),
            this.modelViewMatrix.multiplyMatrices(
              t.camera.matrixWorldInverse,
              this.matrixWorld
            ),
            Dh.setFromMatrixPosition(this.modelViewMatrix),
            t.camera.isPerspectiveCamera &&
              !1 === this.material.sizeAttenuation &&
              Ph.multiplyScalar(-Dh.z);
          const n = this.material.rotation;
          let i, r;
          0 !== n && ((r = Math.cos(n)), (i = Math.sin(n)));
          const a = this.center;
          Vh(Bh.set(-0.5, -0.5, 0), Dh, a, Ph, i, r),
            Vh(zh.set(0.5, -0.5, 0), Dh, a, Ph, i, r),
            Vh(Uh.set(0.5, 0.5, 0), Dh, a, Ph, i, r),
            Fh.set(0, 0),
            Hh.set(1, 0),
            kh.set(1, 1);
          let o = t.ray.intersectTriangle(Bh, zh, Uh, !1, Lh);
          if (
            null === o &&
            (Vh(zh.set(-0.5, 0.5, 0), Dh, a, Ph, i, r),
            Hh.set(0, 1),
            (o = t.ray.intersectTriangle(Bh, Uh, zh, !1, Lh)),
            null === o)
          )
            return;
          const s = t.ray.origin.distanceTo(Lh);
          s < t.near ||
            s > t.far ||
            e.push({
              distance: s,
              point: Lh.clone(),
              uv: Ni.getUV(Lh, Bh, zh, Uh, Fh, Hh, kh, new $e()),
              face: null,
              object: this,
            });
        }
        copy(t) {
          return (
            super.copy(t),
            void 0 !== t.center && this.center.copy(t.center),
            (this.material = t.material),
            this
          );
        }
      }
      function Vh(t, e, n, i, r, a) {
        Ih.subVectors(t, n).addScalar(0.5).multiply(i),
          void 0 !== r
            ? ((Oh.x = a * Ih.x - r * Ih.y), (Oh.y = r * Ih.x + a * Ih.y))
            : Oh.copy(Ih),
          t.copy(e),
          (t.x += Oh.x),
          (t.y += Oh.y),
          t.applyMatrix4(Nh);
      }
      Gh.prototype.isSprite = !0;
      const Wh = new wn(),
        jh = new wn();
      class qh extends Si {
        constructor() {
          super(),
            (this._currentLevel = 0),
            (this.type = "LOD"),
            Object.defineProperties(this, {
              levels: { enumerable: !0, value: [] },
              isLOD: { value: !0 },
            }),
            (this.autoUpdate = !0);
        }
        copy(t) {
          super.copy(t, !1);
          const e = t.levels;
          for (let n = 0, i = e.length; n < i; n++) {
            const t = e[n];
            this.addLevel(t.object.clone(), t.distance);
          }
          return (this.autoUpdate = t.autoUpdate), this;
        }
        addLevel(t, e = 0) {
          e = Math.abs(e);
          const n = this.levels;
          let i;
          for (i = 0; i < n.length; i++) if (e < n[i].distance) break;
          return n.splice(i, 0, { distance: e, object: t }), this.add(t), this;
        }
        getCurrentLevel() {
          return this._currentLevel;
        }
        getObjectForDistance(t) {
          const e = this.levels;
          if (e.length > 0) {
            let n, i;
            for (n = 1, i = e.length; n < i; n++) if (t < e[n].distance) break;
            return e[n - 1].object;
          }
          return null;
        }
        raycast(t, e) {
          const n = this.levels;
          if (n.length > 0) {
            Wh.setFromMatrixPosition(this.matrixWorld);
            const n = t.ray.origin.distanceTo(Wh);
            this.getObjectForDistance(n).raycast(t, e);
          }
        }
        update(t) {
          const e = this.levels;
          if (e.length > 1) {
            Wh.setFromMatrixPosition(t.matrixWorld),
              jh.setFromMatrixPosition(this.matrixWorld);
            const n = Wh.distanceTo(jh) / t.zoom;
            let i, r;
            for (e[0].object.visible = !0, i = 1, r = e.length; i < r; i++) {
              if (!(n >= e[i].distance)) break;
              (e[i - 1].object.visible = !1), (e[i].object.visible = !0);
            }
            for (this._currentLevel = i - 1; i < r; i++)
              e[i].object.visible = !1;
          }
        }
        toJSON(t) {
          const e = super.toJSON(t);
          !1 === this.autoUpdate && (e.object.autoUpdate = !1),
            (e.object.levels = []);
          const n = this.levels;
          for (let i = 0, r = n.length; i < r; i++) {
            const t = n[i];
            e.object.levels.push({
              object: t.object.uuid,
              distance: t.distance,
            });
          }
          return e;
        }
      }
      const Xh = new wn(),
        Yh = new vn(),
        Jh = new vn(),
        Zh = new wn(),
        Kh = new Qn();
      class $h extends vr {
        constructor(t, e) {
          super(t, e),
            (this.type = "SkinnedMesh"),
            (this.bindMode = "attached"),
            (this.bindMatrix = new Qn()),
            (this.bindMatrixInverse = new Qn());
        }
        copy(t) {
          return (
            super.copy(t),
            (this.bindMode = t.bindMode),
            this.bindMatrix.copy(t.bindMatrix),
            this.bindMatrixInverse.copy(t.bindMatrixInverse),
            (this.skeleton = t.skeleton),
            this
          );
        }
        bind(t, e) {
          (this.skeleton = t),
            void 0 === e &&
              (this.updateMatrixWorld(!0),
              this.skeleton.calculateInverses(),
              (e = this.matrixWorld)),
            this.bindMatrix.copy(e),
            this.bindMatrixInverse.copy(e).invert();
        }
        pose() {
          this.skeleton.pose();
        }
        normalizeSkinWeights() {
          const t = new vn(),
            e = this.geometry.attributes.skinWeight;
          for (let n = 0, i = e.count; n < i; n++) {
            (t.x = e.getX(n)),
              (t.y = e.getY(n)),
              (t.z = e.getZ(n)),
              (t.w = e.getW(n));
            const i = 1 / t.manhattanLength();
            i !== 1 / 0 ? t.multiplyScalar(i) : t.set(1, 0, 0, 0),
              e.setXYZW(n, t.x, t.y, t.z, t.w);
          }
        }
        updateMatrixWorld(t) {
          super.updateMatrixWorld(t),
            "attached" === this.bindMode
              ? this.bindMatrixInverse.copy(this.matrixWorld).invert()
              : "detached" === this.bindMode
              ? this.bindMatrixInverse.copy(this.bindMatrix).invert()
              : console.warn(
                  "THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode
                );
        }
        boneTransform(t, e) {
          const n = this.skeleton,
            i = this.geometry;
          Yh.fromBufferAttribute(i.attributes.skinIndex, t),
            Jh.fromBufferAttribute(i.attributes.skinWeight, t),
            Xh.copy(e).applyMatrix4(this.bindMatrix),
            e.set(0, 0, 0);
          for (let r = 0; r < 4; r++) {
            const t = Jh.getComponent(r);
            if (0 !== t) {
              const i = Yh.getComponent(r);
              Kh.multiplyMatrices(n.bones[i].matrixWorld, n.boneInverses[i]),
                e.addScaledVector(Zh.copy(Xh).applyMatrix4(Kh), t);
            }
          }
          return e.applyMatrix4(this.bindMatrixInverse);
        }
      }
      $h.prototype.isSkinnedMesh = !0;
      class Qh extends Si {
        constructor() {
          super(), (this.type = "Bone");
        }
      }
      Qh.prototype.isBone = !0;
      class tu extends mn {
        constructor(
          t = null,
          e = 1,
          n = 1,
          i,
          r,
          a,
          o,
          s,
          c = gt,
          l = gt,
          h,
          u
        ) {
          super(null, a, o, s, c, l, i, r, h, u),
            (this.image = { data: t, width: e, height: n }),
            (this.magFilter = c),
            (this.minFilter = l),
            (this.generateMipmaps = !1),
            (this.flipY = !1),
            (this.unpackAlignment = 1);
        }
      }
      tu.prototype.isDataTexture = !0;
      const eu = new Qn(),
        nu = new Qn();
      class iu {
        constructor(t = [], e = []) {
          (this.uuid = je()),
            (this.bones = t.slice(0)),
            (this.boneInverses = e),
            (this.boneMatrices = null),
            (this.boneTexture = null),
            (this.boneTextureSize = 0),
            (this.frame = -1),
            this.init();
        }
        init() {
          const t = this.bones,
            e = this.boneInverses;
          if (
            ((this.boneMatrices = new Float32Array(16 * t.length)),
            0 === e.length)
          )
            this.calculateInverses();
          else if (t.length !== e.length) {
            console.warn(
              "THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."
            ),
              (this.boneInverses = []);
            for (let t = 0, e = this.bones.length; t < e; t++)
              this.boneInverses.push(new Qn());
          }
        }
        calculateInverses() {
          this.boneInverses.length = 0;
          for (let t = 0, e = this.bones.length; t < e; t++) {
            const e = new Qn();
            this.bones[t] && e.copy(this.bones[t].matrixWorld).invert(),
              this.boneInverses.push(e);
          }
        }
        pose() {
          for (let t = 0, e = this.bones.length; t < e; t++) {
            const e = this.bones[t];
            e && e.matrixWorld.copy(this.boneInverses[t]).invert();
          }
          for (let t = 0, e = this.bones.length; t < e; t++) {
            const e = this.bones[t];
            e &&
              (e.parent && e.parent.isBone
                ? (e.matrix.copy(e.parent.matrixWorld).invert(),
                  e.matrix.multiply(e.matrixWorld))
                : e.matrix.copy(e.matrixWorld),
              e.matrix.decompose(e.position, e.quaternion, e.scale));
          }
        }
        update() {
          const t = this.bones,
            e = this.boneInverses,
            n = this.boneMatrices,
            i = this.boneTexture;
          for (let r = 0, a = t.length; r < a; r++) {
            const i = t[r] ? t[r].matrixWorld : nu;
            eu.multiplyMatrices(i, e[r]), eu.toArray(n, 16 * r);
          }
          null !== i && (i.needsUpdate = !0);
        }
        clone() {
          return new iu(this.bones, this.boneInverses);
        }
        computeBoneTexture() {
          let t = Math.sqrt(4 * this.bones.length);
          (t = Ze(t)), (t = Math.max(t, 4));
          const e = new Float32Array(t * t * 4);
          e.set(this.boneMatrices);
          const n = new tu(e, t, t, Nt, Ct);
          return (
            (n.needsUpdate = !0),
            (this.boneMatrices = e),
            (this.boneTexture = n),
            (this.boneTextureSize = t),
            this
          );
        }
        getBoneByName(t) {
          for (let e = 0, n = this.bones.length; e < n; e++) {
            const n = this.bones[e];
            if (n.name === t) return n;
          }
        }
        dispose() {
          null !== this.boneTexture &&
            (this.boneTexture.dispose(), (this.boneTexture = null));
        }
        fromJSON(t, e) {
          this.uuid = t.uuid;
          for (let n = 0, i = t.bones.length; n < i; n++) {
            const i = t.bones[n];
            let r = e[i];
            void 0 === r &&
              (console.warn("THREE.Skeleton: No bone found with UUID:", i),
              (r = new Qh())),
              this.bones.push(r),
              this.boneInverses.push(new Qn().fromArray(t.boneInverses[n]));
          }
          return this.init(), this;
        }
        toJSON() {
          const t = {
            metadata: {
              version: 4.5,
              type: "Skeleton",
              generator: "Skeleton.toJSON",
            },
            bones: [],
            boneInverses: [],
          };
          t.uuid = this.uuid;
          const e = this.bones,
            n = this.boneInverses;
          for (let i = 0, r = e.length; i < r; i++) {
            const r = e[i];
            t.bones.push(r.uuid);
            const a = n[i];
            t.boneInverses.push(a.toArray());
          }
          return t;
        }
      }
      class ru extends ki {
        constructor(t, e, n, i = 1) {
          "number" === typeof n &&
            ((i = n),
            (n = !1),
            console.error(
              "THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument."
            )),
            super(t, e, n),
            (this.meshPerAttribute = i);
        }
        copy(t) {
          return (
            super.copy(t), (this.meshPerAttribute = t.meshPerAttribute), this
          );
        }
        toJSON() {
          const t = super.toJSON();
          return (
            (t.meshPerAttribute = this.meshPerAttribute),
            (t.isInstancedBufferAttribute = !0),
            t
          );
        }
      }
      ru.prototype.isInstancedBufferAttribute = !0;
      const au = new Qn(),
        ou = new Qn(),
        su = [],
        cu = new vr();
      class lu extends vr {
        constructor(t, e, n) {
          super(t, e),
            (this.instanceMatrix = new ru(new Float32Array(16 * n), 16)),
            (this.instanceColor = null),
            (this.count = n),
            (this.frustumCulled = !1);
        }
        copy(t) {
          return (
            super.copy(t),
            this.instanceMatrix.copy(t.instanceMatrix),
            null !== t.instanceColor &&
              (this.instanceColor = t.instanceColor.clone()),
            (this.count = t.count),
            this
          );
        }
        getColorAt(t, e) {
          e.fromArray(this.instanceColor.array, 3 * t);
        }
        getMatrixAt(t, e) {
          e.fromArray(this.instanceMatrix.array, 16 * t);
        }
        raycast(t, e) {
          const n = this.matrixWorld,
            i = this.count;
          if (
            ((cu.geometry = this.geometry),
            (cu.material = this.material),
            void 0 !== cu.material)
          )
            for (let r = 0; r < i; r++) {
              this.getMatrixAt(r, au),
                ou.multiplyMatrices(n, au),
                (cu.matrixWorld = ou),
                cu.raycast(t, su);
              for (let t = 0, n = su.length; t < n; t++) {
                const n = su[t];
                (n.instanceId = r), (n.object = this), e.push(n);
              }
              su.length = 0;
            }
        }
        setColorAt(t, e) {
          null === this.instanceColor &&
            (this.instanceColor = new ru(
              new Float32Array(3 * this.instanceMatrix.count),
              3
            )),
            e.toArray(this.instanceColor.array, 3 * t);
        }
        setMatrixAt(t, e) {
          e.toArray(this.instanceMatrix.array, 16 * t);
        }
        updateMorphTargets() {}
        dispose() {
          this.dispatchEvent({ type: "dispose" });
        }
      }
      lu.prototype.isInstancedMesh = !0;
      class hu extends zi {
        constructor(t) {
          super(),
            (this.type = "LineBasicMaterial"),
            (this.color = new un(16777215)),
            (this.linewidth = 1),
            (this.linecap = "round"),
            (this.linejoin = "round"),
            this.setValues(t);
        }
        copy(t) {
          return (
            super.copy(t),
            this.color.copy(t.color),
            (this.linewidth = t.linewidth),
            (this.linecap = t.linecap),
            (this.linejoin = t.linejoin),
            this
          );
        }
      }
      hu.prototype.isLineBasicMaterial = !0;
      const uu = new wn(),
        du = new wn(),
        pu = new Qn(),
        fu = new $n(),
        mu = new Wn();
      class gu extends Si {
        constructor(t = new Qi(), e = new hu()) {
          super(),
            (this.type = "Line"),
            (this.geometry = t),
            (this.material = e),
            this.updateMorphTargets();
        }
        copy(t) {
          return (
            super.copy(t),
            (this.material = t.material),
            (this.geometry = t.geometry),
            this
          );
        }
        computeLineDistances() {
          const t = this.geometry;
          if (t.isBufferGeometry)
            if (null === t.index) {
              const e = t.attributes.position,
                n = [0];
              for (let t = 1, i = e.count; t < i; t++)
                uu.fromBufferAttribute(e, t - 1),
                  du.fromBufferAttribute(e, t),
                  (n[t] = n[t - 1]),
                  (n[t] += uu.distanceTo(du));
              t.setAttribute("lineDistance", new ji(n, 1));
            } else
              console.warn(
                "THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
              );
          else
            t.isGeometry &&
              console.error(
                "THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
              );
          return this;
        }
        raycast(t, e) {
          const n = this.geometry,
            i = this.matrixWorld,
            r = t.params.Line.threshold,
            a = n.drawRange;
          if (
            (null === n.boundingSphere && n.computeBoundingSphere(),
            mu.copy(n.boundingSphere),
            mu.applyMatrix4(i),
            (mu.radius += r),
            !1 === t.ray.intersectsSphere(mu))
          )
            return;
          pu.copy(i).invert(), fu.copy(t.ray).applyMatrix4(pu);
          const o = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
            s = o * o,
            c = new wn(),
            l = new wn(),
            h = new wn(),
            u = new wn(),
            d = this.isLineSegments ? 2 : 1;
          if (n.isBufferGeometry) {
            const i = n.index,
              r = n.attributes,
              o = r.position;
            if (null !== i) {
              const n = Math.max(0, a.start),
                r = Math.min(i.count, a.start + a.count);
              for (let a = n, p = r - 1; a < p; a += d) {
                const n = i.getX(a),
                  r = i.getX(a + 1);
                c.fromBufferAttribute(o, n), l.fromBufferAttribute(o, r);
                const d = fu.distanceSqToSegment(c, l, u, h);
                if (d > s) continue;
                u.applyMatrix4(this.matrixWorld);
                const p = t.ray.origin.distanceTo(u);
                p < t.near ||
                  p > t.far ||
                  e.push({
                    distance: p,
                    point: h.clone().applyMatrix4(this.matrixWorld),
                    index: a,
                    face: null,
                    faceIndex: null,
                    object: this,
                  });
              }
            } else {
              const n = Math.max(0, a.start),
                i = Math.min(o.count, a.start + a.count);
              for (let r = n, a = i - 1; r < a; r += d) {
                c.fromBufferAttribute(o, r), l.fromBufferAttribute(o, r + 1);
                const n = fu.distanceSqToSegment(c, l, u, h);
                if (n > s) continue;
                u.applyMatrix4(this.matrixWorld);
                const i = t.ray.origin.distanceTo(u);
                i < t.near ||
                  i > t.far ||
                  e.push({
                    distance: i,
                    point: h.clone().applyMatrix4(this.matrixWorld),
                    index: r,
                    face: null,
                    faceIndex: null,
                    object: this,
                  });
              }
            }
          } else
            n.isGeometry &&
              console.error(
                "THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
              );
        }
        updateMorphTargets() {
          const t = this.geometry;
          if (t.isBufferGeometry) {
            const e = t.morphAttributes,
              n = Object.keys(e);
            if (n.length > 0) {
              const t = e[n[0]];
              if (void 0 !== t) {
                (this.morphTargetInfluences = []),
                  (this.morphTargetDictionary = {});
                for (let e = 0, n = t.length; e < n; e++) {
                  const n = t[e].name || String(e);
                  this.morphTargetInfluences.push(0),
                    (this.morphTargetDictionary[n] = e);
                }
              }
            }
          } else {
            const e = t.morphTargets;
            void 0 !== e &&
              e.length > 0 &&
              console.error(
                "THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead."
              );
          }
        }
      }
      gu.prototype.isLine = !0;
      const vu = new wn(),
        yu = new wn();
      class xu extends gu {
        constructor(t, e) {
          super(t, e), (this.type = "LineSegments");
        }
        computeLineDistances() {
          const t = this.geometry;
          if (t.isBufferGeometry)
            if (null === t.index) {
              const e = t.attributes.position,
                n = [];
              for (let t = 0, i = e.count; t < i; t += 2)
                vu.fromBufferAttribute(e, t),
                  yu.fromBufferAttribute(e, t + 1),
                  (n[t] = 0 === t ? 0 : n[t - 1]),
                  (n[t + 1] = n[t] + vu.distanceTo(yu));
              t.setAttribute("lineDistance", new ji(n, 1));
            } else
              console.warn(
                "THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
              );
          else
            t.isGeometry &&
              console.error(
                "THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
              );
          return this;
        }
      }
      xu.prototype.isLineSegments = !0;
      class _u extends gu {
        constructor(t, e) {
          super(t, e), (this.type = "LineLoop");
        }
      }
      _u.prototype.isLineLoop = !0;
      class bu extends zi {
        constructor(t) {
          super(),
            (this.type = "PointsMaterial"),
            (this.color = new un(16777215)),
            (this.map = null),
            (this.alphaMap = null),
            (this.size = 1),
            (this.sizeAttenuation = !0),
            this.setValues(t);
        }
        copy(t) {
          return (
            super.copy(t),
            this.color.copy(t.color),
            (this.map = t.map),
            (this.alphaMap = t.alphaMap),
            (this.size = t.size),
            (this.sizeAttenuation = t.sizeAttenuation),
            this
          );
        }
      }
      bu.prototype.isPointsMaterial = !0;
      const wu = new Qn(),
        Mu = new $n(),
        Su = new Wn(),
        Eu = new wn();
      class Tu extends Si {
        constructor(t = new Qi(), e = new bu()) {
          super(),
            (this.type = "Points"),
            (this.geometry = t),
            (this.material = e),
            this.updateMorphTargets();
        }
        copy(t) {
          return (
            super.copy(t),
            (this.material = t.material),
            (this.geometry = t.geometry),
            this
          );
        }
        raycast(t, e) {
          const n = this.geometry,
            i = this.matrixWorld,
            r = t.params.Points.threshold,
            a = n.drawRange;
          if (
            (null === n.boundingSphere && n.computeBoundingSphere(),
            Su.copy(n.boundingSphere),
            Su.applyMatrix4(i),
            (Su.radius += r),
            !1 === t.ray.intersectsSphere(Su))
          )
            return;
          wu.copy(i).invert(), Mu.copy(t.ray).applyMatrix4(wu);
          const o = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
            s = o * o;
          if (n.isBufferGeometry) {
            const r = n.index,
              o = n.attributes,
              c = o.position;
            if (null !== r) {
              const n = Math.max(0, a.start),
                o = Math.min(r.count, a.start + a.count);
              for (let a = n, l = o; a < l; a++) {
                const n = r.getX(a);
                Eu.fromBufferAttribute(c, n), Au(Eu, n, s, i, t, e, this);
              }
            } else {
              const n = Math.max(0, a.start),
                r = Math.min(c.count, a.start + a.count);
              for (let a = n, o = r; a < o; a++)
                Eu.fromBufferAttribute(c, a), Au(Eu, a, s, i, t, e, this);
            }
          } else
            console.error(
              "THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
            );
        }
        updateMorphTargets() {
          const t = this.geometry;
          if (t.isBufferGeometry) {
            const e = t.morphAttributes,
              n = Object.keys(e);
            if (n.length > 0) {
              const t = e[n[0]];
              if (void 0 !== t) {
                (this.morphTargetInfluences = []),
                  (this.morphTargetDictionary = {});
                for (let e = 0, n = t.length; e < n; e++) {
                  const n = t[e].name || String(e);
                  this.morphTargetInfluences.push(0),
                    (this.morphTargetDictionary[n] = e);
                }
              }
            }
          } else {
            const e = t.morphTargets;
            void 0 !== e &&
              e.length > 0 &&
              console.error(
                "THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead."
              );
          }
        }
      }
      function Au(t, e, n, i, r, a, o) {
        const s = Mu.distanceSqToPoint(t);
        if (s < n) {
          const n = new wn();
          Mu.closestPointToPoint(t, n), n.applyMatrix4(i);
          const c = r.ray.origin.distanceTo(n);
          if (c < r.near || c > r.far) return;
          a.push({
            distance: c,
            distanceToRay: Math.sqrt(s),
            point: n,
            index: e,
            face: null,
            object: o,
          });
        }
      }
      Tu.prototype.isPoints = !0;
      class Cu extends mn {
        constructor(t, e, n, i, r, a, o, s, c) {
          super(t, e, n, i, r, a, o, s, c),
            (this.minFilter = void 0 !== a ? a : xt),
            (this.magFilter = void 0 !== r ? r : xt),
            (this.generateMipmaps = !1);
          const l = this;
          function h() {
            (l.needsUpdate = !0), t.requestVideoFrameCallback(h);
          }
          "requestVideoFrameCallback" in t && t.requestVideoFrameCallback(h);
        }
        clone() {
          return new this.constructor(this.image).copy(this);
        }
        update() {
          const t = this.image,
            e = "requestVideoFrameCallback" in t;
          !1 === e &&
            t.readyState >= t.HAVE_CURRENT_DATA &&
            (this.needsUpdate = !0);
        }
      }
      Cu.prototype.isVideoTexture = !0;
      class Ru extends mn {
        constructor(t, e, n) {
          super({ width: t, height: e }),
            (this.format = n),
            (this.magFilter = gt),
            (this.minFilter = gt),
            (this.generateMipmaps = !1),
            (this.needsUpdate = !0);
        }
      }
      Ru.prototype.isFramebufferTexture = !0;
      class Lu extends mn {
        constructor(t, e, n, i, r, a, o, s, c, l, h, u) {
          super(null, a, o, s, c, l, i, r, h, u),
            (this.image = { width: e, height: n }),
            (this.mipmaps = t),
            (this.flipY = !1),
            (this.generateMipmaps = !1);
        }
      }
      Lu.prototype.isCompressedTexture = !0;
      class Pu extends mn {
        constructor(t, e, n, i, r, a, o, s, c) {
          super(t, e, n, i, r, a, o, s, c), (this.needsUpdate = !0);
        }
      }
      Pu.prototype.isCanvasTexture = !0;
      class Du extends Qi {
        constructor(t = 1, e = 8, n = 0, i = 2 * Math.PI) {
          super(),
            (this.type = "CircleGeometry"),
            (this.parameters = {
              radius: t,
              segments: e,
              thetaStart: n,
              thetaLength: i,
            }),
            (e = Math.max(3, e));
          const r = [],
            a = [],
            o = [],
            s = [],
            c = new wn(),
            l = new $e();
          a.push(0, 0, 0), o.push(0, 0, 1), s.push(0.5, 0.5);
          for (let h = 0, u = 3; h <= e; h++, u += 3) {
            const r = n + (h / e) * i;
            (c.x = t * Math.cos(r)),
              (c.y = t * Math.sin(r)),
              a.push(c.x, c.y, c.z),
              o.push(0, 0, 1),
              (l.x = (a[u] / t + 1) / 2),
              (l.y = (a[u + 1] / t + 1) / 2),
              s.push(l.x, l.y);
          }
          for (let h = 1; h <= e; h++) r.push(h, h + 1, 0);
          this.setIndex(r),
            this.setAttribute("position", new ji(a, 3)),
            this.setAttribute("normal", new ji(o, 3)),
            this.setAttribute("uv", new ji(s, 2));
        }
        static fromJSON(t) {
          return new Du(t.radius, t.segments, t.thetaStart, t.thetaLength);
        }
      }
      class Iu extends Qi {
        constructor(
          t = 1,
          e = 1,
          n = 1,
          i = 8,
          r = 1,
          a = !1,
          o = 0,
          s = 2 * Math.PI
        ) {
          super(),
            (this.type = "CylinderGeometry"),
            (this.parameters = {
              radiusTop: t,
              radiusBottom: e,
              height: n,
              radialSegments: i,
              heightSegments: r,
              openEnded: a,
              thetaStart: o,
              thetaLength: s,
            });
          const c = this;
          (i = Math.floor(i)), (r = Math.floor(r));
          const l = [],
            h = [],
            u = [],
            d = [];
          let p = 0;
          const f = [],
            m = n / 2;
          let g = 0;
          function v() {
            const a = new wn(),
              v = new wn();
            let y = 0;
            const x = (e - t) / n;
            for (let c = 0; c <= r; c++) {
              const l = [],
                g = c / r,
                y = g * (e - t) + t;
              for (let t = 0; t <= i; t++) {
                const e = t / i,
                  r = e * s + o,
                  c = Math.sin(r),
                  f = Math.cos(r);
                (v.x = y * c),
                  (v.y = -g * n + m),
                  (v.z = y * f),
                  h.push(v.x, v.y, v.z),
                  a.set(c, x, f).normalize(),
                  u.push(a.x, a.y, a.z),
                  d.push(e, 1 - g),
                  l.push(p++);
              }
              f.push(l);
            }
            for (let t = 0; t < i; t++)
              for (let e = 0; e < r; e++) {
                const n = f[e][t],
                  i = f[e + 1][t],
                  r = f[e + 1][t + 1],
                  a = f[e][t + 1];
                l.push(n, i, a), l.push(i, r, a), (y += 6);
              }
            c.addGroup(g, y, 0), (g += y);
          }
          function y(n) {
            const r = p,
              a = new $e(),
              f = new wn();
            let v = 0;
            const y = !0 === n ? t : e,
              x = !0 === n ? 1 : -1;
            for (let t = 1; t <= i; t++)
              h.push(0, m * x, 0), u.push(0, x, 0), d.push(0.5, 0.5), p++;
            const _ = p;
            for (let t = 0; t <= i; t++) {
              const e = t / i,
                n = e * s + o,
                r = Math.cos(n),
                c = Math.sin(n);
              (f.x = y * c),
                (f.y = m * x),
                (f.z = y * r),
                h.push(f.x, f.y, f.z),
                u.push(0, x, 0),
                (a.x = 0.5 * r + 0.5),
                (a.y = 0.5 * c * x + 0.5),
                d.push(a.x, a.y),
                p++;
            }
            for (let t = 0; t < i; t++) {
              const e = r + t,
                i = _ + t;
              !0 === n ? l.push(i, i + 1, e) : l.push(i + 1, i, e), (v += 3);
            }
            c.addGroup(g, v, !0 === n ? 1 : 2), (g += v);
          }
          v(),
            !1 === a && (t > 0 && y(!0), e > 0 && y(!1)),
            this.setIndex(l),
            this.setAttribute("position", new ji(h, 3)),
            this.setAttribute("normal", new ji(u, 3)),
            this.setAttribute("uv", new ji(d, 2));
        }
        static fromJSON(t) {
          return new Iu(
            t.radiusTop,
            t.radiusBottom,
            t.height,
            t.radialSegments,
            t.heightSegments,
            t.openEnded,
            t.thetaStart,
            t.thetaLength
          );
        }
      }
      class Ou extends Iu {
        constructor(
          t = 1,
          e = 1,
          n = 8,
          i = 1,
          r = !1,
          a = 0,
          o = 2 * Math.PI
        ) {
          super(0, t, e, n, i, r, a, o),
            (this.type = "ConeGeometry"),
            (this.parameters = {
              radius: t,
              height: e,
              radialSegments: n,
              heightSegments: i,
              openEnded: r,
              thetaStart: a,
              thetaLength: o,
            });
        }
        static fromJSON(t) {
          return new Ou(
            t.radius,
            t.height,
            t.radialSegments,
            t.heightSegments,
            t.openEnded,
            t.thetaStart,
            t.thetaLength
          );
        }
      }
      class Nu extends Qi {
        constructor(t = [], e = [], n = 1, i = 0) {
          super(),
            (this.type = "PolyhedronGeometry"),
            (this.parameters = {
              vertices: t,
              indices: e,
              radius: n,
              detail: i,
            });
          const r = [],
            a = [];
          function o(t) {
            const n = new wn(),
              i = new wn(),
              r = new wn();
            for (let a = 0; a < e.length; a += 3)
              d(e[a + 0], n), d(e[a + 1], i), d(e[a + 2], r), s(n, i, r, t);
          }
          function s(t, e, n, i) {
            const r = i + 1,
              a = [];
            for (let o = 0; o <= r; o++) {
              a[o] = [];
              const i = t.clone().lerp(n, o / r),
                s = e.clone().lerp(n, o / r),
                c = r - o;
              for (let t = 0; t <= c; t++)
                a[o][t] = 0 === t && o === r ? i : i.clone().lerp(s, t / c);
            }
            for (let o = 0; o < r; o++)
              for (let t = 0; t < 2 * (r - o) - 1; t++) {
                const e = Math.floor(t / 2);
                t % 2 === 0
                  ? (u(a[o][e + 1]), u(a[o + 1][e]), u(a[o][e]))
                  : (u(a[o][e + 1]), u(a[o + 1][e + 1]), u(a[o + 1][e]));
              }
          }
          function c(t) {
            const e = new wn();
            for (let n = 0; n < r.length; n += 3)
              (e.x = r[n + 0]),
                (e.y = r[n + 1]),
                (e.z = r[n + 2]),
                e.normalize().multiplyScalar(t),
                (r[n + 0] = e.x),
                (r[n + 1] = e.y),
                (r[n + 2] = e.z);
          }
          function l() {
            const t = new wn();
            for (let e = 0; e < r.length; e += 3) {
              (t.x = r[e + 0]), (t.y = r[e + 1]), (t.z = r[e + 2]);
              const n = m(t) / 2 / Math.PI + 0.5,
                i = g(t) / Math.PI + 0.5;
              a.push(n, 1 - i);
            }
            p(), h();
          }
          function h() {
            for (let t = 0; t < a.length; t += 6) {
              const e = a[t + 0],
                n = a[t + 2],
                i = a[t + 4],
                r = Math.max(e, n, i),
                o = Math.min(e, n, i);
              r > 0.9 &&
                o < 0.1 &&
                (e < 0.2 && (a[t + 0] += 1),
                n < 0.2 && (a[t + 2] += 1),
                i < 0.2 && (a[t + 4] += 1));
            }
          }
          function u(t) {
            r.push(t.x, t.y, t.z);
          }
          function d(e, n) {
            const i = 3 * e;
            (n.x = t[i + 0]), (n.y = t[i + 1]), (n.z = t[i + 2]);
          }
          function p() {
            const t = new wn(),
              e = new wn(),
              n = new wn(),
              i = new wn(),
              o = new $e(),
              s = new $e(),
              c = new $e();
            for (let l = 0, h = 0; l < r.length; l += 9, h += 6) {
              t.set(r[l + 0], r[l + 1], r[l + 2]),
                e.set(r[l + 3], r[l + 4], r[l + 5]),
                n.set(r[l + 6], r[l + 7], r[l + 8]),
                o.set(a[h + 0], a[h + 1]),
                s.set(a[h + 2], a[h + 3]),
                c.set(a[h + 4], a[h + 5]),
                i.copy(t).add(e).add(n).divideScalar(3);
              const u = m(i);
              f(o, h + 0, t, u), f(s, h + 2, e, u), f(c, h + 4, n, u);
            }
          }
          function f(t, e, n, i) {
            i < 0 && 1 === t.x && (a[e] = t.x - 1),
              0 === n.x && 0 === n.z && (a[e] = i / 2 / Math.PI + 0.5);
          }
          function m(t) {
            return Math.atan2(t.z, -t.x);
          }
          function g(t) {
            return Math.atan2(-t.y, Math.sqrt(t.x * t.x + t.z * t.z));
          }
          o(i),
            c(n),
            l(),
            this.setAttribute("position", new ji(r, 3)),
            this.setAttribute("normal", new ji(r.slice(), 3)),
            this.setAttribute("uv", new ji(a, 2)),
            0 === i ? this.computeVertexNormals() : this.normalizeNormals();
        }
        static fromJSON(t) {
          return new Nu(t.vertices, t.indices, t.radius, t.details);
        }
      }
      class Bu extends Nu {
        constructor(t = 1, e = 0) {
          const n = (1 + Math.sqrt(5)) / 2,
            i = 1 / n,
            r = [
              -1,
              -1,
              -1,
              -1,
              -1,
              1,
              -1,
              1,
              -1,
              -1,
              1,
              1,
              1,
              -1,
              -1,
              1,
              -1,
              1,
              1,
              1,
              -1,
              1,
              1,
              1,
              0,
              -i,
              -n,
              0,
              -i,
              n,
              0,
              i,
              -n,
              0,
              i,
              n,
              -i,
              -n,
              0,
              -i,
              n,
              0,
              i,
              -n,
              0,
              i,
              n,
              0,
              -n,
              0,
              -i,
              n,
              0,
              -i,
              -n,
              0,
              i,
              n,
              0,
              i,
            ],
            a = [
              3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17,
              4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12,
              1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18,
              2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4,
              12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14,
              4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9,
            ];
          super(r, a, t, e),
            (this.type = "DodecahedronGeometry"),
            (this.parameters = { radius: t, detail: e });
        }
        static fromJSON(t) {
          return new Bu(t.radius, t.detail);
        }
      }
      const zu = new wn(),
        Uu = new wn(),
        Fu = new wn(),
        Hu = new Ni();
      class ku extends Qi {
        constructor(t = null, e = 1) {
          if (
            (super(),
            (this.type = "EdgesGeometry"),
            (this.parameters = { geometry: t, thresholdAngle: e }),
            null !== t)
          ) {
            const n = 4,
              i = Math.pow(10, n),
              r = Math.cos(Ve * e),
              a = t.getIndex(),
              o = t.getAttribute("position"),
              s = a ? a.count : o.count,
              c = [0, 0, 0],
              l = ["a", "b", "c"],
              h = new Array(3),
              u = {},
              d = [];
            for (let t = 0; t < s; t += 3) {
              a
                ? ((c[0] = a.getX(t)),
                  (c[1] = a.getX(t + 1)),
                  (c[2] = a.getX(t + 2)))
                : ((c[0] = t), (c[1] = t + 1), (c[2] = t + 2));
              const { a: e, b: n, c: s } = Hu;
              if (
                (e.fromBufferAttribute(o, c[0]),
                n.fromBufferAttribute(o, c[1]),
                s.fromBufferAttribute(o, c[2]),
                Hu.getNormal(Fu),
                (h[0] = `${Math.round(e.x * i)},${Math.round(
                  e.y * i
                )},${Math.round(e.z * i)}`),
                (h[1] = `${Math.round(n.x * i)},${Math.round(
                  n.y * i
                )},${Math.round(n.z * i)}`),
                (h[2] = `${Math.round(s.x * i)},${Math.round(
                  s.y * i
                )},${Math.round(s.z * i)}`),
                h[0] !== h[1] && h[1] !== h[2] && h[2] !== h[0])
              )
                for (let t = 0; t < 3; t++) {
                  const e = (t + 1) % 3,
                    n = h[t],
                    i = h[e],
                    a = Hu[l[t]],
                    o = Hu[l[e]],
                    s = `${n}_${i}`,
                    p = `${i}_${n}`;
                  p in u && u[p]
                    ? (Fu.dot(u[p].normal) <= r &&
                        (d.push(a.x, a.y, a.z), d.push(o.x, o.y, o.z)),
                      (u[p] = null))
                    : s in u ||
                      (u[s] = {
                        index0: c[t],
                        index1: c[e],
                        normal: Fu.clone(),
                      });
                }
            }
            for (const t in u)
              if (u[t]) {
                const { index0: e, index1: n } = u[t];
                zu.fromBufferAttribute(o, e),
                  Uu.fromBufferAttribute(o, n),
                  d.push(zu.x, zu.y, zu.z),
                  d.push(Uu.x, Uu.y, Uu.z);
              }
            this.setAttribute("position", new ji(d, 3));
          }
        }
      }
      class Gu {
        constructor() {
          (this.type = "Curve"), (this.arcLengthDivisions = 200);
        }
        getPoint() {
          return (
            console.warn("THREE.Curve: .getPoint() not implemented."), null
          );
        }
        getPointAt(t, e) {
          const n = this.getUtoTmapping(t);
          return this.getPoint(n, e);
        }
        getPoints(t = 5) {
          const e = [];
          for (let n = 0; n <= t; n++) e.push(this.getPoint(n / t));
          return e;
        }
        getSpacedPoints(t = 5) {
          const e = [];
          for (let n = 0; n <= t; n++) e.push(this.getPointAt(n / t));
          return e;
        }
        getLength() {
          const t = this.getLengths();
          return t[t.length - 1];
        }
        getLengths(t = this.arcLengthDivisions) {
          if (
            this.cacheArcLengths &&
            this.cacheArcLengths.length === t + 1 &&
            !this.needsUpdate
          )
            return this.cacheArcLengths;
          this.needsUpdate = !1;
          const e = [];
          let n,
            i = this.getPoint(0),
            r = 0;
          e.push(0);
          for (let a = 1; a <= t; a++)
            (n = this.getPoint(a / t)),
              (r += n.distanceTo(i)),
              e.push(r),
              (i = n);
          return (this.cacheArcLengths = e), e;
        }
        updateArcLengths() {
          (this.needsUpdate = !0), this.getLengths();
        }
        getUtoTmapping(t, e) {
          const n = this.getLengths();
          let i = 0;
          const r = n.length;
          let a;
          a = e || t * n[r - 1];
          let o,
            s = 0,
            c = r - 1;
          while (s <= c)
            if (((i = Math.floor(s + (c - s) / 2)), (o = n[i] - a), o < 0))
              s = i + 1;
            else {
              if (!(o > 0)) {
                c = i;
                break;
              }
              c = i - 1;
            }
          if (((i = c), n[i] === a)) return i / (r - 1);
          const l = n[i],
            h = n[i + 1],
            u = h - l,
            d = (a - l) / u,
            p = (i + d) / (r - 1);
          return p;
        }
        getTangent(t, e) {
          const n = 1e-4;
          let i = t - n,
            r = t + n;
          i < 0 && (i = 0), r > 1 && (r = 1);
          const a = this.getPoint(i),
            o = this.getPoint(r),
            s = e || (a.isVector2 ? new $e() : new wn());
          return s.copy(o).sub(a).normalize(), s;
        }
        getTangentAt(t, e) {
          const n = this.getUtoTmapping(t);
          return this.getTangent(n, e);
        }
        computeFrenetFrames(t, e) {
          const n = new wn(),
            i = [],
            r = [],
            a = [],
            o = new wn(),
            s = new Qn();
          for (let d = 0; d <= t; d++) {
            const e = d / t;
            i[d] = this.getTangentAt(e, new wn());
          }
          (r[0] = new wn()), (a[0] = new wn());
          let c = Number.MAX_VALUE;
          const l = Math.abs(i[0].x),
            h = Math.abs(i[0].y),
            u = Math.abs(i[0].z);
          l <= c && ((c = l), n.set(1, 0, 0)),
            h <= c && ((c = h), n.set(0, 1, 0)),
            u <= c && n.set(0, 0, 1),
            o.crossVectors(i[0], n).normalize(),
            r[0].crossVectors(i[0], o),
            a[0].crossVectors(i[0], r[0]);
          for (let d = 1; d <= t; d++) {
            if (
              ((r[d] = r[d - 1].clone()),
              (a[d] = a[d - 1].clone()),
              o.crossVectors(i[d - 1], i[d]),
              o.length() > Number.EPSILON)
            ) {
              o.normalize();
              const t = Math.acos(qe(i[d - 1].dot(i[d]), -1, 1));
              r[d].applyMatrix4(s.makeRotationAxis(o, t));
            }
            a[d].crossVectors(i[d], r[d]);
          }
          if (!0 === e) {
            let e = Math.acos(qe(r[0].dot(r[t]), -1, 1));
            (e /= t), i[0].dot(o.crossVectors(r[0], r[t])) > 0 && (e = -e);
            for (let n = 1; n <= t; n++)
              r[n].applyMatrix4(s.makeRotationAxis(i[n], e * n)),
                a[n].crossVectors(i[n], r[n]);
          }
          return { tangents: i, normals: r, binormals: a };
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(t) {
          return (this.arcLengthDivisions = t.arcLengthDivisions), this;
        }
        toJSON() {
          const t = {
            metadata: {
              version: 4.5,
              type: "Curve",
              generator: "Curve.toJSON",
            },
          };
          return (
            (t.arcLengthDivisions = this.arcLengthDivisions),
            (t.type = this.type),
            t
          );
        }
        fromJSON(t) {
          return (this.arcLengthDivisions = t.arcLengthDivisions), this;
        }
      }
      class Vu extends Gu {
        constructor(
          t = 0,
          e = 0,
          n = 1,
          i = 1,
          r = 0,
          a = 2 * Math.PI,
          o = !1,
          s = 0
        ) {
          super(),
            (this.type = "EllipseCurve"),
            (this.aX = t),
            (this.aY = e),
            (this.xRadius = n),
            (this.yRadius = i),
            (this.aStartAngle = r),
            (this.aEndAngle = a),
            (this.aClockwise = o),
            (this.aRotation = s);
        }
        getPoint(t, e) {
          const n = e || new $e(),
            i = 2 * Math.PI;
          let r = this.aEndAngle - this.aStartAngle;
          const a = Math.abs(r) < Number.EPSILON;
          while (r < 0) r += i;
          while (r > i) r -= i;
          r < Number.EPSILON && (r = a ? 0 : i),
            !0 !== this.aClockwise || a || (r === i ? (r = -i) : (r -= i));
          const o = this.aStartAngle + t * r;
          let s = this.aX + this.xRadius * Math.cos(o),
            c = this.aY + this.yRadius * Math.sin(o);
          if (0 !== this.aRotation) {
            const t = Math.cos(this.aRotation),
              e = Math.sin(this.aRotation),
              n = s - this.aX,
              i = c - this.aY;
            (s = n * t - i * e + this.aX), (c = n * e + i * t + this.aY);
          }
          return n.set(s, c);
        }
        copy(t) {
          return (
            super.copy(t),
            (this.aX = t.aX),
            (this.aY = t.aY),
            (this.xRadius = t.xRadius),
            (this.yRadius = t.yRadius),
            (this.aStartAngle = t.aStartAngle),
            (this.aEndAngle = t.aEndAngle),
            (this.aClockwise = t.aClockwise),
            (this.aRotation = t.aRotation),
            this
          );
        }
        toJSON() {
          const t = super.toJSON();
          return (
            (t.aX = this.aX),
            (t.aY = this.aY),
            (t.xRadius = this.xRadius),
            (t.yRadius = this.yRadius),
            (t.aStartAngle = this.aStartAngle),
            (t.aEndAngle = this.aEndAngle),
            (t.aClockwise = this.aClockwise),
            (t.aRotation = this.aRotation),
            t
          );
        }
        fromJSON(t) {
          return (
            super.fromJSON(t),
            (this.aX = t.aX),
            (this.aY = t.aY),
            (this.xRadius = t.xRadius),
            (this.yRadius = t.yRadius),
            (this.aStartAngle = t.aStartAngle),
            (this.aEndAngle = t.aEndAngle),
            (this.aClockwise = t.aClockwise),
            (this.aRotation = t.aRotation),
            this
          );
        }
      }
      Vu.prototype.isEllipseCurve = !0;
      class Wu extends Vu {
        constructor(t, e, n, i, r, a) {
          super(t, e, n, n, i, r, a), (this.type = "ArcCurve");
        }
      }
      function ju() {
        let t = 0,
          e = 0,
          n = 0,
          i = 0;
        function r(r, a, o, s) {
          (t = r),
            (e = o),
            (n = -3 * r + 3 * a - 2 * o - s),
            (i = 2 * r - 2 * a + o + s);
        }
        return {
          initCatmullRom: function (t, e, n, i, a) {
            r(e, n, a * (n - t), a * (i - e));
          },
          initNonuniformCatmullRom: function (t, e, n, i, a, o, s) {
            let c = (e - t) / a - (n - t) / (a + o) + (n - e) / o,
              l = (n - e) / o - (i - e) / (o + s) + (i - n) / s;
            (c *= o), (l *= o), r(e, n, c, l);
          },
          calc: function (r) {
            const a = r * r,
              o = a * r;
            return t + e * r + n * a + i * o;
          },
        };
      }
      Wu.prototype.isArcCurve = !0;
      const qu = new wn(),
        Xu = new ju(),
        Yu = new ju(),
        Ju = new ju();
      class Zu extends Gu {
        constructor(t = [], e = !1, n = "centripetal", i = 0.5) {
          super(),
            (this.type = "CatmullRomCurve3"),
            (this.points = t),
            (this.closed = e),
            (this.curveType = n),
            (this.tension = i);
        }
        getPoint(t, e = new wn()) {
          const n = e,
            i = this.points,
            r = i.length,
            a = (r - (this.closed ? 0 : 1)) * t;
          let o,
            s,
            c = Math.floor(a),
            l = a - c;
          this.closed
            ? (c += c > 0 ? 0 : (Math.floor(Math.abs(c) / r) + 1) * r)
            : 0 === l && c === r - 1 && ((c = r - 2), (l = 1)),
            this.closed || c > 0
              ? (o = i[(c - 1) % r])
              : (qu.subVectors(i[0], i[1]).add(i[0]), (o = qu));
          const h = i[c % r],
            u = i[(c + 1) % r];
          if (
            (this.closed || c + 2 < r
              ? (s = i[(c + 2) % r])
              : (qu.subVectors(i[r - 1], i[r - 2]).add(i[r - 1]), (s = qu)),
            "centripetal" === this.curveType || "chordal" === this.curveType)
          ) {
            const t = "chordal" === this.curveType ? 0.5 : 0.25;
            let e = Math.pow(o.distanceToSquared(h), t),
              n = Math.pow(h.distanceToSquared(u), t),
              i = Math.pow(u.distanceToSquared(s), t);
            n < 1e-4 && (n = 1),
              e < 1e-4 && (e = n),
              i < 1e-4 && (i = n),
              Xu.initNonuniformCatmullRom(o.x, h.x, u.x, s.x, e, n, i),
              Yu.initNonuniformCatmullRom(o.y, h.y, u.y, s.y, e, n, i),
              Ju.initNonuniformCatmullRom(o.z, h.z, u.z, s.z, e, n, i);
          } else
            "catmullrom" === this.curveType &&
              (Xu.initCatmullRom(o.x, h.x, u.x, s.x, this.tension),
              Yu.initCatmullRom(o.y, h.y, u.y, s.y, this.tension),
              Ju.initCatmullRom(o.z, h.z, u.z, s.z, this.tension));
          return n.set(Xu.calc(l), Yu.calc(l), Ju.calc(l)), n;
        }
        copy(t) {
          super.copy(t), (this.points = []);
          for (let e = 0, n = t.points.length; e < n; e++) {
            const n = t.points[e];
            this.points.push(n.clone());
          }
          return (
            (this.closed = t.closed),
            (this.curveType = t.curveType),
            (this.tension = t.tension),
            this
          );
        }
        toJSON() {
          const t = super.toJSON();
          t.points = [];
          for (let e = 0, n = this.points.length; e < n; e++) {
            const n = this.points[e];
            t.points.push(n.toArray());
          }
          return (
            (t.closed = this.closed),
            (t.curveType = this.curveType),
            (t.tension = this.tension),
            t
          );
        }
        fromJSON(t) {
          super.fromJSON(t), (this.points = []);
          for (let e = 0, n = t.points.length; e < n; e++) {
            const n = t.points[e];
            this.points.push(new wn().fromArray(n));
          }
          return (
            (this.closed = t.closed),
            (this.curveType = t.curveType),
            (this.tension = t.tension),
            this
          );
        }
      }
      function Ku(t, e, n, i, r) {
        const a = 0.5 * (i - e),
          o = 0.5 * (r - n),
          s = t * t,
          c = t * s;
        return (
          (2 * n - 2 * i + a + o) * c +
          (-3 * n + 3 * i - 2 * a - o) * s +
          a * t +
          n
        );
      }
      function $u(t, e) {
        const n = 1 - t;
        return n * n * e;
      }
      function Qu(t, e) {
        return 2 * (1 - t) * t * e;
      }
      function td(t, e) {
        return t * t * e;
      }
      function ed(t, e, n, i) {
        return $u(t, e) + Qu(t, n) + td(t, i);
      }
      function nd(t, e) {
        const n = 1 - t;
        return n * n * n * e;
      }
      function id(t, e) {
        const n = 1 - t;
        return 3 * n * n * t * e;
      }
      function rd(t, e) {
        return 3 * (1 - t) * t * t * e;
      }
      function ad(t, e) {
        return t * t * t * e;
      }
      function od(t, e, n, i, r) {
        return nd(t, e) + id(t, n) + rd(t, i) + ad(t, r);
      }
      Zu.prototype.isCatmullRomCurve3 = !0;
      class sd extends Gu {
        constructor(t = new $e(), e = new $e(), n = new $e(), i = new $e()) {
          super(),
            (this.type = "CubicBezierCurve"),
            (this.v0 = t),
            (this.v1 = e),
            (this.v2 = n),
            (this.v3 = i);
        }
        getPoint(t, e = new $e()) {
          const n = e,
            i = this.v0,
            r = this.v1,
            a = this.v2,
            o = this.v3;
          return n.set(od(t, i.x, r.x, a.x, o.x), od(t, i.y, r.y, a.y, o.y)), n;
        }
        copy(t) {
          return (
            super.copy(t),
            this.v0.copy(t.v0),
            this.v1.copy(t.v1),
            this.v2.copy(t.v2),
            this.v3.copy(t.v3),
            this
          );
        }
        toJSON() {
          const t = super.toJSON();
          return (
            (t.v0 = this.v0.toArray()),
            (t.v1 = this.v1.toArray()),
            (t.v2 = this.v2.toArray()),
            (t.v3 = this.v3.toArray()),
            t
          );
        }
        fromJSON(t) {
          return (
            super.fromJSON(t),
            this.v0.fromArray(t.v0),
            this.v1.fromArray(t.v1),
            this.v2.fromArray(t.v2),
            this.v3.fromArray(t.v3),
            this
          );
        }
      }
      sd.prototype.isCubicBezierCurve = !0;
      class cd extends Gu {
        constructor(t = new wn(), e = new wn(), n = new wn(), i = new wn()) {
          super(),
            (this.type = "CubicBezierCurve3"),
            (this.v0 = t),
            (this.v1 = e),
            (this.v2 = n),
            (this.v3 = i);
        }
        getPoint(t, e = new wn()) {
          const n = e,
            i = this.v0,
            r = this.v1,
            a = this.v2,
            o = this.v3;
          return (
            n.set(
              od(t, i.x, r.x, a.x, o.x),
              od(t, i.y, r.y, a.y, o.y),
              od(t, i.z, r.z, a.z, o.z)
            ),
            n
          );
        }
        copy(t) {
          return (
            super.copy(t),
            this.v0.copy(t.v0),
            this.v1.copy(t.v1),
            this.v2.copy(t.v2),
            this.v3.copy(t.v3),
            this
          );
        }
        toJSON() {
          const t = super.toJSON();
          return (
            (t.v0 = this.v0.toArray()),
            (t.v1 = this.v1.toArray()),
            (t.v2 = this.v2.toArray()),
            (t.v3 = this.v3.toArray()),
            t
          );
        }
        fromJSON(t) {
          return (
            super.fromJSON(t),
            this.v0.fromArray(t.v0),
            this.v1.fromArray(t.v1),
            this.v2.fromArray(t.v2),
            this.v3.fromArray(t.v3),
            this
          );
        }
      }
      cd.prototype.isCubicBezierCurve3 = !0;
      class ld extends Gu {
        constructor(t = new $e(), e = new $e()) {
          super(), (this.type = "LineCurve"), (this.v1 = t), (this.v2 = e);
        }
        getPoint(t, e = new $e()) {
          const n = e;
          return (
            1 === t
              ? n.copy(this.v2)
              : (n.copy(this.v2).sub(this.v1),
                n.multiplyScalar(t).add(this.v1)),
            n
          );
        }
        getPointAt(t, e) {
          return this.getPoint(t, e);
        }
        getTangent(t, e) {
          const n = e || new $e();
          return n.copy(this.v2).sub(this.v1).normalize(), n;
        }
        copy(t) {
          return super.copy(t), this.v1.copy(t.v1), this.v2.copy(t.v2), this;
        }
        toJSON() {
          const t = super.toJSON();
          return (t.v1 = this.v1.toArray()), (t.v2 = this.v2.toArray()), t;
        }
        fromJSON(t) {
          return (
            super.fromJSON(t),
            this.v1.fromArray(t.v1),
            this.v2.fromArray(t.v2),
            this
          );
        }
      }
      ld.prototype.isLineCurve = !0;
      class hd extends Gu {
        constructor(t = new wn(), e = new wn()) {
          super(),
            (this.type = "LineCurve3"),
            (this.isLineCurve3 = !0),
            (this.v1 = t),
            (this.v2 = e);
        }
        getPoint(t, e = new wn()) {
          const n = e;
          return (
            1 === t
              ? n.copy(this.v2)
              : (n.copy(this.v2).sub(this.v1),
                n.multiplyScalar(t).add(this.v1)),
            n
          );
        }
        getPointAt(t, e) {
          return this.getPoint(t, e);
        }
        copy(t) {
          return super.copy(t), this.v1.copy(t.v1), this.v2.copy(t.v2), this;
        }
        toJSON() {
          const t = super.toJSON();
          return (t.v1 = this.v1.toArray()), (t.v2 = this.v2.toArray()), t;
        }
        fromJSON(t) {
          return (
            super.fromJSON(t),
            this.v1.fromArray(t.v1),
            this.v2.fromArray(t.v2),
            this
          );
        }
      }
      class ud extends Gu {
        constructor(t = new $e(), e = new $e(), n = new $e()) {
          super(),
            (this.type = "QuadraticBezierCurve"),
            (this.v0 = t),
            (this.v1 = e),
            (this.v2 = n);
        }
        getPoint(t, e = new $e()) {
          const n = e,
            i = this.v0,
            r = this.v1,
            a = this.v2;
          return n.set(ed(t, i.x, r.x, a.x), ed(t, i.y, r.y, a.y)), n;
        }
        copy(t) {
          return (
            super.copy(t),
            this.v0.copy(t.v0),
            this.v1.copy(t.v1),
            this.v2.copy(t.v2),
            this
          );
        }
        toJSON() {
          const t = super.toJSON();
          return (
            (t.v0 = this.v0.toArray()),
            (t.v1 = this.v1.toArray()),
            (t.v2 = this.v2.toArray()),
            t
          );
        }
        fromJSON(t) {
          return (
            super.fromJSON(t),
            this.v0.fromArray(t.v0),
            this.v1.fromArray(t.v1),
            this.v2.fromArray(t.v2),
            this
          );
        }
      }
      ud.prototype.isQuadraticBezierCurve = !0;
      class dd extends Gu {
        constructor(t = new wn(), e = new wn(), n = new wn()) {
          super(),
            (this.type = "QuadraticBezierCurve3"),
            (this.v0 = t),
            (this.v1 = e),
            (this.v2 = n);
        }
        getPoint(t, e = new wn()) {
          const n = e,
            i = this.v0,
            r = this.v1,
            a = this.v2;
          return (
            n.set(
              ed(t, i.x, r.x, a.x),
              ed(t, i.y, r.y, a.y),
              ed(t, i.z, r.z, a.z)
            ),
            n
          );
        }
        copy(t) {
          return (
            super.copy(t),
            this.v0.copy(t.v0),
            this.v1.copy(t.v1),
            this.v2.copy(t.v2),
            this
          );
        }
        toJSON() {
          const t = super.toJSON();
          return (
            (t.v0 = this.v0.toArray()),
            (t.v1 = this.v1.toArray()),
            (t.v2 = this.v2.toArray()),
            t
          );
        }
        fromJSON(t) {
          return (
            super.fromJSON(t),
            this.v0.fromArray(t.v0),
            this.v1.fromArray(t.v1),
            this.v2.fromArray(t.v2),
            this
          );
        }
      }
      dd.prototype.isQuadraticBezierCurve3 = !0;
      class pd extends Gu {
        constructor(t = []) {
          super(), (this.type = "SplineCurve"), (this.points = t);
        }
        getPoint(t, e = new $e()) {
          const n = e,
            i = this.points,
            r = (i.length - 1) * t,
            a = Math.floor(r),
            o = r - a,
            s = i[0 === a ? a : a - 1],
            c = i[a],
            l = i[a > i.length - 2 ? i.length - 1 : a + 1],
            h = i[a > i.length - 3 ? i.length - 1 : a + 2];
          return n.set(Ku(o, s.x, c.x, l.x, h.x), Ku(o, s.y, c.y, l.y, h.y)), n;
        }
        copy(t) {
          super.copy(t), (this.points = []);
          for (let e = 0, n = t.points.length; e < n; e++) {
            const n = t.points[e];
            this.points.push(n.clone());
          }
          return this;
        }
        toJSON() {
          const t = super.toJSON();
          t.points = [];
          for (let e = 0, n = this.points.length; e < n; e++) {
            const n = this.points[e];
            t.points.push(n.toArray());
          }
          return t;
        }
        fromJSON(t) {
          super.fromJSON(t), (this.points = []);
          for (let e = 0, n = t.points.length; e < n; e++) {
            const n = t.points[e];
            this.points.push(new $e().fromArray(n));
          }
          return this;
        }
      }
      pd.prototype.isSplineCurve = !0;
      var fd = Object.freeze({
        __proto__: null,
        ArcCurve: Wu,
        CatmullRomCurve3: Zu,
        CubicBezierCurve: sd,
        CubicBezierCurve3: cd,
        EllipseCurve: Vu,
        LineCurve: ld,
        LineCurve3: hd,
        QuadraticBezierCurve: ud,
        QuadraticBezierCurve3: dd,
        SplineCurve: pd,
      });
      class md extends Gu {
        constructor() {
          super(),
            (this.type = "CurvePath"),
            (this.curves = []),
            (this.autoClose = !1);
        }
        add(t) {
          this.curves.push(t);
        }
        closePath() {
          const t = this.curves[0].getPoint(0),
            e = this.curves[this.curves.length - 1].getPoint(1);
          t.equals(e) || this.curves.push(new ld(e, t));
        }
        getPoint(t, e) {
          const n = t * this.getLength(),
            i = this.getCurveLengths();
          let r = 0;
          while (r < i.length) {
            if (i[r] >= n) {
              const t = i[r] - n,
                a = this.curves[r],
                o = a.getLength(),
                s = 0 === o ? 0 : 1 - t / o;
              return a.getPointAt(s, e);
            }
            r++;
          }
          return null;
        }
        getLength() {
          const t = this.getCurveLengths();
          return t[t.length - 1];
        }
        updateArcLengths() {
          (this.needsUpdate = !0),
            (this.cacheLengths = null),
            this.getCurveLengths();
        }
        getCurveLengths() {
          if (
            this.cacheLengths &&
            this.cacheLengths.length === this.curves.length
          )
            return this.cacheLengths;
          const t = [];
          let e = 0;
          for (let n = 0, i = this.curves.length; n < i; n++)
            (e += this.curves[n].getLength()), t.push(e);
          return (this.cacheLengths = t), t;
        }
        getSpacedPoints(t = 40) {
          const e = [];
          for (let n = 0; n <= t; n++) e.push(this.getPoint(n / t));
          return this.autoClose && e.push(e[0]), e;
        }
        getPoints(t = 12) {
          const e = [];
          let n;
          for (let i = 0, r = this.curves; i < r.length; i++) {
            const a = r[i],
              o =
                a && a.isEllipseCurve
                  ? 2 * t
                  : a && (a.isLineCurve || a.isLineCurve3)
                  ? 1
                  : a && a.isSplineCurve
                  ? t * a.points.length
                  : t,
              s = a.getPoints(o);
            for (let t = 0; t < s.length; t++) {
              const i = s[t];
              (n && n.equals(i)) || (e.push(i), (n = i));
            }
          }
          return (
            this.autoClose &&
              e.length > 1 &&
              !e[e.length - 1].equals(e[0]) &&
              e.push(e[0]),
            e
          );
        }
        copy(t) {
          super.copy(t), (this.curves = []);
          for (let e = 0, n = t.curves.length; e < n; e++) {
            const n = t.curves[e];
            this.curves.push(n.clone());
          }
          return (this.autoClose = t.autoClose), this;
        }
        toJSON() {
          const t = super.toJSON();
          (t.autoClose = this.autoClose), (t.curves = []);
          for (let e = 0, n = this.curves.length; e < n; e++) {
            const n = this.curves[e];
            t.curves.push(n.toJSON());
          }
          return t;
        }
        fromJSON(t) {
          super.fromJSON(t), (this.autoClose = t.autoClose), (this.curves = []);
          for (let e = 0, n = t.curves.length; e < n; e++) {
            const n = t.curves[e];
            this.curves.push(new fd[n.type]().fromJSON(n));
          }
          return this;
        }
      }
      class gd extends md {
        constructor(t) {
          super(),
            (this.type = "Path"),
            (this.currentPoint = new $e()),
            t && this.setFromPoints(t);
        }
        setFromPoints(t) {
          this.moveTo(t[0].x, t[0].y);
          for (let e = 1, n = t.length; e < n; e++) this.lineTo(t[e].x, t[e].y);
          return this;
        }
        moveTo(t, e) {
          return this.currentPoint.set(t, e), this;
        }
        lineTo(t, e) {
          const n = new ld(this.currentPoint.clone(), new $e(t, e));
          return this.curves.push(n), this.currentPoint.set(t, e), this;
        }
        quadraticCurveTo(t, e, n, i) {
          const r = new ud(
            this.currentPoint.clone(),
            new $e(t, e),
            new $e(n, i)
          );
          return this.curves.push(r), this.currentPoint.set(n, i), this;
        }
        bezierCurveTo(t, e, n, i, r, a) {
          const o = new sd(
            this.currentPoint.clone(),
            new $e(t, e),
            new $e(n, i),
            new $e(r, a)
          );
          return this.curves.push(o), this.currentPoint.set(r, a), this;
        }
        splineThru(t) {
          const e = [this.currentPoint.clone()].concat(t),
            n = new pd(e);
          return (
            this.curves.push(n), this.currentPoint.copy(t[t.length - 1]), this
          );
        }
        arc(t, e, n, i, r, a) {
          const o = this.currentPoint.x,
            s = this.currentPoint.y;
          return this.absarc(t + o, e + s, n, i, r, a), this;
        }
        absarc(t, e, n, i, r, a) {
          return this.absellipse(t, e, n, n, i, r, a), this;
        }
        ellipse(t, e, n, i, r, a, o, s) {
          const c = this.currentPoint.x,
            l = this.currentPoint.y;
          return this.absellipse(t + c, e + l, n, i, r, a, o, s), this;
        }
        absellipse(t, e, n, i, r, a, o, s) {
          const c = new Vu(t, e, n, i, r, a, o, s);
          if (this.curves.length > 0) {
            const t = c.getPoint(0);
            t.equals(this.currentPoint) || this.lineTo(t.x, t.y);
          }
          this.curves.push(c);
          const l = c.getPoint(1);
          return this.currentPoint.copy(l), this;
        }
        copy(t) {
          return super.copy(t), this.currentPoint.copy(t.currentPoint), this;
        }
        toJSON() {
          const t = super.toJSON();
          return (t.currentPoint = this.currentPoint.toArray()), t;
        }
        fromJSON(t) {
          return (
            super.fromJSON(t), this.currentPoint.fromArray(t.currentPoint), this
          );
        }
      }
      class vd extends gd {
        constructor(t) {
          super(t),
            (this.uuid = je()),
            (this.type = "Shape"),
            (this.holes = []);
        }
        getPointsHoles(t) {
          const e = [];
          for (let n = 0, i = this.holes.length; n < i; n++)
            e[n] = this.holes[n].getPoints(t);
          return e;
        }
        extractPoints(t) {
          return { shape: this.getPoints(t), holes: this.getPointsHoles(t) };
        }
        copy(t) {
          super.copy(t), (this.holes = []);
          for (let e = 0, n = t.holes.length; e < n; e++) {
            const n = t.holes[e];
            this.holes.push(n.clone());
          }
          return this;
        }
        toJSON() {
          const t = super.toJSON();
          (t.uuid = this.uuid), (t.holes = []);
          for (let e = 0, n = this.holes.length; e < n; e++) {
            const n = this.holes[e];
            t.holes.push(n.toJSON());
          }
          return t;
        }
        fromJSON(t) {
          super.fromJSON(t), (this.uuid = t.uuid), (this.holes = []);
          for (let e = 0, n = t.holes.length; e < n; e++) {
            const n = t.holes[e];
            this.holes.push(new gd().fromJSON(n));
          }
          return this;
        }
      }
      const yd = {
        triangulate: function (t, e, n = 2) {
          const i = e && e.length,
            r = i ? e[0] * n : t.length;
          let a = xd(t, 0, r, n, !0);
          const o = [];
          if (!a || a.next === a.prev) return o;
          let s, c, l, h, u, d, p;
          if ((i && (a = Td(t, e, a, n)), t.length > 80 * n)) {
            (s = l = t[0]), (c = h = t[1]);
            for (let e = n; e < r; e += n)
              (u = t[e]),
                (d = t[e + 1]),
                u < s && (s = u),
                d < c && (c = d),
                u > l && (l = u),
                d > h && (h = d);
            (p = Math.max(l - s, h - c)), (p = 0 !== p ? 1 / p : 0);
          }
          return bd(a, o, n, s, c, p), o;
        },
      };
      function xd(t, e, n, i, r) {
        let a, o;
        if (r === Jd(t, e, n, i) > 0)
          for (a = e; a < n; a += i) o = qd(a, t[a], t[a + 1], o);
        else for (a = n - i; a >= e; a -= i) o = qd(a, t[a], t[a + 1], o);
        return o && Ud(o, o.next) && (Xd(o), (o = o.next)), o;
      }
      function _d(t, e) {
        if (!t) return t;
        e || (e = t);
        let n,
          i = t;
        do {
          if (
            ((n = !1),
            i.steiner || (!Ud(i, i.next) && 0 !== zd(i.prev, i, i.next)))
          )
            i = i.next;
          else {
            if ((Xd(i), (i = e = i.prev), i === i.next)) break;
            n = !0;
          }
        } while (n || i !== e);
        return e;
      }
      function bd(t, e, n, i, r, a, o) {
        if (!t) return;
        !o && a && Pd(t, i, r, a);
        let s,
          c,
          l = t;
        while (t.prev !== t.next)
          if (((s = t.prev), (c = t.next), a ? Md(t, i, r, a) : wd(t)))
            e.push(s.i / n),
              e.push(t.i / n),
              e.push(c.i / n),
              Xd(t),
              (t = c.next),
              (l = c.next);
          else if (((t = c), t === l)) {
            o
              ? 1 === o
                ? ((t = Sd(_d(t), e, n)), bd(t, e, n, i, r, a, 2))
                : 2 === o && Ed(t, e, n, i, r, a)
              : bd(_d(t), e, n, i, r, a, 1);
            break;
          }
      }
      function wd(t) {
        const e = t.prev,
          n = t,
          i = t.next;
        if (zd(e, n, i) >= 0) return !1;
        let r = t.next.next;
        while (r !== t.prev) {
          if (
            Nd(e.x, e.y, n.x, n.y, i.x, i.y, r.x, r.y) &&
            zd(r.prev, r, r.next) >= 0
          )
            return !1;
          r = r.next;
        }
        return !0;
      }
      function Md(t, e, n, i) {
        const r = t.prev,
          a = t,
          o = t.next;
        if (zd(r, a, o) >= 0) return !1;
        const s = r.x < a.x ? (r.x < o.x ? r.x : o.x) : a.x < o.x ? a.x : o.x,
          c = r.y < a.y ? (r.y < o.y ? r.y : o.y) : a.y < o.y ? a.y : o.y,
          l = r.x > a.x ? (r.x > o.x ? r.x : o.x) : a.x > o.x ? a.x : o.x,
          h = r.y > a.y ? (r.y > o.y ? r.y : o.y) : a.y > o.y ? a.y : o.y,
          u = Id(s, c, e, n, i),
          d = Id(l, h, e, n, i);
        let p = t.prevZ,
          f = t.nextZ;
        while (p && p.z >= u && f && f.z <= d) {
          if (
            p !== t.prev &&
            p !== t.next &&
            Nd(r.x, r.y, a.x, a.y, o.x, o.y, p.x, p.y) &&
            zd(p.prev, p, p.next) >= 0
          )
            return !1;
          if (
            ((p = p.prevZ),
            f !== t.prev &&
              f !== t.next &&
              Nd(r.x, r.y, a.x, a.y, o.x, o.y, f.x, f.y) &&
              zd(f.prev, f, f.next) >= 0)
          )
            return !1;
          f = f.nextZ;
        }
        while (p && p.z >= u) {
          if (
            p !== t.prev &&
            p !== t.next &&
            Nd(r.x, r.y, a.x, a.y, o.x, o.y, p.x, p.y) &&
            zd(p.prev, p, p.next) >= 0
          )
            return !1;
          p = p.prevZ;
        }
        while (f && f.z <= d) {
          if (
            f !== t.prev &&
            f !== t.next &&
            Nd(r.x, r.y, a.x, a.y, o.x, o.y, f.x, f.y) &&
            zd(f.prev, f, f.next) >= 0
          )
            return !1;
          f = f.nextZ;
        }
        return !0;
      }
      function Sd(t, e, n) {
        let i = t;
        do {
          const r = i.prev,
            a = i.next.next;
          !Ud(r, a) &&
            Fd(r, i, i.next, a) &&
            Vd(r, a) &&
            Vd(a, r) &&
            (e.push(r.i / n),
            e.push(i.i / n),
            e.push(a.i / n),
            Xd(i),
            Xd(i.next),
            (i = t = a)),
            (i = i.next);
        } while (i !== t);
        return _d(i);
      }
      function Ed(t, e, n, i, r, a) {
        let o = t;
        do {
          let t = o.next.next;
          while (t !== o.prev) {
            if (o.i !== t.i && Bd(o, t)) {
              let s = jd(o, t);
              return (
                (o = _d(o, o.next)),
                (s = _d(s, s.next)),
                bd(o, e, n, i, r, a),
                void bd(s, e, n, i, r, a)
              );
            }
            t = t.next;
          }
          o = o.next;
        } while (o !== t);
      }
      function Td(t, e, n, i) {
        const r = [];
        let a, o, s, c, l;
        for (a = 0, o = e.length; a < o; a++)
          (s = e[a] * i),
            (c = a < o - 1 ? e[a + 1] * i : t.length),
            (l = xd(t, s, c, i, !1)),
            l === l.next && (l.steiner = !0),
            r.push(Od(l));
        for (r.sort(Ad), a = 0; a < r.length; a++)
          Cd(r[a], n), (n = _d(n, n.next));
        return n;
      }
      function Ad(t, e) {
        return t.x - e.x;
      }
      function Cd(t, e) {
        if (((e = Rd(t, e)), e)) {
          const n = jd(e, t);
          _d(e, e.next), _d(n, n.next);
        }
      }
      function Rd(t, e) {
        let n = e;
        const i = t.x,
          r = t.y;
        let a,
          o = -1 / 0;
        do {
          if (r <= n.y && r >= n.next.y && n.next.y !== n.y) {
            const t = n.x + ((r - n.y) * (n.next.x - n.x)) / (n.next.y - n.y);
            if (t <= i && t > o) {
              if (((o = t), t === i)) {
                if (r === n.y) return n;
                if (r === n.next.y) return n.next;
              }
              a = n.x < n.next.x ? n : n.next;
            }
          }
          n = n.next;
        } while (n !== e);
        if (!a) return null;
        if (i === o) return a;
        const s = a,
          c = a.x,
          l = a.y;
        let h,
          u = 1 / 0;
        n = a;
        do {
          i >= n.x &&
            n.x >= c &&
            i !== n.x &&
            Nd(r < l ? i : o, r, c, l, r < l ? o : i, r, n.x, n.y) &&
            ((h = Math.abs(r - n.y) / (i - n.x)),
            Vd(n, t) &&
              (h < u ||
                (h === u && (n.x > a.x || (n.x === a.x && Ld(a, n))))) &&
              ((a = n), (u = h))),
            (n = n.next);
        } while (n !== s);
        return a;
      }
      function Ld(t, e) {
        return zd(t.prev, t, e.prev) < 0 && zd(e.next, t, t.next) < 0;
      }
      function Pd(t, e, n, i) {
        let r = t;
        do {
          null === r.z && (r.z = Id(r.x, r.y, e, n, i)),
            (r.prevZ = r.prev),
            (r.nextZ = r.next),
            (r = r.next);
        } while (r !== t);
        (r.prevZ.nextZ = null), (r.prevZ = null), Dd(r);
      }
      function Dd(t) {
        let e,
          n,
          i,
          r,
          a,
          o,
          s,
          c,
          l = 1;
        do {
          (n = t), (t = null), (a = null), (o = 0);
          while (n) {
            for (o++, i = n, s = 0, e = 0; e < l; e++)
              if ((s++, (i = i.nextZ), !i)) break;
            c = l;
            while (s > 0 || (c > 0 && i))
              0 !== s && (0 === c || !i || n.z <= i.z)
                ? ((r = n), (n = n.nextZ), s--)
                : ((r = i), (i = i.nextZ), c--),
                a ? (a.nextZ = r) : (t = r),
                (r.prevZ = a),
                (a = r);
            n = i;
          }
          (a.nextZ = null), (l *= 2);
        } while (o > 1);
        return t;
      }
      function Id(t, e, n, i, r) {
        return (
          (t = 32767 * (t - n) * r),
          (e = 32767 * (e - i) * r),
          (t = 16711935 & (t | (t << 8))),
          (t = 252645135 & (t | (t << 4))),
          (t = 858993459 & (t | (t << 2))),
          (t = 1431655765 & (t | (t << 1))),
          (e = 16711935 & (e | (e << 8))),
          (e = 252645135 & (e | (e << 4))),
          (e = 858993459 & (e | (e << 2))),
          (e = 1431655765 & (e | (e << 1))),
          t | (e << 1)
        );
      }
      function Od(t) {
        let e = t,
          n = t;
        do {
          (e.x < n.x || (e.x === n.x && e.y < n.y)) && (n = e), (e = e.next);
        } while (e !== t);
        return n;
      }
      function Nd(t, e, n, i, r, a, o, s) {
        return (
          (r - o) * (e - s) - (t - o) * (a - s) >= 0 &&
          (t - o) * (i - s) - (n - o) * (e - s) >= 0 &&
          (n - o) * (a - s) - (r - o) * (i - s) >= 0
        );
      }
      function Bd(t, e) {
        return (
          t.next.i !== e.i &&
          t.prev.i !== e.i &&
          !Gd(t, e) &&
          ((Vd(t, e) &&
            Vd(e, t) &&
            Wd(t, e) &&
            (zd(t.prev, t, e.prev) || zd(t, e.prev, e))) ||
            (Ud(t, e) &&
              zd(t.prev, t, t.next) > 0 &&
              zd(e.prev, e, e.next) > 0))
        );
      }
      function zd(t, e, n) {
        return (e.y - t.y) * (n.x - e.x) - (e.x - t.x) * (n.y - e.y);
      }
      function Ud(t, e) {
        return t.x === e.x && t.y === e.y;
      }
      function Fd(t, e, n, i) {
        const r = kd(zd(t, e, n)),
          a = kd(zd(t, e, i)),
          o = kd(zd(n, i, t)),
          s = kd(zd(n, i, e));
        return (
          (r !== a && o !== s) ||
          !(0 !== r || !Hd(t, n, e)) ||
          !(0 !== a || !Hd(t, i, e)) ||
          !(0 !== o || !Hd(n, t, i)) ||
          !(0 !== s || !Hd(n, e, i))
        );
      }
      function Hd(t, e, n) {
        return (
          e.x <= Math.max(t.x, n.x) &&
          e.x >= Math.min(t.x, n.x) &&
          e.y <= Math.max(t.y, n.y) &&
          e.y >= Math.min(t.y, n.y)
        );
      }
      function kd(t) {
        return t > 0 ? 1 : t < 0 ? -1 : 0;
      }
      function Gd(t, e) {
        let n = t;
        do {
          if (
            n.i !== t.i &&
            n.next.i !== t.i &&
            n.i !== e.i &&
            n.next.i !== e.i &&
            Fd(n, n.next, t, e)
          )
            return !0;
          n = n.next;
        } while (n !== t);
        return !1;
      }
      function Vd(t, e) {
        return zd(t.prev, t, t.next) < 0
          ? zd(t, e, t.next) >= 0 && zd(t, t.prev, e) >= 0
          : zd(t, e, t.prev) < 0 || zd(t, t.next, e) < 0;
      }
      function Wd(t, e) {
        let n = t,
          i = !1;
        const r = (t.x + e.x) / 2,
          a = (t.y + e.y) / 2;
        do {
          n.y > a !== n.next.y > a &&
            n.next.y !== n.y &&
            r < ((n.next.x - n.x) * (a - n.y)) / (n.next.y - n.y) + n.x &&
            (i = !i),
            (n = n.next);
        } while (n !== t);
        return i;
      }
      function jd(t, e) {
        const n = new Yd(t.i, t.x, t.y),
          i = new Yd(e.i, e.x, e.y),
          r = t.next,
          a = e.prev;
        return (
          (t.next = e),
          (e.prev = t),
          (n.next = r),
          (r.prev = n),
          (i.next = n),
          (n.prev = i),
          (a.next = i),
          (i.prev = a),
          i
        );
      }
      function qd(t, e, n, i) {
        const r = new Yd(t, e, n);
        return (
          i
            ? ((r.next = i.next), (r.prev = i), (i.next.prev = r), (i.next = r))
            : ((r.prev = r), (r.next = r)),
          r
        );
      }
      function Xd(t) {
        (t.next.prev = t.prev),
          (t.prev.next = t.next),
          t.prevZ && (t.prevZ.nextZ = t.nextZ),
          t.nextZ && (t.nextZ.prevZ = t.prevZ);
      }
      function Yd(t, e, n) {
        (this.i = t),
          (this.x = e),
          (this.y = n),
          (this.prev = null),
          (this.next = null),
          (this.z = null),
          (this.prevZ = null),
          (this.nextZ = null),
          (this.steiner = !1);
      }
      function Jd(t, e, n, i) {
        let r = 0;
        for (let a = e, o = n - i; a < n; a += i)
          (r += (t[o] - t[a]) * (t[a + 1] + t[o + 1])), (o = a);
        return r;
      }
      class Zd {
        static area(t) {
          const e = t.length;
          let n = 0;
          for (let i = e - 1, r = 0; r < e; i = r++)
            n += t[i].x * t[r].y - t[r].x * t[i].y;
          return 0.5 * n;
        }
        static isClockWise(t) {
          return Zd.area(t) < 0;
        }
        static triangulateShape(t, e) {
          const n = [],
            i = [],
            r = [];
          Kd(t), $d(n, t);
          let a = t.length;
          e.forEach(Kd);
          for (let s = 0; s < e.length; s++)
            i.push(a), (a += e[s].length), $d(n, e[s]);
          const o = yd.triangulate(n, i);
          for (let s = 0; s < o.length; s += 3) r.push(o.slice(s, s + 3));
          return r;
        }
      }
      function Kd(t) {
        const e = t.length;
        e > 2 && t[e - 1].equals(t[0]) && t.pop();
      }
      function $d(t, e) {
        for (let n = 0; n < e.length; n++) t.push(e[n].x), t.push(e[n].y);
      }
      class Qd extends Qi {
        constructor(
          t = new vd([
            new $e(0.5, 0.5),
            new $e(-0.5, 0.5),
            new $e(-0.5, -0.5),
            new $e(0.5, -0.5),
          ]),
          e = {}
        ) {
          super(),
            (this.type = "ExtrudeGeometry"),
            (this.parameters = { shapes: t, options: e }),
            (t = Array.isArray(t) ? t : [t]);
          const n = this,
            i = [],
            r = [];
          for (let o = 0, s = t.length; o < s; o++) {
            const e = t[o];
            a(e);
          }
          function a(t) {
            const a = [],
              o = void 0 !== e.curveSegments ? e.curveSegments : 12,
              s = void 0 !== e.steps ? e.steps : 1;
            let c = void 0 !== e.depth ? e.depth : 1,
              l = void 0 === e.bevelEnabled || e.bevelEnabled,
              h = void 0 !== e.bevelThickness ? e.bevelThickness : 0.2,
              u = void 0 !== e.bevelSize ? e.bevelSize : h - 0.1,
              d = void 0 !== e.bevelOffset ? e.bevelOffset : 0,
              p = void 0 !== e.bevelSegments ? e.bevelSegments : 3;
            const f = e.extrudePath,
              m = void 0 !== e.UVGenerator ? e.UVGenerator : tp;
            void 0 !== e.amount &&
              (console.warn(
                "THREE.ExtrudeBufferGeometry: amount has been renamed to depth."
              ),
              (c = e.amount));
            let g,
              v,
              y,
              x,
              _,
              b = !1;
            f &&
              ((g = f.getSpacedPoints(s)),
              (b = !0),
              (l = !1),
              (v = f.computeFrenetFrames(s, !1)),
              (y = new wn()),
              (x = new wn()),
              (_ = new wn())),
              l || ((p = 0), (h = 0), (u = 0), (d = 0));
            const w = t.extractPoints(o);
            let M = w.shape;
            const S = w.holes,
              E = !Zd.isClockWise(M);
            if (E) {
              M = M.reverse();
              for (let t = 0, e = S.length; t < e; t++) {
                const e = S[t];
                Zd.isClockWise(e) && (S[t] = e.reverse());
              }
            }
            const T = Zd.triangulateShape(M, S),
              A = M;
            for (let e = 0, n = S.length; e < n; e++) {
              const t = S[e];
              M = M.concat(t);
            }
            function C(t, e, n) {
              return (
                e || console.error("THREE.ExtrudeGeometry: vec does not exist"),
                e.clone().multiplyScalar(n).add(t)
              );
            }
            const R = M.length,
              L = T.length;
            function P(t, e, n) {
              let i, r, a;
              const o = t.x - e.x,
                s = t.y - e.y,
                c = n.x - t.x,
                l = n.y - t.y,
                h = o * o + s * s,
                u = o * l - s * c;
              if (Math.abs(u) > Number.EPSILON) {
                const u = Math.sqrt(h),
                  d = Math.sqrt(c * c + l * l),
                  p = e.x - s / u,
                  f = e.y + o / u,
                  m = n.x - l / d,
                  g = n.y + c / d,
                  v = ((m - p) * l - (g - f) * c) / (o * l - s * c);
                (i = p + o * v - t.x), (r = f + s * v - t.y);
                const y = i * i + r * r;
                if (y <= 2) return new $e(i, r);
                a = Math.sqrt(y / 2);
              } else {
                let t = !1;
                o > Number.EPSILON
                  ? c > Number.EPSILON && (t = !0)
                  : o < -Number.EPSILON
                  ? c < -Number.EPSILON && (t = !0)
                  : Math.sign(s) === Math.sign(l) && (t = !0),
                  t
                    ? ((i = -s), (r = o), (a = Math.sqrt(h)))
                    : ((i = o), (r = s), (a = Math.sqrt(h / 2)));
              }
              return new $e(i / a, r / a);
            }
            const D = [];
            for (
              let e = 0, n = A.length, i = n - 1, r = e + 1;
              e < n;
              e++, i++, r++
            )
              i === n && (i = 0),
                r === n && (r = 0),
                (D[e] = P(A[e], A[i], A[r]));
            const I = [];
            let O,
              N = D.concat();
            for (let e = 0, n = S.length; e < n; e++) {
              const t = S[e];
              O = [];
              for (
                let e = 0, n = t.length, i = n - 1, r = e + 1;
                e < n;
                e++, i++, r++
              )
                i === n && (i = 0),
                  r === n && (r = 0),
                  (O[e] = P(t[e], t[i], t[r]));
              I.push(O), (N = N.concat(O));
            }
            for (let e = 0; e < p; e++) {
              const t = e / p,
                n = h * Math.cos((t * Math.PI) / 2),
                i = u * Math.sin((t * Math.PI) / 2) + d;
              for (let e = 0, r = A.length; e < r; e++) {
                const t = C(A[e], D[e], i);
                H(t.x, t.y, -n);
              }
              for (let e = 0, r = S.length; e < r; e++) {
                const t = S[e];
                O = I[e];
                for (let e = 0, r = t.length; e < r; e++) {
                  const r = C(t[e], O[e], i);
                  H(r.x, r.y, -n);
                }
              }
            }
            const B = u + d;
            for (let e = 0; e < R; e++) {
              const t = l ? C(M[e], N[e], B) : M[e];
              b
                ? (x.copy(v.normals[0]).multiplyScalar(t.x),
                  y.copy(v.binormals[0]).multiplyScalar(t.y),
                  _.copy(g[0]).add(x).add(y),
                  H(_.x, _.y, _.z))
                : H(t.x, t.y, 0);
            }
            for (let e = 1; e <= s; e++)
              for (let t = 0; t < R; t++) {
                const n = l ? C(M[t], N[t], B) : M[t];
                b
                  ? (x.copy(v.normals[e]).multiplyScalar(n.x),
                    y.copy(v.binormals[e]).multiplyScalar(n.y),
                    _.copy(g[e]).add(x).add(y),
                    H(_.x, _.y, _.z))
                  : H(n.x, n.y, (c / s) * e);
              }
            for (let e = p - 1; e >= 0; e--) {
              const t = e / p,
                n = h * Math.cos((t * Math.PI) / 2),
                i = u * Math.sin((t * Math.PI) / 2) + d;
              for (let e = 0, r = A.length; e < r; e++) {
                const t = C(A[e], D[e], i);
                H(t.x, t.y, c + n);
              }
              for (let e = 0, r = S.length; e < r; e++) {
                const t = S[e];
                O = I[e];
                for (let e = 0, r = t.length; e < r; e++) {
                  const r = C(t[e], O[e], i);
                  b
                    ? H(r.x, r.y + g[s - 1].y, g[s - 1].x + n)
                    : H(r.x, r.y, c + n);
                }
              }
            }
            function z() {
              const t = i.length / 3;
              if (l) {
                let t = 0,
                  e = R * t;
                for (let n = 0; n < L; n++) {
                  const t = T[n];
                  k(t[2] + e, t[1] + e, t[0] + e);
                }
                (t = s + 2 * p), (e = R * t);
                for (let n = 0; n < L; n++) {
                  const t = T[n];
                  k(t[0] + e, t[1] + e, t[2] + e);
                }
              } else {
                for (let t = 0; t < L; t++) {
                  const e = T[t];
                  k(e[2], e[1], e[0]);
                }
                for (let t = 0; t < L; t++) {
                  const e = T[t];
                  k(e[0] + R * s, e[1] + R * s, e[2] + R * s);
                }
              }
              n.addGroup(t, i.length / 3 - t, 0);
            }
            function U() {
              const t = i.length / 3;
              let e = 0;
              F(A, e), (e += A.length);
              for (let n = 0, i = S.length; n < i; n++) {
                const t = S[n];
                F(t, e), (e += t.length);
              }
              n.addGroup(t, i.length / 3 - t, 1);
            }
            function F(t, e) {
              let n = t.length;
              while (--n >= 0) {
                const i = n;
                let r = n - 1;
                r < 0 && (r = t.length - 1);
                for (let t = 0, n = s + 2 * p; t < n; t++) {
                  const n = R * t,
                    a = R * (t + 1),
                    o = e + i + n,
                    s = e + r + n,
                    c = e + r + a,
                    l = e + i + a;
                  G(o, s, c, l);
                }
              }
            }
            function H(t, e, n) {
              a.push(t), a.push(e), a.push(n);
            }
            function k(t, e, r) {
              V(t), V(e), V(r);
              const a = i.length / 3,
                o = m.generateTopUV(n, i, a - 3, a - 2, a - 1);
              W(o[0]), W(o[1]), W(o[2]);
            }
            function G(t, e, r, a) {
              V(t), V(e), V(a), V(e), V(r), V(a);
              const o = i.length / 3,
                s = m.generateSideWallUV(n, i, o - 6, o - 3, o - 2, o - 1);
              W(s[0]), W(s[1]), W(s[3]), W(s[1]), W(s[2]), W(s[3]);
            }
            function V(t) {
              i.push(a[3 * t + 0]), i.push(a[3 * t + 1]), i.push(a[3 * t + 2]);
            }
            function W(t) {
              r.push(t.x), r.push(t.y);
            }
            z(), U();
          }
          this.setAttribute("position", new ji(i, 3)),
            this.setAttribute("uv", new ji(r, 2)),
            this.computeVertexNormals();
        }
        toJSON() {
          const t = super.toJSON(),
            e = this.parameters.shapes,
            n = this.parameters.options;
          return ep(e, n, t);
        }
        static fromJSON(t, e) {
          const n = [];
          for (let r = 0, a = t.shapes.length; r < a; r++) {
            const i = e[t.shapes[r]];
            n.push(i);
          }
          const i = t.options.extrudePath;
          return (
            void 0 !== i &&
              (t.options.extrudePath = new fd[i.type]().fromJSON(i)),
            new Qd(n, t.options)
          );
        }
      }
      const tp = {
        generateTopUV: function (t, e, n, i, r) {
          const a = e[3 * n],
            o = e[3 * n + 1],
            s = e[3 * i],
            c = e[3 * i + 1],
            l = e[3 * r],
            h = e[3 * r + 1];
          return [new $e(a, o), new $e(s, c), new $e(l, h)];
        },
        generateSideWallUV: function (t, e, n, i, r, a) {
          const o = e[3 * n],
            s = e[3 * n + 1],
            c = e[3 * n + 2],
            l = e[3 * i],
            h = e[3 * i + 1],
            u = e[3 * i + 2],
            d = e[3 * r],
            p = e[3 * r + 1],
            f = e[3 * r + 2],
            m = e[3 * a],
            g = e[3 * a + 1],
            v = e[3 * a + 2];
          return Math.abs(s - h) < Math.abs(o - l)
            ? [
                new $e(o, 1 - c),
                new $e(l, 1 - u),
                new $e(d, 1 - f),
                new $e(m, 1 - v),
              ]
            : [
                new $e(s, 1 - c),
                new $e(h, 1 - u),
                new $e(p, 1 - f),
                new $e(g, 1 - v),
              ];
        },
      };
      function ep(t, e, n) {
        if (((n.shapes = []), Array.isArray(t)))
          for (let i = 0, r = t.length; i < r; i++) {
            const e = t[i];
            n.shapes.push(e.uuid);
          }
        else n.shapes.push(t.uuid);
        return (
          void 0 !== e.extrudePath &&
            (n.options.extrudePath = e.extrudePath.toJSON()),
          n
        );
      }
      class np extends Nu {
        constructor(t = 1, e = 0) {
          const n = (1 + Math.sqrt(5)) / 2,
            i = [
              -1,
              n,
              0,
              1,
              n,
              0,
              -1,
              -n,
              0,
              1,
              -n,
              0,
              0,
              -1,
              n,
              0,
              1,
              n,
              0,
              -1,
              -n,
              0,
              1,
              -n,
              n,
              0,
              -1,
              n,
              0,
              1,
              -n,
              0,
              -1,
              -n,
              0,
              1,
            ],
            r = [
              0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11,
              4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6,
              8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1,
            ];
          super(i, r, t, e),
            (this.type = "IcosahedronGeometry"),
            (this.parameters = { radius: t, detail: e });
        }
        static fromJSON(t) {
          return new np(t.radius, t.detail);
        }
      }
      class ip extends Qi {
        constructor(
          t = [new $e(0, 0.5), new $e(0.5, 0), new $e(0, -0.5)],
          e = 12,
          n = 0,
          i = 2 * Math.PI
        ) {
          super(),
            (this.type = "LatheGeometry"),
            (this.parameters = {
              points: t,
              segments: e,
              phiStart: n,
              phiLength: i,
            }),
            (e = Math.floor(e)),
            (i = qe(i, 0, 2 * Math.PI));
          const r = [],
            a = [],
            o = [],
            s = [],
            c = [],
            l = 1 / e,
            h = new wn(),
            u = new $e(),
            d = new wn(),
            p = new wn(),
            f = new wn();
          let m = 0,
            g = 0;
          for (let v = 0; v <= t.length - 1; v++)
            switch (v) {
              case 0:
                (m = t[v + 1].x - t[v].x),
                  (g = t[v + 1].y - t[v].y),
                  (d.x = 1 * g),
                  (d.y = -m),
                  (d.z = 0 * g),
                  f.copy(d),
                  d.normalize(),
                  s.push(d.x, d.y, d.z);
                break;
              case t.length - 1:
                s.push(f.x, f.y, f.z);
                break;
              default:
                (m = t[v + 1].x - t[v].x),
                  (g = t[v + 1].y - t[v].y),
                  (d.x = 1 * g),
                  (d.y = -m),
                  (d.z = 0 * g),
                  p.copy(d),
                  (d.x += f.x),
                  (d.y += f.y),
                  (d.z += f.z),
                  d.normalize(),
                  s.push(d.x, d.y, d.z),
                  f.copy(p);
            }
          for (let v = 0; v <= e; v++) {
            const r = n + v * l * i,
              d = Math.sin(r),
              p = Math.cos(r);
            for (let n = 0; n <= t.length - 1; n++) {
              (h.x = t[n].x * d),
                (h.y = t[n].y),
                (h.z = t[n].x * p),
                a.push(h.x, h.y, h.z),
                (u.x = v / e),
                (u.y = n / (t.length - 1)),
                o.push(u.x, u.y);
              const i = s[3 * n + 0] * d,
                r = s[3 * n + 1],
                l = s[3 * n + 0] * p;
              c.push(i, r, l);
            }
          }
          for (let v = 0; v < e; v++)
            for (let e = 0; e < t.length - 1; e++) {
              const n = e + v * t.length,
                i = n,
                a = n + t.length,
                o = n + t.length + 1,
                s = n + 1;
              r.push(i, a, s), r.push(o, s, a);
            }
          this.setIndex(r),
            this.setAttribute("position", new ji(a, 3)),
            this.setAttribute("uv", new ji(o, 2)),
            this.setAttribute("normal", new ji(c, 3));
        }
        static fromJSON(t) {
          return new ip(t.points, t.segments, t.phiStart, t.phiLength);
        }
      }
      class rp extends Nu {
        constructor(t = 1, e = 0) {
          const n = [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1],
            i = [
              0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1,
              4, 2,
            ];
          super(n, i, t, e),
            (this.type = "OctahedronGeometry"),
            (this.parameters = { radius: t, detail: e });
        }
        static fromJSON(t) {
          return new rp(t.radius, t.detail);
        }
      }
      class ap extends Qi {
        constructor(t = 0.5, e = 1, n = 8, i = 1, r = 0, a = 2 * Math.PI) {
          super(),
            (this.type = "RingGeometry"),
            (this.parameters = {
              innerRadius: t,
              outerRadius: e,
              thetaSegments: n,
              phiSegments: i,
              thetaStart: r,
              thetaLength: a,
            }),
            (n = Math.max(3, n)),
            (i = Math.max(1, i));
          const o = [],
            s = [],
            c = [],
            l = [];
          let h = t;
          const u = (e - t) / i,
            d = new wn(),
            p = new $e();
          for (let f = 0; f <= i; f++) {
            for (let t = 0; t <= n; t++) {
              const i = r + (t / n) * a;
              (d.x = h * Math.cos(i)),
                (d.y = h * Math.sin(i)),
                s.push(d.x, d.y, d.z),
                c.push(0, 0, 1),
                (p.x = (d.x / e + 1) / 2),
                (p.y = (d.y / e + 1) / 2),
                l.push(p.x, p.y);
            }
            h += u;
          }
          for (let f = 0; f < i; f++) {
            const t = f * (n + 1);
            for (let e = 0; e < n; e++) {
              const i = e + t,
                r = i,
                a = i + n + 1,
                s = i + n + 2,
                c = i + 1;
              o.push(r, a, c), o.push(a, s, c);
            }
          }
          this.setIndex(o),
            this.setAttribute("position", new ji(s, 3)),
            this.setAttribute("normal", new ji(c, 3)),
            this.setAttribute("uv", new ji(l, 2));
        }
        static fromJSON(t) {
          return new ap(
            t.innerRadius,
            t.outerRadius,
            t.thetaSegments,
            t.phiSegments,
            t.thetaStart,
            t.thetaLength
          );
        }
      }
      class op extends Qi {
        constructor(
          t = new vd([new $e(0, 0.5), new $e(-0.5, -0.5), new $e(0.5, -0.5)]),
          e = 12
        ) {
          super(),
            (this.type = "ShapeGeometry"),
            (this.parameters = { shapes: t, curveSegments: e });
          const n = [],
            i = [],
            r = [],
            a = [];
          let o = 0,
            s = 0;
          if (!1 === Array.isArray(t)) c(t);
          else
            for (let l = 0; l < t.length; l++)
              c(t[l]), this.addGroup(o, s, l), (o += s), (s = 0);
          function c(t) {
            const o = i.length / 3,
              c = t.extractPoints(e);
            let l = c.shape;
            const h = c.holes;
            !1 === Zd.isClockWise(l) && (l = l.reverse());
            for (let e = 0, n = h.length; e < n; e++) {
              const t = h[e];
              !0 === Zd.isClockWise(t) && (h[e] = t.reverse());
            }
            const u = Zd.triangulateShape(l, h);
            for (let e = 0, n = h.length; e < n; e++) {
              const t = h[e];
              l = l.concat(t);
            }
            for (let e = 0, n = l.length; e < n; e++) {
              const t = l[e];
              i.push(t.x, t.y, 0), r.push(0, 0, 1), a.push(t.x, t.y);
            }
            for (let e = 0, i = u.length; e < i; e++) {
              const t = u[e],
                i = t[0] + o,
                r = t[1] + o,
                a = t[2] + o;
              n.push(i, r, a), (s += 3);
            }
          }
          this.setIndex(n),
            this.setAttribute("position", new ji(i, 3)),
            this.setAttribute("normal", new ji(r, 3)),
            this.setAttribute("uv", new ji(a, 2));
        }
        toJSON() {
          const t = super.toJSON(),
            e = this.parameters.shapes;
          return sp(e, t);
        }
        static fromJSON(t, e) {
          const n = [];
          for (let i = 0, r = t.shapes.length; i < r; i++) {
            const r = e[t.shapes[i]];
            n.push(r);
          }
          return new op(n, t.curveSegments);
        }
      }
      function sp(t, e) {
        if (((e.shapes = []), Array.isArray(t)))
          for (let n = 0, i = t.length; n < i; n++) {
            const i = t[n];
            e.shapes.push(i.uuid);
          }
        else e.shapes.push(t.uuid);
        return e;
      }
      class cp extends Qi {
        constructor(
          t = 1,
          e = 32,
          n = 16,
          i = 0,
          r = 2 * Math.PI,
          a = 0,
          o = Math.PI
        ) {
          super(),
            (this.type = "SphereGeometry"),
            (this.parameters = {
              radius: t,
              widthSegments: e,
              heightSegments: n,
              phiStart: i,
              phiLength: r,
              thetaStart: a,
              thetaLength: o,
            }),
            (e = Math.max(3, Math.floor(e))),
            (n = Math.max(2, Math.floor(n)));
          const s = Math.min(a + o, Math.PI);
          let c = 0;
          const l = [],
            h = new wn(),
            u = new wn(),
            d = [],
            p = [],
            f = [],
            m = [];
          for (let g = 0; g <= n; g++) {
            const d = [],
              v = g / n;
            let y = 0;
            0 == g && 0 == a
              ? (y = 0.5 / e)
              : g == n && s == Math.PI && (y = -0.5 / e);
            for (let n = 0; n <= e; n++) {
              const s = n / e;
              (h.x = -t * Math.cos(i + s * r) * Math.sin(a + v * o)),
                (h.y = t * Math.cos(a + v * o)),
                (h.z = t * Math.sin(i + s * r) * Math.sin(a + v * o)),
                p.push(h.x, h.y, h.z),
                u.copy(h).normalize(),
                f.push(u.x, u.y, u.z),
                m.push(s + y, 1 - v),
                d.push(c++);
            }
            l.push(d);
          }
          for (let g = 0; g < n; g++)
            for (let t = 0; t < e; t++) {
              const e = l[g][t + 1],
                i = l[g][t],
                r = l[g + 1][t],
                o = l[g + 1][t + 1];
              (0 !== g || a > 0) && d.push(e, i, o),
                (g !== n - 1 || s < Math.PI) && d.push(i, r, o);
            }
          this.setIndex(d),
            this.setAttribute("position", new ji(p, 3)),
            this.setAttribute("normal", new ji(f, 3)),
            this.setAttribute("uv", new ji(m, 2));
        }
        static fromJSON(t) {
          return new cp(
            t.radius,
            t.widthSegments,
            t.heightSegments,
            t.phiStart,
            t.phiLength,
            t.thetaStart,
            t.thetaLength
          );
        }
      }
      class lp extends Nu {
        constructor(t = 1, e = 0) {
          const n = [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1],
            i = [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1];
          super(n, i, t, e),
            (this.type = "TetrahedronGeometry"),
            (this.parameters = { radius: t, detail: e });
        }
        static fromJSON(t) {
          return new lp(t.radius, t.detail);
        }
      }
      class hp extends Qi {
        constructor(t = 1, e = 0.4, n = 8, i = 6, r = 2 * Math.PI) {
          super(),
            (this.type = "TorusGeometry"),
            (this.parameters = {
              radius: t,
              tube: e,
              radialSegments: n,
              tubularSegments: i,
              arc: r,
            }),
            (n = Math.floor(n)),
            (i = Math.floor(i));
          const a = [],
            o = [],
            s = [],
            c = [],
            l = new wn(),
            h = new wn(),
            u = new wn();
          for (let d = 0; d <= n; d++)
            for (let a = 0; a <= i; a++) {
              const p = (a / i) * r,
                f = (d / n) * Math.PI * 2;
              (h.x = (t + e * Math.cos(f)) * Math.cos(p)),
                (h.y = (t + e * Math.cos(f)) * Math.sin(p)),
                (h.z = e * Math.sin(f)),
                o.push(h.x, h.y, h.z),
                (l.x = t * Math.cos(p)),
                (l.y = t * Math.sin(p)),
                u.subVectors(h, l).normalize(),
                s.push(u.x, u.y, u.z),
                c.push(a / i),
                c.push(d / n);
            }
          for (let d = 1; d <= n; d++)
            for (let t = 1; t <= i; t++) {
              const e = (i + 1) * d + t - 1,
                n = (i + 1) * (d - 1) + t - 1,
                r = (i + 1) * (d - 1) + t,
                o = (i + 1) * d + t;
              a.push(e, n, o), a.push(n, r, o);
            }
          this.setIndex(a),
            this.setAttribute("position", new ji(o, 3)),
            this.setAttribute("normal", new ji(s, 3)),
            this.setAttribute("uv", new ji(c, 2));
        }
        static fromJSON(t) {
          return new hp(
            t.radius,
            t.tube,
            t.radialSegments,
            t.tubularSegments,
            t.arc
          );
        }
      }
      class up extends Qi {
        constructor(t = 1, e = 0.4, n = 64, i = 8, r = 2, a = 3) {
          super(),
            (this.type = "TorusKnotGeometry"),
            (this.parameters = {
              radius: t,
              tube: e,
              tubularSegments: n,
              radialSegments: i,
              p: r,
              q: a,
            }),
            (n = Math.floor(n)),
            (i = Math.floor(i));
          const o = [],
            s = [],
            c = [],
            l = [],
            h = new wn(),
            u = new wn(),
            d = new wn(),
            p = new wn(),
            f = new wn(),
            m = new wn(),
            g = new wn();
          for (let y = 0; y <= n; ++y) {
            const o = (y / n) * r * Math.PI * 2;
            v(o, r, a, t, d),
              v(o + 0.01, r, a, t, p),
              m.subVectors(p, d),
              g.addVectors(p, d),
              f.crossVectors(m, g),
              g.crossVectors(f, m),
              f.normalize(),
              g.normalize();
            for (let t = 0; t <= i; ++t) {
              const r = (t / i) * Math.PI * 2,
                a = -e * Math.cos(r),
                o = e * Math.sin(r);
              (h.x = d.x + (a * g.x + o * f.x)),
                (h.y = d.y + (a * g.y + o * f.y)),
                (h.z = d.z + (a * g.z + o * f.z)),
                s.push(h.x, h.y, h.z),
                u.subVectors(h, d).normalize(),
                c.push(u.x, u.y, u.z),
                l.push(y / n),
                l.push(t / i);
            }
          }
          for (let y = 1; y <= n; y++)
            for (let t = 1; t <= i; t++) {
              const e = (i + 1) * (y - 1) + (t - 1),
                n = (i + 1) * y + (t - 1),
                r = (i + 1) * y + t,
                a = (i + 1) * (y - 1) + t;
              o.push(e, n, a), o.push(n, r, a);
            }
          function v(t, e, n, i, r) {
            const a = Math.cos(t),
              o = Math.sin(t),
              s = (n / e) * t,
              c = Math.cos(s);
            (r.x = i * (2 + c) * 0.5 * a),
              (r.y = i * (2 + c) * o * 0.5),
              (r.z = i * Math.sin(s) * 0.5);
          }
          this.setIndex(o),
            this.setAttribute("position", new ji(s, 3)),
            this.setAttribute("normal", new ji(c, 3)),
            this.setAttribute("uv", new ji(l, 2));
        }
        static fromJSON(t) {
          return new up(
            t.radius,
            t.tube,
            t.tubularSegments,
            t.radialSegments,
            t.p,
            t.q
          );
        }
      }
      class dp extends Qi {
        constructor(
          t = new dd(new wn(-1, -1, 0), new wn(-1, 1, 0), new wn(1, 1, 0)),
          e = 64,
          n = 1,
          i = 8,
          r = !1
        ) {
          super(),
            (this.type = "TubeGeometry"),
            (this.parameters = {
              path: t,
              tubularSegments: e,
              radius: n,
              radialSegments: i,
              closed: r,
            });
          const a = t.computeFrenetFrames(e, r);
          (this.tangents = a.tangents),
            (this.normals = a.normals),
            (this.binormals = a.binormals);
          const o = new wn(),
            s = new wn(),
            c = new $e();
          let l = new wn();
          const h = [],
            u = [],
            d = [],
            p = [];
          function f() {
            for (let t = 0; t < e; t++) m(t);
            m(!1 === r ? e : 0), v(), g();
          }
          function m(r) {
            l = t.getPointAt(r / e, l);
            const c = a.normals[r],
              d = a.binormals[r];
            for (let t = 0; t <= i; t++) {
              const e = (t / i) * Math.PI * 2,
                r = Math.sin(e),
                a = -Math.cos(e);
              (s.x = a * c.x + r * d.x),
                (s.y = a * c.y + r * d.y),
                (s.z = a * c.z + r * d.z),
                s.normalize(),
                u.push(s.x, s.y, s.z),
                (o.x = l.x + n * s.x),
                (o.y = l.y + n * s.y),
                (o.z = l.z + n * s.z),
                h.push(o.x, o.y, o.z);
            }
          }
          function g() {
            for (let t = 1; t <= e; t++)
              for (let e = 1; e <= i; e++) {
                const n = (i + 1) * (t - 1) + (e - 1),
                  r = (i + 1) * t + (e - 1),
                  a = (i + 1) * t + e,
                  o = (i + 1) * (t - 1) + e;
                p.push(n, r, o), p.push(r, a, o);
              }
          }
          function v() {
            for (let t = 0; t <= e; t++)
              for (let n = 0; n <= i; n++)
                (c.x = t / e), (c.y = n / i), d.push(c.x, c.y);
          }
          f(),
            this.setIndex(p),
            this.setAttribute("position", new ji(h, 3)),
            this.setAttribute("normal", new ji(u, 3)),
            this.setAttribute("uv", new ji(d, 2));
        }
        toJSON() {
          const t = super.toJSON();
          return (t.path = this.parameters.path.toJSON()), t;
        }
        static fromJSON(t) {
          return new dp(
            new fd[t.path.type]().fromJSON(t.path),
            t.tubularSegments,
            t.radius,
            t.radialSegments,
            t.closed
          );
        }
      }
      class pp extends Qi {
        constructor(t = null) {
          if (
            (super(),
            (this.type = "WireframeGeometry"),
            (this.parameters = { geometry: t }),
            null !== t)
          ) {
            const e = [],
              n = new Set(),
              i = new wn(),
              r = new wn();
            if (null !== t.index) {
              const a = t.attributes.position,
                o = t.index;
              let s = t.groups;
              0 === s.length &&
                (s = [{ start: 0, count: o.count, materialIndex: 0 }]);
              for (let t = 0, c = s.length; t < c; ++t) {
                const c = s[t],
                  l = c.start,
                  h = c.count;
                for (let t = l, s = l + h; t < s; t += 3)
                  for (let c = 0; c < 3; c++) {
                    const s = o.getX(t + c),
                      l = o.getX(t + ((c + 1) % 3));
                    i.fromBufferAttribute(a, s),
                      r.fromBufferAttribute(a, l),
                      !0 === fp(i, r, n) &&
                        (e.push(i.x, i.y, i.z), e.push(r.x, r.y, r.z));
                  }
              }
            } else {
              const a = t.attributes.position;
              for (let t = 0, o = a.count / 3; t < o; t++)
                for (let s = 0; s < 3; s++) {
                  const o = 3 * t + s,
                    c = 3 * t + ((s + 1) % 3);
                  i.fromBufferAttribute(a, o),
                    r.fromBufferAttribute(a, c),
                    !0 === fp(i, r, n) &&
                      (e.push(i.x, i.y, i.z), e.push(r.x, r.y, r.z));
                }
            }
            this.setAttribute("position", new ji(e, 3));
          }
        }
      }
      function fp(t, e, n) {
        const i = `${t.x},${t.y},${t.z}-${e.x},${e.y},${e.z}`,
          r = `${e.x},${e.y},${e.z}-${t.x},${t.y},${t.z}`;
        return !0 !== n.has(i) && !0 !== n.has(r) && (n.add(i, r), !0);
      }
      var mp = Object.freeze({
        __proto__: null,
        BoxGeometry: _r,
        BoxBufferGeometry: _r,
        CircleGeometry: Du,
        CircleBufferGeometry: Du,
        ConeGeometry: Ou,
        ConeBufferGeometry: Ou,
        CylinderGeometry: Iu,
        CylinderBufferGeometry: Iu,
        DodecahedronGeometry: Bu,
        DodecahedronBufferGeometry: Bu,
        EdgesGeometry: ku,
        ExtrudeGeometry: Qd,
        ExtrudeBufferGeometry: Qd,
        IcosahedronGeometry: np,
        IcosahedronBufferGeometry: np,
        LatheGeometry: ip,
        LatheBufferGeometry: ip,
        OctahedronGeometry: rp,
        OctahedronBufferGeometry: rp,
        PlaneGeometry: Vr,
        PlaneBufferGeometry: Vr,
        PolyhedronGeometry: Nu,
        PolyhedronBufferGeometry: Nu,
        RingGeometry: ap,
        RingBufferGeometry: ap,
        ShapeGeometry: op,
        ShapeBufferGeometry: op,
        SphereGeometry: cp,
        SphereBufferGeometry: cp,
        TetrahedronGeometry: lp,
        TetrahedronBufferGeometry: lp,
        TorusGeometry: hp,
        TorusBufferGeometry: hp,
        TorusKnotGeometry: up,
        TorusKnotBufferGeometry: up,
        TubeGeometry: dp,
        TubeBufferGeometry: dp,
        WireframeGeometry: pp,
      });
      class gp extends zi {
        constructor(t) {
          super(),
            (this.type = "ShadowMaterial"),
            (this.color = new un(0)),
            (this.transparent = !0),
            this.setValues(t);
        }
        copy(t) {
          return super.copy(t), this.color.copy(t.color), this;
        }
      }
      gp.prototype.isShadowMaterial = !0;
      class vp extends zi {
        constructor(t) {
          super(),
            (this.defines = { STANDARD: "" }),
            (this.type = "MeshStandardMaterial"),
            (this.color = new un(16777215)),
            (this.roughness = 1),
            (this.metalness = 0),
            (this.map = null),
            (this.lightMap = null),
            (this.lightMapIntensity = 1),
            (this.aoMap = null),
            (this.aoMapIntensity = 1),
            (this.emissive = new un(0)),
            (this.emissiveIntensity = 1),
            (this.emissiveMap = null),
            (this.bumpMap = null),
            (this.bumpScale = 1),
            (this.normalMap = null),
            (this.normalMapType = Ie),
            (this.normalScale = new $e(1, 1)),
            (this.displacementMap = null),
            (this.displacementScale = 1),
            (this.displacementBias = 0),
            (this.roughnessMap = null),
            (this.metalnessMap = null),
            (this.alphaMap = null),
            (this.envMap = null),
            (this.envMapIntensity = 1),
            (this.refractionRatio = 0.98),
            (this.wireframe = !1),
            (this.wireframeLinewidth = 1),
            (this.wireframeLinecap = "round"),
            (this.wireframeLinejoin = "round"),
            (this.flatShading = !1),
            this.setValues(t);
        }
        copy(t) {
          return (
            super.copy(t),
            (this.defines = { STANDARD: "" }),
            this.color.copy(t.color),
            (this.roughness = t.roughness),
            (this.metalness = t.metalness),
            (this.map = t.map),
            (this.lightMap = t.lightMap),
            (this.lightMapIntensity = t.lightMapIntensity),
            (this.aoMap = t.aoMap),
            (this.aoMapIntensity = t.aoMapIntensity),
            this.emissive.copy(t.emissive),
            (this.emissiveMap = t.emissiveMap),
            (this.emissiveIntensity = t.emissiveIntensity),
            (this.bumpMap = t.bumpMap),
            (this.bumpScale = t.bumpScale),
            (this.normalMap = t.normalMap),
            (this.normalMapType = t.normalMapType),
            this.normalScale.copy(t.normalScale),
            (this.displacementMap = t.displacementMap),
            (this.displacementScale = t.displacementScale),
            (this.displacementBias = t.displacementBias),
            (this.roughnessMap = t.roughnessMap),
            (this.metalnessMap = t.metalnessMap),
            (this.alphaMap = t.alphaMap),
            (this.envMap = t.envMap),
            (this.envMapIntensity = t.envMapIntensity),
            (this.refractionRatio = t.refractionRatio),
            (this.wireframe = t.wireframe),
            (this.wireframeLinewidth = t.wireframeLinewidth),
            (this.wireframeLinecap = t.wireframeLinecap),
            (this.wireframeLinejoin = t.wireframeLinejoin),
            (this.flatShading = t.flatShading),
            this
          );
        }
      }
      vp.prototype.isMeshStandardMaterial = !0;
      class yp extends vp {
        constructor(t) {
          super(),
            (this.defines = { STANDARD: "", PHYSICAL: "" }),
            (this.type = "MeshPhysicalMaterial"),
            (this.clearcoatMap = null),
            (this.clearcoatRoughness = 0),
            (this.clearcoatRoughnessMap = null),
            (this.clearcoatNormalScale = new $e(1, 1)),
            (this.clearcoatNormalMap = null),
            (this.ior = 1.5),
            Object.defineProperty(this, "reflectivity", {
              get: function () {
                return qe((2.5 * (this.ior - 1)) / (this.ior + 1), 0, 1);
              },
              set: function (t) {
                this.ior = (1 + 0.4 * t) / (1 - 0.4 * t);
              },
            }),
            (this.sheenColor = new un(0)),
            (this.sheenColorMap = null),
            (this.sheenRoughness = 1),
            (this.sheenRoughnessMap = null),
            (this.transmissionMap = null),
            (this.thickness = 0),
            (this.thicknessMap = null),
            (this.attenuationDistance = 0),
            (this.attenuationColor = new un(1, 1, 1)),
            (this.specularIntensity = 1),
            (this.specularIntensityMap = null),
            (this.specularColor = new un(1, 1, 1)),
            (this.specularColorMap = null),
            (this._sheen = 0),
            (this._clearcoat = 0),
            (this._transmission = 0),
            this.setValues(t);
        }
        get sheen() {
          return this._sheen;
        }
        set sheen(t) {
          this._sheen > 0 !== t > 0 && this.version++, (this._sheen = t);
        }
        get clearcoat() {
          return this._clearcoat;
        }
        set clearcoat(t) {
          this._clearcoat > 0 !== t > 0 && this.version++,
            (this._clearcoat = t);
        }
        get transmission() {
          return this._transmission;
        }
        set transmission(t) {
          this._transmission > 0 !== t > 0 && this.version++,
            (this._transmission = t);
        }
        copy(t) {
          return (
            super.copy(t),
            (this.defines = { STANDARD: "", PHYSICAL: "" }),
            (this.clearcoat = t.clearcoat),
            (this.clearcoatMap = t.clearcoatMap),
            (this.clearcoatRoughness = t.clearcoatRoughness),
            (this.clearcoatRoughnessMap = t.clearcoatRoughnessMap),
            (this.clearcoatNormalMap = t.clearcoatNormalMap),
            this.clearcoatNormalScale.copy(t.clearcoatNormalScale),
            (this.ior = t.ior),
            (this.sheen = t.sheen),
            this.sheenColor.copy(t.sheenColor),
            (this.sheenColorMap = t.sheenColorMap),
            (this.sheenRoughness = t.sheenRoughness),
            (this.sheenRoughnessMap = t.sheenRoughnessMap),
            (this.transmission = t.transmission),
            (this.transmissionMap = t.transmissionMap),
            (this.thickness = t.thickness),
            (this.thicknessMap = t.thicknessMap),
            (this.attenuationDistance = t.attenuationDistance),
            this.attenuationColor.copy(t.attenuationColor),
            (this.specularIntensity = t.specularIntensity),
            (this.specularIntensityMap = t.specularIntensityMap),
            this.specularColor.copy(t.specularColor),
            (this.specularColorMap = t.specularColorMap),
            this
          );
        }
      }
      yp.prototype.isMeshPhysicalMaterial = !0;
      class xp extends zi {
        constructor(t) {
          super(),
            (this.type = "MeshPhongMaterial"),
            (this.color = new un(16777215)),
            (this.specular = new un(1118481)),
            (this.shininess = 30),
            (this.map = null),
            (this.lightMap = null),
            (this.lightMapIntensity = 1),
            (this.aoMap = null),
            (this.aoMapIntensity = 1),
            (this.emissive = new un(0)),
            (this.emissiveIntensity = 1),
            (this.emissiveMap = null),
            (this.bumpMap = null),
            (this.bumpScale = 1),
            (this.normalMap = null),
            (this.normalMapType = Ie),
            (this.normalScale = new $e(1, 1)),
            (this.displacementMap = null),
            (this.displacementScale = 1),
            (this.displacementBias = 0),
            (this.specularMap = null),
            (this.alphaMap = null),
            (this.envMap = null),
            (this.combine = Z),
            (this.reflectivity = 1),
            (this.refractionRatio = 0.98),
            (this.wireframe = !1),
            (this.wireframeLinewidth = 1),
            (this.wireframeLinecap = "round"),
            (this.wireframeLinejoin = "round"),
            (this.flatShading = !1),
            this.setValues(t);
        }
        copy(t) {
          return (
            super.copy(t),
            this.color.copy(t.color),
            this.specular.copy(t.specular),
            (this.shininess = t.shininess),
            (this.map = t.map),
            (this.lightMap = t.lightMap),
            (this.lightMapIntensity = t.lightMapIntensity),
            (this.aoMap = t.aoMap),
            (this.aoMapIntensity = t.aoMapIntensity),
            this.emissive.copy(t.emissive),
            (this.emissiveMap = t.emissiveMap),
            (this.emissiveIntensity = t.emissiveIntensity),
            (this.bumpMap = t.bumpMap),
            (this.bumpScale = t.bumpScale),
            (this.normalMap = t.normalMap),
            (this.normalMapType = t.normalMapType),
            this.normalScale.copy(t.normalScale),
            (this.displacementMap = t.displacementMap),
            (this.displacementScale = t.displacementScale),
            (this.displacementBias = t.displacementBias),
            (this.specularMap = t.specularMap),
            (this.alphaMap = t.alphaMap),
            (this.envMap = t.envMap),
            (this.combine = t.combine),
            (this.reflectivity = t.reflectivity),
            (this.refractionRatio = t.refractionRatio),
            (this.wireframe = t.wireframe),
            (this.wireframeLinewidth = t.wireframeLinewidth),
            (this.wireframeLinecap = t.wireframeLinecap),
            (this.wireframeLinejoin = t.wireframeLinejoin),
            (this.flatShading = t.flatShading),
            this
          );
        }
      }
      xp.prototype.isMeshPhongMaterial = !0;
      class _p extends zi {
        constructor(t) {
          super(),
            (this.defines = { TOON: "" }),
            (this.type = "MeshToonMaterial"),
            (this.color = new un(16777215)),
            (this.map = null),
            (this.gradientMap = null),
            (this.lightMap = null),
            (this.lightMapIntensity = 1),
            (this.aoMap = null),
            (this.aoMapIntensity = 1),
            (this.emissive = new un(0)),
            (this.emissiveIntensity = 1),
            (this.emissiveMap = null),
            (this.bumpMap = null),
            (this.bumpScale = 1),
            (this.normalMap = null),
            (this.normalMapType = Ie),
            (this.normalScale = new $e(1, 1)),
            (this.displacementMap = null),
            (this.displacementScale = 1),
            (this.displacementBias = 0),
            (this.alphaMap = null),
            (this.wireframe = !1),
            (this.wireframeLinewidth = 1),
            (this.wireframeLinecap = "round"),
            (this.wireframeLinejoin = "round"),
            this.setValues(t);
        }
        copy(t) {
          return (
            super.copy(t),
            this.color.copy(t.color),
            (this.map = t.map),
            (this.gradientMap = t.gradientMap),
            (this.lightMap = t.lightMap),
            (this.lightMapIntensity = t.lightMapIntensity),
            (this.aoMap = t.aoMap),
            (this.aoMapIntensity = t.aoMapIntensity),
            this.emissive.copy(t.emissive),
            (this.emissiveMap = t.emissiveMap),
            (this.emissiveIntensity = t.emissiveIntensity),
            (this.bumpMap = t.bumpMap),
            (this.bumpScale = t.bumpScale),
            (this.normalMap = t.normalMap),
            (this.normalMapType = t.normalMapType),
            this.normalScale.copy(t.normalScale),
            (this.displacementMap = t.displacementMap),
            (this.displacementScale = t.displacementScale),
            (this.displacementBias = t.displacementBias),
            (this.alphaMap = t.alphaMap),
            (this.wireframe = t.wireframe),
            (this.wireframeLinewidth = t.wireframeLinewidth),
            (this.wireframeLinecap = t.wireframeLinecap),
            (this.wireframeLinejoin = t.wireframeLinejoin),
            this
          );
        }
      }
      _p.prototype.isMeshToonMaterial = !0;
      class bp extends zi {
        constructor(t) {
          super(),
            (this.type = "MeshNormalMaterial"),
            (this.bumpMap = null),
            (this.bumpScale = 1),
            (this.normalMap = null),
            (this.normalMapType = Ie),
            (this.normalScale = new $e(1, 1)),
            (this.displacementMap = null),
            (this.displacementScale = 1),
            (this.displacementBias = 0),
            (this.wireframe = !1),
            (this.wireframeLinewidth = 1),
            (this.fog = !1),
            (this.flatShading = !1),
            this.setValues(t);
        }
        copy(t) {
          return (
            super.copy(t),
            (this.bumpMap = t.bumpMap),
            (this.bumpScale = t.bumpScale),
            (this.normalMap = t.normalMap),
            (this.normalMapType = t.normalMapType),
            this.normalScale.copy(t.normalScale),
            (this.displacementMap = t.displacementMap),
            (this.displacementScale = t.displacementScale),
            (this.displacementBias = t.displacementBias),
            (this.wireframe = t.wireframe),
            (this.wireframeLinewidth = t.wireframeLinewidth),
            (this.flatShading = t.flatShading),
            this
          );
        }
      }
      bp.prototype.isMeshNormalMaterial = !0;
      class wp extends zi {
        constructor(t) {
          super(),
            (this.type = "MeshLambertMaterial"),
            (this.color = new un(16777215)),
            (this.map = null),
            (this.lightMap = null),
            (this.lightMapIntensity = 1),
            (this.aoMap = null),
            (this.aoMapIntensity = 1),
            (this.emissive = new un(0)),
            (this.emissiveIntensity = 1),
            (this.emissiveMap = null),
            (this.specularMap = null),
            (this.alphaMap = null),
            (this.envMap = null),
            (this.combine = Z),
            (this.reflectivity = 1),
            (this.refractionRatio = 0.98),
            (this.wireframe = !1),
            (this.wireframeLinewidth = 1),
            (this.wireframeLinecap = "round"),
            (this.wireframeLinejoin = "round"),
            this.setValues(t);
        }
        copy(t) {
          return (
            super.copy(t),
            this.color.copy(t.color),
            (this.map = t.map),
            (this.lightMap = t.lightMap),
            (this.lightMapIntensity = t.lightMapIntensity),
            (this.aoMap = t.aoMap),
            (this.aoMapIntensity = t.aoMapIntensity),
            this.emissive.copy(t.emissive),
            (this.emissiveMap = t.emissiveMap),
            (this.emissiveIntensity = t.emissiveIntensity),
            (this.specularMap = t.specularMap),
            (this.alphaMap = t.alphaMap),
            (this.envMap = t.envMap),
            (this.combine = t.combine),
            (this.reflectivity = t.reflectivity),
            (this.refractionRatio = t.refractionRatio),
            (this.wireframe = t.wireframe),
            (this.wireframeLinewidth = t.wireframeLinewidth),
            (this.wireframeLinecap = t.wireframeLinecap),
            (this.wireframeLinejoin = t.wireframeLinejoin),
            this
          );
        }
      }
      wp.prototype.isMeshLambertMaterial = !0;
      class Mp extends zi {
        constructor(t) {
          super(),
            (this.defines = { MATCAP: "" }),
            (this.type = "MeshMatcapMaterial"),
            (this.color = new un(16777215)),
            (this.matcap = null),
            (this.map = null),
            (this.bumpMap = null),
            (this.bumpScale = 1),
            (this.normalMap = null),
            (this.normalMapType = Ie),
            (this.normalScale = new $e(1, 1)),
            (this.displacementMap = null),
            (this.displacementScale = 1),
            (this.displacementBias = 0),
            (this.alphaMap = null),
            (this.flatShading = !1),
            this.setValues(t);
        }
        copy(t) {
          return (
            super.copy(t),
            (this.defines = { MATCAP: "" }),
            this.color.copy(t.color),
            (this.matcap = t.matcap),
            (this.map = t.map),
            (this.bumpMap = t.bumpMap),
            (this.bumpScale = t.bumpScale),
            (this.normalMap = t.normalMap),
            (this.normalMapType = t.normalMapType),
            this.normalScale.copy(t.normalScale),
            (this.displacementMap = t.displacementMap),
            (this.displacementScale = t.displacementScale),
            (this.displacementBias = t.displacementBias),
            (this.alphaMap = t.alphaMap),
            (this.flatShading = t.flatShading),
            this
          );
        }
      }
      Mp.prototype.isMeshMatcapMaterial = !0;
      class Sp extends hu {
        constructor(t) {
          super(),
            (this.type = "LineDashedMaterial"),
            (this.scale = 1),
            (this.dashSize = 3),
            (this.gapSize = 1),
            this.setValues(t);
        }
        copy(t) {
          return (
            super.copy(t),
            (this.scale = t.scale),
            (this.dashSize = t.dashSize),
            (this.gapSize = t.gapSize),
            this
          );
        }
      }
      Sp.prototype.isLineDashedMaterial = !0;
      var Ep = Object.freeze({
        __proto__: null,
        ShadowMaterial: gp,
        SpriteMaterial: Ch,
        RawShaderMaterial: As,
        ShaderMaterial: Tr,
        PointsMaterial: bu,
        MeshPhysicalMaterial: yp,
        MeshStandardMaterial: vp,
        MeshPhongMaterial: xp,
        MeshToonMaterial: _p,
        MeshNormalMaterial: bp,
        MeshLambertMaterial: wp,
        MeshDepthMaterial: rh,
        MeshDistanceMaterial: ah,
        MeshBasicMaterial: Ui,
        MeshMatcapMaterial: Mp,
        LineDashedMaterial: Sp,
        LineBasicMaterial: hu,
        Material: zi,
      });
      const Tp = {
        arraySlice: function (t, e, n) {
          return Tp.isTypedArray(t)
            ? new t.constructor(t.subarray(e, void 0 !== n ? n : t.length))
            : t.slice(e, n);
        },
        convertArray: function (t, e, n) {
          return !t || (!n && t.constructor === e)
            ? t
            : "number" === typeof e.BYTES_PER_ELEMENT
            ? new e(t)
            : Array.prototype.slice.call(t);
        },
        isTypedArray: function (t) {
          return ArrayBuffer.isView(t) && !(t instanceof DataView);
        },
        getKeyframeOrder: function (t) {
          function e(e, n) {
            return t[e] - t[n];
          }
          const n = t.length,
            i = new Array(n);
          for (let r = 0; r !== n; ++r) i[r] = r;
          return i.sort(e), i;
        },
        sortedArray: function (t, e, n) {
          const i = t.length,
            r = new t.constructor(i);
          for (let a = 0, o = 0; o !== i; ++a) {
            const i = n[a] * e;
            for (let n = 0; n !== e; ++n) r[o++] = t[i + n];
          }
          return r;
        },
        flattenJSON: function (t, e, n, i) {
          let r = 1,
            a = t[0];
          while (void 0 !== a && void 0 === a[i]) a = t[r++];
          if (void 0 === a) return;
          let o = a[i];
          if (void 0 !== o)
            if (Array.isArray(o))
              do {
                (o = a[i]),
                  void 0 !== o && (e.push(a.time), n.push.apply(n, o)),
                  (a = t[r++]);
              } while (void 0 !== a);
            else if (void 0 !== o.toArray)
              do {
                (o = a[i]),
                  void 0 !== o && (e.push(a.time), o.toArray(n, n.length)),
                  (a = t[r++]);
              } while (void 0 !== a);
            else
              do {
                (o = a[i]),
                  void 0 !== o && (e.push(a.time), n.push(o)),
                  (a = t[r++]);
              } while (void 0 !== a);
        },
        subclip: function (t, e, n, i, r = 30) {
          const a = t.clone();
          a.name = e;
          const o = [];
          for (let c = 0; c < a.tracks.length; ++c) {
            const t = a.tracks[c],
              e = t.getValueSize(),
              s = [],
              l = [];
            for (let a = 0; a < t.times.length; ++a) {
              const o = t.times[a] * r;
              if (!(o < n || o >= i)) {
                s.push(t.times[a]);
                for (let n = 0; n < e; ++n) l.push(t.values[a * e + n]);
              }
            }
            0 !== s.length &&
              ((t.times = Tp.convertArray(s, t.times.constructor)),
              (t.values = Tp.convertArray(l, t.values.constructor)),
              o.push(t));
          }
          a.tracks = o;
          let s = 1 / 0;
          for (let c = 0; c < a.tracks.length; ++c)
            s > a.tracks[c].times[0] && (s = a.tracks[c].times[0]);
          for (let c = 0; c < a.tracks.length; ++c) a.tracks[c].shift(-1 * s);
          return a.resetDuration(), a;
        },
        makeClipAdditive: function (t, e = 0, n = t, i = 30) {
          i <= 0 && (i = 30);
          const r = n.tracks.length,
            a = e / i;
          for (let o = 0; o < r; ++o) {
            const e = n.tracks[o],
              i = e.ValueTypeName;
            if ("bool" === i || "string" === i) continue;
            const r = t.tracks.find(function (t) {
              return t.name === e.name && t.ValueTypeName === i;
            });
            if (void 0 === r) continue;
            let s = 0;
            const c = e.getValueSize();
            e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline &&
              (s = c / 3);
            let l = 0;
            const h = r.getValueSize();
            r.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline &&
              (l = h / 3);
            const u = e.times.length - 1;
            let d;
            if (a <= e.times[0]) {
              const t = s,
                n = c - s;
              d = Tp.arraySlice(e.values, t, n);
            } else if (a >= e.times[u]) {
              const t = u * c + s,
                n = t + c - s;
              d = Tp.arraySlice(e.values, t, n);
            } else {
              const t = e.createInterpolant(),
                n = s,
                i = c - s;
              t.evaluate(a), (d = Tp.arraySlice(t.resultBuffer, n, i));
            }
            if ("quaternion" === i) {
              const t = new bn().fromArray(d).normalize().conjugate();
              t.toArray(d);
            }
            const p = r.times.length;
            for (let t = 0; t < p; ++t) {
              const e = t * h + l;
              if ("quaternion" === i)
                bn.multiplyQuaternionsFlat(r.values, e, d, 0, r.values, e);
              else {
                const t = h - 2 * l;
                for (let n = 0; n < t; ++n) r.values[e + n] -= d[n];
              }
            }
          }
          return (t.blendMode = Ae), t;
        },
      };
      class Ap {
        constructor(t, e, n, i) {
          (this.parameterPositions = t),
            (this._cachedIndex = 0),
            (this.resultBuffer = void 0 !== i ? i : new e.constructor(n)),
            (this.sampleValues = e),
            (this.valueSize = n),
            (this.settings = null),
            (this.DefaultSettings_ = {});
        }
        evaluate(t) {
          const e = this.parameterPositions;
          let n = this._cachedIndex,
            i = e[n],
            r = e[n - 1];
          t: {
            e: {
              let a;
              n: {
                i: if (!(t < i)) {
                  for (let a = n + 2; ; ) {
                    if (void 0 === i) {
                      if (t < r) break i;
                      return (
                        (n = e.length),
                        (this._cachedIndex = n),
                        this.afterEnd_(n - 1, t, r)
                      );
                    }
                    if (n === a) break;
                    if (((r = i), (i = e[++n]), t < i)) break e;
                  }
                  a = e.length;
                  break n;
                }
                if (t >= r) break t;
                {
                  const o = e[1];
                  t < o && ((n = 2), (r = o));
                  for (let a = n - 2; ; ) {
                    if (void 0 === r)
                      return (
                        (this._cachedIndex = 0), this.beforeStart_(0, t, i)
                      );
                    if (n === a) break;
                    if (((i = r), (r = e[--n - 1]), t >= r)) break e;
                  }
                  (a = n), (n = 0);
                }
              }
              while (n < a) {
                const i = (n + a) >>> 1;
                t < e[i] ? (a = i) : (n = i + 1);
              }
              if (((i = e[n]), (r = e[n - 1]), void 0 === r))
                return (this._cachedIndex = 0), this.beforeStart_(0, t, i);
              if (void 0 === i)
                return (
                  (n = e.length),
                  (this._cachedIndex = n),
                  this.afterEnd_(n - 1, r, t)
                );
            }
            (this._cachedIndex = n), this.intervalChanged_(n, r, i);
          }
          return this.interpolate_(n, r, t, i);
        }
        getSettings_() {
          return this.settings || this.DefaultSettings_;
        }
        copySampleValue_(t) {
          const e = this.resultBuffer,
            n = this.sampleValues,
            i = this.valueSize,
            r = t * i;
          for (let a = 0; a !== i; ++a) e[a] = n[r + a];
          return e;
        }
        interpolate_() {
          throw new Error("call to abstract method");
        }
        intervalChanged_() {}
      }
      (Ap.prototype.beforeStart_ = Ap.prototype.copySampleValue_),
        (Ap.prototype.afterEnd_ = Ap.prototype.copySampleValue_);
      class Cp extends Ap {
        constructor(t, e, n, i) {
          super(t, e, n, i),
            (this._weightPrev = -0),
            (this._offsetPrev = -0),
            (this._weightNext = -0),
            (this._offsetNext = -0),
            (this.DefaultSettings_ = { endingStart: Me, endingEnd: Me });
        }
        intervalChanged_(t, e, n) {
          const i = this.parameterPositions;
          let r = t - 2,
            a = t + 1,
            o = i[r],
            s = i[a];
          if (void 0 === o)
            switch (this.getSettings_().endingStart) {
              case Se:
                (r = t), (o = 2 * e - n);
                break;
              case Ee:
                (r = i.length - 2), (o = e + i[r] - i[r + 1]);
                break;
              default:
                (r = t), (o = n);
            }
          if (void 0 === s)
            switch (this.getSettings_().endingEnd) {
              case Se:
                (a = t), (s = 2 * n - e);
                break;
              case Ee:
                (a = 1), (s = n + i[1] - i[0]);
                break;
              default:
                (a = t - 1), (s = e);
            }
          const c = 0.5 * (n - e),
            l = this.valueSize;
          (this._weightPrev = c / (e - o)),
            (this._weightNext = c / (s - n)),
            (this._offsetPrev = r * l),
            (this._offsetNext = a * l);
        }
        interpolate_(t, e, n, i) {
          const r = this.resultBuffer,
            a = this.sampleValues,
            o = this.valueSize,
            s = t * o,
            c = s - o,
            l = this._offsetPrev,
            h = this._offsetNext,
            u = this._weightPrev,
            d = this._weightNext,
            p = (n - e) / (i - e),
            f = p * p,
            m = f * p,
            g = -u * m + 2 * u * f - u * p,
            v = (1 + u) * m + (-1.5 - 2 * u) * f + (-0.5 + u) * p + 1,
            y = (-1 - d) * m + (1.5 + d) * f + 0.5 * p,
            x = d * m - d * f;
          for (let _ = 0; _ !== o; ++_)
            r[_] = g * a[l + _] + v * a[c + _] + y * a[s + _] + x * a[h + _];
          return r;
        }
      }
      class Rp extends Ap {
        constructor(t, e, n, i) {
          super(t, e, n, i);
        }
        interpolate_(t, e, n, i) {
          const r = this.resultBuffer,
            a = this.sampleValues,
            o = this.valueSize,
            s = t * o,
            c = s - o,
            l = (n - e) / (i - e),
            h = 1 - l;
          for (let u = 0; u !== o; ++u) r[u] = a[c + u] * h + a[s + u] * l;
          return r;
        }
      }
      class Lp extends Ap {
        constructor(t, e, n, i) {
          super(t, e, n, i);
        }
        interpolate_(t) {
          return this.copySampleValue_(t - 1);
        }
      }
      class Pp {
        constructor(t, e, n, i) {
          if (void 0 === t)
            throw new Error("THREE.KeyframeTrack: track name is undefined");
          if (void 0 === e || 0 === e.length)
            throw new Error(
              "THREE.KeyframeTrack: no keyframes in track named " + t
            );
          (this.name = t),
            (this.times = Tp.convertArray(e, this.TimeBufferType)),
            (this.values = Tp.convertArray(n, this.ValueBufferType)),
            this.setInterpolation(i || this.DefaultInterpolation);
        }
        static toJSON(t) {
          const e = t.constructor;
          let n;
          if (e.toJSON !== this.toJSON) n = e.toJSON(t);
          else {
            n = {
              name: t.name,
              times: Tp.convertArray(t.times, Array),
              values: Tp.convertArray(t.values, Array),
            };
            const e = t.getInterpolation();
            e !== t.DefaultInterpolation && (n.interpolation = e);
          }
          return (n.type = t.ValueTypeName), n;
        }
        InterpolantFactoryMethodDiscrete(t) {
          return new Lp(this.times, this.values, this.getValueSize(), t);
        }
        InterpolantFactoryMethodLinear(t) {
          return new Rp(this.times, this.values, this.getValueSize(), t);
        }
        InterpolantFactoryMethodSmooth(t) {
          return new Cp(this.times, this.values, this.getValueSize(), t);
        }
        setInterpolation(t) {
          let e;
          switch (t) {
            case _e:
              e = this.InterpolantFactoryMethodDiscrete;
              break;
            case be:
              e = this.InterpolantFactoryMethodLinear;
              break;
            case we:
              e = this.InterpolantFactoryMethodSmooth;
              break;
          }
          if (void 0 === e) {
            const e =
              "unsupported interpolation for " +
              this.ValueTypeName +
              " keyframe track named " +
              this.name;
            if (void 0 === this.createInterpolant) {
              if (t === this.DefaultInterpolation) throw new Error(e);
              this.setInterpolation(this.DefaultInterpolation);
            }
            return console.warn("THREE.KeyframeTrack:", e), this;
          }
          return (this.createInterpolant = e), this;
        }
        getInterpolation() {
          switch (this.createInterpolant) {
            case this.InterpolantFactoryMethodDiscrete:
              return _e;
            case this.InterpolantFactoryMethodLinear:
              return be;
            case this.InterpolantFactoryMethodSmooth:
              return we;
          }
        }
        getValueSize() {
          return this.values.length / this.times.length;
        }
        shift(t) {
          if (0 !== t) {
            const e = this.times;
            for (let n = 0, i = e.length; n !== i; ++n) e[n] += t;
          }
          return this;
        }
        scale(t) {
          if (1 !== t) {
            const e = this.times;
            for (let n = 0, i = e.length; n !== i; ++n) e[n] *= t;
          }
          return this;
        }
        trim(t, e) {
          const n = this.times,
            i = n.length;
          let r = 0,
            a = i - 1;
          while (r !== i && n[r] < t) ++r;
          while (-1 !== a && n[a] > e) --a;
          if ((++a, 0 !== r || a !== i)) {
            r >= a && ((a = Math.max(a, 1)), (r = a - 1));
            const t = this.getValueSize();
            (this.times = Tp.arraySlice(n, r, a)),
              (this.values = Tp.arraySlice(this.values, r * t, a * t));
          }
          return this;
        }
        validate() {
          let t = !0;
          const e = this.getValueSize();
          e - Math.floor(e) !== 0 &&
            (console.error(
              "THREE.KeyframeTrack: Invalid value size in track.",
              this
            ),
            (t = !1));
          const n = this.times,
            i = this.values,
            r = n.length;
          0 === r &&
            (console.error("THREE.KeyframeTrack: Track is empty.", this),
            (t = !1));
          let a = null;
          for (let o = 0; o !== r; o++) {
            const e = n[o];
            if ("number" === typeof e && isNaN(e)) {
              console.error(
                "THREE.KeyframeTrack: Time is not a valid number.",
                this,
                o,
                e
              ),
                (t = !1);
              break;
            }
            if (null !== a && a > e) {
              console.error(
                "THREE.KeyframeTrack: Out of order keys.",
                this,
                o,
                e,
                a
              ),
                (t = !1);
              break;
            }
            a = e;
          }
          if (void 0 !== i && Tp.isTypedArray(i))
            for (let o = 0, s = i.length; o !== s; ++o) {
              const e = i[o];
              if (isNaN(e)) {
                console.error(
                  "THREE.KeyframeTrack: Value is not a valid number.",
                  this,
                  o,
                  e
                ),
                  (t = !1);
                break;
              }
            }
          return t;
        }
        optimize() {
          const t = Tp.arraySlice(this.times),
            e = Tp.arraySlice(this.values),
            n = this.getValueSize(),
            i = this.getInterpolation() === we,
            r = t.length - 1;
          let a = 1;
          for (let o = 1; o < r; ++o) {
            let r = !1;
            const s = t[o],
              c = t[o + 1];
            if (s !== c && (1 !== o || s !== t[0]))
              if (i) r = !0;
              else {
                const t = o * n,
                  i = t - n,
                  a = t + n;
                for (let o = 0; o !== n; ++o) {
                  const n = e[t + o];
                  if (n !== e[i + o] || n !== e[a + o]) {
                    r = !0;
                    break;
                  }
                }
              }
            if (r) {
              if (o !== a) {
                t[a] = t[o];
                const i = o * n,
                  r = a * n;
                for (let t = 0; t !== n; ++t) e[r + t] = e[i + t];
              }
              ++a;
            }
          }
          if (r > 0) {
            t[a] = t[r];
            for (let t = r * n, i = a * n, o = 0; o !== n; ++o)
              e[i + o] = e[t + o];
            ++a;
          }
          return (
            a !== t.length
              ? ((this.times = Tp.arraySlice(t, 0, a)),
                (this.values = Tp.arraySlice(e, 0, a * n)))
              : ((this.times = t), (this.values = e)),
            this
          );
        }
        clone() {
          const t = Tp.arraySlice(this.times, 0),
            e = Tp.arraySlice(this.values, 0),
            n = this.constructor,
            i = new n(this.name, t, e);
          return (i.createInterpolant = this.createInterpolant), i;
        }
      }
      (Pp.prototype.TimeBufferType = Float32Array),
        (Pp.prototype.ValueBufferType = Float32Array),
        (Pp.prototype.DefaultInterpolation = be);
      class Dp extends Pp {}
      (Dp.prototype.ValueTypeName = "bool"),
        (Dp.prototype.ValueBufferType = Array),
        (Dp.prototype.DefaultInterpolation = _e),
        (Dp.prototype.InterpolantFactoryMethodLinear = void 0),
        (Dp.prototype.InterpolantFactoryMethodSmooth = void 0);
      class Ip extends Pp {}
      Ip.prototype.ValueTypeName = "color";
      class Op extends Pp {}
      Op.prototype.ValueTypeName = "number";
      class Np extends Ap {
        constructor(t, e, n, i) {
          super(t, e, n, i);
        }
        interpolate_(t, e, n, i) {
          const r = this.resultBuffer,
            a = this.sampleValues,
            o = this.valueSize,
            s = (n - e) / (i - e);
          let c = t * o;
          for (let l = c + o; c !== l; c += 4)
            bn.slerpFlat(r, 0, a, c - o, a, c, s);
          return r;
        }
      }
      class Bp extends Pp {
        InterpolantFactoryMethodLinear(t) {
          return new Np(this.times, this.values, this.getValueSize(), t);
        }
      }
      (Bp.prototype.ValueTypeName = "quaternion"),
        (Bp.prototype.DefaultInterpolation = be),
        (Bp.prototype.InterpolantFactoryMethodSmooth = void 0);
      class zp extends Pp {}
      (zp.prototype.ValueTypeName = "string"),
        (zp.prototype.ValueBufferType = Array),
        (zp.prototype.DefaultInterpolation = _e),
        (zp.prototype.InterpolantFactoryMethodLinear = void 0),
        (zp.prototype.InterpolantFactoryMethodSmooth = void 0);
      class Up extends Pp {}
      Up.prototype.ValueTypeName = "vector";
      class Fp {
        constructor(t, e = -1, n, i = Te) {
          (this.name = t),
            (this.tracks = n),
            (this.duration = e),
            (this.blendMode = i),
            (this.uuid = je()),
            this.duration < 0 && this.resetDuration();
        }
        static parse(t) {
          const e = [],
            n = t.tracks,
            i = 1 / (t.fps || 1);
          for (let a = 0, o = n.length; a !== o; ++a) e.push(kp(n[a]).scale(i));
          const r = new this(t.name, t.duration, e, t.blendMode);
          return (r.uuid = t.uuid), r;
        }
        static toJSON(t) {
          const e = [],
            n = t.tracks,
            i = {
              name: t.name,
              duration: t.duration,
              tracks: e,
              uuid: t.uuid,
              blendMode: t.blendMode,
            };
          for (let r = 0, a = n.length; r !== a; ++r) e.push(Pp.toJSON(n[r]));
          return i;
        }
        static CreateFromMorphTargetSequence(t, e, n, i) {
          const r = e.length,
            a = [];
          for (let o = 0; o < r; o++) {
            let t = [],
              s = [];
            t.push((o + r - 1) % r, o, (o + 1) % r), s.push(0, 1, 0);
            const c = Tp.getKeyframeOrder(t);
            (t = Tp.sortedArray(t, 1, c)),
              (s = Tp.sortedArray(s, 1, c)),
              i || 0 !== t[0] || (t.push(r), s.push(s[0])),
              a.push(
                new Op(".morphTargetInfluences[" + e[o].name + "]", t, s).scale(
                  1 / n
                )
              );
          }
          return new this(t, -1, a);
        }
        static findByName(t, e) {
          let n = t;
          if (!Array.isArray(t)) {
            const e = t;
            n = (e.geometry && e.geometry.animations) || e.animations;
          }
          for (let i = 0; i < n.length; i++) if (n[i].name === e) return n[i];
          return null;
        }
        static CreateClipsFromMorphTargetSequences(t, e, n) {
          const i = {},
            r = /^([\w-]*?)([\d]+)$/;
          for (let o = 0, s = t.length; o < s; o++) {
            const e = t[o],
              n = e.name.match(r);
            if (n && n.length > 1) {
              const t = n[1];
              let r = i[t];
              r || (i[t] = r = []), r.push(e);
            }
          }
          const a = [];
          for (const o in i)
            a.push(this.CreateFromMorphTargetSequence(o, i[o], e, n));
          return a;
        }
        static parseAnimation(t, e) {
          if (!t)
            return (
              console.error(
                "THREE.AnimationClip: No animation in JSONLoader data."
              ),
              null
            );
          const n = function (t, e, n, i, r) {
              if (0 !== n.length) {
                const a = [],
                  o = [];
                Tp.flattenJSON(n, a, o, i),
                  0 !== a.length && r.push(new t(e, a, o));
              }
            },
            i = [],
            r = t.name || "default",
            a = t.fps || 30,
            o = t.blendMode;
          let s = t.length || -1;
          const c = t.hierarchy || [];
          for (let h = 0; h < c.length; h++) {
            const t = c[h].keys;
            if (t && 0 !== t.length)
              if (t[0].morphTargets) {
                const e = {};
                let n;
                for (n = 0; n < t.length; n++)
                  if (t[n].morphTargets)
                    for (let i = 0; i < t[n].morphTargets.length; i++)
                      e[t[n].morphTargets[i]] = -1;
                for (const r in e) {
                  const e = [],
                    a = [];
                  for (let i = 0; i !== t[n].morphTargets.length; ++i) {
                    const i = t[n];
                    e.push(i.time), a.push(i.morphTarget === r ? 1 : 0);
                  }
                  i.push(new Op(".morphTargetInfluence[" + r + "]", e, a));
                }
                s = e.length * (a || 1);
              } else {
                const r = ".bones[" + e[h].name + "]";
                n(Up, r + ".position", t, "pos", i),
                  n(Bp, r + ".quaternion", t, "rot", i),
                  n(Up, r + ".scale", t, "scl", i);
              }
          }
          if (0 === i.length) return null;
          const l = new this(r, s, i, o);
          return l;
        }
        resetDuration() {
          const t = this.tracks;
          let e = 0;
          for (let n = 0, i = t.length; n !== i; ++n) {
            const t = this.tracks[n];
            e = Math.max(e, t.times[t.times.length - 1]);
          }
          return (this.duration = e), this;
        }
        trim() {
          for (let t = 0; t < this.tracks.length; t++)
            this.tracks[t].trim(0, this.duration);
          return this;
        }
        validate() {
          let t = !0;
          for (let e = 0; e < this.tracks.length; e++)
            t = t && this.tracks[e].validate();
          return t;
        }
        optimize() {
          for (let t = 0; t < this.tracks.length; t++)
            this.tracks[t].optimize();
          return this;
        }
        clone() {
          const t = [];
          for (let e = 0; e < this.tracks.length; e++)
            t.push(this.tracks[e].clone());
          return new this.constructor(
            this.name,
            this.duration,
            t,
            this.blendMode
          );
        }
        toJSON() {
          return this.constructor.toJSON(this);
        }
      }
      function Hp(t) {
        switch (t.toLowerCase()) {
          case "scalar":
          case "double":
          case "float":
          case "number":
          case "integer":
            return Op;
          case "vector":
          case "vector2":
          case "vector3":
          case "vector4":
            return Up;
          case "color":
            return Ip;
          case "quaternion":
            return Bp;
          case "bool":
          case "boolean":
            return Dp;
          case "string":
            return zp;
        }
        throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + t);
      }
      function kp(t) {
        if (void 0 === t.type)
          throw new Error(
            "THREE.KeyframeTrack: track type undefined, can not parse"
          );
        const e = Hp(t.type);
        if (void 0 === t.times) {
          const e = [],
            n = [];
          Tp.flattenJSON(t.keys, e, n, "value"), (t.times = e), (t.values = n);
        }
        return void 0 !== e.parse
          ? e.parse(t)
          : new e(t.name, t.times, t.values, t.interpolation);
      }
      const Gp = {
        enabled: !1,
        files: {},
        add: function (t, e) {
          !1 !== this.enabled && (this.files[t] = e);
        },
        get: function (t) {
          if (!1 !== this.enabled) return this.files[t];
        },
        remove: function (t) {
          delete this.files[t];
        },
        clear: function () {
          this.files = {};
        },
      };
      class Vp {
        constructor(t, e, n) {
          const i = this;
          let r = !1,
            a = 0,
            o = 0,
            s = void 0;
          const c = [];
          (this.onStart = void 0),
            (this.onLoad = t),
            (this.onProgress = e),
            (this.onError = n),
            (this.itemStart = function (t) {
              o++,
                !1 === r && void 0 !== i.onStart && i.onStart(t, a, o),
                (r = !0);
            }),
            (this.itemEnd = function (t) {
              a++,
                void 0 !== i.onProgress && i.onProgress(t, a, o),
                a === o && ((r = !1), void 0 !== i.onLoad && i.onLoad());
            }),
            (this.itemError = function (t) {
              void 0 !== i.onError && i.onError(t);
            }),
            (this.resolveURL = function (t) {
              return s ? s(t) : t;
            }),
            (this.setURLModifier = function (t) {
              return (s = t), this;
            }),
            (this.addHandler = function (t, e) {
              return c.push(t, e), this;
            }),
            (this.removeHandler = function (t) {
              const e = c.indexOf(t);
              return -1 !== e && c.splice(e, 2), this;
            }),
            (this.getHandler = function (t) {
              for (let e = 0, n = c.length; e < n; e += 2) {
                const n = c[e],
                  i = c[e + 1];
                if ((n.global && (n.lastIndex = 0), n.test(t))) return i;
              }
              return null;
            });
        }
      }
      const Wp = new Vp();
      class jp {
        constructor(t) {
          (this.manager = void 0 !== t ? t : Wp),
            (this.crossOrigin = "anonymous"),
            (this.withCredentials = !1),
            (this.path = ""),
            (this.resourcePath = ""),
            (this.requestHeader = {});
        }
        load() {}
        loadAsync(t, e) {
          const n = this;
          return new Promise(function (i, r) {
            n.load(t, i, e, r);
          });
        }
        parse() {}
        setCrossOrigin(t) {
          return (this.crossOrigin = t), this;
        }
        setWithCredentials(t) {
          return (this.withCredentials = t), this;
        }
        setPath(t) {
          return (this.path = t), this;
        }
        setResourcePath(t) {
          return (this.resourcePath = t), this;
        }
        setRequestHeader(t) {
          return (this.requestHeader = t), this;
        }
      }
      const qp = {};
      class Xp extends jp {
        constructor(t) {
          super(t);
        }
        load(t, e, n, i) {
          void 0 === t && (t = ""),
            void 0 !== this.path && (t = this.path + t),
            (t = this.manager.resolveURL(t));
          const r = Gp.get(t);
          if (void 0 !== r)
            return (
              this.manager.itemStart(t),
              setTimeout(() => {
                e && e(r), this.manager.itemEnd(t);
              }, 0),
              r
            );
          if (void 0 !== qp[t])
            return void qp[t].push({ onLoad: e, onProgress: n, onError: i });
          (qp[t] = []), qp[t].push({ onLoad: e, onProgress: n, onError: i });
          const a = new Request(t, {
              headers: new Headers(this.requestHeader),
              credentials: this.withCredentials ? "include" : "same-origin",
            }),
            o = this.mimeType,
            s = this.responseType;
          fetch(a)
            .then((e) => {
              if (200 === e.status || 0 === e.status) {
                if (
                  (0 === e.status &&
                    console.warn("THREE.FileLoader: HTTP Status 0 received."),
                  "undefined" === typeof ReadableStream ||
                    void 0 === e.body.getReader)
                )
                  return e;
                const n = qp[t],
                  i = e.body.getReader(),
                  r = e.headers.get("Content-Length"),
                  a = r ? parseInt(r) : 0,
                  o = 0 !== a;
                let s = 0;
                const c = new ReadableStream({
                  start(t) {
                    function e() {
                      i.read().then(({ done: i, value: r }) => {
                        if (i) t.close();
                        else {
                          s += r.byteLength;
                          const i = new ProgressEvent("progress", {
                            lengthComputable: o,
                            loaded: s,
                            total: a,
                          });
                          for (let t = 0, e = n.length; t < e; t++) {
                            const e = n[t];
                            e.onProgress && e.onProgress(i);
                          }
                          t.enqueue(r), e();
                        }
                      });
                    }
                    e();
                  },
                });
                return new Response(c);
              }
              throw Error(
                `fetch for "${e.url}" responded with ${e.status}: ${e.statusText}`
              );
            })
            .then((t) => {
              switch (s) {
                case "arraybuffer":
                  return t.arrayBuffer();
                case "blob":
                  return t.blob();
                case "document":
                  return t.text().then((t) => {
                    const e = new DOMParser();
                    return e.parseFromString(t, o);
                  });
                case "json":
                  return t.json();
                default:
                  if (void 0 === o) return t.text();
                  {
                    const e = /charset="?([^;"\s]*)"?/i,
                      n = e.exec(o),
                      i = n && n[1] ? n[1].toLowerCase() : void 0,
                      r = new TextDecoder(i);
                    return t.arrayBuffer().then((t) => r.decode(t));
                  }
              }
            })
            .then((e) => {
              Gp.add(t, e);
              const n = qp[t];
              delete qp[t];
              for (let t = 0, i = n.length; t < i; t++) {
                const i = n[t];
                i.onLoad && i.onLoad(e);
              }
            })
            .catch((e) => {
              const n = qp[t];
              if (void 0 === n) throw (this.manager.itemError(t), e);
              delete qp[t];
              for (let t = 0, i = n.length; t < i; t++) {
                const i = n[t];
                i.onError && i.onError(e);
              }
              this.manager.itemError(t);
            })
            .finally(() => {
              this.manager.itemEnd(t);
            }),
            this.manager.itemStart(t);
        }
        setResponseType(t) {
          return (this.responseType = t), this;
        }
        setMimeType(t) {
          return (this.mimeType = t), this;
        }
      }
      class Yp extends jp {
        constructor(t) {
          super(t);
        }
        load(t, e, n, i) {
          void 0 !== this.path && (t = this.path + t),
            (t = this.manager.resolveURL(t));
          const r = this,
            a = Gp.get(t);
          if (void 0 !== a)
            return (
              r.manager.itemStart(t),
              setTimeout(function () {
                e && e(a), r.manager.itemEnd(t);
              }, 0),
              a
            );
          const o = rn("img");
          function s() {
            l(), Gp.add(t, this), e && e(this), r.manager.itemEnd(t);
          }
          function c(e) {
            l(), i && i(e), r.manager.itemError(t), r.manager.itemEnd(t);
          }
          function l() {
            o.removeEventListener("load", s, !1),
              o.removeEventListener("error", c, !1);
          }
          return (
            o.addEventListener("load", s, !1),
            o.addEventListener("error", c, !1),
            "data:" !== t.substr(0, 5) &&
              void 0 !== this.crossOrigin &&
              (o.crossOrigin = this.crossOrigin),
            r.manager.itemStart(t),
            (o.src = t),
            o
          );
        }
      }
      class Jp extends jp {
        constructor(t) {
          super(t);
        }
        load(t, e, n, i) {
          const r = new Dr(),
            a = new Yp(this.manager);
          a.setCrossOrigin(this.crossOrigin), a.setPath(this.path);
          let o = 0;
          function s(n) {
            a.load(
              t[n],
              function (t) {
                (r.images[n] = t),
                  o++,
                  6 === o && ((r.needsUpdate = !0), e && e(r));
              },
              void 0,
              i
            );
          }
          for (let c = 0; c < t.length; ++c) s(c);
          return r;
        }
      }
      class Zp extends jp {
        constructor(t) {
          super(t);
        }
        load(t, e, n, i) {
          const r = new mn(),
            a = new Yp(this.manager);
          return (
            a.setCrossOrigin(this.crossOrigin),
            a.setPath(this.path),
            a.load(
              t,
              function (t) {
                (r.image = t), (r.needsUpdate = !0), void 0 !== e && e(r);
              },
              n,
              i
            ),
            r
          );
        }
      }
      class Kp extends Si {
        constructor(t, e = 1) {
          super(),
            (this.type = "Light"),
            (this.color = new un(t)),
            (this.intensity = e);
        }
        dispose() {}
        copy(t) {
          return (
            super.copy(t),
            this.color.copy(t.color),
            (this.intensity = t.intensity),
            this
          );
        }
        toJSON(t) {
          const e = super.toJSON(t);
          return (
            (e.object.color = this.color.getHex()),
            (e.object.intensity = this.intensity),
            void 0 !== this.groundColor &&
              (e.object.groundColor = this.groundColor.getHex()),
            void 0 !== this.distance && (e.object.distance = this.distance),
            void 0 !== this.angle && (e.object.angle = this.angle),
            void 0 !== this.decay && (e.object.decay = this.decay),
            void 0 !== this.penumbra && (e.object.penumbra = this.penumbra),
            void 0 !== this.shadow && (e.object.shadow = this.shadow.toJSON()),
            e
          );
        }
      }
      Kp.prototype.isLight = !0;
      class $p extends Kp {
        constructor(t, e, n) {
          super(t, n),
            (this.type = "HemisphereLight"),
            this.position.copy(Si.DefaultUp),
            this.updateMatrix(),
            (this.groundColor = new un(e));
        }
        copy(t) {
          return (
            Kp.prototype.copy.call(this, t),
            this.groundColor.copy(t.groundColor),
            this
          );
        }
      }
      $p.prototype.isHemisphereLight = !0;
      const Qp = new Qn(),
        tf = new wn(),
        ef = new wn();
      class nf {
        constructor(t) {
          (this.camera = t),
            (this.bias = 0),
            (this.normalBias = 0),
            (this.radius = 1),
            (this.blurSamples = 8),
            (this.mapSize = new $e(512, 512)),
            (this.map = null),
            (this.mapPass = null),
            (this.matrix = new Qn()),
            (this.autoUpdate = !0),
            (this.needsUpdate = !1),
            (this._frustum = new Hr()),
            (this._frameExtents = new $e(1, 1)),
            (this._viewportCount = 1),
            (this._viewports = [new vn(0, 0, 1, 1)]);
        }
        getViewportCount() {
          return this._viewportCount;
        }
        getFrustum() {
          return this._frustum;
        }
        updateMatrices(t) {
          const e = this.camera,
            n = this.matrix;
          tf.setFromMatrixPosition(t.matrixWorld),
            e.position.copy(tf),
            ef.setFromMatrixPosition(t.target.matrixWorld),
            e.lookAt(ef),
            e.updateMatrixWorld(),
            Qp.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse),
            this._frustum.setFromProjectionMatrix(Qp),
            n.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1),
            n.multiply(e.projectionMatrix),
            n.multiply(e.matrixWorldInverse);
        }
        getViewport(t) {
          return this._viewports[t];
        }
        getFrameExtents() {
          return this._frameExtents;
        }
        dispose() {
          this.map && this.map.dispose(),
            this.mapPass && this.mapPass.dispose();
        }
        copy(t) {
          return (
            (this.camera = t.camera.clone()),
            (this.bias = t.bias),
            (this.radius = t.radius),
            this.mapSize.copy(t.mapSize),
            this
          );
        }
        clone() {
          return new this.constructor().copy(this);
        }
        toJSON() {
          const t = {};
          return (
            0 !== this.bias && (t.bias = this.bias),
            0 !== this.normalBias && (t.normalBias = this.normalBias),
            1 !== this.radius && (t.radius = this.radius),
            (512 === this.mapSize.x && 512 === this.mapSize.y) ||
              (t.mapSize = this.mapSize.toArray()),
            (t.camera = this.camera.toJSON(!1).object),
            delete t.camera.matrix,
            t
          );
        }
      }
      class rf extends nf {
        constructor() {
          super(new Cr(50, 1, 0.5, 500)), (this.focus = 1);
        }
        updateMatrices(t) {
          const e = this.camera,
            n = 2 * We * t.angle * this.focus,
            i = this.mapSize.width / this.mapSize.height,
            r = t.distance || e.far;
          (n === e.fov && i === e.aspect && r === e.far) ||
            ((e.fov = n),
            (e.aspect = i),
            (e.far = r),
            e.updateProjectionMatrix()),
            super.updateMatrices(t);
        }
        copy(t) {
          return super.copy(t), (this.focus = t.focus), this;
        }
      }
      rf.prototype.isSpotLightShadow = !0;
      class af extends Kp {
        constructor(t, e, n = 0, i = Math.PI / 3, r = 0, a = 1) {
          super(t, e),
            (this.type = "SpotLight"),
            this.position.copy(Si.DefaultUp),
            this.updateMatrix(),
            (this.target = new Si()),
            (this.distance = n),
            (this.angle = i),
            (this.penumbra = r),
            (this.decay = a),
            (this.shadow = new rf());
        }
        get power() {
          return this.intensity * Math.PI;
        }
        set power(t) {
          this.intensity = t / Math.PI;
        }
        dispose() {
          this.shadow.dispose();
        }
        copy(t) {
          return (
            super.copy(t),
            (this.distance = t.distance),
            (this.angle = t.angle),
            (this.penumbra = t.penumbra),
            (this.decay = t.decay),
            (this.target = t.target.clone()),
            (this.shadow = t.shadow.clone()),
            this
          );
        }
      }
      af.prototype.isSpotLight = !0;
      const of = new Qn(),
        sf = new wn(),
        cf = new wn();
      class lf extends nf {
        constructor() {
          super(new Cr(90, 1, 0.5, 500)),
            (this._frameExtents = new $e(4, 2)),
            (this._viewportCount = 6),
            (this._viewports = [
              new vn(2, 1, 1, 1),
              new vn(0, 1, 1, 1),
              new vn(3, 1, 1, 1),
              new vn(1, 1, 1, 1),
              new vn(3, 0, 1, 1),
              new vn(1, 0, 1, 1),
            ]),
            (this._cubeDirections = [
              new wn(1, 0, 0),
              new wn(-1, 0, 0),
              new wn(0, 0, 1),
              new wn(0, 0, -1),
              new wn(0, 1, 0),
              new wn(0, -1, 0),
            ]),
            (this._cubeUps = [
              new wn(0, 1, 0),
              new wn(0, 1, 0),
              new wn(0, 1, 0),
              new wn(0, 1, 0),
              new wn(0, 0, 1),
              new wn(0, 0, -1),
            ]);
        }
        updateMatrices(t, e = 0) {
          const n = this.camera,
            i = this.matrix,
            r = t.distance || n.far;
          r !== n.far && ((n.far = r), n.updateProjectionMatrix()),
            sf.setFromMatrixPosition(t.matrixWorld),
            n.position.copy(sf),
            cf.copy(n.position),
            cf.add(this._cubeDirections[e]),
            n.up.copy(this._cubeUps[e]),
            n.lookAt(cf),
            n.updateMatrixWorld(),
            i.makeTranslation(-sf.x, -sf.y, -sf.z),
            of.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse),
            this._frustum.setFromProjectionMatrix(of);
        }
      }
      lf.prototype.isPointLightShadow = !0;
      class hf extends Kp {
        constructor(t, e, n = 0, i = 1) {
          super(t, e),
            (this.type = "PointLight"),
            (this.distance = n),
            (this.decay = i),
            (this.shadow = new lf());
        }
        get power() {
          return 4 * this.intensity * Math.PI;
        }
        set power(t) {
          this.intensity = t / (4 * Math.PI);
        }
        dispose() {
          this.shadow.dispose();
        }
        copy(t) {
          return (
            super.copy(t),
            (this.distance = t.distance),
            (this.decay = t.decay),
            (this.shadow = t.shadow.clone()),
            this
          );
        }
      }
      hf.prototype.isPointLight = !0;
      class uf extends nf {
        constructor() {
          super(new Ts(-5, 5, 5, -5, 0.5, 500));
        }
      }
      uf.prototype.isDirectionalLightShadow = !0;
      class df extends Kp {
        constructor(t, e) {
          super(t, e),
            (this.type = "DirectionalLight"),
            this.position.copy(Si.DefaultUp),
            this.updateMatrix(),
            (this.target = new Si()),
            (this.shadow = new uf());
        }
        dispose() {
          this.shadow.dispose();
        }
        copy(t) {
          return (
            super.copy(t),
            (this.target = t.target.clone()),
            (this.shadow = t.shadow.clone()),
            this
          );
        }
      }
      df.prototype.isDirectionalLight = !0;
      class pf extends Kp {
        constructor(t, e) {
          super(t, e), (this.type = "AmbientLight");
        }
      }
      pf.prototype.isAmbientLight = !0;
      class ff extends Kp {
        constructor(t, e, n = 10, i = 10) {
          super(t, e),
            (this.type = "RectAreaLight"),
            (this.width = n),
            (this.height = i);
        }
        get power() {
          return this.intensity * this.width * this.height * Math.PI;
        }
        set power(t) {
          this.intensity = t / (this.width * this.height * Math.PI);
        }
        copy(t) {
          return (
            super.copy(t),
            (this.width = t.width),
            (this.height = t.height),
            this
          );
        }
        toJSON(t) {
          const e = super.toJSON(t);
          return (
            (e.object.width = this.width), (e.object.height = this.height), e
          );
        }
      }
      ff.prototype.isRectAreaLight = !0;
      class mf {
        constructor() {
          this.coefficients = [];
          for (let t = 0; t < 9; t++) this.coefficients.push(new wn());
        }
        set(t) {
          for (let e = 0; e < 9; e++) this.coefficients[e].copy(t[e]);
          return this;
        }
        zero() {
          for (let t = 0; t < 9; t++) this.coefficients[t].set(0, 0, 0);
          return this;
        }
        getAt(t, e) {
          const n = t.x,
            i = t.y,
            r = t.z,
            a = this.coefficients;
          return (
            e.copy(a[0]).multiplyScalar(0.282095),
            e.addScaledVector(a[1], 0.488603 * i),
            e.addScaledVector(a[2], 0.488603 * r),
            e.addScaledVector(a[3], 0.488603 * n),
            e.addScaledVector(a[4], n * i * 1.092548),
            e.addScaledVector(a[5], i * r * 1.092548),
            e.addScaledVector(a[6], 0.315392 * (3 * r * r - 1)),
            e.addScaledVector(a[7], n * r * 1.092548),
            e.addScaledVector(a[8], 0.546274 * (n * n - i * i)),
            e
          );
        }
        getIrradianceAt(t, e) {
          const n = t.x,
            i = t.y,
            r = t.z,
            a = this.coefficients;
          return (
            e.copy(a[0]).multiplyScalar(0.886227),
            e.addScaledVector(a[1], 1.023328 * i),
            e.addScaledVector(a[2], 1.023328 * r),
            e.addScaledVector(a[3], 1.023328 * n),
            e.addScaledVector(a[4], 0.858086 * n * i),
            e.addScaledVector(a[5], 0.858086 * i * r),
            e.addScaledVector(a[6], 0.743125 * r * r - 0.247708),
            e.addScaledVector(a[7], 0.858086 * n * r),
            e.addScaledVector(a[8], 0.429043 * (n * n - i * i)),
            e
          );
        }
        add(t) {
          for (let e = 0; e < 9; e++)
            this.coefficients[e].add(t.coefficients[e]);
          return this;
        }
        addScaledSH(t, e) {
          for (let n = 0; n < 9; n++)
            this.coefficients[n].addScaledVector(t.coefficients[n], e);
          return this;
        }
        scale(t) {
          for (let e = 0; e < 9; e++) this.coefficients[e].multiplyScalar(t);
          return this;
        }
        lerp(t, e) {
          for (let n = 0; n < 9; n++)
            this.coefficients[n].lerp(t.coefficients[n], e);
          return this;
        }
        equals(t) {
          for (let e = 0; e < 9; e++)
            if (!this.coefficients[e].equals(t.coefficients[e])) return !1;
          return !0;
        }
        copy(t) {
          return this.set(t.coefficients);
        }
        clone() {
          return new this.constructor().copy(this);
        }
        fromArray(t, e = 0) {
          const n = this.coefficients;
          for (let i = 0; i < 9; i++) n[i].fromArray(t, e + 3 * i);
          return this;
        }
        toArray(t = [], e = 0) {
          const n = this.coefficients;
          for (let i = 0; i < 9; i++) n[i].toArray(t, e + 3 * i);
          return t;
        }
        static getBasisAt(t, e) {
          const n = t.x,
            i = t.y,
            r = t.z;
          (e[0] = 0.282095),
            (e[1] = 0.488603 * i),
            (e[2] = 0.488603 * r),
            (e[3] = 0.488603 * n),
            (e[4] = 1.092548 * n * i),
            (e[5] = 1.092548 * i * r),
            (e[6] = 0.315392 * (3 * r * r - 1)),
            (e[7] = 1.092548 * n * r),
            (e[8] = 0.546274 * (n * n - i * i));
        }
      }
      mf.prototype.isSphericalHarmonics3 = !0;
      class gf extends Kp {
        constructor(t = new mf(), e = 1) {
          super(void 0, e), (this.sh = t);
        }
        copy(t) {
          return super.copy(t), this.sh.copy(t.sh), this;
        }
        fromJSON(t) {
          return (this.intensity = t.intensity), this.sh.fromArray(t.sh), this;
        }
        toJSON(t) {
          const e = super.toJSON(t);
          return (e.object.sh = this.sh.toArray()), e;
        }
      }
      gf.prototype.isLightProbe = !0;
      class vf extends jp {
        constructor(t) {
          super(t), (this.textures = {});
        }
        load(t, e, n, i) {
          const r = this,
            a = new Xp(r.manager);
          a.setPath(r.path),
            a.setRequestHeader(r.requestHeader),
            a.setWithCredentials(r.withCredentials),
            a.load(
              t,
              function (n) {
                try {
                  e(r.parse(JSON.parse(n)));
                } catch (a) {
                  i ? i(a) : console.error(a), r.manager.itemError(t);
                }
              },
              n,
              i
            );
        }
        parse(t) {
          const e = this.textures;
          function n(t) {
            return (
              void 0 === e[t] &&
                console.warn("THREE.MaterialLoader: Undefined texture", t),
              e[t]
            );
          }
          const i = new Ep[t.type]();
          if (
            (void 0 !== t.uuid && (i.uuid = t.uuid),
            void 0 !== t.name && (i.name = t.name),
            void 0 !== t.color && void 0 !== i.color && i.color.setHex(t.color),
            void 0 !== t.roughness && (i.roughness = t.roughness),
            void 0 !== t.metalness && (i.metalness = t.metalness),
            void 0 !== t.sheen && (i.sheen = t.sheen),
            void 0 !== t.sheenColor &&
              (i.sheenColor = new un().setHex(t.sheenColor)),
            void 0 !== t.sheenRoughness &&
              (i.sheenRoughness = t.sheenRoughness),
            void 0 !== t.emissive &&
              void 0 !== i.emissive &&
              i.emissive.setHex(t.emissive),
            void 0 !== t.specular &&
              void 0 !== i.specular &&
              i.specular.setHex(t.specular),
            void 0 !== t.specularIntensity &&
              (i.specularIntensity = t.specularIntensity),
            void 0 !== t.specularColor &&
              void 0 !== i.specularColor &&
              i.specularColor.setHex(t.specularColor),
            void 0 !== t.shininess && (i.shininess = t.shininess),
            void 0 !== t.clearcoat && (i.clearcoat = t.clearcoat),
            void 0 !== t.clearcoatRoughness &&
              (i.clearcoatRoughness = t.clearcoatRoughness),
            void 0 !== t.transmission && (i.transmission = t.transmission),
            void 0 !== t.thickness && (i.thickness = t.thickness),
            void 0 !== t.attenuationDistance &&
              (i.attenuationDistance = t.attenuationDistance),
            void 0 !== t.attenuationColor &&
              void 0 !== i.attenuationColor &&
              i.attenuationColor.setHex(t.attenuationColor),
            void 0 !== t.fog && (i.fog = t.fog),
            void 0 !== t.flatShading && (i.flatShading = t.flatShading),
            void 0 !== t.blending && (i.blending = t.blending),
            void 0 !== t.combine && (i.combine = t.combine),
            void 0 !== t.side && (i.side = t.side),
            void 0 !== t.shadowSide && (i.shadowSide = t.shadowSide),
            void 0 !== t.opacity && (i.opacity = t.opacity),
            void 0 !== t.transparent && (i.transparent = t.transparent),
            void 0 !== t.alphaTest && (i.alphaTest = t.alphaTest),
            void 0 !== t.depthTest && (i.depthTest = t.depthTest),
            void 0 !== t.depthWrite && (i.depthWrite = t.depthWrite),
            void 0 !== t.colorWrite && (i.colorWrite = t.colorWrite),
            void 0 !== t.stencilWrite && (i.stencilWrite = t.stencilWrite),
            void 0 !== t.stencilWriteMask &&
              (i.stencilWriteMask = t.stencilWriteMask),
            void 0 !== t.stencilFunc && (i.stencilFunc = t.stencilFunc),
            void 0 !== t.stencilRef && (i.stencilRef = t.stencilRef),
            void 0 !== t.stencilFuncMask &&
              (i.stencilFuncMask = t.stencilFuncMask),
            void 0 !== t.stencilFail && (i.stencilFail = t.stencilFail),
            void 0 !== t.stencilZFail && (i.stencilZFail = t.stencilZFail),
            void 0 !== t.stencilZPass && (i.stencilZPass = t.stencilZPass),
            void 0 !== t.wireframe && (i.wireframe = t.wireframe),
            void 0 !== t.wireframeLinewidth &&
              (i.wireframeLinewidth = t.wireframeLinewidth),
            void 0 !== t.wireframeLinecap &&
              (i.wireframeLinecap = t.wireframeLinecap),
            void 0 !== t.wireframeLinejoin &&
              (i.wireframeLinejoin = t.wireframeLinejoin),
            void 0 !== t.rotation && (i.rotation = t.rotation),
            1 !== t.linewidth && (i.linewidth = t.linewidth),
            void 0 !== t.dashSize && (i.dashSize = t.dashSize),
            void 0 !== t.gapSize && (i.gapSize = t.gapSize),
            void 0 !== t.scale && (i.scale = t.scale),
            void 0 !== t.polygonOffset && (i.polygonOffset = t.polygonOffset),
            void 0 !== t.polygonOffsetFactor &&
              (i.polygonOffsetFactor = t.polygonOffsetFactor),
            void 0 !== t.polygonOffsetUnits &&
              (i.polygonOffsetUnits = t.polygonOffsetUnits),
            void 0 !== t.dithering && (i.dithering = t.dithering),
            void 0 !== t.alphaToCoverage &&
              (i.alphaToCoverage = t.alphaToCoverage),
            void 0 !== t.premultipliedAlpha &&
              (i.premultipliedAlpha = t.premultipliedAlpha),
            void 0 !== t.visible && (i.visible = t.visible),
            void 0 !== t.toneMapped && (i.toneMapped = t.toneMapped),
            void 0 !== t.userData && (i.userData = t.userData),
            void 0 !== t.vertexColors &&
              ("number" === typeof t.vertexColors
                ? (i.vertexColors = t.vertexColors > 0)
                : (i.vertexColors = t.vertexColors)),
            void 0 !== t.uniforms)
          )
            for (const r in t.uniforms) {
              const e = t.uniforms[r];
              switch (((i.uniforms[r] = {}), e.type)) {
                case "t":
                  i.uniforms[r].value = n(e.value);
                  break;
                case "c":
                  i.uniforms[r].value = new un().setHex(e.value);
                  break;
                case "v2":
                  i.uniforms[r].value = new $e().fromArray(e.value);
                  break;
                case "v3":
                  i.uniforms[r].value = new wn().fromArray(e.value);
                  break;
                case "v4":
                  i.uniforms[r].value = new vn().fromArray(e.value);
                  break;
                case "m3":
                  i.uniforms[r].value = new Qe().fromArray(e.value);
                  break;
                case "m4":
                  i.uniforms[r].value = new Qn().fromArray(e.value);
                  break;
                default:
                  i.uniforms[r].value = e.value;
              }
            }
          if (
            (void 0 !== t.defines && (i.defines = t.defines),
            void 0 !== t.vertexShader && (i.vertexShader = t.vertexShader),
            void 0 !== t.fragmentShader &&
              (i.fragmentShader = t.fragmentShader),
            void 0 !== t.extensions)
          )
            for (const r in t.extensions) i.extensions[r] = t.extensions[r];
          if (
            (void 0 !== t.shading && (i.flatShading = 1 === t.shading),
            void 0 !== t.size && (i.size = t.size),
            void 0 !== t.sizeAttenuation &&
              (i.sizeAttenuation = t.sizeAttenuation),
            void 0 !== t.map && (i.map = n(t.map)),
            void 0 !== t.matcap && (i.matcap = n(t.matcap)),
            void 0 !== t.alphaMap && (i.alphaMap = n(t.alphaMap)),
            void 0 !== t.bumpMap && (i.bumpMap = n(t.bumpMap)),
            void 0 !== t.bumpScale && (i.bumpScale = t.bumpScale),
            void 0 !== t.normalMap && (i.normalMap = n(t.normalMap)),
            void 0 !== t.normalMapType && (i.normalMapType = t.normalMapType),
            void 0 !== t.normalScale)
          ) {
            let e = t.normalScale;
            !1 === Array.isArray(e) && (e = [e, e]),
              (i.normalScale = new $e().fromArray(e));
          }
          return (
            void 0 !== t.displacementMap &&
              (i.displacementMap = n(t.displacementMap)),
            void 0 !== t.displacementScale &&
              (i.displacementScale = t.displacementScale),
            void 0 !== t.displacementBias &&
              (i.displacementBias = t.displacementBias),
            void 0 !== t.roughnessMap && (i.roughnessMap = n(t.roughnessMap)),
            void 0 !== t.metalnessMap && (i.metalnessMap = n(t.metalnessMap)),
            void 0 !== t.emissiveMap && (i.emissiveMap = n(t.emissiveMap)),
            void 0 !== t.emissiveIntensity &&
              (i.emissiveIntensity = t.emissiveIntensity),
            void 0 !== t.specularMap && (i.specularMap = n(t.specularMap)),
            void 0 !== t.specularIntensityMap &&
              (i.specularIntensityMap = n(t.specularIntensityMap)),
            void 0 !== t.specularColorMap &&
              (i.specularColorMap = n(t.specularColorMap)),
            void 0 !== t.envMap && (i.envMap = n(t.envMap)),
            void 0 !== t.envMapIntensity &&
              (i.envMapIntensity = t.envMapIntensity),
            void 0 !== t.reflectivity && (i.reflectivity = t.reflectivity),
            void 0 !== t.refractionRatio &&
              (i.refractionRatio = t.refractionRatio),
            void 0 !== t.lightMap && (i.lightMap = n(t.lightMap)),
            void 0 !== t.lightMapIntensity &&
              (i.lightMapIntensity = t.lightMapIntensity),
            void 0 !== t.aoMap && (i.aoMap = n(t.aoMap)),
            void 0 !== t.aoMapIntensity &&
              (i.aoMapIntensity = t.aoMapIntensity),
            void 0 !== t.gradientMap && (i.gradientMap = n(t.gradientMap)),
            void 0 !== t.clearcoatMap && (i.clearcoatMap = n(t.clearcoatMap)),
            void 0 !== t.clearcoatRoughnessMap &&
              (i.clearcoatRoughnessMap = n(t.clearcoatRoughnessMap)),
            void 0 !== t.clearcoatNormalMap &&
              (i.clearcoatNormalMap = n(t.clearcoatNormalMap)),
            void 0 !== t.clearcoatNormalScale &&
              (i.clearcoatNormalScale = new $e().fromArray(
                t.clearcoatNormalScale
              )),
            void 0 !== t.transmissionMap &&
              (i.transmissionMap = n(t.transmissionMap)),
            void 0 !== t.thicknessMap && (i.thicknessMap = n(t.thicknessMap)),
            void 0 !== t.sheenColorMap &&
              (i.sheenColorMap = n(t.sheenColorMap)),
            void 0 !== t.sheenRoughnessMap &&
              (i.sheenRoughnessMap = n(t.sheenRoughnessMap)),
            i
          );
        }
        setTextures(t) {
          return (this.textures = t), this;
        }
      }
      class yf {
        static decodeText(t) {
          if ("undefined" !== typeof TextDecoder)
            return new TextDecoder().decode(t);
          let e = "";
          for (let i = 0, r = t.length; i < r; i++)
            e += String.fromCharCode(t[i]);
          try {
            return decodeURIComponent(escape(e));
          } catch (n) {
            return e;
          }
        }
        static extractUrlBase(t) {
          const e = t.lastIndexOf("/");
          return -1 === e ? "./" : t.substr(0, e + 1);
        }
        static resolveURL(t, e) {
          return "string" !== typeof t || "" === t
            ? ""
            : (/^https?:\/\//i.test(e) &&
                /^\//.test(t) &&
                (e = e.replace(/(^https?:\/\/[^\/]+).*/i, "$1")),
              /^(https?:)?\/\//i.test(t) ||
              /^data:.*,.*$/i.test(t) ||
              /^blob:.*$/i.test(t)
                ? t
                : e + t);
        }
      }
      class xf extends Qi {
        constructor() {
          super(),
            (this.type = "InstancedBufferGeometry"),
            (this.instanceCount = 1 / 0);
        }
        copy(t) {
          return super.copy(t), (this.instanceCount = t.instanceCount), this;
        }
        clone() {
          return new this.constructor().copy(this);
        }
        toJSON() {
          const t = super.toJSON(this);
          return (
            (t.instanceCount = this.instanceCount),
            (t.isInstancedBufferGeometry = !0),
            t
          );
        }
      }
      xf.prototype.isInstancedBufferGeometry = !0;
      class _f extends jp {
        constructor(t) {
          super(t);
        }
        load(t, e, n, i) {
          const r = this,
            a = new Xp(r.manager);
          a.setPath(r.path),
            a.setRequestHeader(r.requestHeader),
            a.setWithCredentials(r.withCredentials),
            a.load(
              t,
              function (n) {
                try {
                  e(r.parse(JSON.parse(n)));
                } catch (a) {
                  i ? i(a) : console.error(a), r.manager.itemError(t);
                }
              },
              n,
              i
            );
        }
        parse(t) {
          const e = {},
            n = {};
          function i(t, n) {
            if (void 0 !== e[n]) return e[n];
            const i = t.interleavedBuffers,
              a = i[n],
              o = r(t, a.buffer),
              s = nn(a.type, o),
              c = new Eh(s, a.stride);
            return (c.uuid = a.uuid), (e[n] = c), c;
          }
          function r(t, e) {
            if (void 0 !== n[e]) return n[e];
            const i = t.arrayBuffers,
              r = i[e],
              a = new Uint32Array(r).buffer;
            return (n[e] = a), a;
          }
          const a = t.isInstancedBufferGeometry ? new xf() : new Qi(),
            o = t.data.index;
          if (void 0 !== o) {
            const t = nn(o.type, o.array);
            a.setIndex(new ki(t, 1));
          }
          const s = t.data.attributes;
          for (const d in s) {
            const e = s[d];
            let n;
            if (e.isInterleavedBufferAttribute) {
              const r = i(t.data, e.data);
              n = new Ah(r, e.itemSize, e.offset, e.normalized);
            } else {
              const t = nn(e.type, e.array),
                i = e.isInstancedBufferAttribute ? ru : ki;
              n = new i(t, e.itemSize, e.normalized);
            }
            void 0 !== e.name && (n.name = e.name),
              void 0 !== e.usage && n.setUsage(e.usage),
              void 0 !== e.updateRange &&
                ((n.updateRange.offset = e.updateRange.offset),
                (n.updateRange.count = e.updateRange.count)),
              a.setAttribute(d, n);
          }
          const c = t.data.morphAttributes;
          if (c)
            for (const d in c) {
              const e = c[d],
                n = [];
              for (let r = 0, a = e.length; r < a; r++) {
                const a = e[r];
                let o;
                if (a.isInterleavedBufferAttribute) {
                  const e = i(t.data, a.data);
                  o = new Ah(e, a.itemSize, a.offset, a.normalized);
                } else {
                  const t = nn(a.type, a.array);
                  o = new ki(t, a.itemSize, a.normalized);
                }
                void 0 !== a.name && (o.name = a.name), n.push(o);
              }
              a.morphAttributes[d] = n;
            }
          const l = t.data.morphTargetsRelative;
          l && (a.morphTargetsRelative = !0);
          const h = t.data.groups || t.data.drawcalls || t.data.offsets;
          if (void 0 !== h)
            for (let d = 0, p = h.length; d !== p; ++d) {
              const t = h[d];
              a.addGroup(t.start, t.count, t.materialIndex);
            }
          const u = t.data.boundingSphere;
          if (void 0 !== u) {
            const t = new wn();
            void 0 !== u.center && t.fromArray(u.center),
              (a.boundingSphere = new Wn(t, u.radius));
          }
          return (
            t.name && (a.name = t.name),
            t.userData && (a.userData = t.userData),
            a
          );
        }
      }
      class bf extends jp {
        constructor(t) {
          super(t);
        }
        load(t, e, n, i) {
          const r = this,
            a = "" === this.path ? yf.extractUrlBase(t) : this.path;
          this.resourcePath = this.resourcePath || a;
          const o = new Xp(this.manager);
          o.setPath(this.path),
            o.setRequestHeader(this.requestHeader),
            o.setWithCredentials(this.withCredentials),
            o.load(
              t,
              function (n) {
                let a = null;
                try {
                  a = JSON.parse(n);
                } catch (s) {
                  return (
                    void 0 !== i && i(s),
                    void console.error(
                      "THREE:ObjectLoader: Can't parse " + t + ".",
                      s.message
                    )
                  );
                }
                const o = a.metadata;
                void 0 !== o &&
                void 0 !== o.type &&
                "geometry" !== o.type.toLowerCase()
                  ? r.parse(a, e)
                  : console.error("THREE.ObjectLoader: Can't load " + t);
              },
              n,
              i
            );
        }
        async loadAsync(t, e) {
          const n = this,
            i = "" === this.path ? yf.extractUrlBase(t) : this.path;
          this.resourcePath = this.resourcePath || i;
          const r = new Xp(this.manager);
          r.setPath(this.path),
            r.setRequestHeader(this.requestHeader),
            r.setWithCredentials(this.withCredentials);
          const a = await r.loadAsync(t, e),
            o = JSON.parse(a),
            s = o.metadata;
          if (
            void 0 === s ||
            void 0 === s.type ||
            "geometry" === s.type.toLowerCase()
          )
            throw new Error("THREE.ObjectLoader: Can't load " + t);
          return await n.parseAsync(o);
        }
        parse(t, e) {
          const n = this.parseAnimations(t.animations),
            i = this.parseShapes(t.shapes),
            r = this.parseGeometries(t.geometries, i),
            a = this.parseImages(t.images, function () {
              void 0 !== e && e(c);
            }),
            o = this.parseTextures(t.textures, a),
            s = this.parseMaterials(t.materials, o),
            c = this.parseObject(t.object, r, s, o, n),
            l = this.parseSkeletons(t.skeletons, c);
          if ((this.bindSkeletons(c, l), void 0 !== e)) {
            let t = !1;
            for (const e in a)
              if (a[e] instanceof HTMLImageElement) {
                t = !0;
                break;
              }
            !1 === t && e(c);
          }
          return c;
        }
        async parseAsync(t) {
          const e = this.parseAnimations(t.animations),
            n = this.parseShapes(t.shapes),
            i = this.parseGeometries(t.geometries, n),
            r = await this.parseImagesAsync(t.images),
            a = this.parseTextures(t.textures, r),
            o = this.parseMaterials(t.materials, a),
            s = this.parseObject(t.object, i, o, a, e),
            c = this.parseSkeletons(t.skeletons, s);
          return this.bindSkeletons(s, c), s;
        }
        parseShapes(t) {
          const e = {};
          if (void 0 !== t)
            for (let n = 0, i = t.length; n < i; n++) {
              const i = new vd().fromJSON(t[n]);
              e[i.uuid] = i;
            }
          return e;
        }
        parseSkeletons(t, e) {
          const n = {},
            i = {};
          if (
            (e.traverse(function (t) {
              t.isBone && (i[t.uuid] = t);
            }),
            void 0 !== t)
          )
            for (let r = 0, a = t.length; r < a; r++) {
              const e = new iu().fromJSON(t[r], i);
              n[e.uuid] = e;
            }
          return n;
        }
        parseGeometries(t, e) {
          const n = {};
          if (void 0 !== t) {
            const i = new _f();
            for (let r = 0, a = t.length; r < a; r++) {
              let a;
              const o = t[r];
              switch (o.type) {
                case "BufferGeometry":
                case "InstancedBufferGeometry":
                  a = i.parse(o);
                  break;
                case "Geometry":
                  console.error(
                    "THREE.ObjectLoader: The legacy Geometry type is no longer supported."
                  );
                  break;
                default:
                  o.type in mp
                    ? (a = mp[o.type].fromJSON(o, e))
                    : console.warn(
                        `THREE.ObjectLoader: Unsupported geometry type "${o.type}"`
                      );
              }
              (a.uuid = o.uuid),
                void 0 !== o.name && (a.name = o.name),
                !0 === a.isBufferGeometry &&
                  void 0 !== o.userData &&
                  (a.userData = o.userData),
                (n[o.uuid] = a);
            }
          }
          return n;
        }
        parseMaterials(t, e) {
          const n = {},
            i = {};
          if (void 0 !== t) {
            const r = new vf();
            r.setTextures(e);
            for (let e = 0, a = t.length; e < a; e++) {
              const a = t[e];
              if ("MultiMaterial" === a.type) {
                const t = [];
                for (let e = 0; e < a.materials.length; e++) {
                  const i = a.materials[e];
                  void 0 === n[i.uuid] && (n[i.uuid] = r.parse(i)),
                    t.push(n[i.uuid]);
                }
                i[a.uuid] = t;
              } else
                void 0 === n[a.uuid] && (n[a.uuid] = r.parse(a)),
                  (i[a.uuid] = n[a.uuid]);
            }
          }
          return i;
        }
        parseAnimations(t) {
          const e = {};
          if (void 0 !== t)
            for (let n = 0; n < t.length; n++) {
              const i = t[n],
                r = Fp.parse(i);
              e[r.uuid] = r;
            }
          return e;
        }
        parseImages(t, e) {
          const n = this,
            i = {};
          let r;
          function a(t) {
            return (
              n.manager.itemStart(t),
              r.load(
                t,
                function () {
                  n.manager.itemEnd(t);
                },
                void 0,
                function () {
                  n.manager.itemError(t), n.manager.itemEnd(t);
                }
              )
            );
          }
          function o(t) {
            if ("string" === typeof t) {
              const e = t,
                i = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(e)
                  ? e
                  : n.resourcePath + e;
              return a(i);
            }
            return t.data
              ? { data: nn(t.type, t.data), width: t.width, height: t.height }
              : null;
          }
          if (void 0 !== t && t.length > 0) {
            const n = new Vp(e);
            (r = new Yp(n)), r.setCrossOrigin(this.crossOrigin);
            for (let e = 0, r = t.length; e < r; e++) {
              const n = t[e],
                r = n.url;
              if (Array.isArray(r)) {
                i[n.uuid] = [];
                for (let t = 0, e = r.length; t < e; t++) {
                  const e = r[t],
                    a = o(e);
                  null !== a &&
                    (a instanceof HTMLImageElement
                      ? i[n.uuid].push(a)
                      : i[n.uuid].push(new tu(a.data, a.width, a.height)));
                }
              } else {
                const t = o(n.url);
                null !== t && (i[n.uuid] = t);
              }
            }
          }
          return i;
        }
        async parseImagesAsync(t) {
          const e = this,
            n = {};
          let i;
          async function r(t) {
            if ("string" === typeof t) {
              const n = t,
                r = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(n)
                  ? n
                  : e.resourcePath + n;
              return await i.loadAsync(r);
            }
            return t.data
              ? { data: nn(t.type, t.data), width: t.width, height: t.height }
              : null;
          }
          if (void 0 !== t && t.length > 0) {
            (i = new Yp(this.manager)), i.setCrossOrigin(this.crossOrigin);
            for (let e = 0, i = t.length; e < i; e++) {
              const i = t[e],
                a = i.url;
              if (Array.isArray(a)) {
                n[i.uuid] = [];
                for (let t = 0, e = a.length; t < e; t++) {
                  const e = a[t],
                    o = await r(e);
                  null !== o &&
                    (o instanceof HTMLImageElement
                      ? n[i.uuid].push(o)
                      : n[i.uuid].push(new tu(o.data, o.width, o.height)));
                }
              } else {
                const t = await r(i.url);
                null !== t && (n[i.uuid] = t);
              }
            }
          }
          return n;
        }
        parseTextures(t, e) {
          function n(t, e) {
            return "number" === typeof t
              ? t
              : (console.warn(
                  "THREE.ObjectLoader.parseTexture: Constant should be in numeric form.",
                  t
                ),
                e[t]);
          }
          const i = {};
          if (void 0 !== t)
            for (let r = 0, a = t.length; r < a; r++) {
              const a = t[r];
              let o;
              void 0 === a.image &&
                console.warn(
                  'THREE.ObjectLoader: No "image" specified for',
                  a.uuid
                ),
                void 0 === e[a.image] &&
                  console.warn("THREE.ObjectLoader: Undefined image", a.image);
              const s = e[a.image];
              Array.isArray(s)
                ? ((o = new Dr(s)), 6 === s.length && (o.needsUpdate = !0))
                : ((o =
                    s && s.data
                      ? new tu(s.data, s.width, s.height)
                      : new mn(s)),
                  s && (o.needsUpdate = !0)),
                (o.uuid = a.uuid),
                void 0 !== a.name && (o.name = a.name),
                void 0 !== a.mapping && (o.mapping = n(a.mapping, wf)),
                void 0 !== a.offset && o.offset.fromArray(a.offset),
                void 0 !== a.repeat && o.repeat.fromArray(a.repeat),
                void 0 !== a.center && o.center.fromArray(a.center),
                void 0 !== a.rotation && (o.rotation = a.rotation),
                void 0 !== a.wrap &&
                  ((o.wrapS = n(a.wrap[0], Mf)), (o.wrapT = n(a.wrap[1], Mf))),
                void 0 !== a.format && (o.format = a.format),
                void 0 !== a.type && (o.type = a.type),
                void 0 !== a.encoding && (o.encoding = a.encoding),
                void 0 !== a.minFilter && (o.minFilter = n(a.minFilter, Sf)),
                void 0 !== a.magFilter && (o.magFilter = n(a.magFilter, Sf)),
                void 0 !== a.anisotropy && (o.anisotropy = a.anisotropy),
                void 0 !== a.flipY && (o.flipY = a.flipY),
                void 0 !== a.premultiplyAlpha &&
                  (o.premultiplyAlpha = a.premultiplyAlpha),
                void 0 !== a.unpackAlignment &&
                  (o.unpackAlignment = a.unpackAlignment),
                void 0 !== a.userData && (o.userData = a.userData),
                (i[a.uuid] = o);
            }
          return i;
        }
        parseObject(t, e, n, i, r) {
          let a, o, s;
          function c(t) {
            return (
              void 0 === e[t] &&
                console.warn("THREE.ObjectLoader: Undefined geometry", t),
              e[t]
            );
          }
          function l(t) {
            if (void 0 !== t) {
              if (Array.isArray(t)) {
                const e = [];
                for (let i = 0, r = t.length; i < r; i++) {
                  const r = t[i];
                  void 0 === n[r] &&
                    console.warn("THREE.ObjectLoader: Undefined material", r),
                    e.push(n[r]);
                }
                return e;
              }
              return (
                void 0 === n[t] &&
                  console.warn("THREE.ObjectLoader: Undefined material", t),
                n[t]
              );
            }
          }
          function h(t) {
            return (
              void 0 === i[t] &&
                console.warn("THREE.ObjectLoader: Undefined texture", t),
              i[t]
            );
          }
          switch (t.type) {
            case "Scene":
              (a = new Sh()),
                void 0 !== t.background &&
                  (Number.isInteger(t.background)
                    ? (a.background = new un(t.background))
                    : (a.background = h(t.background))),
                void 0 !== t.environment && (a.environment = h(t.environment)),
                void 0 !== t.fog &&
                  ("Fog" === t.fog.type
                    ? (a.fog = new Mh(t.fog.color, t.fog.near, t.fog.far))
                    : "FogExp2" === t.fog.type &&
                      (a.fog = new wh(t.fog.color, t.fog.density)));
              break;
            case "PerspectiveCamera":
              (a = new Cr(t.fov, t.aspect, t.near, t.far)),
                void 0 !== t.focus && (a.focus = t.focus),
                void 0 !== t.zoom && (a.zoom = t.zoom),
                void 0 !== t.filmGauge && (a.filmGauge = t.filmGauge),
                void 0 !== t.filmOffset && (a.filmOffset = t.filmOffset),
                void 0 !== t.view && (a.view = Object.assign({}, t.view));
              break;
            case "OrthographicCamera":
              (a = new Ts(t.left, t.right, t.top, t.bottom, t.near, t.far)),
                void 0 !== t.zoom && (a.zoom = t.zoom),
                void 0 !== t.view && (a.view = Object.assign({}, t.view));
              break;
            case "AmbientLight":
              a = new pf(t.color, t.intensity);
              break;
            case "DirectionalLight":
              a = new df(t.color, t.intensity);
              break;
            case "PointLight":
              a = new hf(t.color, t.intensity, t.distance, t.decay);
              break;
            case "RectAreaLight":
              a = new ff(t.color, t.intensity, t.width, t.height);
              break;
            case "SpotLight":
              a = new af(
                t.color,
                t.intensity,
                t.distance,
                t.angle,
                t.penumbra,
                t.decay
              );
              break;
            case "HemisphereLight":
              a = new $p(t.color, t.groundColor, t.intensity);
              break;
            case "LightProbe":
              a = new gf().fromJSON(t);
              break;
            case "SkinnedMesh":
              (o = c(t.geometry)),
                (s = l(t.material)),
                (a = new $h(o, s)),
                void 0 !== t.bindMode && (a.bindMode = t.bindMode),
                void 0 !== t.bindMatrix && a.bindMatrix.fromArray(t.bindMatrix),
                void 0 !== t.skeleton && (a.skeleton = t.skeleton);
              break;
            case "Mesh":
              (o = c(t.geometry)), (s = l(t.material)), (a = new vr(o, s));
              break;
            case "InstancedMesh":
              (o = c(t.geometry)), (s = l(t.material));
              const e = t.count,
                n = t.instanceMatrix,
                i = t.instanceColor;
              (a = new lu(o, s, e)),
                (a.instanceMatrix = new ru(new Float32Array(n.array), 16)),
                void 0 !== i &&
                  (a.instanceColor = new ru(
                    new Float32Array(i.array),
                    i.itemSize
                  ));
              break;
            case "LOD":
              a = new qh();
              break;
            case "Line":
              a = new gu(c(t.geometry), l(t.material));
              break;
            case "LineLoop":
              a = new _u(c(t.geometry), l(t.material));
              break;
            case "LineSegments":
              a = new xu(c(t.geometry), l(t.material));
              break;
            case "PointCloud":
            case "Points":
              a = new Tu(c(t.geometry), l(t.material));
              break;
            case "Sprite":
              a = new Gh(l(t.material));
              break;
            case "Group":
              a = new ph();
              break;
            case "Bone":
              a = new Qh();
              break;
            default:
              a = new Si();
          }
          if (
            ((a.uuid = t.uuid),
            void 0 !== t.name && (a.name = t.name),
            void 0 !== t.matrix
              ? (a.matrix.fromArray(t.matrix),
                void 0 !== t.matrixAutoUpdate &&
                  (a.matrixAutoUpdate = t.matrixAutoUpdate),
                a.matrixAutoUpdate &&
                  a.matrix.decompose(a.position, a.quaternion, a.scale))
              : (void 0 !== t.position && a.position.fromArray(t.position),
                void 0 !== t.rotation && a.rotation.fromArray(t.rotation),
                void 0 !== t.quaternion && a.quaternion.fromArray(t.quaternion),
                void 0 !== t.scale && a.scale.fromArray(t.scale)),
            void 0 !== t.castShadow && (a.castShadow = t.castShadow),
            void 0 !== t.receiveShadow && (a.receiveShadow = t.receiveShadow),
            t.shadow &&
              (void 0 !== t.shadow.bias && (a.shadow.bias = t.shadow.bias),
              void 0 !== t.shadow.normalBias &&
                (a.shadow.normalBias = t.shadow.normalBias),
              void 0 !== t.shadow.radius && (a.shadow.radius = t.shadow.radius),
              void 0 !== t.shadow.mapSize &&
                a.shadow.mapSize.fromArray(t.shadow.mapSize),
              void 0 !== t.shadow.camera &&
                (a.shadow.camera = this.parseObject(t.shadow.camera))),
            void 0 !== t.visible && (a.visible = t.visible),
            void 0 !== t.frustumCulled && (a.frustumCulled = t.frustumCulled),
            void 0 !== t.renderOrder && (a.renderOrder = t.renderOrder),
            void 0 !== t.userData && (a.userData = t.userData),
            void 0 !== t.layers && (a.layers.mask = t.layers),
            void 0 !== t.children)
          ) {
            const o = t.children;
            for (let t = 0; t < o.length; t++)
              a.add(this.parseObject(o[t], e, n, i, r));
          }
          if (void 0 !== t.animations) {
            const e = t.animations;
            for (let t = 0; t < e.length; t++) {
              const n = e[t];
              a.animations.push(r[n]);
            }
          }
          if ("LOD" === t.type) {
            void 0 !== t.autoUpdate && (a.autoUpdate = t.autoUpdate);
            const e = t.levels;
            for (let t = 0; t < e.length; t++) {
              const n = e[t],
                i = a.getObjectByProperty("uuid", n.object);
              void 0 !== i && a.addLevel(i, n.distance);
            }
          }
          return a;
        }
        bindSkeletons(t, e) {
          0 !== Object.keys(e).length &&
            t.traverse(function (t) {
              if (!0 === t.isSkinnedMesh && void 0 !== t.skeleton) {
                const n = e[t.skeleton];
                void 0 === n
                  ? console.warn(
                      "THREE.ObjectLoader: No skeleton found with UUID:",
                      t.skeleton
                    )
                  : t.bind(n, t.bindMatrix);
              }
            });
        }
        setTexturePath(t) {
          return (
            console.warn(
              "THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath()."
            ),
            this.setResourcePath(t)
          );
        }
      }
      const wf = {
          UVMapping: ot,
          CubeReflectionMapping: st,
          CubeRefractionMapping: ct,
          EquirectangularReflectionMapping: lt,
          EquirectangularRefractionMapping: ht,
          CubeUVReflectionMapping: ut,
          CubeUVRefractionMapping: dt,
        },
        Mf = {
          RepeatWrapping: pt,
          ClampToEdgeWrapping: ft,
          MirroredRepeatWrapping: mt,
        },
        Sf = {
          NearestFilter: gt,
          NearestMipmapNearestFilter: vt,
          NearestMipmapLinearFilter: yt,
          LinearFilter: xt,
          LinearMipmapNearestFilter: _t,
          LinearMipmapLinearFilter: bt,
        };
      class Ef extends jp {
        constructor(t) {
          super(t),
            "undefined" === typeof createImageBitmap &&
              console.warn(
                "THREE.ImageBitmapLoader: createImageBitmap() not supported."
              ),
            "undefined" === typeof fetch &&
              console.warn("THREE.ImageBitmapLoader: fetch() not supported."),
            (this.options = { premultiplyAlpha: "none" });
        }
        setOptions(t) {
          return (this.options = t), this;
        }
        load(t, e, n, i) {
          void 0 === t && (t = ""),
            void 0 !== this.path && (t = this.path + t),
            (t = this.manager.resolveURL(t));
          const r = this,
            a = Gp.get(t);
          if (void 0 !== a)
            return (
              r.manager.itemStart(t),
              setTimeout(function () {
                e && e(a), r.manager.itemEnd(t);
              }, 0),
              a
            );
          const o = {};
          (o.credentials =
            "anonymous" === this.crossOrigin ? "same-origin" : "include"),
            (o.headers = this.requestHeader),
            fetch(t, o)
              .then(function (t) {
                return t.blob();
              })
              .then(function (t) {
                return createImageBitmap(
                  t,
                  Object.assign(r.options, { colorSpaceConversion: "none" })
                );
              })
              .then(function (n) {
                Gp.add(t, n), e && e(n), r.manager.itemEnd(t);
              })
              .catch(function (e) {
                i && i(e), r.manager.itemError(t), r.manager.itemEnd(t);
              }),
            r.manager.itemStart(t);
        }
      }
      let Tf;
      Ef.prototype.isImageBitmapLoader = !0;
      const Af = {
        getContext: function () {
          return (
            void 0 === Tf &&
              (Tf = new (window.AudioContext || window.webkitAudioContext)()),
            Tf
          );
        },
        setContext: function (t) {
          Tf = t;
        },
      };
      class Cf extends jp {
        constructor(t) {
          super(t);
        }
        load(t, e, n, i) {
          const r = this,
            a = new Xp(this.manager);
          a.setResponseType("arraybuffer"),
            a.setPath(this.path),
            a.setRequestHeader(this.requestHeader),
            a.setWithCredentials(this.withCredentials),
            a.load(
              t,
              function (n) {
                try {
                  const t = n.slice(0),
                    i = Af.getContext();
                  i.decodeAudioData(t, function (t) {
                    e(t);
                  });
                } catch (a) {
                  i ? i(a) : console.error(a), r.manager.itemError(t);
                }
              },
              n,
              i
            );
        }
      }
      class Rf extends gf {
        constructor(t, e, n = 1) {
          super(void 0, n);
          const i = new un().set(t),
            r = new un().set(e),
            a = new wn(i.r, i.g, i.b),
            o = new wn(r.r, r.g, r.b),
            s = Math.sqrt(Math.PI),
            c = s * Math.sqrt(0.75);
          this.sh.coefficients[0].copy(a).add(o).multiplyScalar(s),
            this.sh.coefficients[1].copy(a).sub(o).multiplyScalar(c);
        }
      }
      Rf.prototype.isHemisphereLightProbe = !0;
      class Lf extends gf {
        constructor(t, e = 1) {
          super(void 0, e);
          const n = new un().set(t);
          this.sh.coefficients[0]
            .set(n.r, n.g, n.b)
            .multiplyScalar(2 * Math.sqrt(Math.PI));
        }
      }
      Lf.prototype.isAmbientLightProbe = !0;
      class Pf extends Si {
        constructor(t) {
          super(),
            (this.type = "Audio"),
            (this.listener = t),
            (this.context = t.context),
            (this.gain = this.context.createGain()),
            this.gain.connect(t.getInput()),
            (this.autoplay = !1),
            (this.buffer = null),
            (this.detune = 0),
            (this.loop = !1),
            (this.loopStart = 0),
            (this.loopEnd = 0),
            (this.offset = 0),
            (this.duration = void 0),
            (this.playbackRate = 1),
            (this.isPlaying = !1),
            (this.hasPlaybackControl = !0),
            (this.source = null),
            (this.sourceType = "empty"),
            (this._startedAt = 0),
            (this._progress = 0),
            (this._connected = !1),
            (this.filters = []);
        }
        getOutput() {
          return this.gain;
        }
        setNodeSource(t) {
          return (
            (this.hasPlaybackControl = !1),
            (this.sourceType = "audioNode"),
            (this.source = t),
            this.connect(),
            this
          );
        }
        setMediaElementSource(t) {
          return (
            (this.hasPlaybackControl = !1),
            (this.sourceType = "mediaNode"),
            (this.source = this.context.createMediaElementSource(t)),
            this.connect(),
            this
          );
        }
        setMediaStreamSource(t) {
          return (
            (this.hasPlaybackControl = !1),
            (this.sourceType = "mediaStreamNode"),
            (this.source = this.context.createMediaStreamSource(t)),
            this.connect(),
            this
          );
        }
        setBuffer(t) {
          return (
            (this.buffer = t),
            (this.sourceType = "buffer"),
            this.autoplay && this.play(),
            this
          );
        }
        play(t = 0) {
          if (!0 === this.isPlaying)
            return void console.warn("THREE.Audio: Audio is already playing.");
          if (!1 === this.hasPlaybackControl)
            return void console.warn(
              "THREE.Audio: this Audio has no playback control."
            );
          this._startedAt = this.context.currentTime + t;
          const e = this.context.createBufferSource();
          return (
            (e.buffer = this.buffer),
            (e.loop = this.loop),
            (e.loopStart = this.loopStart),
            (e.loopEnd = this.loopEnd),
            (e.onended = this.onEnded.bind(this)),
            e.start(
              this._startedAt,
              this._progress + this.offset,
              this.duration
            ),
            (this.isPlaying = !0),
            (this.source = e),
            this.setDetune(this.detune),
            this.setPlaybackRate(this.playbackRate),
            this.connect()
          );
        }
        pause() {
          if (!1 !== this.hasPlaybackControl)
            return (
              !0 === this.isPlaying &&
                ((this._progress +=
                  Math.max(this.context.currentTime - this._startedAt, 0) *
                  this.playbackRate),
                !0 === this.loop &&
                  (this._progress =
                    this._progress % (this.duration || this.buffer.duration)),
                this.source.stop(),
                (this.source.onended = null),
                (this.isPlaying = !1)),
              this
            );
          console.warn("THREE.Audio: this Audio has no playback control.");
        }
        stop() {
          if (!1 !== this.hasPlaybackControl)
            return (
              (this._progress = 0),
              this.source.stop(),
              (this.source.onended = null),
              (this.isPlaying = !1),
              this
            );
          console.warn("THREE.Audio: this Audio has no playback control.");
        }
        connect() {
          if (this.filters.length > 0) {
            this.source.connect(this.filters[0]);
            for (let t = 1, e = this.filters.length; t < e; t++)
              this.filters[t - 1].connect(this.filters[t]);
            this.filters[this.filters.length - 1].connect(this.getOutput());
          } else this.source.connect(this.getOutput());
          return (this._connected = !0), this;
        }
        disconnect() {
          if (this.filters.length > 0) {
            this.source.disconnect(this.filters[0]);
            for (let t = 1, e = this.filters.length; t < e; t++)
              this.filters[t - 1].disconnect(this.filters[t]);
            this.filters[this.filters.length - 1].disconnect(this.getOutput());
          } else this.source.disconnect(this.getOutput());
          return (this._connected = !1), this;
        }
        getFilters() {
          return this.filters;
        }
        setFilters(t) {
          return (
            t || (t = []),
            !0 === this._connected
              ? (this.disconnect(), (this.filters = t.slice()), this.connect())
              : (this.filters = t.slice()),
            this
          );
        }
        setDetune(t) {
          if (((this.detune = t), void 0 !== this.source.detune))
            return (
              !0 === this.isPlaying &&
                this.source.detune.setTargetAtTime(
                  this.detune,
                  this.context.currentTime,
                  0.01
                ),
              this
            );
        }
        getDetune() {
          return this.detune;
        }
        getFilter() {
          return this.getFilters()[0];
        }
        setFilter(t) {
          return this.setFilters(t ? [t] : []);
        }
        setPlaybackRate(t) {
          if (!1 !== this.hasPlaybackControl)
            return (
              (this.playbackRate = t),
              !0 === this.isPlaying &&
                this.source.playbackRate.setTargetAtTime(
                  this.playbackRate,
                  this.context.currentTime,
                  0.01
                ),
              this
            );
          console.warn("THREE.Audio: this Audio has no playback control.");
        }
        getPlaybackRate() {
          return this.playbackRate;
        }
        onEnded() {
          this.isPlaying = !1;
        }
        getLoop() {
          return !1 === this.hasPlaybackControl
            ? (console.warn("THREE.Audio: this Audio has no playback control."),
              !1)
            : this.loop;
        }
        setLoop(t) {
          if (!1 !== this.hasPlaybackControl)
            return (
              (this.loop = t),
              !0 === this.isPlaying && (this.source.loop = this.loop),
              this
            );
          console.warn("THREE.Audio: this Audio has no playback control.");
        }
        setLoopStart(t) {
          return (this.loopStart = t), this;
        }
        setLoopEnd(t) {
          return (this.loopEnd = t), this;
        }
        getVolume() {
          return this.gain.gain.value;
        }
        setVolume(t) {
          return (
            this.gain.gain.setTargetAtTime(t, this.context.currentTime, 0.01),
            this
          );
        }
      }
      class Df {
        constructor(t, e = 2048) {
          (this.analyser = t.context.createAnalyser()),
            (this.analyser.fftSize = e),
            (this.data = new Uint8Array(this.analyser.frequencyBinCount)),
            t.getOutput().connect(this.analyser);
        }
        getFrequencyData() {
          return this.analyser.getByteFrequencyData(this.data), this.data;
        }
        getAverageFrequency() {
          let t = 0;
          const e = this.getFrequencyData();
          for (let n = 0; n < e.length; n++) t += e[n];
          return t / e.length;
        }
      }
      class If {
        constructor(t, e, n) {
          let i, r, a;
          switch (((this.binding = t), (this.valueSize = n), e)) {
            case "quaternion":
              (i = this._slerp),
                (r = this._slerpAdditive),
                (a = this._setAdditiveIdentityQuaternion),
                (this.buffer = new Float64Array(6 * n)),
                (this._workIndex = 5);
              break;
            case "string":
            case "bool":
              (i = this._select),
                (r = this._select),
                (a = this._setAdditiveIdentityOther),
                (this.buffer = new Array(5 * n));
              break;
            default:
              (i = this._lerp),
                (r = this._lerpAdditive),
                (a = this._setAdditiveIdentityNumeric),
                (this.buffer = new Float64Array(5 * n));
          }
          (this._mixBufferRegion = i),
            (this._mixBufferRegionAdditive = r),
            (this._setIdentity = a),
            (this._origIndex = 3),
            (this._addIndex = 4),
            (this.cumulativeWeight = 0),
            (this.cumulativeWeightAdditive = 0),
            (this.useCount = 0),
            (this.referenceCount = 0);
        }
        accumulate(t, e) {
          const n = this.buffer,
            i = this.valueSize,
            r = t * i + i;
          let a = this.cumulativeWeight;
          if (0 === a) {
            for (let t = 0; t !== i; ++t) n[r + t] = n[t];
            a = e;
          } else {
            a += e;
            const t = e / a;
            this._mixBufferRegion(n, r, 0, t, i);
          }
          this.cumulativeWeight = a;
        }
        accumulateAdditive(t) {
          const e = this.buffer,
            n = this.valueSize,
            i = n * this._addIndex;
          0 === this.cumulativeWeightAdditive && this._setIdentity(),
            this._mixBufferRegionAdditive(e, i, 0, t, n),
            (this.cumulativeWeightAdditive += t);
        }
        apply(t) {
          const e = this.valueSize,
            n = this.buffer,
            i = t * e + e,
            r = this.cumulativeWeight,
            a = this.cumulativeWeightAdditive,
            o = this.binding;
          if (
            ((this.cumulativeWeight = 0),
            (this.cumulativeWeightAdditive = 0),
            r < 1)
          ) {
            const t = e * this._origIndex;
            this._mixBufferRegion(n, i, t, 1 - r, e);
          }
          a > 0 &&
            this._mixBufferRegionAdditive(n, i, this._addIndex * e, 1, e);
          for (let s = e, c = e + e; s !== c; ++s)
            if (n[s] !== n[s + e]) {
              o.setValue(n, i);
              break;
            }
        }
        saveOriginalState() {
          const t = this.binding,
            e = this.buffer,
            n = this.valueSize,
            i = n * this._origIndex;
          t.getValue(e, i);
          for (let r = n, a = i; r !== a; ++r) e[r] = e[i + (r % n)];
          this._setIdentity(),
            (this.cumulativeWeight = 0),
            (this.cumulativeWeightAdditive = 0);
        }
        restoreOriginalState() {
          const t = 3 * this.valueSize;
          this.binding.setValue(this.buffer, t);
        }
        _setAdditiveIdentityNumeric() {
          const t = this._addIndex * this.valueSize,
            e = t + this.valueSize;
          for (let n = t; n < e; n++) this.buffer[n] = 0;
        }
        _setAdditiveIdentityQuaternion() {
          this._setAdditiveIdentityNumeric(),
            (this.buffer[this._addIndex * this.valueSize + 3] = 1);
        }
        _setAdditiveIdentityOther() {
          const t = this._origIndex * this.valueSize,
            e = this._addIndex * this.valueSize;
          for (let n = 0; n < this.valueSize; n++)
            this.buffer[e + n] = this.buffer[t + n];
        }
        _select(t, e, n, i, r) {
          if (i >= 0.5) for (let a = 0; a !== r; ++a) t[e + a] = t[n + a];
        }
        _slerp(t, e, n, i) {
          bn.slerpFlat(t, e, t, e, t, n, i);
        }
        _slerpAdditive(t, e, n, i, r) {
          const a = this._workIndex * r;
          bn.multiplyQuaternionsFlat(t, a, t, e, t, n),
            bn.slerpFlat(t, e, t, e, t, a, i);
        }
        _lerp(t, e, n, i, r) {
          const a = 1 - i;
          for (let o = 0; o !== r; ++o) {
            const r = e + o;
            t[r] = t[r] * a + t[n + o] * i;
          }
        }
        _lerpAdditive(t, e, n, i, r) {
          for (let a = 0; a !== r; ++a) {
            const r = e + a;
            t[r] = t[r] + t[n + a] * i;
          }
        }
      }
      const Of = "\\[\\]\\.:\\/",
        Nf = new RegExp("[" + Of + "]", "g"),
        Bf = "[^" + Of + "]",
        zf = "[^" + Of.replace("\\.", "") + "]",
        Uf = /((?:WC+[\/:])*)/.source.replace("WC", Bf),
        Ff = /(WCOD+)?/.source.replace("WCOD", zf),
        Hf = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", Bf),
        kf = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", Bf),
        Gf = new RegExp("^" + Uf + Ff + Hf + kf + "$"),
        Vf = ["material", "materials", "bones"];
      class Wf {
        constructor(t, e, n) {
          const i = n || jf.parseTrackName(e);
          (this._targetGroup = t), (this._bindings = t.subscribe_(e, i));
        }
        getValue(t, e) {
          this.bind();
          const n = this._targetGroup.nCachedObjects_,
            i = this._bindings[n];
          void 0 !== i && i.getValue(t, e);
        }
        setValue(t, e) {
          const n = this._bindings;
          for (
            let i = this._targetGroup.nCachedObjects_, r = n.length;
            i !== r;
            ++i
          )
            n[i].setValue(t, e);
        }
        bind() {
          const t = this._bindings;
          for (
            let e = this._targetGroup.nCachedObjects_, n = t.length;
            e !== n;
            ++e
          )
            t[e].bind();
        }
        unbind() {
          const t = this._bindings;
          for (
            let e = this._targetGroup.nCachedObjects_, n = t.length;
            e !== n;
            ++e
          )
            t[e].unbind();
        }
      }
      class jf {
        constructor(t, e, n) {
          (this.path = e),
            (this.parsedPath = n || jf.parseTrackName(e)),
            (this.node = jf.findNode(t, this.parsedPath.nodeName) || t),
            (this.rootNode = t),
            (this.getValue = this._getValue_unbound),
            (this.setValue = this._setValue_unbound);
        }
        static create(t, e, n) {
          return t && t.isAnimationObjectGroup
            ? new jf.Composite(t, e, n)
            : new jf(t, e, n);
        }
        static sanitizeNodeName(t) {
          return t.replace(/\s/g, "_").replace(Nf, "");
        }
        static parseTrackName(t) {
          const e = Gf.exec(t);
          if (!e)
            throw new Error("PropertyBinding: Cannot parse trackName: " + t);
          const n = {
              nodeName: e[2],
              objectName: e[3],
              objectIndex: e[4],
              propertyName: e[5],
              propertyIndex: e[6],
            },
            i = n.nodeName && n.nodeName.lastIndexOf(".");
          if (void 0 !== i && -1 !== i) {
            const t = n.nodeName.substring(i + 1);
            -1 !== Vf.indexOf(t) &&
              ((n.nodeName = n.nodeName.substring(0, i)), (n.objectName = t));
          }
          if (null === n.propertyName || 0 === n.propertyName.length)
            throw new Error(
              "PropertyBinding: can not parse propertyName from trackName: " + t
            );
          return n;
        }
        static findNode(t, e) {
          if (
            !e ||
            "" === e ||
            "." === e ||
            -1 === e ||
            e === t.name ||
            e === t.uuid
          )
            return t;
          if (t.skeleton) {
            const n = t.skeleton.getBoneByName(e);
            if (void 0 !== n) return n;
          }
          if (t.children) {
            const n = function (t) {
                for (let i = 0; i < t.length; i++) {
                  const r = t[i];
                  if (r.name === e || r.uuid === e) return r;
                  const a = n(r.children);
                  if (a) return a;
                }
                return null;
              },
              i = n(t.children);
            if (i) return i;
          }
          return null;
        }
        _getValue_unavailable() {}
        _setValue_unavailable() {}
        _getValue_direct(t, e) {
          t[e] = this.targetObject[this.propertyName];
        }
        _getValue_array(t, e) {
          const n = this.resolvedProperty;
          for (let i = 0, r = n.length; i !== r; ++i) t[e++] = n[i];
        }
        _getValue_arrayElement(t, e) {
          t[e] = this.resolvedProperty[this.propertyIndex];
        }
        _getValue_toArray(t, e) {
          this.resolvedProperty.toArray(t, e);
        }
        _setValue_direct(t, e) {
          this.targetObject[this.propertyName] = t[e];
        }
        _setValue_direct_setNeedsUpdate(t, e) {
          (this.targetObject[this.propertyName] = t[e]),
            (this.targetObject.needsUpdate = !0);
        }
        _setValue_direct_setMatrixWorldNeedsUpdate(t, e) {
          (this.targetObject[this.propertyName] = t[e]),
            (this.targetObject.matrixWorldNeedsUpdate = !0);
        }
        _setValue_array(t, e) {
          const n = this.resolvedProperty;
          for (let i = 0, r = n.length; i !== r; ++i) n[i] = t[e++];
        }
        _setValue_array_setNeedsUpdate(t, e) {
          const n = this.resolvedProperty;
          for (let i = 0, r = n.length; i !== r; ++i) n[i] = t[e++];
          this.targetObject.needsUpdate = !0;
        }
        _setValue_array_setMatrixWorldNeedsUpdate(t, e) {
          const n = this.resolvedProperty;
          for (let i = 0, r = n.length; i !== r; ++i) n[i] = t[e++];
          this.targetObject.matrixWorldNeedsUpdate = !0;
        }
        _setValue_arrayElement(t, e) {
          this.resolvedProperty[this.propertyIndex] = t[e];
        }
        _setValue_arrayElement_setNeedsUpdate(t, e) {
          (this.resolvedProperty[this.propertyIndex] = t[e]),
            (this.targetObject.needsUpdate = !0);
        }
        _setValue_arrayElement_setMatrixWorldNeedsUpdate(t, e) {
          (this.resolvedProperty[this.propertyIndex] = t[e]),
            (this.targetObject.matrixWorldNeedsUpdate = !0);
        }
        _setValue_fromArray(t, e) {
          this.resolvedProperty.fromArray(t, e);
        }
        _setValue_fromArray_setNeedsUpdate(t, e) {
          this.resolvedProperty.fromArray(t, e),
            (this.targetObject.needsUpdate = !0);
        }
        _setValue_fromArray_setMatrixWorldNeedsUpdate(t, e) {
          this.resolvedProperty.fromArray(t, e),
            (this.targetObject.matrixWorldNeedsUpdate = !0);
        }
        _getValue_unbound(t, e) {
          this.bind(), this.getValue(t, e);
        }
        _setValue_unbound(t, e) {
          this.bind(), this.setValue(t, e);
        }
        bind() {
          let t = this.node;
          const e = this.parsedPath,
            n = e.objectName,
            i = e.propertyName;
          let r = e.propertyIndex;
          if (
            (t ||
              ((t = jf.findNode(this.rootNode, e.nodeName) || this.rootNode),
              (this.node = t)),
            (this.getValue = this._getValue_unavailable),
            (this.setValue = this._setValue_unavailable),
            !t)
          )
            return void console.error(
              "THREE.PropertyBinding: Trying to update node for track: " +
                this.path +
                " but it wasn't found."
            );
          if (n) {
            let i = e.objectIndex;
            switch (n) {
              case "materials":
                if (!t.material)
                  return void console.error(
                    "THREE.PropertyBinding: Can not bind to material as node does not have a material.",
                    this
                  );
                if (!t.material.materials)
                  return void console.error(
                    "THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",
                    this
                  );
                t = t.material.materials;
                break;
              case "bones":
                if (!t.skeleton)
                  return void console.error(
                    "THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",
                    this
                  );
                t = t.skeleton.bones;
                for (let e = 0; e < t.length; e++)
                  if (t[e].name === i) {
                    i = e;
                    break;
                  }
                break;
              default:
                if (void 0 === t[n])
                  return void console.error(
                    "THREE.PropertyBinding: Can not bind to objectName of node undefined.",
                    this
                  );
                t = t[n];
            }
            if (void 0 !== i) {
              if (void 0 === t[i])
                return void console.error(
                  "THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",
                  this,
                  t
                );
              t = t[i];
            }
          }
          const a = t[i];
          if (void 0 === a) {
            const n = e.nodeName;
            return void console.error(
              "THREE.PropertyBinding: Trying to update property for track: " +
                n +
                "." +
                i +
                " but it wasn't found.",
              t
            );
          }
          let o = this.Versioning.None;
          (this.targetObject = t),
            void 0 !== t.needsUpdate
              ? (o = this.Versioning.NeedsUpdate)
              : void 0 !== t.matrixWorldNeedsUpdate &&
                (o = this.Versioning.MatrixWorldNeedsUpdate);
          let s = this.BindingType.Direct;
          if (void 0 !== r) {
            if ("morphTargetInfluences" === i) {
              if (!t.geometry)
                return void console.error(
                  "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",
                  this
                );
              if (!t.geometry.isBufferGeometry)
                return void console.error(
                  "THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.",
                  this
                );
              if (!t.geometry.morphAttributes)
                return void console.error(
                  "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",
                  this
                );
              void 0 !== t.morphTargetDictionary[r] &&
                (r = t.morphTargetDictionary[r]);
            }
            (s = this.BindingType.ArrayElement),
              (this.resolvedProperty = a),
              (this.propertyIndex = r);
          } else
            void 0 !== a.fromArray && void 0 !== a.toArray
              ? ((s = this.BindingType.HasFromToArray),
                (this.resolvedProperty = a))
              : Array.isArray(a)
              ? ((s = this.BindingType.EntireArray),
                (this.resolvedProperty = a))
              : (this.propertyName = i);
          (this.getValue = this.GetterByBindingType[s]),
            (this.setValue = this.SetterByBindingTypeAndVersioning[s][o]);
        }
        unbind() {
          (this.node = null),
            (this.getValue = this._getValue_unbound),
            (this.setValue = this._setValue_unbound);
        }
      }
      (jf.Composite = Wf),
        (jf.prototype.BindingType = {
          Direct: 0,
          EntireArray: 1,
          ArrayElement: 2,
          HasFromToArray: 3,
        }),
        (jf.prototype.Versioning = {
          None: 0,
          NeedsUpdate: 1,
          MatrixWorldNeedsUpdate: 2,
        }),
        (jf.prototype.GetterByBindingType = [
          jf.prototype._getValue_direct,
          jf.prototype._getValue_array,
          jf.prototype._getValue_arrayElement,
          jf.prototype._getValue_toArray,
        ]),
        (jf.prototype.SetterByBindingTypeAndVersioning = [
          [
            jf.prototype._setValue_direct,
            jf.prototype._setValue_direct_setNeedsUpdate,
            jf.prototype._setValue_direct_setMatrixWorldNeedsUpdate,
          ],
          [
            jf.prototype._setValue_array,
            jf.prototype._setValue_array_setNeedsUpdate,
            jf.prototype._setValue_array_setMatrixWorldNeedsUpdate,
          ],
          [
            jf.prototype._setValue_arrayElement,
            jf.prototype._setValue_arrayElement_setNeedsUpdate,
            jf.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate,
          ],
          [
            jf.prototype._setValue_fromArray,
            jf.prototype._setValue_fromArray_setNeedsUpdate,
            jf.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate,
          ],
        ]);
      class qf {
        constructor() {
          (this.uuid = je()),
            (this._objects = Array.prototype.slice.call(arguments)),
            (this.nCachedObjects_ = 0);
          const t = {};
          this._indicesByUUID = t;
          for (let n = 0, i = arguments.length; n !== i; ++n)
            t[arguments[n].uuid] = n;
          (this._paths = []),
            (this._parsedPaths = []),
            (this._bindings = []),
            (this._bindingsIndicesByPath = {});
          const e = this;
          this.stats = {
            objects: {
              get total() {
                return e._objects.length;
              },
              get inUse() {
                return this.total - e.nCachedObjects_;
              },
            },
            get bindingsPerObject() {
              return e._bindings.length;
            },
          };
        }
        add() {
          const t = this._objects,
            e = this._indicesByUUID,
            n = this._paths,
            i = this._parsedPaths,
            r = this._bindings,
            a = r.length;
          let o = void 0,
            s = t.length,
            c = this.nCachedObjects_;
          for (let l = 0, h = arguments.length; l !== h; ++l) {
            const h = arguments[l],
              u = h.uuid;
            let d = e[u];
            if (void 0 === d) {
              (d = s++), (e[u] = d), t.push(h);
              for (let t = 0, e = a; t !== e; ++t)
                r[t].push(new jf(h, n[t], i[t]));
            } else if (d < c) {
              o = t[d];
              const s = --c,
                l = t[s];
              (e[l.uuid] = d), (t[d] = l), (e[u] = s), (t[s] = h);
              for (let t = 0, e = a; t !== e; ++t) {
                const e = r[t],
                  a = e[s];
                let o = e[d];
                (e[d] = a),
                  void 0 === o && (o = new jf(h, n[t], i[t])),
                  (e[s] = o);
              }
            } else
              t[d] !== o &&
                console.error(
                  "THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes."
                );
          }
          this.nCachedObjects_ = c;
        }
        remove() {
          const t = this._objects,
            e = this._indicesByUUID,
            n = this._bindings,
            i = n.length;
          let r = this.nCachedObjects_;
          for (let a = 0, o = arguments.length; a !== o; ++a) {
            const o = arguments[a],
              s = o.uuid,
              c = e[s];
            if (void 0 !== c && c >= r) {
              const a = r++,
                l = t[a];
              (e[l.uuid] = c), (t[c] = l), (e[s] = a), (t[a] = o);
              for (let t = 0, e = i; t !== e; ++t) {
                const e = n[t],
                  i = e[a],
                  r = e[c];
                (e[c] = i), (e[a] = r);
              }
            }
          }
          this.nCachedObjects_ = r;
        }
        uncache() {
          const t = this._objects,
            e = this._indicesByUUID,
            n = this._bindings,
            i = n.length;
          let r = this.nCachedObjects_,
            a = t.length;
          for (let o = 0, s = arguments.length; o !== s; ++o) {
            const s = arguments[o],
              c = s.uuid,
              l = e[c];
            if (void 0 !== l)
              if ((delete e[c], l < r)) {
                const o = --r,
                  s = t[o],
                  c = --a,
                  h = t[c];
                (e[s.uuid] = l),
                  (t[l] = s),
                  (e[h.uuid] = o),
                  (t[o] = h),
                  t.pop();
                for (let t = 0, e = i; t !== e; ++t) {
                  const e = n[t],
                    i = e[o],
                    r = e[c];
                  (e[l] = i), (e[o] = r), e.pop();
                }
              } else {
                const r = --a,
                  o = t[r];
                r > 0 && (e[o.uuid] = l), (t[l] = o), t.pop();
                for (let t = 0, e = i; t !== e; ++t) {
                  const e = n[t];
                  (e[l] = e[r]), e.pop();
                }
              }
          }
          this.nCachedObjects_ = r;
        }
        subscribe_(t, e) {
          const n = this._bindingsIndicesByPath;
          let i = n[t];
          const r = this._bindings;
          if (void 0 !== i) return r[i];
          const a = this._paths,
            o = this._parsedPaths,
            s = this._objects,
            c = s.length,
            l = this.nCachedObjects_,
            h = new Array(c);
          (i = r.length), (n[t] = i), a.push(t), o.push(e), r.push(h);
          for (let u = l, d = s.length; u !== d; ++u) {
            const n = s[u];
            h[u] = new jf(n, t, e);
          }
          return h;
        }
        unsubscribe_(t) {
          const e = this._bindingsIndicesByPath,
            n = e[t];
          if (void 0 !== n) {
            const i = this._paths,
              r = this._parsedPaths,
              a = this._bindings,
              o = a.length - 1,
              s = a[o],
              c = t[o];
            (e[c] = n),
              (a[n] = s),
              a.pop(),
              (r[n] = r[o]),
              r.pop(),
              (i[n] = i[o]),
              i.pop();
          }
        }
      }
      qf.prototype.isAnimationObjectGroup = !0;
      class Xf {
        constructor(t, e, n = null, i = e.blendMode) {
          (this._mixer = t),
            (this._clip = e),
            (this._localRoot = n),
            (this.blendMode = i);
          const r = e.tracks,
            a = r.length,
            o = new Array(a),
            s = { endingStart: Me, endingEnd: Me };
          for (let c = 0; c !== a; ++c) {
            const t = r[c].createInterpolant(null);
            (o[c] = t), (t.settings = s);
          }
          (this._interpolantSettings = s),
            (this._interpolants = o),
            (this._propertyBindings = new Array(a)),
            (this._cacheIndex = null),
            (this._byClipCacheIndex = null),
            (this._timeScaleInterpolant = null),
            (this._weightInterpolant = null),
            (this.loop = ye),
            (this._loopCount = -1),
            (this._startTime = null),
            (this.time = 0),
            (this.timeScale = 1),
            (this._effectiveTimeScale = 1),
            (this.weight = 1),
            (this._effectiveWeight = 1),
            (this.repetitions = 1 / 0),
            (this.paused = !1),
            (this.enabled = !0),
            (this.clampWhenFinished = !1),
            (this.zeroSlopeAtStart = !0),
            (this.zeroSlopeAtEnd = !0);
        }
        play() {
          return this._mixer._activateAction(this), this;
        }
        stop() {
          return this._mixer._deactivateAction(this), this.reset();
        }
        reset() {
          return (
            (this.paused = !1),
            (this.enabled = !0),
            (this.time = 0),
            (this._loopCount = -1),
            (this._startTime = null),
            this.stopFading().stopWarping()
          );
        }
        isRunning() {
          return (
            this.enabled &&
            !this.paused &&
            0 !== this.timeScale &&
            null === this._startTime &&
            this._mixer._isActiveAction(this)
          );
        }
        isScheduled() {
          return this._mixer._isActiveAction(this);
        }
        startAt(t) {
          return (this._startTime = t), this;
        }
        setLoop(t, e) {
          return (this.loop = t), (this.repetitions = e), this;
        }
        setEffectiveWeight(t) {
          return (
            (this.weight = t),
            (this._effectiveWeight = this.enabled ? t : 0),
            this.stopFading()
          );
        }
        getEffectiveWeight() {
          return this._effectiveWeight;
        }
        fadeIn(t) {
          return this._scheduleFading(t, 0, 1);
        }
        fadeOut(t) {
          return this._scheduleFading(t, 1, 0);
        }
        crossFadeFrom(t, e, n) {
          if ((t.fadeOut(e), this.fadeIn(e), n)) {
            const n = this._clip.duration,
              i = t._clip.duration,
              r = i / n,
              a = n / i;
            t.warp(1, r, e), this.warp(a, 1, e);
          }
          return this;
        }
        crossFadeTo(t, e, n) {
          return t.crossFadeFrom(this, e, n);
        }
        stopFading() {
          const t = this._weightInterpolant;
          return (
            null !== t &&
              ((this._weightInterpolant = null),
              this._mixer._takeBackControlInterpolant(t)),
            this
          );
        }
        setEffectiveTimeScale(t) {
          return (
            (this.timeScale = t),
            (this._effectiveTimeScale = this.paused ? 0 : t),
            this.stopWarping()
          );
        }
        getEffectiveTimeScale() {
          return this._effectiveTimeScale;
        }
        setDuration(t) {
          return (this.timeScale = this._clip.duration / t), this.stopWarping();
        }
        syncWith(t) {
          return (
            (this.time = t.time),
            (this.timeScale = t.timeScale),
            this.stopWarping()
          );
        }
        halt(t) {
          return this.warp(this._effectiveTimeScale, 0, t);
        }
        warp(t, e, n) {
          const i = this._mixer,
            r = i.time,
            a = this.timeScale;
          let o = this._timeScaleInterpolant;
          null === o &&
            ((o = i._lendControlInterpolant()),
            (this._timeScaleInterpolant = o));
          const s = o.parameterPositions,
            c = o.sampleValues;
          return (
            (s[0] = r), (s[1] = r + n), (c[0] = t / a), (c[1] = e / a), this
          );
        }
        stopWarping() {
          const t = this._timeScaleInterpolant;
          return (
            null !== t &&
              ((this._timeScaleInterpolant = null),
              this._mixer._takeBackControlInterpolant(t)),
            this
          );
        }
        getMixer() {
          return this._mixer;
        }
        getClip() {
          return this._clip;
        }
        getRoot() {
          return this._localRoot || this._mixer._root;
        }
        _update(t, e, n, i) {
          if (!this.enabled) return void this._updateWeight(t);
          const r = this._startTime;
          if (null !== r) {
            const i = (t - r) * n;
            if (i < 0 || 0 === n) return;
            (this._startTime = null), (e = n * i);
          }
          e *= this._updateTimeScale(t);
          const a = this._updateTime(e),
            o = this._updateWeight(t);
          if (o > 0) {
            const t = this._interpolants,
              e = this._propertyBindings;
            switch (this.blendMode) {
              case Ae:
                for (let n = 0, i = t.length; n !== i; ++n)
                  t[n].evaluate(a), e[n].accumulateAdditive(o);
                break;
              case Te:
              default:
                for (let n = 0, r = t.length; n !== r; ++n)
                  t[n].evaluate(a), e[n].accumulate(i, o);
            }
          }
        }
        _updateWeight(t) {
          let e = 0;
          if (this.enabled) {
            e = this.weight;
            const n = this._weightInterpolant;
            if (null !== n) {
              const i = n.evaluate(t)[0];
              (e *= i),
                t > n.parameterPositions[1] &&
                  (this.stopFading(), 0 === i && (this.enabled = !1));
            }
          }
          return (this._effectiveWeight = e), e;
        }
        _updateTimeScale(t) {
          let e = 0;
          if (!this.paused) {
            e = this.timeScale;
            const n = this._timeScaleInterpolant;
            if (null !== n) {
              const i = n.evaluate(t)[0];
              (e *= i),
                t > n.parameterPositions[1] &&
                  (this.stopWarping(),
                  0 === e ? (this.paused = !0) : (this.timeScale = e));
            }
          }
          return (this._effectiveTimeScale = e), e;
        }
        _updateTime(t) {
          const e = this._clip.duration,
            n = this.loop;
          let i = this.time + t,
            r = this._loopCount;
          const a = n === xe;
          if (0 === t) return -1 === r ? i : a && 1 === (1 & r) ? e - i : i;
          if (n === ve) {
            -1 === r && ((this._loopCount = 0), this._setEndings(!0, !0, !1));
            t: {
              if (i >= e) i = e;
              else {
                if (!(i < 0)) {
                  this.time = i;
                  break t;
                }
                i = 0;
              }
              this.clampWhenFinished ? (this.paused = !0) : (this.enabled = !1),
                (this.time = i),
                this._mixer.dispatchEvent({
                  type: "finished",
                  action: this,
                  direction: t < 0 ? -1 : 1,
                });
            }
          } else {
            if (
              (-1 === r &&
                (t >= 0
                  ? ((r = 0), this._setEndings(!0, 0 === this.repetitions, a))
                  : this._setEndings(0 === this.repetitions, !0, a)),
              i >= e || i < 0)
            ) {
              const n = Math.floor(i / e);
              (i -= e * n), (r += Math.abs(n));
              const o = this.repetitions - r;
              if (o <= 0)
                this.clampWhenFinished
                  ? (this.paused = !0)
                  : (this.enabled = !1),
                  (i = t > 0 ? e : 0),
                  (this.time = i),
                  this._mixer.dispatchEvent({
                    type: "finished",
                    action: this,
                    direction: t > 0 ? 1 : -1,
                  });
              else {
                if (1 === o) {
                  const e = t < 0;
                  this._setEndings(e, !e, a);
                } else this._setEndings(!1, !1, a);
                (this._loopCount = r),
                  (this.time = i),
                  this._mixer.dispatchEvent({
                    type: "loop",
                    action: this,
                    loopDelta: n,
                  });
              }
            } else this.time = i;
            if (a && 1 === (1 & r)) return e - i;
          }
          return i;
        }
        _setEndings(t, e, n) {
          const i = this._interpolantSettings;
          n
            ? ((i.endingStart = Se), (i.endingEnd = Se))
            : ((i.endingStart = t ? (this.zeroSlopeAtStart ? Se : Me) : Ee),
              (i.endingEnd = e ? (this.zeroSlopeAtEnd ? Se : Me) : Ee));
        }
        _scheduleFading(t, e, n) {
          const i = this._mixer,
            r = i.time;
          let a = this._weightInterpolant;
          null === a &&
            ((a = i._lendControlInterpolant()), (this._weightInterpolant = a));
          const o = a.parameterPositions,
            s = a.sampleValues;
          return (o[0] = r), (s[0] = e), (o[1] = r + t), (s[1] = n), this;
        }
      }
      class Yf extends ke {
        constructor(t) {
          super(),
            (this._root = t),
            this._initMemoryManager(),
            (this._accuIndex = 0),
            (this.time = 0),
            (this.timeScale = 1);
        }
        _bindAction(t, e) {
          const n = t._localRoot || this._root,
            i = t._clip.tracks,
            r = i.length,
            a = t._propertyBindings,
            o = t._interpolants,
            s = n.uuid,
            c = this._bindingsByRootAndName;
          let l = c[s];
          void 0 === l && ((l = {}), (c[s] = l));
          for (let h = 0; h !== r; ++h) {
            const t = i[h],
              r = t.name;
            let c = l[r];
            if (void 0 !== c) ++c.referenceCount, (a[h] = c);
            else {
              if (((c = a[h]), void 0 !== c)) {
                null === c._cacheIndex &&
                  (++c.referenceCount, this._addInactiveBinding(c, s, r));
                continue;
              }
              const i = e && e._propertyBindings[h].binding.parsedPath;
              (c = new If(
                jf.create(n, r, i),
                t.ValueTypeName,
                t.getValueSize()
              )),
                ++c.referenceCount,
                this._addInactiveBinding(c, s, r),
                (a[h] = c);
            }
            o[h].resultBuffer = c.buffer;
          }
        }
        _activateAction(t) {
          if (!this._isActiveAction(t)) {
            if (null === t._cacheIndex) {
              const e = (t._localRoot || this._root).uuid,
                n = t._clip.uuid,
                i = this._actionsByClip[n];
              this._bindAction(t, i && i.knownActions[0]),
                this._addInactiveAction(t, n, e);
            }
            const e = t._propertyBindings;
            for (let t = 0, n = e.length; t !== n; ++t) {
              const n = e[t];
              0 === n.useCount++ &&
                (this._lendBinding(n), n.saveOriginalState());
            }
            this._lendAction(t);
          }
        }
        _deactivateAction(t) {
          if (this._isActiveAction(t)) {
            const e = t._propertyBindings;
            for (let t = 0, n = e.length; t !== n; ++t) {
              const n = e[t];
              0 === --n.useCount &&
                (n.restoreOriginalState(), this._takeBackBinding(n));
            }
            this._takeBackAction(t);
          }
        }
        _initMemoryManager() {
          (this._actions = []),
            (this._nActiveActions = 0),
            (this._actionsByClip = {}),
            (this._bindings = []),
            (this._nActiveBindings = 0),
            (this._bindingsByRootAndName = {}),
            (this._controlInterpolants = []),
            (this._nActiveControlInterpolants = 0);
          const t = this;
          this.stats = {
            actions: {
              get total() {
                return t._actions.length;
              },
              get inUse() {
                return t._nActiveActions;
              },
            },
            bindings: {
              get total() {
                return t._bindings.length;
              },
              get inUse() {
                return t._nActiveBindings;
              },
            },
            controlInterpolants: {
              get total() {
                return t._controlInterpolants.length;
              },
              get inUse() {
                return t._nActiveControlInterpolants;
              },
            },
          };
        }
        _isActiveAction(t) {
          const e = t._cacheIndex;
          return null !== e && e < this._nActiveActions;
        }
        _addInactiveAction(t, e, n) {
          const i = this._actions,
            r = this._actionsByClip;
          let a = r[e];
          if (void 0 === a)
            (a = { knownActions: [t], actionByRoot: {} }),
              (t._byClipCacheIndex = 0),
              (r[e] = a);
          else {
            const e = a.knownActions;
            (t._byClipCacheIndex = e.length), e.push(t);
          }
          (t._cacheIndex = i.length), i.push(t), (a.actionByRoot[n] = t);
        }
        _removeInactiveAction(t) {
          const e = this._actions,
            n = e[e.length - 1],
            i = t._cacheIndex;
          (n._cacheIndex = i), (e[i] = n), e.pop(), (t._cacheIndex = null);
          const r = t._clip.uuid,
            a = this._actionsByClip,
            o = a[r],
            s = o.knownActions,
            c = s[s.length - 1],
            l = t._byClipCacheIndex;
          (c._byClipCacheIndex = l),
            (s[l] = c),
            s.pop(),
            (t._byClipCacheIndex = null);
          const h = o.actionByRoot,
            u = (t._localRoot || this._root).uuid;
          delete h[u],
            0 === s.length && delete a[r],
            this._removeInactiveBindingsForAction(t);
        }
        _removeInactiveBindingsForAction(t) {
          const e = t._propertyBindings;
          for (let n = 0, i = e.length; n !== i; ++n) {
            const t = e[n];
            0 === --t.referenceCount && this._removeInactiveBinding(t);
          }
        }
        _lendAction(t) {
          const e = this._actions,
            n = t._cacheIndex,
            i = this._nActiveActions++,
            r = e[i];
          (t._cacheIndex = i), (e[i] = t), (r._cacheIndex = n), (e[n] = r);
        }
        _takeBackAction(t) {
          const e = this._actions,
            n = t._cacheIndex,
            i = --this._nActiveActions,
            r = e[i];
          (t._cacheIndex = i), (e[i] = t), (r._cacheIndex = n), (e[n] = r);
        }
        _addInactiveBinding(t, e, n) {
          const i = this._bindingsByRootAndName,
            r = this._bindings;
          let a = i[e];
          void 0 === a && ((a = {}), (i[e] = a)),
            (a[n] = t),
            (t._cacheIndex = r.length),
            r.push(t);
        }
        _removeInactiveBinding(t) {
          const e = this._bindings,
            n = t.binding,
            i = n.rootNode.uuid,
            r = n.path,
            a = this._bindingsByRootAndName,
            o = a[i],
            s = e[e.length - 1],
            c = t._cacheIndex;
          (s._cacheIndex = c),
            (e[c] = s),
            e.pop(),
            delete o[r],
            0 === Object.keys(o).length && delete a[i];
        }
        _lendBinding(t) {
          const e = this._bindings,
            n = t._cacheIndex,
            i = this._nActiveBindings++,
            r = e[i];
          (t._cacheIndex = i), (e[i] = t), (r._cacheIndex = n), (e[n] = r);
        }
        _takeBackBinding(t) {
          const e = this._bindings,
            n = t._cacheIndex,
            i = --this._nActiveBindings,
            r = e[i];
          (t._cacheIndex = i), (e[i] = t), (r._cacheIndex = n), (e[n] = r);
        }
        _lendControlInterpolant() {
          const t = this._controlInterpolants,
            e = this._nActiveControlInterpolants++;
          let n = t[e];
          return (
            void 0 === n &&
              ((n = new Rp(
                new Float32Array(2),
                new Float32Array(2),
                1,
                this._controlInterpolantsResultBuffer
              )),
              (n.__cacheIndex = e),
              (t[e] = n)),
            n
          );
        }
        _takeBackControlInterpolant(t) {
          const e = this._controlInterpolants,
            n = t.__cacheIndex,
            i = --this._nActiveControlInterpolants,
            r = e[i];
          (t.__cacheIndex = i), (e[i] = t), (r.__cacheIndex = n), (e[n] = r);
        }
        clipAction(t, e, n) {
          const i = e || this._root,
            r = i.uuid;
          let a = "string" === typeof t ? Fp.findByName(i, t) : t;
          const o = null !== a ? a.uuid : t,
            s = this._actionsByClip[o];
          let c = null;
          if (
            (void 0 === n && (n = null !== a ? a.blendMode : Te), void 0 !== s)
          ) {
            const t = s.actionByRoot[r];
            if (void 0 !== t && t.blendMode === n) return t;
            (c = s.knownActions[0]), null === a && (a = c._clip);
          }
          if (null === a) return null;
          const l = new Xf(this, a, e, n);
          return this._bindAction(l, c), this._addInactiveAction(l, o, r), l;
        }
        existingAction(t, e) {
          const n = e || this._root,
            i = n.uuid,
            r = "string" === typeof t ? Fp.findByName(n, t) : t,
            a = r ? r.uuid : t,
            o = this._actionsByClip[a];
          return (void 0 !== o && o.actionByRoot[i]) || null;
        }
        stopAllAction() {
          const t = this._actions,
            e = this._nActiveActions;
          for (let n = e - 1; n >= 0; --n) t[n].stop();
          return this;
        }
        update(t) {
          t *= this.timeScale;
          const e = this._actions,
            n = this._nActiveActions,
            i = (this.time += t),
            r = Math.sign(t),
            a = (this._accuIndex ^= 1);
          for (let c = 0; c !== n; ++c) {
            const n = e[c];
            n._update(i, t, r, a);
          }
          const o = this._bindings,
            s = this._nActiveBindings;
          for (let c = 0; c !== s; ++c) o[c].apply(a);
          return this;
        }
        setTime(t) {
          this.time = 0;
          for (let e = 0; e < this._actions.length; e++)
            this._actions[e].time = 0;
          return this.update(t);
        }
        getRoot() {
          return this._root;
        }
        uncacheClip(t) {
          const e = this._actions,
            n = t.uuid,
            i = this._actionsByClip,
            r = i[n];
          if (void 0 !== r) {
            const t = r.knownActions;
            for (let n = 0, i = t.length; n !== i; ++n) {
              const i = t[n];
              this._deactivateAction(i);
              const r = i._cacheIndex,
                a = e[e.length - 1];
              (i._cacheIndex = null),
                (i._byClipCacheIndex = null),
                (a._cacheIndex = r),
                (e[r] = a),
                e.pop(),
                this._removeInactiveBindingsForAction(i);
            }
            delete i[n];
          }
        }
        uncacheRoot(t) {
          const e = t.uuid,
            n = this._actionsByClip;
          for (const a in n) {
            const t = n[a].actionByRoot,
              i = t[e];
            void 0 !== i &&
              (this._deactivateAction(i), this._removeInactiveAction(i));
          }
          const i = this._bindingsByRootAndName,
            r = i[e];
          if (void 0 !== r)
            for (const a in r) {
              const t = r[a];
              t.restoreOriginalState(), this._removeInactiveBinding(t);
            }
        }
        uncacheAction(t, e) {
          const n = this.existingAction(t, e);
          null !== n &&
            (this._deactivateAction(n), this._removeInactiveAction(n));
        }
      }
      Yf.prototype._controlInterpolantsResultBuffer = new Float32Array(1);
      class Jf {
        constructor(t) {
          "string" === typeof t &&
            (console.warn("THREE.Uniform: Type parameter is no longer needed."),
            (t = arguments[1])),
            (this.value = t);
        }
        clone() {
          return new Jf(
            void 0 === this.value.clone ? this.value : this.value.clone()
          );
        }
      }
      class Zf extends Eh {
        constructor(t, e, n = 1) {
          super(t, e), (this.meshPerAttribute = n);
        }
        copy(t) {
          return (
            super.copy(t), (this.meshPerAttribute = t.meshPerAttribute), this
          );
        }
        clone(t) {
          const e = super.clone(t);
          return (e.meshPerAttribute = this.meshPerAttribute), e;
        }
        toJSON(t) {
          const e = super.toJSON(t);
          return (
            (e.isInstancedInterleavedBuffer = !0),
            (e.meshPerAttribute = this.meshPerAttribute),
            e
          );
        }
      }
      Zf.prototype.isInstancedInterleavedBuffer = !0;
      class Kf {
        constructor(t, e, n, i, r) {
          (this.buffer = t),
            (this.type = e),
            (this.itemSize = n),
            (this.elementSize = i),
            (this.count = r),
            (this.version = 0);
        }
        set needsUpdate(t) {
          !0 === t && this.version++;
        }
        setBuffer(t) {
          return (this.buffer = t), this;
        }
        setType(t, e) {
          return (this.type = t), (this.elementSize = e), this;
        }
        setItemSize(t) {
          return (this.itemSize = t), this;
        }
        setCount(t) {
          return (this.count = t), this;
        }
      }
      Kf.prototype.isGLBufferAttribute = !0;
      const $f = new $e();
      class Qf {
        constructor(t = new $e(1 / 0, 1 / 0), e = new $e(-1 / 0, -1 / 0)) {
          (this.min = t), (this.max = e);
        }
        set(t, e) {
          return this.min.copy(t), this.max.copy(e), this;
        }
        setFromPoints(t) {
          this.makeEmpty();
          for (let e = 0, n = t.length; e < n; e++) this.expandByPoint(t[e]);
          return this;
        }
        setFromCenterAndSize(t, e) {
          const n = $f.copy(e).multiplyScalar(0.5);
          return this.min.copy(t).sub(n), this.max.copy(t).add(n), this;
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(t) {
          return this.min.copy(t.min), this.max.copy(t.max), this;
        }
        makeEmpty() {
          return (
            (this.min.x = this.min.y = 1 / 0),
            (this.max.x = this.max.y = -1 / 0),
            this
          );
        }
        isEmpty() {
          return this.max.x < this.min.x || this.max.y < this.min.y;
        }
        getCenter(t) {
          return this.isEmpty()
            ? t.set(0, 0)
            : t.addVectors(this.min, this.max).multiplyScalar(0.5);
        }
        getSize(t) {
          return this.isEmpty()
            ? t.set(0, 0)
            : t.subVectors(this.max, this.min);
        }
        expandByPoint(t) {
          return this.min.min(t), this.max.max(t), this;
        }
        expandByVector(t) {
          return this.min.sub(t), this.max.add(t), this;
        }
        expandByScalar(t) {
          return this.min.addScalar(-t), this.max.addScalar(t), this;
        }
        containsPoint(t) {
          return !(
            t.x < this.min.x ||
            t.x > this.max.x ||
            t.y < this.min.y ||
            t.y > this.max.y
          );
        }
        containsBox(t) {
          return (
            this.min.x <= t.min.x &&
            t.max.x <= this.max.x &&
            this.min.y <= t.min.y &&
            t.max.y <= this.max.y
          );
        }
        getParameter(t, e) {
          return e.set(
            (t.x - this.min.x) / (this.max.x - this.min.x),
            (t.y - this.min.y) / (this.max.y - this.min.y)
          );
        }
        intersectsBox(t) {
          return !(
            t.max.x < this.min.x ||
            t.min.x > this.max.x ||
            t.max.y < this.min.y ||
            t.min.y > this.max.y
          );
        }
        clampPoint(t, e) {
          return e.copy(t).clamp(this.min, this.max);
        }
        distanceToPoint(t) {
          const e = $f.copy(t).clamp(this.min, this.max);
          return e.sub(t).length();
        }
        intersect(t) {
          return this.min.max(t.min), this.max.min(t.max), this;
        }
        union(t) {
          return this.min.min(t.min), this.max.max(t.max), this;
        }
        translate(t) {
          return this.min.add(t), this.max.add(t), this;
        }
        equals(t) {
          return t.min.equals(this.min) && t.max.equals(this.max);
        }
      }
      Qf.prototype.isBox2 = !0;
      const tm = new wn(),
        em = new wn();
      class nm {
        constructor(t = new wn(), e = new wn()) {
          (this.start = t), (this.end = e);
        }
        set(t, e) {
          return this.start.copy(t), this.end.copy(e), this;
        }
        copy(t) {
          return this.start.copy(t.start), this.end.copy(t.end), this;
        }
        getCenter(t) {
          return t.addVectors(this.start, this.end).multiplyScalar(0.5);
        }
        delta(t) {
          return t.subVectors(this.end, this.start);
        }
        distanceSq() {
          return this.start.distanceToSquared(this.end);
        }
        distance() {
          return this.start.distanceTo(this.end);
        }
        at(t, e) {
          return this.delta(e).multiplyScalar(t).add(this.start);
        }
        closestPointToPointParameter(t, e) {
          tm.subVectors(t, this.start), em.subVectors(this.end, this.start);
          const n = em.dot(em),
            i = em.dot(tm);
          let r = i / n;
          return e && (r = qe(r, 0, 1)), r;
        }
        closestPointToPoint(t, e, n) {
          const i = this.closestPointToPointParameter(t, e);
          return this.delta(n).multiplyScalar(i).add(this.start);
        }
        applyMatrix4(t) {
          return this.start.applyMatrix4(t), this.end.applyMatrix4(t), this;
        }
        equals(t) {
          return t.start.equals(this.start) && t.end.equals(this.end);
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      const im = new wn(),
        rm = new Qn(),
        am = new Qn();
      class om extends xu {
        constructor(t) {
          const e = sm(t),
            n = new Qi(),
            i = [],
            r = [],
            a = new un(0, 0, 1),
            o = new un(0, 1, 0);
          for (let c = 0; c < e.length; c++) {
            const t = e[c];
            t.parent &&
              t.parent.isBone &&
              (i.push(0, 0, 0),
              i.push(0, 0, 0),
              r.push(a.r, a.g, a.b),
              r.push(o.r, o.g, o.b));
          }
          n.setAttribute("position", new ji(i, 3)),
            n.setAttribute("color", new ji(r, 3));
          const s = new hu({
            vertexColors: !0,
            depthTest: !1,
            depthWrite: !1,
            toneMapped: !1,
            transparent: !0,
          });
          super(n, s),
            (this.type = "SkeletonHelper"),
            (this.isSkeletonHelper = !0),
            (this.root = t),
            (this.bones = e),
            (this.matrix = t.matrixWorld),
            (this.matrixAutoUpdate = !1);
        }
        updateMatrixWorld(t) {
          const e = this.bones,
            n = this.geometry,
            i = n.getAttribute("position");
          am.copy(this.root.matrixWorld).invert();
          for (let r = 0, a = 0; r < e.length; r++) {
            const t = e[r];
            t.parent &&
              t.parent.isBone &&
              (rm.multiplyMatrices(am, t.matrixWorld),
              im.setFromMatrixPosition(rm),
              i.setXYZ(a, im.x, im.y, im.z),
              rm.multiplyMatrices(am, t.parent.matrixWorld),
              im.setFromMatrixPosition(rm),
              i.setXYZ(a + 1, im.x, im.y, im.z),
              (a += 2));
          }
          (n.getAttribute("position").needsUpdate = !0),
            super.updateMatrixWorld(t);
        }
      }
      function sm(t) {
        const e = [];
        t && t.isBone && e.push(t);
        for (let n = 0; n < t.children.length; n++)
          e.push.apply(e, sm(t.children[n]));
        return e;
      }
      class cm extends xu {
        constructor(t = 10, e = 10, n = 4473924, i = 8947848) {
          (n = new un(n)), (i = new un(i));
          const r = e / 2,
            a = t / e,
            o = t / 2,
            s = [],
            c = [];
          for (let u = 0, d = 0, p = -o; u <= e; u++, p += a) {
            s.push(-o, 0, p, o, 0, p), s.push(p, 0, -o, p, 0, o);
            const t = u === r ? n : i;
            t.toArray(c, d),
              (d += 3),
              t.toArray(c, d),
              (d += 3),
              t.toArray(c, d),
              (d += 3),
              t.toArray(c, d),
              (d += 3);
          }
          const l = new Qi();
          l.setAttribute("position", new ji(s, 3)),
            l.setAttribute("color", new ji(c, 3));
          const h = new hu({ vertexColors: !0, toneMapped: !1 });
          super(l, h), (this.type = "GridHelper");
        }
      }
      class lm extends xu {
        constructor(t = 1) {
          const e = [0, 0, 0, t, 0, 0, 0, 0, 0, 0, t, 0, 0, 0, 0, 0, 0, t],
            n = [1, 0, 0, 1, 0.6, 0, 0, 1, 0, 0.6, 1, 0, 0, 0, 1, 0, 0.6, 1],
            i = new Qi();
          i.setAttribute("position", new ji(e, 3)),
            i.setAttribute("color", new ji(n, 3));
          const r = new hu({ vertexColors: !0, toneMapped: !1 });
          super(i, r), (this.type = "AxesHelper");
        }
        setColors(t, e, n) {
          const i = new un(),
            r = this.geometry.attributes.color.array;
          return (
            i.set(t),
            i.toArray(r, 0),
            i.toArray(r, 3),
            i.set(e),
            i.toArray(r, 6),
            i.toArray(r, 9),
            i.set(n),
            i.toArray(r, 12),
            i.toArray(r, 15),
            (this.geometry.attributes.color.needsUpdate = !0),
            this
          );
        }
        dispose() {
          this.geometry.dispose(), this.material.dispose();
        }
      }
      const hm = new Float32Array(1);
      new Int32Array(hm.buffer);
      (Gu.create = function (t, e) {
        return (
          console.log("THREE.Curve.create() has been deprecated"),
          (t.prototype = Object.create(Gu.prototype)),
          (t.prototype.constructor = t),
          (t.prototype.getPoint = e),
          t
        );
      }),
        (gd.prototype.fromPoints = function (t) {
          return (
            console.warn(
              "THREE.Path: .fromPoints() has been renamed to .setFromPoints()."
            ),
            this.setFromPoints(t)
          );
        }),
        (cm.prototype.setColors = function () {
          console.error(
            "THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead."
          );
        }),
        (om.prototype.update = function () {
          console.error(
            "THREE.SkeletonHelper: update() no longer needs to be called."
          );
        }),
        (jp.prototype.extractUrlBase = function (t) {
          return (
            console.warn(
              "THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."
            ),
            yf.extractUrlBase(t)
          );
        }),
        (jp.Handlers = {
          add: function () {
            console.error(
              "THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead."
            );
          },
          get: function () {
            console.error(
              "THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead."
            );
          },
        }),
        (Qf.prototype.center = function (t) {
          return (
            console.warn(
              "THREE.Box2: .center() has been renamed to .getCenter()."
            ),
            this.getCenter(t)
          );
        }),
        (Qf.prototype.empty = function () {
          return (
            console.warn(
              "THREE.Box2: .empty() has been renamed to .isEmpty()."
            ),
            this.isEmpty()
          );
        }),
        (Qf.prototype.isIntersectionBox = function (t) {
          return (
            console.warn(
              "THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."
            ),
            this.intersectsBox(t)
          );
        }),
        (Qf.prototype.size = function (t) {
          return (
            console.warn("THREE.Box2: .size() has been renamed to .getSize()."),
            this.getSize(t)
          );
        }),
        (En.prototype.center = function (t) {
          return (
            console.warn(
              "THREE.Box3: .center() has been renamed to .getCenter()."
            ),
            this.getCenter(t)
          );
        }),
        (En.prototype.empty = function () {
          return (
            console.warn(
              "THREE.Box3: .empty() has been renamed to .isEmpty()."
            ),
            this.isEmpty()
          );
        }),
        (En.prototype.isIntersectionBox = function (t) {
          return (
            console.warn(
              "THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."
            ),
            this.intersectsBox(t)
          );
        }),
        (En.prototype.isIntersectionSphere = function (t) {
          return (
            console.warn(
              "THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."
            ),
            this.intersectsSphere(t)
          );
        }),
        (En.prototype.size = function (t) {
          return (
            console.warn("THREE.Box3: .size() has been renamed to .getSize()."),
            this.getSize(t)
          );
        }),
        (Wn.prototype.empty = function () {
          return (
            console.warn(
              "THREE.Sphere: .empty() has been renamed to .isEmpty()."
            ),
            this.isEmpty()
          );
        }),
        (Hr.prototype.setFromMatrix = function (t) {
          return (
            console.warn(
              "THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."
            ),
            this.setFromProjectionMatrix(t)
          );
        }),
        (nm.prototype.center = function (t) {
          return (
            console.warn(
              "THREE.Line3: .center() has been renamed to .getCenter()."
            ),
            this.getCenter(t)
          );
        }),
        (Qe.prototype.flattenToArrayOffset = function (t, e) {
          return (
            console.warn(
              "THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."
            ),
            this.toArray(t, e)
          );
        }),
        (Qe.prototype.multiplyVector3 = function (t) {
          return (
            console.warn(
              "THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."
            ),
            t.applyMatrix3(this)
          );
        }),
        (Qe.prototype.multiplyVector3Array = function () {
          console.error(
            "THREE.Matrix3: .multiplyVector3Array() has been removed."
          );
        }),
        (Qe.prototype.applyToBufferAttribute = function (t) {
          return (
            console.warn(
              "THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."
            ),
            t.applyMatrix3(this)
          );
        }),
        (Qe.prototype.applyToVector3Array = function () {
          console.error(
            "THREE.Matrix3: .applyToVector3Array() has been removed."
          );
        }),
        (Qe.prototype.getInverse = function (t) {
          return (
            console.warn(
              "THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."
            ),
            this.copy(t).invert()
          );
        }),
        (Qn.prototype.extractPosition = function (t) {
          return (
            console.warn(
              "THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."
            ),
            this.copyPosition(t)
          );
        }),
        (Qn.prototype.flattenToArrayOffset = function (t, e) {
          return (
            console.warn(
              "THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."
            ),
            this.toArray(t, e)
          );
        }),
        (Qn.prototype.getPosition = function () {
          return (
            console.warn(
              "THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."
            ),
            new wn().setFromMatrixColumn(this, 3)
          );
        }),
        (Qn.prototype.setRotationFromQuaternion = function (t) {
          return (
            console.warn(
              "THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."
            ),
            this.makeRotationFromQuaternion(t)
          );
        }),
        (Qn.prototype.multiplyToArray = function () {
          console.warn("THREE.Matrix4: .multiplyToArray() has been removed.");
        }),
        (Qn.prototype.multiplyVector3 = function (t) {
          return (
            console.warn(
              "THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."
            ),
            t.applyMatrix4(this)
          );
        }),
        (Qn.prototype.multiplyVector4 = function (t) {
          return (
            console.warn(
              "THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."
            ),
            t.applyMatrix4(this)
          );
        }),
        (Qn.prototype.multiplyVector3Array = function () {
          console.error(
            "THREE.Matrix4: .multiplyVector3Array() has been removed."
          );
        }),
        (Qn.prototype.rotateAxis = function (t) {
          console.warn(
            "THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."
          ),
            t.transformDirection(this);
        }),
        (Qn.prototype.crossVector = function (t) {
          return (
            console.warn(
              "THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."
            ),
            t.applyMatrix4(this)
          );
        }),
        (Qn.prototype.translate = function () {
          console.error("THREE.Matrix4: .translate() has been removed.");
        }),
        (Qn.prototype.rotateX = function () {
          console.error("THREE.Matrix4: .rotateX() has been removed.");
        }),
        (Qn.prototype.rotateY = function () {
          console.error("THREE.Matrix4: .rotateY() has been removed.");
        }),
        (Qn.prototype.rotateZ = function () {
          console.error("THREE.Matrix4: .rotateZ() has been removed.");
        }),
        (Qn.prototype.rotateByAxis = function () {
          console.error("THREE.Matrix4: .rotateByAxis() has been removed.");
        }),
        (Qn.prototype.applyToBufferAttribute = function (t) {
          return (
            console.warn(
              "THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."
            ),
            t.applyMatrix4(this)
          );
        }),
        (Qn.prototype.applyToVector3Array = function () {
          console.error(
            "THREE.Matrix4: .applyToVector3Array() has been removed."
          );
        }),
        (Qn.prototype.makeFrustum = function (t, e, n, i, r, a) {
          return (
            console.warn(
              "THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."
            ),
            this.makePerspective(t, e, i, n, r, a)
          );
        }),
        (Qn.prototype.getInverse = function (t) {
          return (
            console.warn(
              "THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."
            ),
            this.copy(t).invert()
          );
        }),
        (zr.prototype.isIntersectionLine = function (t) {
          return (
            console.warn(
              "THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."
            ),
            this.intersectsLine(t)
          );
        }),
        (bn.prototype.multiplyVector3 = function (t) {
          return (
            console.warn(
              "THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."
            ),
            t.applyQuaternion(this)
          );
        }),
        (bn.prototype.inverse = function () {
          return (
            console.warn(
              "THREE.Quaternion: .inverse() has been renamed to invert()."
            ),
            this.invert()
          );
        }),
        ($n.prototype.isIntersectionBox = function (t) {
          return (
            console.warn(
              "THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."
            ),
            this.intersectsBox(t)
          );
        }),
        ($n.prototype.isIntersectionPlane = function (t) {
          return (
            console.warn(
              "THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."
            ),
            this.intersectsPlane(t)
          );
        }),
        ($n.prototype.isIntersectionSphere = function (t) {
          return (
            console.warn(
              "THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."
            ),
            this.intersectsSphere(t)
          );
        }),
        (Ni.prototype.area = function () {
          return (
            console.warn(
              "THREE.Triangle: .area() has been renamed to .getArea()."
            ),
            this.getArea()
          );
        }),
        (Ni.prototype.barycoordFromPoint = function (t, e) {
          return (
            console.warn(
              "THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."
            ),
            this.getBarycoord(t, e)
          );
        }),
        (Ni.prototype.midpoint = function (t) {
          return (
            console.warn(
              "THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."
            ),
            this.getMidpoint(t)
          );
        }),
        (Ni.prototypenormal = function (t) {
          return (
            console.warn(
              "THREE.Triangle: .normal() has been renamed to .getNormal()."
            ),
            this.getNormal(t)
          );
        }),
        (Ni.prototype.plane = function (t) {
          return (
            console.warn(
              "THREE.Triangle: .plane() has been renamed to .getPlane()."
            ),
            this.getPlane(t)
          );
        }),
        (Ni.barycoordFromPoint = function (t, e, n, i, r) {
          return (
            console.warn(
              "THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."
            ),
            Ni.getBarycoord(t, e, n, i, r)
          );
        }),
        (Ni.normal = function (t, e, n, i) {
          return (
            console.warn(
              "THREE.Triangle: .normal() has been renamed to .getNormal()."
            ),
            Ni.getNormal(t, e, n, i)
          );
        }),
        (vd.prototype.extractAllPoints = function (t) {
          return (
            console.warn(
              "THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."
            ),
            this.extractPoints(t)
          );
        }),
        (vd.prototype.extrude = function (t) {
          return (
            console.warn(
              "THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."
            ),
            new Qd(this, t)
          );
        }),
        (vd.prototype.makeGeometry = function (t) {
          return (
            console.warn(
              "THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."
            ),
            new op(this, t)
          );
        }),
        ($e.prototype.fromAttribute = function (t, e, n) {
          return (
            console.warn(
              "THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."
            ),
            this.fromBufferAttribute(t, e, n)
          );
        }),
        ($e.prototype.distanceToManhattan = function (t) {
          return (
            console.warn(
              "THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."
            ),
            this.manhattanDistanceTo(t)
          );
        }),
        ($e.prototype.lengthManhattan = function () {
          return (
            console.warn(
              "THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."
            ),
            this.manhattanLength()
          );
        }),
        (wn.prototype.setEulerFromRotationMatrix = function () {
          console.error(
            "THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead."
          );
        }),
        (wn.prototype.setEulerFromQuaternion = function () {
          console.error(
            "THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead."
          );
        }),
        (wn.prototype.getPositionFromMatrix = function (t) {
          return (
            console.warn(
              "THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."
            ),
            this.setFromMatrixPosition(t)
          );
        }),
        (wn.prototype.getScaleFromMatrix = function (t) {
          return (
            console.warn(
              "THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."
            ),
            this.setFromMatrixScale(t)
          );
        }),
        (wn.prototype.getColumnFromMatrix = function (t, e) {
          return (
            console.warn(
              "THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."
            ),
            this.setFromMatrixColumn(e, t)
          );
        }),
        (wn.prototype.applyProjection = function (t) {
          return (
            console.warn(
              "THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."
            ),
            this.applyMatrix4(t)
          );
        }),
        (wn.prototype.fromAttribute = function (t, e, n) {
          return (
            console.warn(
              "THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."
            ),
            this.fromBufferAttribute(t, e, n)
          );
        }),
        (wn.prototype.distanceToManhattan = function (t) {
          return (
            console.warn(
              "THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."
            ),
            this.manhattanDistanceTo(t)
          );
        }),
        (wn.prototype.lengthManhattan = function () {
          return (
            console.warn(
              "THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."
            ),
            this.manhattanLength()
          );
        }),
        (vn.prototype.fromAttribute = function (t, e, n) {
          return (
            console.warn(
              "THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."
            ),
            this.fromBufferAttribute(t, e, n)
          );
        }),
        (vn.prototype.lengthManhattan = function () {
          return (
            console.warn(
              "THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."
            ),
            this.manhattanLength()
          );
        }),
        (Si.prototype.getChildByName = function (t) {
          return (
            console.warn(
              "THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."
            ),
            this.getObjectByName(t)
          );
        }),
        (Si.prototype.renderDepth = function () {
          console.warn(
            "THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead."
          );
        }),
        (Si.prototype.translate = function (t, e) {
          return (
            console.warn(
              "THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."
            ),
            this.translateOnAxis(e, t)
          );
        }),
        (Si.prototype.getWorldRotation = function () {
          console.error(
            "THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead."
          );
        }),
        (Si.prototype.applyMatrix = function (t) {
          return (
            console.warn(
              "THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."
            ),
            this.applyMatrix4(t)
          );
        }),
        Object.defineProperties(Si.prototype, {
          eulerOrder: {
            get: function () {
              return (
                console.warn(
                  "THREE.Object3D: .eulerOrder is now .rotation.order."
                ),
                this.rotation.order
              );
            },
            set: function (t) {
              console.warn(
                "THREE.Object3D: .eulerOrder is now .rotation.order."
              ),
                (this.rotation.order = t);
            },
          },
          useQuaternion: {
            get: function () {
              console.warn(
                "THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default."
              );
            },
            set: function () {
              console.warn(
                "THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default."
              );
            },
          },
        }),
        (vr.prototype.setDrawMode = function () {
          console.error(
            "THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary."
          );
        }),
        Object.defineProperties(vr.prototype, {
          drawMode: {
            get: function () {
              return (
                console.error(
                  "THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."
                ),
                Ce
              );
            },
            set: function () {
              console.error(
                "THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary."
              );
            },
          },
        }),
        ($h.prototype.initBones = function () {
          console.error("THREE.SkinnedMesh: initBones() has been removed.");
        }),
        (Cr.prototype.setLens = function (t, e) {
          console.warn(
            "THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."
          ),
            void 0 !== e && (this.filmGauge = e),
            this.setFocalLength(t);
        }),
        Object.defineProperties(Kp.prototype, {
          onlyShadow: {
            set: function () {
              console.warn("THREE.Light: .onlyShadow has been removed.");
            },
          },
          shadowCameraFov: {
            set: function (t) {
              console.warn(
                "THREE.Light: .shadowCameraFov is now .shadow.camera.fov."
              ),
                (this.shadow.camera.fov = t);
            },
          },
          shadowCameraLeft: {
            set: function (t) {
              console.warn(
                "THREE.Light: .shadowCameraLeft is now .shadow.camera.left."
              ),
                (this.shadow.camera.left = t);
            },
          },
          shadowCameraRight: {
            set: function (t) {
              console.warn(
                "THREE.Light: .shadowCameraRight is now .shadow.camera.right."
              ),
                (this.shadow.camera.right = t);
            },
          },
          shadowCameraTop: {
            set: function (t) {
              console.warn(
                "THREE.Light: .shadowCameraTop is now .shadow.camera.top."
              ),
                (this.shadow.camera.top = t);
            },
          },
          shadowCameraBottom: {
            set: function (t) {
              console.warn(
                "THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."
              ),
                (this.shadow.camera.bottom = t);
            },
          },
          shadowCameraNear: {
            set: function (t) {
              console.warn(
                "THREE.Light: .shadowCameraNear is now .shadow.camera.near."
              ),
                (this.shadow.camera.near = t);
            },
          },
          shadowCameraFar: {
            set: function (t) {
              console.warn(
                "THREE.Light: .shadowCameraFar is now .shadow.camera.far."
              ),
                (this.shadow.camera.far = t);
            },
          },
          shadowCameraVisible: {
            set: function () {
              console.warn(
                "THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead."
              );
            },
          },
          shadowBias: {
            set: function (t) {
              console.warn("THREE.Light: .shadowBias is now .shadow.bias."),
                (this.shadow.bias = t);
            },
          },
          shadowDarkness: {
            set: function () {
              console.warn("THREE.Light: .shadowDarkness has been removed.");
            },
          },
          shadowMapWidth: {
            set: function (t) {
              console.warn(
                "THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."
              ),
                (this.shadow.mapSize.width = t);
            },
          },
          shadowMapHeight: {
            set: function (t) {
              console.warn(
                "THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."
              ),
                (this.shadow.mapSize.height = t);
            },
          },
        }),
        Object.defineProperties(ki.prototype, {
          length: {
            get: function () {
              return (
                console.warn(
                  "THREE.BufferAttribute: .length has been deprecated. Use .count instead."
                ),
                this.array.length
              );
            },
          },
          dynamic: {
            get: function () {
              return (
                console.warn(
                  "THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."
                ),
                this.usage === Ue
              );
            },
            set: function () {
              console.warn(
                "THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."
              ),
                this.setUsage(Ue);
            },
          },
        }),
        (ki.prototype.setDynamic = function (t) {
          return (
            console.warn(
              "THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."
            ),
            this.setUsage(!0 === t ? Ue : ze),
            this
          );
        }),
        (ki.prototype.copyIndicesArray = function () {
          console.error(
            "THREE.BufferAttribute: .copyIndicesArray() has been removed."
          );
        }),
        (ki.prototype.setArray = function () {
          console.error(
            "THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers"
          );
        }),
        (Qi.prototype.addIndex = function (t) {
          console.warn(
            "THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."
          ),
            this.setIndex(t);
        }),
        (Qi.prototype.addAttribute = function (t, e) {
          return (
            console.warn(
              "THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."
            ),
            (e && e.isBufferAttribute) || (e && e.isInterleavedBufferAttribute)
              ? "index" === t
                ? (console.warn(
                    "THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."
                  ),
                  this.setIndex(e),
                  this)
                : this.setAttribute(t, e)
              : (console.warn(
                  "THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."
                ),
                this.setAttribute(t, new ki(arguments[1], arguments[2])))
          );
        }),
        (Qi.prototype.addDrawCall = function (t, e, n) {
          void 0 !== n &&
            console.warn(
              "THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."
            ),
            console.warn(
              "THREE.BufferGeometry: .addDrawCall() is now .addGroup()."
            ),
            this.addGroup(t, e);
        }),
        (Qi.prototype.clearDrawCalls = function () {
          console.warn(
            "THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."
          ),
            this.clearGroups();
        }),
        (Qi.prototype.computeOffsets = function () {
          console.warn(
            "THREE.BufferGeometry: .computeOffsets() has been removed."
          );
        }),
        (Qi.prototype.removeAttribute = function (t) {
          return (
            console.warn(
              "THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."
            ),
            this.deleteAttribute(t)
          );
        }),
        (Qi.prototype.applyMatrix = function (t) {
          return (
            console.warn(
              "THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."
            ),
            this.applyMatrix4(t)
          );
        }),
        Object.defineProperties(Qi.prototype, {
          drawcalls: {
            get: function () {
              return (
                console.error(
                  "THREE.BufferGeometry: .drawcalls has been renamed to .groups."
                ),
                this.groups
              );
            },
          },
          offsets: {
            get: function () {
              return (
                console.warn(
                  "THREE.BufferGeometry: .offsets has been renamed to .groups."
                ),
                this.groups
              );
            },
          },
        }),
        (Eh.prototype.setDynamic = function (t) {
          return (
            console.warn(
              "THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."
            ),
            this.setUsage(!0 === t ? Ue : ze),
            this
          );
        }),
        (Eh.prototype.setArray = function () {
          console.error(
            "THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers"
          );
        }),
        (Qd.prototype.getArrays = function () {
          console.error(
            "THREE.ExtrudeGeometry: .getArrays() has been removed."
          );
        }),
        (Qd.prototype.addShapeList = function () {
          console.error(
            "THREE.ExtrudeGeometry: .addShapeList() has been removed."
          );
        }),
        (Qd.prototype.addShape = function () {
          console.error("THREE.ExtrudeGeometry: .addShape() has been removed.");
        }),
        (Sh.prototype.dispose = function () {
          console.error("THREE.Scene: .dispose() has been removed.");
        }),
        (Jf.prototype.onUpdate = function () {
          return (
            console.warn(
              "THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."
            ),
            this
          );
        }),
        Object.defineProperties(zi.prototype, {
          wrapAround: {
            get: function () {
              console.warn("THREE.Material: .wrapAround has been removed.");
            },
            set: function () {
              console.warn("THREE.Material: .wrapAround has been removed.");
            },
          },
          overdraw: {
            get: function () {
              console.warn("THREE.Material: .overdraw has been removed.");
            },
            set: function () {
              console.warn("THREE.Material: .overdraw has been removed.");
            },
          },
          wrapRGB: {
            get: function () {
              return (
                console.warn("THREE.Material: .wrapRGB has been removed."),
                new un()
              );
            },
          },
          shading: {
            get: function () {
              console.error(
                "THREE." +
                  this.type +
                  ": .shading has been removed. Use the boolean .flatShading instead."
              );
            },
            set: function (t) {
              console.warn(
                "THREE." +
                  this.type +
                  ": .shading has been removed. Use the boolean .flatShading instead."
              ),
                (this.flatShading = t === x);
            },
          },
          stencilMask: {
            get: function () {
              return (
                console.warn(
                  "THREE." +
                    this.type +
                    ": .stencilMask has been removed. Use .stencilFuncMask instead."
                ),
                this.stencilFuncMask
              );
            },
            set: function (t) {
              console.warn(
                "THREE." +
                  this.type +
                  ": .stencilMask has been removed. Use .stencilFuncMask instead."
              ),
                (this.stencilFuncMask = t);
            },
          },
          vertexTangents: {
            get: function () {
              console.warn(
                "THREE." + this.type + ": .vertexTangents has been removed."
              );
            },
            set: function () {
              console.warn(
                "THREE." + this.type + ": .vertexTangents has been removed."
              );
            },
          },
        }),
        Object.defineProperties(Tr.prototype, {
          derivatives: {
            get: function () {
              return (
                console.warn(
                  "THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."
                ),
                this.extensions.derivatives
              );
            },
            set: function (t) {
              console.warn(
                "THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."
              ),
                (this.extensions.derivatives = t);
            },
          },
        }),
        (_h.prototype.clearTarget = function (t, e, n, i) {
          console.warn(
            "THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."
          ),
            this.setRenderTarget(t),
            this.clear(e, n, i);
        }),
        (_h.prototype.animate = function (t) {
          console.warn(
            "THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."
          ),
            this.setAnimationLoop(t);
        }),
        (_h.prototype.getCurrentRenderTarget = function () {
          return (
            console.warn(
              "THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."
            ),
            this.getRenderTarget()
          );
        }),
        (_h.prototype.getMaxAnisotropy = function () {
          return (
            console.warn(
              "THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."
            ),
            this.capabilities.getMaxAnisotropy()
          );
        }),
        (_h.prototype.getPrecision = function () {
          return (
            console.warn(
              "THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."
            ),
            this.capabilities.precision
          );
        }),
        (_h.prototype.resetGLState = function () {
          return (
            console.warn(
              "THREE.WebGLRenderer: .resetGLState() is now .state.reset()."
            ),
            this.state.reset()
          );
        }),
        (_h.prototype.supportsFloatTextures = function () {
          return (
            console.warn(
              "THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."
            ),
            this.extensions.get("OES_texture_float")
          );
        }),
        (_h.prototype.supportsHalfFloatTextures = function () {
          return (
            console.warn(
              "THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."
            ),
            this.extensions.get("OES_texture_half_float")
          );
        }),
        (_h.prototype.supportsStandardDerivatives = function () {
          return (
            console.warn(
              "THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."
            ),
            this.extensions.get("OES_standard_derivatives")
          );
        }),
        (_h.prototype.supportsCompressedTextureS3TC = function () {
          return (
            console.warn(
              "THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."
            ),
            this.extensions.get("WEBGL_compressed_texture_s3tc")
          );
        }),
        (_h.prototype.supportsCompressedTexturePVRTC = function () {
          return (
            console.warn(
              "THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."
            ),
            this.extensions.get("WEBGL_compressed_texture_pvrtc")
          );
        }),
        (_h.prototype.supportsBlendMinMax = function () {
          return (
            console.warn(
              "THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."
            ),
            this.extensions.get("EXT_blend_minmax")
          );
        }),
        (_h.prototype.supportsVertexTextures = function () {
          return (
            console.warn(
              "THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."
            ),
            this.capabilities.vertexTextures
          );
        }),
        (_h.prototype.supportsInstancedArrays = function () {
          return (
            console.warn(
              "THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."
            ),
            this.extensions.get("ANGLE_instanced_arrays")
          );
        }),
        (_h.prototype.enableScissorTest = function (t) {
          console.warn(
            "THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."
          ),
            this.setScissorTest(t);
        }),
        (_h.prototype.initMaterial = function () {
          console.warn(
            "THREE.WebGLRenderer: .initMaterial() has been removed."
          );
        }),
        (_h.prototype.addPrePlugin = function () {
          console.warn(
            "THREE.WebGLRenderer: .addPrePlugin() has been removed."
          );
        }),
        (_h.prototype.addPostPlugin = function () {
          console.warn(
            "THREE.WebGLRenderer: .addPostPlugin() has been removed."
          );
        }),
        (_h.prototype.updateShadowMap = function () {
          console.warn(
            "THREE.WebGLRenderer: .updateShadowMap() has been removed."
          );
        }),
        (_h.prototype.setFaceCulling = function () {
          console.warn(
            "THREE.WebGLRenderer: .setFaceCulling() has been removed."
          );
        }),
        (_h.prototype.allocTextureUnit = function () {
          console.warn(
            "THREE.WebGLRenderer: .allocTextureUnit() has been removed."
          );
        }),
        (_h.prototype.setTexture = function () {
          console.warn("THREE.WebGLRenderer: .setTexture() has been removed.");
        }),
        (_h.prototype.setTexture2D = function () {
          console.warn(
            "THREE.WebGLRenderer: .setTexture2D() has been removed."
          );
        }),
        (_h.prototype.setTextureCube = function () {
          console.warn(
            "THREE.WebGLRenderer: .setTextureCube() has been removed."
          );
        }),
        (_h.prototype.getActiveMipMapLevel = function () {
          return (
            console.warn(
              "THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."
            ),
            this.getActiveMipmapLevel()
          );
        }),
        Object.defineProperties(_h.prototype, {
          shadowMapEnabled: {
            get: function () {
              return this.shadowMap.enabled;
            },
            set: function (t) {
              console.warn(
                "THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."
              ),
                (this.shadowMap.enabled = t);
            },
          },
          shadowMapType: {
            get: function () {
              return this.shadowMap.type;
            },
            set: function (t) {
              console.warn(
                "THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."
              ),
                (this.shadowMap.type = t);
            },
          },
          shadowMapCullFace: {
            get: function () {
              console.warn(
                "THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead."
              );
            },
            set: function () {
              console.warn(
                "THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead."
              );
            },
          },
          context: {
            get: function () {
              return (
                console.warn(
                  "THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."
                ),
                this.getContext()
              );
            },
          },
          vr: {
            get: function () {
              return (
                console.warn(
                  "THREE.WebGLRenderer: .vr has been renamed to .xr"
                ),
                this.xr
              );
            },
          },
          gammaInput: {
            get: function () {
              return (
                console.warn(
                  "THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."
                ),
                !1
              );
            },
            set: function () {
              console.warn(
                "THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."
              );
            },
          },
          gammaOutput: {
            get: function () {
              return (
                console.warn(
                  "THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."
                ),
                !1
              );
            },
            set: function (t) {
              console.warn(
                "THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."
              ),
                (this.outputEncoding = !0 === t ? Le : Re);
            },
          },
          toneMappingWhitePoint: {
            get: function () {
              return (
                console.warn(
                  "THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."
                ),
                1
              );
            },
            set: function () {
              console.warn(
                "THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."
              );
            },
          },
          gammaFactor: {
            get: function () {
              return (
                console.warn(
                  "THREE.WebGLRenderer: .gammaFactor has been removed."
                ),
                2
              );
            },
            set: function () {
              console.warn(
                "THREE.WebGLRenderer: .gammaFactor has been removed."
              );
            },
          },
        }),
        Object.defineProperties(ch.prototype, {
          cullFace: {
            get: function () {
              console.warn(
                "THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead."
              );
            },
            set: function () {
              console.warn(
                "THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead."
              );
            },
          },
          renderReverseSided: {
            get: function () {
              console.warn(
                "THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead."
              );
            },
            set: function () {
              console.warn(
                "THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead."
              );
            },
          },
          renderSingleSided: {
            get: function () {
              console.warn(
                "THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead."
              );
            },
            set: function () {
              console.warn(
                "THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead."
              );
            },
          },
        }),
        Object.defineProperties(yn.prototype, {
          wrapS: {
            get: function () {
              return (
                console.warn(
                  "THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."
                ),
                this.texture.wrapS
              );
            },
            set: function (t) {
              console.warn(
                "THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."
              ),
                (this.texture.wrapS = t);
            },
          },
          wrapT: {
            get: function () {
              return (
                console.warn(
                  "THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."
                ),
                this.texture.wrapT
              );
            },
            set: function (t) {
              console.warn(
                "THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."
              ),
                (this.texture.wrapT = t);
            },
          },
          magFilter: {
            get: function () {
              return (
                console.warn(
                  "THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."
                ),
                this.texture.magFilter
              );
            },
            set: function (t) {
              console.warn(
                "THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."
              ),
                (this.texture.magFilter = t);
            },
          },
          minFilter: {
            get: function () {
              return (
                console.warn(
                  "THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."
                ),
                this.texture.minFilter
              );
            },
            set: function (t) {
              console.warn(
                "THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."
              ),
                (this.texture.minFilter = t);
            },
          },
          anisotropy: {
            get: function () {
              return (
                console.warn(
                  "THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."
                ),
                this.texture.anisotropy
              );
            },
            set: function (t) {
              console.warn(
                "THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."
              ),
                (this.texture.anisotropy = t);
            },
          },
          offset: {
            get: function () {
              return (
                console.warn(
                  "THREE.WebGLRenderTarget: .offset is now .texture.offset."
                ),
                this.texture.offset
              );
            },
            set: function (t) {
              console.warn(
                "THREE.WebGLRenderTarget: .offset is now .texture.offset."
              ),
                (this.texture.offset = t);
            },
          },
          repeat: {
            get: function () {
              return (
                console.warn(
                  "THREE.WebGLRenderTarget: .repeat is now .texture.repeat."
                ),
                this.texture.repeat
              );
            },
            set: function (t) {
              console.warn(
                "THREE.WebGLRenderTarget: .repeat is now .texture.repeat."
              ),
                (this.texture.repeat = t);
            },
          },
          format: {
            get: function () {
              return (
                console.warn(
                  "THREE.WebGLRenderTarget: .format is now .texture.format."
                ),
                this.texture.format
              );
            },
            set: function (t) {
              console.warn(
                "THREE.WebGLRenderTarget: .format is now .texture.format."
              ),
                (this.texture.format = t);
            },
          },
          type: {
            get: function () {
              return (
                console.warn(
                  "THREE.WebGLRenderTarget: .type is now .texture.type."
                ),
                this.texture.type
              );
            },
            set: function (t) {
              console.warn(
                "THREE.WebGLRenderTarget: .type is now .texture.type."
              ),
                (this.texture.type = t);
            },
          },
          generateMipmaps: {
            get: function () {
              return (
                console.warn(
                  "THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."
                ),
                this.texture.generateMipmaps
              );
            },
            set: function (t) {
              console.warn(
                "THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."
              ),
                (this.texture.generateMipmaps = t);
            },
          },
        }),
        (Pf.prototype.load = function (t) {
          console.warn(
            "THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead."
          );
          const e = this,
            n = new Cf();
          return (
            n.load(t, function (t) {
              e.setBuffer(t);
            }),
            this
          );
        }),
        (Df.prototype.getData = function () {
          return (
            console.warn(
              "THREE.AudioAnalyser: .getData() is now .getFrequencyData()."
            ),
            this.getFrequencyData()
          );
        }),
        (Pr.prototype.updateCubeMap = function (t, e) {
          return (
            console.warn(
              "THREE.CubeCamera: .updateCubeMap() is now .update()."
            ),
            this.update(t, e)
          );
        }),
        (Pr.prototype.clear = function (t, e, n, i) {
          return (
            console.warn(
              "THREE.CubeCamera: .clear() is now .renderTarget.clear()."
            ),
            this.renderTarget.clear(t, e, n, i)
          );
        }),
        (pn.crossOrigin = void 0),
        (pn.loadTexture = function (t, e, n, i) {
          console.warn(
            "THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead."
          );
          const r = new Zp();
          r.setCrossOrigin(this.crossOrigin);
          const a = r.load(t, n, void 0, i);
          return e && (a.mapping = e), a;
        }),
        (pn.loadTextureCube = function (t, e, n, i) {
          console.warn(
            "THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead."
          );
          const r = new Jp();
          r.setCrossOrigin(this.crossOrigin);
          const a = r.load(t, n, void 0, i);
          return e && (a.mapping = e), a;
        }),
        (pn.loadCompressedTexture = function () {
          console.error(
            "THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead."
          );
        }),
        (pn.loadCompressedTextureCube = function () {
          console.error(
            "THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead."
          );
        });
      "undefined" !== typeof __THREE_DEVTOOLS__ &&
        __THREE_DEVTOOLS__.dispatchEvent(
          new CustomEvent("register", { detail: { revision: l } })
        ),
        "undefined" !== typeof window &&
          (window.__THREE__
            ? console.warn(
                "WARNING: Multiple instances of Three.js being imported."
              )
            : (window.__THREE__ = l));
      var um,
        dm,
        pm,
        fm = n("8a05"),
        mm = n("bc3a"),
        gm = n.n(mm);
      (function (t) {
        (t[(t["none"] = 0)] = "none"),
          (t[(t["forward"] = 1)] = "forward"),
          (t[(t["backward"] = 2)] = "backward"),
          (t[(t["leftToRight"] = 3)] = "leftToRight"),
          (t[(t["rightToLeft"] = 4)] = "rightToLeft");
      })(um || (um = {}));
      (function (t) {
        (t[(t["none"] = 0)] = "none"),
          (t[(t["vertical"] = 1)] = "vertical"),
          (t[(t["triangle"] = 2)] = "triangle"),
          (t[(t["triangleVertical"] = 3)] = "triangleVertical"),
          (t[(t["flat"] = 4)] = "flat");
      })(dm || (dm = {})),
        (function (t) {
          (t[(t["none"] = 0)] = "none"),
            (t[(t["concreteBase"] = 1)] = "concreteBase"),
            (t[(t["piles"] = 2)] = "piles"),
            (t[(t["pillarConcreating"] = 3)] = "pillarConcreating"),
            (t[(t["stripFoundation"] = 4)] = "stripFoundation");
        })(pm || (pm = {}));
      var vm = n("3452"),
        xm = n.n(vm),
        _m = n("eb11"),
        bm = n.n(_m),
        wm = {
          props: {
            allowedFarmTypes: {
              type: Array,
              default: () => [1, 2, 3, 4, 5, 6, 7],
            },
            farmType: {
              type: Object,
              default: function () {
                return {
                  id: 1,
                  caption: "ÐÑÐ¾ÑÐ½ÑÐ¹",
                  manipulationId: 102,
                  roofTypes: [0, 1, 2],
                };
              },
            },
            roofType: {
              type: Object,
              default: function () {
                return { id: 1, caption: "Ð¡Ð¾ÑÐ¾Ð²ÑÐ¹ Ð¿Ð¾Ð»Ð¸ÐºÐ°ÑÐ±Ð¾Ð½Ð°Ñ" };
              },
            },
            roofSubType: {
              type: Object,
              default: function () {
                return {
                  id: 1,
                  caption: "ÐÑÐµÐ¼Ð¸ÑÐ¼ 10Ð¼Ð¼, 1.1ÐºÐ³/Ð¼2",
                  thikness: 10,
                  width: 2130,
                  height: 12e3,
                  density: 1.1,
                  materialId: 101,
                  jointMaterialId: 152,
                  endMaterialId: 151,
                  roofRidgeMaterialId: 157,
                };
              },
            },
            desiredRoofColor: {
              type: Object,
              default: function () {
                return {
                  color: "#CD7F32",
                  correctedColor: "#8f6034",
                  caption: "Ð¯Ð½ÑÐ°ÑÑ",
                };
              },
            },
            showFarmTypes: { type: Boolean, default: !1 },
            fullMode: { type: Boolean, default: !1 },
            isMobile: { type: Boolean, default: !1 },
            desiredSlopeHeight: { type: Number, default: 0.8 },
            desiredWidth: { type: Number, default: 4.5 },
            desiredHeight: { type: Number, default: 6 },
            desiredServerUrl: {
              type: String,
              default: "https://calc.mosnavesi.ru",
            },
            desiredApiUrl: {
              type: String,
              default: "https://calc.mosnavesi.ru",
            },
          },
          data() {
            return {
              LathingType: dm,
              loading: !1,
              needReloadModel: !1,
              serverUrl: this.desiredServerUrl,
              apiUrl: this.desiredApiUrl,
              fullScreenMode: !1,
              extraParamsOpened: !1,
              width: this.desiredWidth,
              height: this.desiredHeight,
              useRoofShift: !1,
              roofShift: 0,
              hasPillars: !0,
              useDelivery: !0,
              useSheating: !0,
              renderTime: 0,
              clientHeight: this.desiredHeight,
              slopeHeight: this.desiredSlopeHeight,
              slopeHeight2: 0,
              groupReady: !1,
              model: null,
              remoteResponse: null,
              distance: 0,
              calculation: null,
              specification: null,
              order: { userName: null, phone: null, comment: null },
              clientCalculation: {
                calculationKey: null,
                folderId: 2,
                title: null,
                userName: null,
                phone: null,
                email: null,
                comment: null,
                regionName: null,
                defaultRegion: 0,
                needsConsultation: !0,
                url: null,
                calculationSum: null,
              },
              updatingCamera: !1,
              farmTypeLocal: this.farmType,
              roofTypeLocal: this.roofType,
              roofSubTypeLocal: this.roofSubType,
              sendingOrder: !1,
              sendingCalculation: !1,
              hasError: !1,
              error: null,
              orderComplete: !1,
              calculationComplete: !1,
              slopeDirection: um,
              x: 30,
              farmWidth: 250,
              farmMargin: 150,
              tieStepWidth: 400,
              ribStepWidth: 800,
              pillarHeight: 2.1,
              complexityPrice: 0,
              craneDays: 0,
              roofThickness: 10,
              roofMargin: 40,
              sideMargin: 40,
              arcShift: 30,
              arcProfileWidth: 4,
              arcProfileHeight: 2,
              arcCurveRatio: 0.21,
              color: "Ð±ÐµÐ»ÑÐ¹",
              roofColor: {
                color: "#CD7F32",
                correctedColor: "#8f6034",
                caption: "Ð¯Ð½ÑÐ°ÑÑ",
              },
              frameColor: { color: "#0f0f11", caption: "Ð§ÐµÑÐ½ÑÐ¹ (RAL 9005)" },
              installationType: {
                id: 1,
                caption: "ÐÐ° Ð±ÐµÑÐ¾Ð½Ð½Ð¾Ðµ Ð¾ÑÐ½Ð¾Ð²Ð°Ð½Ð¸Ðµ",
                manipulationId: 200,
                mountingTypeId: pm.concreteBase,
              },
              paintingType: {
                id: 1,
                caption: "ÐÑÑÐ½Ñ ÑÐ¼Ð°Ð»Ñ Slaven 3 Ð² 1",
                paintingMaterialId: 501,
                solventMaterialId: 500,
              },
              polycarbonHeight: 1,
              pillarSize: {
                id: 21,
                caption: "ÐÑÐ¾ÑÐ¸Ð»ÑÐ½Ð°Ñ ÑÑÑÐ±Ð° 80 x 80 x 3 Ð¼Ð¼ ",
                shortCaption: "80 x 80 x 3 Ð¼Ð¼ ",
                size: 8,
                width: 80,
                height: 80,
                thikness: 3,
                materialId: 51,
              },
              pillarArmingSize: {
                id: 21,
                caption: "ÐÑÐ¾ÑÐ¸Ð»ÑÐ½Ð°Ñ ÑÑÑÐ±Ð° 80 x 40 x 2 Ð¼Ð¼ ",
                shortCaption: "80 x 40 x 2 Ð¼Ð¼ ",
                size: 8,
                width: 80,
                height: 40,
                thikness: 2,
                materialId: 53,
              },
              usePillarArming: !1,
              pillarArmingRows: 1,
              pillarArmingOffset: 0.5,
              frameSize: {
                id: 22,
                caption: "ÐÑÐ¾ÑÐ¸Ð»ÑÐ½Ð°Ñ ÑÑÑÐ±Ð° 40 x 40 x 2 Ð¼Ð¼",
                shortCaption: "40 x 40 x 2 Ð¼Ð¼",
                width: 40,
                height: 40,
                thikness: 2,
                materialId: 22,
              },
              frameBaseStrengthening: !1,
              ribSize: {
                id: 1,
                caption: "ÐÑÐ¾ÑÐ¸Ð»ÑÐ½Ð°Ñ ÑÑÑÐ±Ð° 40 x 20 x 1.5 Ð¼Ð¼",
                shortCaption: "40 x 20 x 1.5 Ð¼Ð¼",
                width: 40,
                height: 20,
                thikness: 1.5,
                materialId: 11,
              },
              channelSize: { id: 4, caption: "Ð¨Ð²ÐµÐ»Ð»ÐµÑ Ð20", materialId: 81 },
              tieSize: {
                id: 1,
                caption: "ÐÑÐ¾ÑÐ¸Ð»ÑÐ½Ð°Ñ ÑÑÑÐ±Ð° 40 x 20 x 1.5 Ð¼Ð¼",
                shortCaption: "40 x 20 x 1.5 Ð¼Ð¼",
                width: 40,
                height: 20,
                thikness: 1.5,
                materialId: 11,
              },
              pillarInstallationType: 0,
              concreteDepth: 1.2,
              pillarStepWidth: 2,
              farmStepWidth: 1.5,
              cubes: [],
              lagStepWidth: 40,
              discount: 0.1,
              mountingDiscount: 0.2,
              lathingType: { id: dm.triangle, caption: "Ð¢ÑÐµÑÐ³Ð¾Ð»ÑÐ½Ð°Ñ" },
              lightRadius: 15e4,
              lightIntencity: 0.25,
              lightCount: 6,
              lightHeight: 0,
              materialBalance: [],
              currentConfigurationId: 1,
              sizingLayers: {
                showCanopyBounds: !1,
                showFarmSteps: !1,
                showPillarSteps: !1,
                showPillarHeights: !1,
              },
              pillarsMarginBack: 300,
              pillarsMarginFront: 300,
              pillarInnerRows: 0,
              flatProfileCount: 3,
              farmMarginBackWidth: 150,
              farmMarginFrontWidth: 150,
              config: null,
              camera: null,
              scene: null,
              group: null,
              cameraConfig: {
                cameraX: 0,
                cameraY: 5e3,
                cameraZ: 1e4,
                cameraZoom: 45,
              },
              sheathing: {
                enabled: !1,
                tieRows: 2,
                tieSize: {
                  id: 1,
                  caption: "ÐÑÐ¾ÑÐ¸Ð»ÑÐ½Ð°Ñ ÑÑÑÐ±Ð° 40 x 20 x 1.5 Ð¼Ð¼",
                  shortCaption: "40 x 20 x 1.5 Ð¼Ð¼",
                  width: 40,
                  height: 20,
                  thikness: 1.5,
                  materialId: 11,
                },
                marginBottom: 0,
                type: { id: 1, caption: "Ð¡Ð¾ÑÐ¾Ð²ÑÐ¹ Ð¿Ð¾Ð»Ð¸ÐºÐ°ÑÐ±Ð¾Ð½Ð°Ñ" },
                subType: {
                  id: 1,
                  caption: "ÐÑÐµÐ¼Ð¸ÑÐ¼ 10Ð¼Ð¼, 1.1ÐºÐ³/Ð¼2",
                  thikness: 10,
                  width: 2130,
                  height: 12e3,
                  density: 1.1,
                  materialId: 101,
                  jointMaterialId: 152,
                  endMaterialId: 151,
                  roofRidgeMaterialId: 157,
                },
              },
            };
          },
          computed: {
            farmRadius() {
              var t, e, n;
              return null === (t = this.model) ||
                void 0 === t ||
                null === (e = t.roof) ||
                void 0 === e ||
                null === (n = e.farms[0]) ||
                void 0 === n
                ? void 0
                : n.topFrame.radius;
            },
            roofFarmWidth() {
              var t, e, n;
              return null === (t = this.model) ||
                void 0 === t ||
                null === (e = t.roof) ||
                void 0 === e ||
                null === (n = e.farms[0]) ||
                void 0 === n
                ? void 0
                : n.width;
            },
            baseWidth() {
              var t, e, n;
              return null === (t = this.model) ||
                void 0 === t ||
                null === (e = t.roof) ||
                void 0 === e ||
                null === (n = e.farms[0]) ||
                void 0 === n
                ? void 0
                : n.baseWidth;
            },
            topFrameLength() {
              var t, e, n;
              return null === (t = this.model) ||
                void 0 === t ||
                null === (e = t.roof) ||
                void 0 === e ||
                null === (n = e.farms[0]) ||
                void 0 === n
                ? void 0
                : n.topFrame.extrudePath.getLength();
            },
            bottomFrameLength() {
              var t, e, n;
              return null === (t = this.model) ||
                void 0 === t ||
                null === (e = t.roof) ||
                void 0 === e ||
                null === (n = e.farms[0]) ||
                void 0 === n
                ? void 0
                : n.bottomFrame.extrudePath.getLength();
            },
            doubleShedCanopyFarm() {
              var t, e, n, i;
              return (
                null === (t = this.model) ||
                  void 0 === t ||
                  null === (e = t.roof) ||
                  void 0 === e ||
                  e.farms[0],
                null === (n = this.model) ||
                void 0 === n ||
                null === (i = n.roof) ||
                void 0 === i
                  ? void 0
                  : i.farms[0]
              );
            },
            slopeDegree() {
              let t =
                (Number(1e3 * this.width) +
                  this.pillarSize.width +
                  Number(this.farmMargin)) /
                1e3;
              switch (this.farmTypeLocal.id) {
                case 4:
                  return (
                    (180 *
                      Math.atan((this.slopeHeight - this.slopeHeight2) / t)) /
                    Math.PI
                  ).toFixed(2);
                case 6:
                case 7:
                  return (
                    (180 * Math.atan(this.slopeHeight / (t / 2))) /
                    Math.PI
                  ).toFixed(2);
                default:
                  return (
                    (180 * Math.atan(this.slopeHeight / t)) /
                    Math.PI
                  ).toFixed(2);
              }
            },
            area() {
              return this.width * this.height;
            },
            canSendOrder() {
              return (
                this.order.phone && this.order.userName && !this.sendingOrder
              );
            },
            canSendCalculation() {
              var t;
              return (
                this.clientCalculation.phone &&
                this.clientCalculation.phone.length > 14 &&
                this.clientCalculation.userName &&
                (0 == this.clientCalculation.defaultRegion ||
                  (null === (t = this.clientCalculation.regionName) ||
                  void 0 === t
                    ? void 0
                    : t.replace(/\s/g, "").length) > 0) &&
                !this.sendingCalculation
              );
            },
            longTieCount() {
              var t, e, n, i, r, a, o, s, c;
              switch (this.farmTypeLocal.id) {
                case 7:
                case 6:
                  return (
                    (null === (t = this.model) ||
                    void 0 === t ||
                    null === (e = t.roof) ||
                    void 0 === e ||
                    null === (n = e.tiesLeft) ||
                    void 0 === n
                      ? void 0
                      : n.length) +
                    (null === (i = this.model) ||
                    void 0 === i ||
                    null === (r = i.roof) ||
                    void 0 === r ||
                    null === (a = r.tiesRight) ||
                    void 0 === a
                      ? void 0
                      : a.length)
                  );
                default:
                  return null === (o = this.model) ||
                    void 0 === o ||
                    null === (s = o.roof) ||
                    void 0 === s ||
                    null === (c = s.ties) ||
                    void 0 === c
                    ? void 0
                    : c.length;
              }
            },
            pillarHeight2() {
              return (
                parseFloat(this.pillarHeight) + parseFloat(this.slopeHeight)
              );
            },
            horizontalTubeCount() {
              return 2;
            },
            pillarCount() {
              var t;
              const e =
                null === (t = this.model) || void 0 === t
                  ? void 0
                  : t.pillars.length;
              return e;
            },
            farmCount() {
              let t = 1e3 * this.height,
                e = 1e3 * this.farmStepWidth,
                n = Math.floor(t / e) + 1;
              return t % e > 1 && (n += 1), n;
            },
            cameraX: {
              get: function () {
                return this.cameraConfig.cameraX;
              },
              set: function (t) {
                (this.cameraConfig.cameraX = parseInt(t)),
                  (this.camera.position.x = this.cameraConfig.cameraX),
                  this.animate();
              },
            },
            cameraY: {
              get: function () {
                return this.cameraConfig.cameraY;
              },
              set: function (t) {
                (this.cameraConfig.cameraY = parseInt(t)),
                  (this.camera.position.y = this.cameraConfig.cameraY),
                  this.animate();
              },
            },
            cameraZ: {
              get: function () {
                return this.cameraConfig.cameraZ;
              },
              set: function (t) {
                (this.cameraConfig.cameraZ = parseInt(t)),
                  (this.camera.position.z = this.cameraConfig.cameraZ),
                  this.animate();
              },
            },
            cameraZoom: {
              get: function () {
                return this.cameraConfig.cameraZoom;
              },
              set: function (t) {
                (this.cameraConfig.cameraZoom = parseInt(t)), this.render();
              },
            },
            rotate: {
              get: function () {
                return this.rotate;
              },
              set: function (t) {
                (this.rotate = t), t && setTimeout(this.rotateScene, 10);
              },
            },
            pillarLength() {
              return (
                (this.pillarCount / 2) * this.pillarHeight +
                (this.pillarCount / 2) * this.pillarHeight2 +
                2 * this.height +
                (2 === this.installationType.id ? 1.2 * this.pillarCount : 0)
              );
            },
            longTieLength() {
              let t = new vd();
              t.moveTo(
                (100 * -this.width) / 2 -
                  this.arcShift / 2 -
                  this.arcProfileWidth / 2,
                0
              ),
                t.quadraticCurveTo(
                  0,
                  2 * this.arcCurveRatio * this.width * 100 +
                    this.arcProfileHeight,
                  (100 * this.width) / 2 +
                    this.arcShift / 2 +
                    this.arcProfileWidth / 2,
                  0
                );
              let e = t.curves[0],
                n = e.getLength(),
                i = this.getLagCount(n, this.lagStepWidth),
                r = this.arcShift / 100 / Math.sin(Math.PI / 4);
              return (
                i * this.height +
                this.farmCount * (n / 100) * 2 +
                r * i * 2 * this.farmCount
              );
            },
          },
          async mounted() {
            await this.loadConfiguration(), await this.loadCalculation();
            new Zp();
            this.loadTextures(),
              (window.onresize = () => {
                (this.clientWidth == this.$refs.canvas.clientWidth &&
                  this.clientHeight == this.$refs.canvas.clientHeight) ||
                  ((this.clientWidth = this.$refs.canvas.clientWidth),
                  (this.clientHeight = this.$refs.canvas.clientHeight),
                  this.renderer &&
                    this.scene &&
                    (this.renderer.setSize(this.clientWidth, this.clientHeight),
                    (this.camera.aspect = this.clientWidth / this.clientHeight),
                    this.camera.updateProjectionMatrix(),
                    this.prepareBackground(),
                    this.animate()));
              }),
              this.clientCalculation.calculationKey
                ? this.setPredefinedConfiguration(
                    this.config.predefinedConfigurations.find(
                      (t) => 100 == t.id
                    ),
                    !0
                  )
                : (1 != this.roofType.id &&
                    this.setRoofType(this.roofTypeLocal, !1),
                  this.setPredefinedConfiguration(
                    this.config.predefinedConfigurations.find((t) => 1 == t.id),
                    !0
                  ));
          },
          methods: {
            async loadConfiguration() {
              let t = await gm.a.get(this.serverUrl + "/config");
              this.config = t.data;
            },
            async loadCalculation() {
              let t = new URLSearchParams(window.location.search);
              if (t.has("key")) {
                this.clientCalculation.calculationKey = t.get("key");
                let e = await gm.a.get(
                  `${this.apiUrl}/api/v1/clientcalculation/${t.get("key")}`
                );
                Object.assign(this, e.data.dataJson.config);
              }
            },
            setFullScreenMode(t) {
              (this.fullScreenMode = t),
                o.a.nextTick(() => {
                  (this.clientWidth == this.$refs.canvas.clientWidth &&
                    this.clientHeight == this.$refs.canvas.clientHeight) ||
                    ((this.clientWidth = this.$refs.canvas.clientWidth),
                    (this.clientHeight = this.$refs.canvas.clientHeight),
                    this.renderer &&
                      (this.renderer.setSize(
                        this.clientWidth,
                        this.clientHeight
                      ),
                      (this.camera.aspect =
                        this.clientWidth / this.clientHeight),
                      this.camera.updateProjectionMatrix(),
                      this.prepareBackground(),
                      this.animate()));
                });
            },
            prepareBackground() {
              var t = 1 / (this.clientWidth / this.clientHeight);
              (this.scene.background.offset.x = t > 1 ? (1 - 1 / t) / 2 : 0),
                (this.scene.background.offset.y = t > 1 ? 0 : (1 - t) / 2),
                (this.scene.background.repeat.x = t > 1 ? 1 / t : 1),
                (this.scene.background.repeat.y = t > 1 ? 1 : t);
            },
            loadGroup() {
              (this.loading = !0),
                o.a.nextTick(() => {
                  this.group.add(this.model.get3DObject()),
                    this.scene.add(this.group),
                    (this.loading = !1),
                    (this.groupReady = !1),
                    this.animate();
                });
            },
            async loadTextures() {
              const t = new Zp();
              var e = [];
              for (var n in this.config.textures)
                e.push(
                  new Promise((e, i) => {
                    var r = this.config.textures[n],
                      a = r.url;
                    t.load(
                      a,
                      (t) => {
                        (r.texture = t), r.texture instanceof mn && e(r);
                      },
                      (t) => {},
                      (t) => {
                        i(
                          new Error(
                            t +
                              "An error occurred loading while loading: " +
                              r.url
                          )
                        );
                      }
                    );
                  })
                );
              Promise.all(e).then((t) => {
                this.render(), this.groupReady && this.loadGroup();
              });
            },
            roofShiftChanged() {
              0 == this.roofShift &&
                this.useRoofShift &&
                (this.roofShift = this.width / 2),
                this.render();
            },
            setInstallationType(t, e) {
              (t.preventDefault = !0),
                (this.installationType = e),
                this.render();
            },
            async parseRemoteModel(t, e, n) {
              var i;
              let r = null;
              return (
                (null === (i = t.children) || void 0 === i
                  ? void 0
                  : i.length) > 0
                  ? ((r = new ph()),
                    t.children.forEach((t) => {
                      this.parseRemoteModel(t, e, r);
                    }))
                  : ((r = e.parse(t.data)), n && n.add(r)),
                r.position.set(t.position.x, t.position.y, t.position.z),
                r.rotation.set(t.rotation.x, t.rotation.y, t.rotation.z),
                r
              );
            },
            async getRemoteModel() {
              this.loading = !0;
              const t = await gm.a.post(this.serverUrl, {
                version: 2,
                product: "Canopy",
                farmType: this.farmTypeLocal,
                width: 1e3 * this.width,
                height: 1e3 * this.height,
                area: this.area,
                useRoofShift: this.useRoofShift,
                roofShift: 1e3 * this.roofShift,
                lathingType: this.lathingType,
                roofType: this.roofTypeLocal,
                roofSubType: this.roofSubTypeLocal,
                pillarHeight: 1e3 * this.pillarHeight,
                pillarHeight2: 1e3 * this.pillarHeight2,
                hasPillars: this.hasPillars,
                pillarSize: this.pillarSize,
                frameSize: this.frameSize,
                tieSize: this.tieSize,
                ribSize: this.ribSize,
                slopeHeight: 1e3 * this.slopeHeight,
                slopeHeight2: 1e3 * this.slopeHeight2,
                roofThickness: this.roofThickness,
                roofMargin: this.roofMargin,
                sideMargin: this.sideMargin,
                arcShift: this.arcShift,
                arcProfileWidth: this.arcProfileWidth,
                arcProfileHeight: this.arcProfileHeight,
                arcCurveRatio: this.arcCurveRatio,
                roofColor: this.roofColor,
                frameColor: this.frameColor,
                pillarStepWidth: 1e3 * this.pillarStepWidth,
                tieStepWidth: this.tieStepWidth,
                farmStepWidth: 1e3 * this.farmStepWidth,
                ribStepWidth: this.ribStepWidth,
                installationType: this.installationType,
                useDelivery: this.useDelivery,
                sizingLayers: this.sizingLayers,
                sizingConfig: this.config.sizingConfig,
                pillarArmingSize: this.pillarArmingSize,
                concreteDepth: 1e3 * this.concreteDepth,
                farmHeight: this.farmWidth,
                farmMargin: this.farmMargin,
                pillarInnerRows: this.pillarInnerRows,
                channelSize: this.channelSize,
                pillarsMarginBack: this.pillarsMarginBack,
                pillarsMarginFront: this.pillarsMarginFront,
                paintingType: this.paintingType,
                useDelivery: this.useDelivery,
                distance: this.distance,
                mountingDiscount: this.mountingDiscount,
                usePillarArming: this.usePillarArming,
                pillarArmingRows: this.pillarArmingRows,
                pillarArmingOffset: 1e3 * this.pillarArmingOffset,
                flatProfileCount: this.flatProfileCount,
                farmMarginBackWidth: this.farmMarginBackWidth,
                farmMarginFrontWidth: this.farmMarginFrontWidth,
                craneDays: this.craneDays,
                complexityPrice: this.complexityPrice,
                sheathing: this.sheathing,
              });
              if (this.needReloadModel)
                return (this.needReloadModel = !1), void this.getRemoteModel();
              const e = new bf(),
                n = JSON.parse(bm.a.decompress(t.data.data));
              this.remoteResponse = n;
              let i = window.location.origin;
              n.mesh.geometries.forEach((t) => {
                t.uuid = xm.a.AES.decrypt(t.uuid, i).toString(xm.a.enc.Utf8);
              }),
                e.parse(n.mesh, (t) => {
                  let e = t.getObjectByName("base"),
                    i = t.getObjectByName("soil"),
                    r = this.config;
                  if (
                    (this.installationType.mountingTypeId ==
                      pm.pillarConcreating &&
                      t.traverse(function (t) {
                        "ConcretePillar" == t.userData.className &&
                          t.material.forEach((t) => {
                            (t.map = r.textures.pillarConcrete.texture),
                              (t.needsUpdate = !0);
                          });
                      }),
                    e.material.forEach((t) => {
                      (t.map = this.config.textures.concrete.texture),
                        (t.needsUpdate = !0);
                    }),
                    i)
                  ) {
                    let t = 1e3 * this.width + 1e3,
                      e = 1e3 * this.height + 500,
                      n = 600,
                      r = this.config.textures.soil.texture;
                    (r.repeat = new $e(1, 1)),
                      (r.repeat = new $e(t / e, 1)),
                      (r.center = new $e(0.5, 0.5));
                    let a = r.clone();
                    (a.needsUpdate = !0),
                      (a.repeat = new $e(n / e, 1)),
                      (a.center = new $e(0.5, 0.5));
                    let o = r.clone();
                    (o.needsUpdate = !0),
                      (o.repeat = new $e(1, n / t)),
                      (o.center = new $e(0.5, 0.5)),
                      (i.material[0].map = a),
                      (i.material[1].map = a),
                      (i.material[2].map = o),
                      (i.material[3].map = o),
                      (i.material[4].map = r),
                      (i.material[5].map = r),
                      i.material.forEach((t) => {
                        t.needsUpdate = !0;
                      });
                  }
                  (this.calculation = n.calculation),
                    (this.specification = n.specification),
                    this.scene.remove(this.group),
                    (this.group = new ph()),
                    this.scene.add(this.group),
                    this.group.add(t),
                    (this.loading = !1),
                    this.animate();
                }),
                (this.loading = !1);
            },
            async sendOrder() {
              try {
                var t, e, n, i;
                (this.hasError = !1),
                  (this.sendingOrder = !0),
                  (this.orderComplete = !1);
                await gm.a.post("/api/v1/clientweborder/", {
                  ...this.order,
                  dataJson: {
                    version: 2,
                    product: "ÐÐ°Ð²ÐµÑ",
                    farmType: this.farmType,
                    width: this.width,
                    height: this.height,
                    farmTypeLocal: this.farmTypeLocal,
                    lathingType: this.lathingType,
                    roofType: this.roofTypeLocal,
                    roofSubType: this.roofSubTypeLocal,
                    square: (this.width * this.height).toFixed(2),
                    pillarHeight: this.pillarHeight,
                    pillarHeight2: this.pillarHeight2,
                    pillarSize: this.pillarSize,
                    frameSize: this.frameSize,
                    tieSize: this.tieSize,
                    ribSize: this.ribSize,
                    slopeHeight: this.slopeHeight,
                    slopeHeight2: this.slopeHeight2,
                    roofThickness: this.roofThickness,
                    roofMargin: this.roofMargin,
                    sideMargin: this.sideMargin,
                    arcShift: this.arcShift,
                    arcProfileWidth: this.arcProfileWidth,
                    arcProfileHeight: this.arcProfileHeight,
                    arcCurveRatio: this.arcCurveRatio,
                    roofColor: this.roofColor,
                    frameColor: this.frameColor,
                    pillarStepWidth: this.pillarStepWidth,
                    tieStepWidth: this.tieStepWidth,
                    farmStepWidth: this.farmStepWidth,
                    lagStepWidth: this.lagStepWidth,
                    installationType: this.installationType,
                    calculatedPrice:
                      null === (t = this.calculation) || void 0 === t
                        ? void 0
                        : t.calculatedPrice,
                    calculatedDiscount:
                      null === (e = this.calculation) || void 0 === e
                        ? void 0
                        : e.calculatedDiscount,
                    finalPrice:
                      (null === (n = this.calculation) || void 0 === n
                        ? void 0
                        : n.calculatedPrice) -
                      (null === (i = this.calculation) || void 0 === i
                        ? void 0
                        : i.calculatedDiscount),
                    calculation: this.calculation.groups,
                    useDelivery: this.useDelivery,
                  },
                });
                (this.orderComplete = !0),
                  ym(67222159, "reachGoal", "webOrder");
              } catch (r) {
                (this.hasError = !0), (this.error = r);
              } finally {
                this.sendingOrder = !1;
              }
            },
            async trySaveCalculation() {
              if (null != this.clientCalculation.calculationKey)
                await this.sendCalculation(),
                  $("#calculationModal").modal("show");
              else {
                try {
                  ym(67222159, "reachGoal", "calcTry");
                } finally {
                }
                (this.calculationComplete = !1),
                  $("#calculationModal").modal("show");
              }
            },
            async sendCalculation() {
              try {
                (this.hasError = !1),
                  (this.sendingCalculation = !0),
                  (this.calculationComplete = !1),
                  (this.clientCalculation.calculationSum =
                    this.calculation.finalPrice),
                  (this.clientCalculation.regionName =
                    0 == this.clientCalculation.defaultRegion
                      ? "ÐÐ¾ÑÐºÐ²Ð° Ð¸ Ð¾Ð±Ð»Ð°ÑÑÑ"
                      : this.clientCalculation.regionName),
                  (this.clientCalculation.title = `ÐÐ°Ð²ÐµÑ ${
                    this.farmTypeLocal.caption
                  }, ${this.width}x${
                    this.height
                  }, ${this.calculation.finalPrice.toFixed(0)}`),
                  (this.clientCalculation.url =
                    "https://mosnavesi.ru/calc/?key={0}");
                const t = await gm.a.post(
                  this.apiUrl + "/api/v1/clientcalculation/",
                  {
                    ...this.clientCalculation,
                    dataJson: {
                      config: {
                        version: 2,
                        product: "Canopy",
                        width: this.width,
                        height: this.height,
                        farmTypeLocal: this.farmTypeLocal,
                        lathingType: this.lathingType,
                        roofTypeLocal: this.roofTypeLocal,
                        roofSubTypeLocal: this.roofSubTypeLocal,
                        pillarHeight: this.pillarHeight,
                        pillarSize: this.pillarSize,
                        frameSize: this.frameSize,
                        tieSize: this.tieSize,
                        ribSize: this.ribSize,
                        slopeHeight: this.slopeHeight,
                        slopeHeight2: this.slopeHeight2,
                        roofThickness: this.roofThickness,
                        roofMargin: this.roofMargin,
                        sideMargin: this.sideMargin,
                        arcShift: this.arcShift,
                        arcProfileWidth: this.arcProfileWidth,
                        arcProfileHeight: this.arcProfileHeight,
                        arcCurveRatio: this.arcCurveRatio,
                        roofColor: this.roofColor,
                        frameColor: this.frameColor,
                        pillarStepWidth: this.pillarStepWidth,
                        tieStepWidth: this.tieStepWidth,
                        farmStepWidth: this.farmStepWidth,
                        ribStepWidth: this.ribStepWidth,
                        installationType: this.installationType,
                        useDelivery: this.useDelivery,
                        sizingLayers: this.sizingLayers,
                        sizingConfig: this.config.sizingConfig,
                        pillarArmingSize: this.pillarArmingSize,
                        concreteDepth: this.concreteDepth,
                        farmHeight: this.farmWidth,
                        farmMargin: this.farmMargin,
                        pillarInnerRows: this.pillarInnerRows,
                        channelSize: this.channelSize,
                        pillarsMarginBack: this.pillarsMarginBack,
                        pillarsMarginFront: this.pillarsMarginFront,
                        paintingType: this.paintingType,
                        useDelivery: this.useDelivery,
                        distance: this.distance,
                        mountingDiscount: this.mountingDiscount,
                        usePillarArming: this.usePillarArming,
                        pillarArmingRows: this.pillarArmingRows,
                        pillarArmingOffset: this.pillarArmingOffset,
                        flatProfileCount: this.flatProfileCount,
                        farmMarginBackWidth: this.farmMarginBackWidth,
                        farmMarginFrontWidth: this.farmMarginFrontWidth,
                        craneDays: this.craneDays,
                        complexityPrice: this.complexityPrice,
                        sheathing: this.sheathing,
                      },
                    },
                  }
                );
                (this.sendingCalculation = !1),
                  (this.calculationComplete = !0),
                  (this.clientCalculation.calculationKey =
                    t.data.calculationKey);
                try {
                  ym(67222159, "reachGoal", "clientCalculation");
                } catch {}
                let e = new URLSearchParams(window.location.search);
                e.has("key") ||
                  window.location.replace(
                    `${window.location.href.split("?")[0]}?key=${
                      this.clientCalculation.calculationKey
                    }`
                  );
              } catch (t) {
                (this.hasError = !0), (this.error = t);
              } finally {
                this.sendingCalculation = !1;
              }
            },
            rotateScene() {
              this.group &&
                ((this.group.rotation.y += 0.01),
                this.renderer.render(this.scene, this.camera),
                this.rotate && setTimeout(this.rotateScene, 10));
            },
            setPillarSize(t) {
              (this.pillarSize = t), this.render();
            },
            setPillarArmingSize(t) {
              (this.pillarArmingSize = t), this.render();
            },
            setFrameSize(t) {
              (this.frameSize = t), this.render();
            },
            setRibSize(t) {
              (this.ribSize = t), this.render();
            },
            setChannelSize(t) {
              (this.channelSize = t), this.render();
            },
            setTieSize(t) {
              (this.tieSize = t), this.render();
            },
            setRoofColor(t) {
              (this.roofColor = t), this.render();
            },
            setframeColor(t) {
              (this.frameColor = t), this.render();
            },
            setRoofType(t, e = !0) {
              var n, i;
              this.roofTypeLocal = { id: t.id, caption: t.caption };
              let r =
                null ===
                  (n = this.config.roofTypes.find((e) => e.id == t.id)) ||
                void 0 === n
                  ? void 0
                  : n.types[0];
              (this.roofSubTypeLocal =
                (null === (i = t.types) || void 0 === i ? void 0 : i.length) > 0
                  ? t.types[0]
                  : r),
                this.roofSubTypeLocal
                  ? ((this.config.roofColors = this.config.materials.find(
                      (t) => t.id == this.roofSubTypeLocal.materialId
                    ).colors),
                    (this.roofColor = this.config.roofColors[0]))
                  : (this.roofColors = []),
                t.recommendedTieStepWidth &&
                  (this.tieStepWidth = t.recommendedTieStepWidth),
                e && this.render();
            },
            async setRoofSubType(t) {
              (this.roofSubTypeLocal = t),
                this.roofSubTypeLocal
                  ? ((this.config.roofColors = this.config.materials.find(
                      (t) => t.id == this.roofSubTypeLocal.materialId
                    ).colors),
                    (this.roofColor = this.config.roofColors[0]))
                  : (this.config.roofColors = []),
                this.render();
            },
            setPaintingType(t) {
              (this.paintingType = t), this.render();
            },
            setFarmType(t) {
              var e;
              [3, 4].includes(this.roofTypeLocal.id) &&
                [1, 2].includes(t.id) &&
                this.setRoofType(this.config.roofTypes[1]),
                (this.farmTypeLocal = t),
                (this.ribStepWidth =
                  null !== (e = t.defaultRibStepWidth) && void 0 !== e
                    ? e
                    : this.ribStepWidth),
                o.a.nextTick(() => {
                  this.render();
                });
            },
            setLathingType(t) {
              (this.lathingType = t),
                o.a.nextTick(() => {
                  this.render();
                });
            },
            setPredefinedConfiguration(t, e) {
              switch (t.id) {
                case 100:
                  this.currentConfigurationId = t.id;
                  break;
                default:
                  (this.tieStepWidth = t.tieStepWidth),
                    (this.pillarStepWidth = t.pillarStepWidth),
                    (this.arcCurveRatio = t.arcCurveRatio),
                    (this.lathingType = this.config.lathingTypes.find(
                      (e) => e.id == t.lathingTypeId
                    ));
              }
              (this.currentConfigurationId = t.id),
                e ||
                  o.a.nextTick(() => {
                    this.render();
                  });
            },
            updateCamera() {
              (this.updatingCamera = !0),
                (this.cameraX = this.camera.position.x),
                (this.cameraY = this.camera.position.y),
                (this.cameraZ = this.camera.position.z),
                (this.cameraZoom = this.camera.fov),
                (this.updatingCamera = !1);
            },
            animate() {
              this.renderer.render(this.scene, this.camera);
            },
            prepareScene() {
              (this.$refs.canvas.innerHTML = ""),
                (this.clientWidth = this.$refs.canvas.clientWidth),
                (this.clientHeight = this.$refs.canvas.clientHeight),
                (this.scene = new Sh()),
                (this.scene.background =
                  this.config.textures.background.texture);
              var t = 1 / (this.clientWidth / this.clientHeight);
              (this.scene.background.offset.x = t > 1 ? (1 - 1 / t) / 2 : 0),
                (this.scene.background.offset.y = t > 1 ? 0 : (1 - t) / 2),
                (this.scene.background.repeat.x = t > 1 ? 1 / t : 1),
                (this.scene.background.repeat.y = t > 1 ? 1 : t),
                (this.group = new ph());
              let e = this.lightCount;
              for (let n = 0; n < e; n++) {
                let t = new df(16645629, this.lightIntencity);
                t.position
                  .set(
                    this.lightRadius * Math.cos((2 * n * Math.PI) / e),
                    this.lightHeight,
                    this.lightRadius * Math.sin((2 * n * Math.PI) / e)
                  )
                  .normalize(),
                  t.lookAt(
                    0 * Math.cos((2 * n * Math.PI) / e),
                    0,
                    0 * Math.sin((2 * n * Math.PI) / e)
                  ),
                  this.scene.add(t);
              }
              (this.ambientLight = new pf(4210752)),
                this.scene.add(this.ambientLight),
                (this.camera = new Cr(
                  this.cameraZoom,
                  this.clientWidth / this.clientHeight,
                  10,
                  2e5
                )),
                null == this.renderer &&
                  ((this.renderer = new _h({
                    antialias: !0,
                    preserveDrawingBuffer: !0,
                    alfa: !0,
                    localClippingEnabled: !0,
                  })),
                  this.renderer.setClearColor(0, 0),
                  this.renderer.setSize(this.clientWidth, this.clientHeight),
                  (this.renderer.localClippingEnabled = !0)),
                this.showAxes &&
                  !this.axesHelper &&
                  ((this.axesHelper = new lm(5e3)),
                  this.scene.add(this.axesHelper)),
                (this.camera.position.x = this.cameraX),
                (this.camera.position.y = this.cameraY),
                (this.camera.position.z = this.cameraZ),
                (this.controls = new fm["OrbitControls"](
                  this.camera,
                  this.renderer.domElement
                )),
                (this.controls.enableZoom = !0),
                this.controls.addEventListener("change", this.animate),
                this.$refs.canvas.append(this.renderer.domElement);
            },
            render() {
              null == this.scene && this.prepareScene(),
                this.timeout &&
                  (clearTimeout(this.timeout), (this.timeout = null)),
                this.loading
                  ? (this.needReloadModel = !0)
                  : (this.timeout = setTimeout(() => {
                      this.getRemoteModel(), !this.isMobile && this.groupReady;
                    }, 1e3));
            },
            saveFile(t, e) {
              var n = document.createElement("a");
              "string" === typeof n.download
                ? (document.body.appendChild(n),
                  (n.download = e),
                  (n.href = t),
                  n.click(),
                  document.body.removeChild(n))
                : location.replace(uri);
            },
            saveAsImage() {
              var t;
              try {
                var e = "image/jpeg",
                  n = "image/octet-stream";
                this.$refs.canvas.clientWidth, this.$refs.canvas.clientHeight;
                (t = this.renderer.domElement.toDataURL(e)),
                  this.saveFile(
                    t.replace(e, n),
                    `ÐÐ°Ð²ÐµÑ ${this.farmTypeLocal.caption} ${this.width}x${this.height} ÐºÐ¾Ð¼Ð¿Ð°Ð½Ð¸Ð¸ ÐÐ¾ÑÐ½Ð°Ð²ÐµÑÑ ÑÐµÐ»ÐµÑÐ¾Ð½ 8(495)151-68-01.jpg`
                  ),
                  ym(67222159, "reachGoal", "screenshot");
              } catch (i) {
                return void console.log(i);
              }
            },
          },
        },
        Mm = wm;
      n("d396");
      function Sm(t, e, n, i, r, a, o, s) {
        var c,
          l = "function" === typeof t ? t.options : t;
        if (
          (e && ((l.render = e), (l.staticRenderFns = n), (l._compiled = !0)),
          i && (l.functional = !0),
          a && (l._scopeId = "data-v-" + a),
          o
            ? ((c = function (t) {
                (t =
                  t ||
                  (this.$vnode && this.$vnode.ssrContext) ||
                  (this.parent &&
                    this.parent.$vnode &&
                    this.parent.$vnode.ssrContext)),
                  t ||
                    "undefined" === typeof __VUE_SSR_CONTEXT__ ||
                    (t = __VUE_SSR_CONTEXT__),
                  r && r.call(this, t),
                  t &&
                    t._registeredComponents &&
                    t._registeredComponents.add(o);
              }),
              (l._ssrRegister = c))
            : r &&
              (c = s
                ? function () {
                    r.call(
                      this,
                      (l.functional ? this.parent : this).$root.$options
                        .shadowRoot
                    );
                  }
                : r),
          c)
        )
          if (l.functional) {
            l._injectStyles = c;
            var h = l.render;
            l.render = function (t, e) {
              return c.call(e), h(t, e);
            };
          } else {
            var u = l.beforeCreate;
            l.beforeCreate = u ? [].concat(u, c) : [c];
          }
        return { exports: t, options: l };
      }
      var Em = Sm(Mm, s, c, !1, null, null, null),
        Tm = Em.exports;
      function Am(t) {
        t.component("calc", Tm),
          t.directive("calcphone", {
            bind(t) {
              t.oninput = function (e) {
                if (!e.isTrusted) return;
                ("7" != this.value && "+77" != this.value) || (this.value = "");
                let n = this.value
                  .replace(/\+7/, "")
                  .replace(/\D/g, "")
                  .match(/(\d{0,3})?(\d{0,3})?(\d{0,4})?/);
                (this.value =
                  "+7" +
                  (n[1] ? "(" + n[1] : "") +
                  (n[2] ? ") " + n[2] : "") +
                  (n[3] ? " " + n[3] : "") +
                  (n[4] ? "-" + n[4] : "")),
                  t.dispatchEvent(new Event("input"));
              };
            },
          });
      }
      "undefined" !== typeof window &&
        window.Vue &&
        window.Vue === o.a &&
        Am(window.Vue);
      var Cm = Am;
      e["default"] = Cm;
    },
    fc6a: function (t, e, n) {
      var i = n("44ad"),
        r = n("1d80");
      t.exports = function (t) {
        return i(r(t));
      };
    },
    fdbf: function (t, e, n) {
      var i = n("04f8");
      t.exports = i && !Symbol.sham && "symbol" == typeof Symbol.iterator;
    },
  });
});
//# sourceMappingURL=calc.umd.min.js.map
